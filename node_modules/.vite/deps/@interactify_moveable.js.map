{
  "version": 3,
  "sources": ["../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/AbleManager.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/node_modules/.pnpm/@egjs+agent@2.4.3/node_modules/@egjs/agent/dist/agent.esm.js", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/consts.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/utils/framework-utils.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/node_modules/.pnpm/@daybrush+utils@1.13.0/node_modules/@daybrush/utils/dist/utils.esm.js", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/node_modules/.pnpm/@scena+matrix@1.1.1/node_modules/@scena/matrix/dist/matrix.esm.js", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/node_modules/.pnpm/css-to-mat@1.1.1/node_modules/css-to-mat/dist/css-to-mat.esm.js", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/gesto/CustomGesto.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/utils/calculateElementPosition.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/gesto/GestoUtils.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/gesto/GestoData.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/utils/getMatrixStackInfo.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/store/Store.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/node_modules/.pnpm/react@18.3.1/node_modules/react/cjs/react-jsx-runtime.production.min.js", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/node_modules/.pnpm/react@18.3.1/node_modules/react/cjs/react-jsx-runtime.development.js", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/node_modules/.pnpm/react@18.3.1/node_modules/react/jsx-runtime.js", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/groupUtils.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/render-directions.tsx", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/snappable/bounds.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/snappable/utils.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/snappable/names.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/snappable/snap.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/snappable/innerBounds.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/snappable/snapBounds.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/Draggable.tsx", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/utils/getFixedDirection.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/Resizable.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/Rotatable.tsx", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/snappable/render.tsx", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/node_modules/.pnpm/@egjs+list-differ@1.0.1/node_modules/@egjs/list-differ/dist/list-differ.esm.js", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/node_modules/.pnpm/@egjs+children-differ@1.0.1/node_modules/@egjs/children-differ/dist/children-differ.esm.js", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/snappable/getTotalGuidelines.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/Snappable.tsx", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/utils.tsx", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/Pinchable.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/Scalable.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/Warpable.tsx", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/classNames.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/DragArea.tsx", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/Origin.tsx", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/node_modules/.pnpm/@scena+event-emitter@1.0.5/node_modules/@scena/event-emitter/dist/event-emitter.esm.js", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/node_modules/.pnpm/@scena+dragscroll@1.4.0/node_modules/@scena/dragscroll/dist/dragscroll.esm.js", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/Scrollable.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/Default.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/Padding.tsx", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/roundable/borderRadius.tsx", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/node_modules/.pnpm/overlap-area@1.1.0/node_modules/overlap-area/dist/overlap-area.esm.js", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/clippable/utils.tsx", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/Clippable.tsx", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/OriginDraggable.tsx", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/Roundable.tsx", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/node_modules/.pnpm/gesto@1.19.4/node_modules/gesto/dist/gesto.esm.js", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/BeforeRenderable.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/Renderable.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/gesto/getAbleGesto.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/EventManager.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/node_modules/.pnpm/css-styled@1.0.8/node_modules/css-styled/dist/styled.esm.js", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/node_modules/.pnpm/react-css-styled@1.1.9/node_modules/react-css-styled/dist/styled.esm.js", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/utils/calculateMatrixStack.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/utils/getElementInfo.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/utils/getMoveableTargetInfo.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/utils/persist.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/MoveableManager.tsx", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/Groupable.tsx", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/Clickable.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/edgeDraggable.tsx", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/IndividualGroupable.tsx", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/ables/consts.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/snappable/utils.ts", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/MoveableGroup.tsx", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/MoveableIndividualGroup.tsx", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/InitialMoveable.tsx", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/Moveable.tsx", "../../.pnpm/@interactify+moveable@0.0.2_d1a6a66991e4ebdd042fbe81fa337b3b/node_modules/@interactify/moveable/src/makeMoveable.ts"],
  "sourcesContent": ["import { Able } from \"../types\";\n\nexport function makeAble<\n    Name extends string,\n    AbleObject extends Partial<Able<any, any>>,\n>(name: Name, able: AbleObject) {\n    return {\n        events: [] as AbleObject[\"events\"] extends readonly any[] ? AbleObject[\"events\"] : readonly [],\n        props: [] as AbleObject[\"props\"] extends readonly any[] ? AbleObject[\"props\"] : readonly [],\n        name,\n        ...able,\n    } as const;\n}\n", "/*\nCopyright (c) 2015 NAVER Corp.\nname: @egjs/agent\nlicense: MIT\nauthor: NAVER Corp.\nrepository: git+https://github.com/naver/agent.git\nversion: 2.4.3\n*/\nfunction some(arr, callback) {\n  var length = arr.length;\n\n  for (var i = 0; i < length; ++i) {\n    if (callback(arr[i], i)) {\n      return true;\n    }\n  }\n\n  return false;\n}\nfunction find(arr, callback) {\n  var length = arr.length;\n\n  for (var i = 0; i < length; ++i) {\n    if (callback(arr[i], i)) {\n      return arr[i];\n    }\n  }\n\n  return null;\n}\nfunction getUserAgentString(agent) {\n  var userAgent = agent;\n\n  if (typeof userAgent === \"undefined\") {\n    if (typeof navigator === \"undefined\" || !navigator) {\n      return \"\";\n    }\n\n    userAgent = navigator.userAgent || \"\";\n  }\n\n  return userAgent.toLowerCase();\n}\nfunction execRegExp(pattern, text) {\n  try {\n    return new RegExp(pattern, \"g\").exec(text);\n  } catch (e) {\n    return null;\n  }\n}\nfunction hasUserAgentData() {\n  if (typeof navigator === \"undefined\" || !navigator || !navigator.userAgentData) {\n    return false;\n  }\n\n  var userAgentData = navigator.userAgentData;\n  var brands = userAgentData.brands || userAgentData.uaList;\n  return !!(brands && brands.length);\n}\nfunction findVersion(versionTest, userAgent) {\n  var result = execRegExp(\"(\" + versionTest + \")((?:\\\\/|\\\\s|:)([0-9|\\\\.|_]+))\", userAgent);\n  return result ? result[3] : \"\";\n}\nfunction convertVersion(text) {\n  return text.replace(/_/g, \".\");\n}\nfunction findPreset(presets, userAgent) {\n  var userPreset = null;\n  var version = \"-1\";\n  some(presets, function (preset) {\n    var result = execRegExp(\"(\" + preset.test + \")((?:\\\\/|\\\\s|:)([0-9|\\\\.|_]+))?\", userAgent);\n\n    if (!result || preset.brand) {\n      return false;\n    }\n\n    userPreset = preset;\n    version = result[3] || \"-1\";\n\n    if (preset.versionAlias) {\n      version = preset.versionAlias;\n    } else if (preset.versionTest) {\n      version = findVersion(preset.versionTest.toLowerCase(), userAgent) || version;\n    }\n\n    version = convertVersion(version);\n    return true;\n  });\n  return {\n    preset: userPreset,\n    version: version\n  };\n}\nfunction findPresetBrand(presets, brands) {\n  var brandInfo = {\n    brand: \"\",\n    version: \"-1\"\n  };\n  some(presets, function (preset) {\n    var result = findBrand(brands, preset);\n\n    if (!result) {\n      return false;\n    }\n\n    brandInfo.brand = preset.id;\n    brandInfo.version = preset.versionAlias || result.version;\n    return brandInfo.version !== \"-1\";\n  });\n  return brandInfo;\n}\nfunction findBrand(brands, preset) {\n  return find(brands, function (_a) {\n    var brand = _a.brand;\n    return execRegExp(\"\" + preset.test, brand.toLowerCase());\n  });\n}\n\nvar BROWSER_PRESETS = [{\n  test: \"phantomjs\",\n  id: \"phantomjs\"\n}, {\n  test: \"whale\",\n  id: \"whale\"\n}, {\n  test: \"edgios|edge|edg\",\n  id: \"edge\"\n}, {\n  test: \"msie|trident|windows phone\",\n  id: \"ie\",\n  versionTest: \"iemobile|msie|rv\"\n}, {\n  test: \"miuibrowser\",\n  id: \"miui browser\"\n}, {\n  test: \"samsungbrowser\",\n  id: \"samsung internet\"\n}, {\n  test: \"samsung\",\n  id: \"samsung internet\",\n  versionTest: \"version\"\n}, {\n  test: \"chrome|crios\",\n  id: \"chrome\"\n}, {\n  test: \"firefox|fxios\",\n  id: \"firefox\"\n}, {\n  test: \"android\",\n  id: \"android browser\",\n  versionTest: \"version\"\n}, {\n  test: \"safari|iphone|ipad|ipod\",\n  id: \"safari\",\n  versionTest: \"version\"\n}]; // chromium's engine(blink) is based on applewebkit 537.36.\n\nvar CHROMIUM_PRESETS = [{\n  test: \"(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\\\schrome)\",\n  id: \"chrome\",\n  versionTest: \"chrome\"\n}, {\n  test: \"chromium\",\n  id: \"chrome\"\n}, {\n  test: \"whale\",\n  id: \"chrome\",\n  versionAlias: \"-1\",\n  brand: true\n}];\nvar WEBKIT_PRESETS = [{\n  test: \"applewebkit\",\n  id: \"webkit\",\n  versionTest: \"applewebkit|safari\"\n}];\nvar WEBVIEW_PRESETS = [{\n  test: \"(?=(iphone|ipad))(?!(.*version))\",\n  id: \"webview\"\n}, {\n  test: \"(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))\",\n  id: \"webview\"\n}, {\n  // test webview\n  test: \"webview\",\n  id: \"webview\"\n}];\nvar OS_PRESETS = [{\n  test: \"windows phone\",\n  id: \"windows phone\"\n}, {\n  test: \"windows 2000\",\n  id: \"window\",\n  versionAlias: \"5.0\"\n}, {\n  test: \"windows nt\",\n  id: \"window\"\n}, {\n  test: \"win32|windows\",\n  id: \"window\"\n}, {\n  test: \"iphone|ipad|ipod\",\n  id: \"ios\",\n  versionTest: \"iphone os|cpu os\"\n}, {\n  test: \"macos|macintel|mac os x\",\n  id: \"mac\"\n}, {\n  test: \"android|linux armv81\",\n  id: \"android\"\n}, {\n  test: \"tizen\",\n  id: \"tizen\"\n}, {\n  test: \"webos|web0s\",\n  id: \"webos\"\n}];\n\nfunction isWebView(userAgent) {\n  return !!findPreset(WEBVIEW_PRESETS, userAgent).preset;\n}\nfunction getLegacyAgent(userAgent) {\n  var nextAgent = getUserAgentString(userAgent);\n  var isMobile = !!/mobi/g.exec(nextAgent);\n  var browser = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1,\n    webview: isWebView(nextAgent),\n    chromium: false,\n    chromiumVersion: \"-1\",\n    webkit: false,\n    webkitVersion: \"-1\"\n  };\n  var os = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1\n  };\n\n  var _a = findPreset(BROWSER_PRESETS, nextAgent),\n      browserPreset = _a.preset,\n      browserVersion = _a.version;\n\n  var _b = findPreset(OS_PRESETS, nextAgent),\n      osPreset = _b.preset,\n      osVersion = _b.version;\n\n  var chromiumPreset = findPreset(CHROMIUM_PRESETS, nextAgent);\n  browser.chromium = !!chromiumPreset.preset;\n  browser.chromiumVersion = chromiumPreset.version;\n\n  if (!browser.chromium) {\n    var webkitPreset = findPreset(WEBKIT_PRESETS, nextAgent);\n    browser.webkit = !!webkitPreset.preset;\n    browser.webkitVersion = webkitPreset.version;\n  }\n\n  if (osPreset) {\n    os.name = osPreset.id;\n    os.version = osVersion;\n    os.majorVersion = parseInt(osVersion, 10);\n  }\n\n  if (browserPreset) {\n    browser.name = browserPreset.id;\n    browser.version = browserVersion; // Early whale bugs\n\n    if (browser.webview && os.name === \"ios\" && browser.name !== \"safari\") {\n      browser.webview = false;\n    }\n  }\n\n  browser.majorVersion = parseInt(browser.version, 10);\n  return {\n    browser: browser,\n    os: os,\n    isMobile: isMobile,\n    isHints: false\n  };\n}\n\nfunction getClientHintsAgent(osData) {\n  var userAgentData = navigator.userAgentData;\n  var brands = (userAgentData.uaList || userAgentData.brands).slice();\n  var fullVersionList = osData && osData.fullVersionList;\n  var isMobile = userAgentData.mobile || false;\n  var firstBrand = brands[0];\n  var platform = (osData && osData.platform || userAgentData.platform || navigator.platform).toLowerCase();\n  var browser = {\n    name: firstBrand.brand,\n    version: firstBrand.version,\n    majorVersion: -1,\n    webkit: false,\n    webkitVersion: \"-1\",\n    chromium: false,\n    chromiumVersion: \"-1\",\n    webview: !!findPresetBrand(WEBVIEW_PRESETS, brands).brand || isWebView(getUserAgentString())\n  };\n  var os = {\n    name: \"unknown\",\n    version: \"-1\",\n    majorVersion: -1\n  };\n  browser.webkit = !browser.chromium && some(WEBKIT_PRESETS, function (preset) {\n    return findBrand(brands, preset);\n  });\n  var chromiumBrand = findPresetBrand(CHROMIUM_PRESETS, brands);\n  browser.chromium = !!chromiumBrand.brand;\n  browser.chromiumVersion = chromiumBrand.version;\n\n  if (!browser.chromium) {\n    var webkitBrand = findPresetBrand(WEBKIT_PRESETS, brands);\n    browser.webkit = !!webkitBrand.brand;\n    browser.webkitVersion = webkitBrand.version;\n  }\n\n  var platfomResult = find(OS_PRESETS, function (preset) {\n    return new RegExp(\"\" + preset.test, \"g\").exec(platform);\n  });\n  os.name = platfomResult ? platfomResult.id : \"\";\n\n  if (osData) {\n    os.version = osData.platformVersion;\n  }\n\n  if (fullVersionList && fullVersionList.length) {\n    var browserBrandByFullVersionList = findPresetBrand(BROWSER_PRESETS, fullVersionList);\n    browser.name = browserBrandByFullVersionList.brand || browser.name;\n    browser.version = browserBrandByFullVersionList.version || browser.version;\n  } else {\n    var browserBrand = findPresetBrand(BROWSER_PRESETS, brands);\n    browser.name = browserBrand.brand || browser.name;\n    browser.version = browserBrand.brand && osData ? osData.uaFullVersion : browserBrand.version;\n  }\n\n  if (browser.webkit) {\n    os.name = isMobile ? \"ios\" : \"mac\";\n  }\n\n  if (os.name === \"ios\" && browser.webview) {\n    browser.version = \"-1\";\n  }\n\n  os.version = convertVersion(os.version);\n  browser.version = convertVersion(browser.version);\n  os.majorVersion = parseInt(os.version, 10);\n  browser.majorVersion = parseInt(browser.version, 10);\n  return {\n    browser: browser,\n    os: os,\n    isMobile: isMobile,\n    isHints: true\n  };\n}\n\n/**\n * @namespace eg.agent\n */\n\n/**\n* Extracts accuate browser and operating system information from the user agent string or client hints.\n* @ko 유저 에이전트 문자열 또는 client hints에서 정확한 브라우저와 운영체제 정보를 추출한다.\n* @function eg.agent#getAccurateAgent\n* @param - Callback function to get the accuate agent <ko>정확한 에이전트를 가져오기 위한 callback 함수</ko>\n* @return - get the accuate agent promise. If Promise are not supported, null is returned. <ko> 정확한 에이전트 promise를 가져온다. Promise를 지원 하지 않는 경우, null을 반환한다. </ko>\n* @example\nimport { getAccurateAgent } from \"@egjs/agent\";\n// eg.agent.getAccurateAgent()\ngetAccurateAgent().then(agent => {\n   const { os, browser, isMobile } = agent;\n});\ngetAccurateAgent(agent => {\n    const { os, browser, isMobile } = agent;\n});\n*/\n\nfunction getAccurateAgent(callback) {\n  if (hasUserAgentData()) {\n    return navigator.userAgentData.getHighEntropyValues([\"architecture\", \"model\", \"platform\", \"platformVersion\", \"uaFullVersion\", \"fullVersionList\"]).then(function (info) {\n      var agentInfo = getClientHintsAgent(info);\n      callback && callback(agentInfo);\n      return agentInfo;\n    });\n  }\n\n  callback && callback(agent());\n\n  if (typeof Promise === \"undefined\" || !Promise) {\n    return null;\n  }\n\n  return Promise.resolve(agent());\n}\n/**\n * Extracts browser and operating system information from the user agent string.\n * @ko 유저 에이전트 문자열에서 브라우저와 운영체제 정보를 추출한다.\n * @function eg.agent#agent\n * @param - user agent string to parse <ko>파싱할 유저에이전트 문자열</ko>\n * @return - agent Info <ko> 에이전트 정보 </ko>\n * @example\nimport agent from \"@egjs/agent\";\n// eg.agent();\nconst { os, browser, isMobile } = agent();\n */\n\nfunction agent(userAgent) {\n  if (typeof userAgent === \"undefined\" && hasUserAgentData()) {\n    return getClientHintsAgent();\n  } else {\n    return getLegacyAgent(userAgent);\n  }\n}\n\nexport default agent;\nexport { getAccurateAgent, getLegacyAgent };\n//# sourceMappingURL=agent.esm.js.map\n", "import getAgent from \"@egjs/agent\";\nimport { IObject } from \"@daybrush/utils\";\nimport { MoveableInterface } from \"./types\";\n\n\nexport const DIRECTIONS4 = [\"n\", \"w\", \"s\", \"e\"];\nexport const DIRECTIONS = [\"n\", \"w\", \"s\", \"e\", \"nw\", \"ne\", \"sw\", \"se\"];\n\n\nfunction getSVGCursor(scale: number, degree: number) {\n    return `data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${32 * scale}px\" height=\"${32 * scale}px\" viewBox=\"0 0 32 32\" ><path d=\"M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z\" stroke-linejoin=\"round\" stroke-width=\"1.2\" fill=\"black\" stroke=\"white\" style=\"transform:rotate(${degree}deg);transform-origin: 16px 16px\"></path></svg>`;\n}\nfunction getCursorCSS(degree: number) {\n    const x1 = getSVGCursor(1, degree);\n    // const x2 = getSVGCursor(2, degree);\n    const degree45 = (Math.round(degree / 45) * 45) % 180;\n    let defaultCursor = \"ns-resize\";\n\n    if (degree45 === 135) {\n        defaultCursor = \"nwse-resize\";\n    } else if (degree45 === 45) {\n        defaultCursor = \"nesw-resize\";\n    } else if (degree45 === 90) {\n        defaultCursor = \"ew-resize\";\n    }\n\n    // tslint:disable-next-line: max-line-length\n    return `cursor:${defaultCursor};cursor: url('${x1}') 16 16, ${defaultCursor};`;\n}\n\nexport const agent = getAgent();\nexport const IS_WEBKIT = agent.browser.webkit;\nexport const IS_WEBKIT605 = IS_WEBKIT && (() => {\n    const navi = typeof window === \"undefined\" ? { userAgent: \"\" } : window.navigator;\n    const res = /applewebkit\\/([^\\s]+)/g.exec(navi.userAgent.toLowerCase());\n\n    return res ? parseFloat(res[1]) < 605 : false;\n})();\n\nconst browserName = agent.browser.name;\nconst browserVersion = parseInt(agent.browser.version, 10);\nconst IS_CHROME = browserName === \"chrome\";\nconst IS_CHROMIUM = agent.browser.chromium;\nconst chromiumVersion = parseInt(agent.browser.chromiumVersion, 10) || 0;\n\nexport const IS_CHROMIUM109 = (IS_CHROME && browserVersion >= 109)\n    || (IS_CHROMIUM && chromiumVersion >= 109);\nexport const IS_FIREFOX = browserName === \"firefox\";\nexport const IS_SAFARI_ABOVE15\n    = parseInt(agent.browser.webkitVersion, 10) >= 612\n    || browserVersion >= 15;\n\nexport const PREFIX = \"moveable-\";\n\n\nconst directionCSS = DIRECTIONS.map(dir => {\n    let top = \"\";\n    let left = \"\";\n    let originX = \"center\";\n    let originY = \"center\";\n    const offset =  `calc(var(--moveable-control-padding, 20) * -1px)`;\n\n    if (dir.indexOf(\"n\") > -1) {\n        top = `top: ${offset};`;\n        originY = `bottom`;\n    }\n    if (dir.indexOf(`s`) > -1) {\n        top = `top: 0px;`;\n        originY = `top`;\n    }\n    if (dir.indexOf(`w`) > -1) {\n        left = `left: ${offset};`;\n        originX = `right`;\n    }\n    if (dir.indexOf(`e`) > -1) {\n        left = `left: 0px;`;\n        originX = `left`;\n    }\n    return `.around-control[data-direction*=\"${dir}\"] {\n        ${left}${top}\n        transform-origin: ${originX} ${originY};\n    }`;\n}).join(\"\\n\");\n\nexport const MOVEABLE_CSS = `\n{\nposition: absolute;\nwidth: 1px;\nheight: 1px;\nleft: 0;\ntop: 0;\nz-index: 3000;\n--moveable-color: #4af;\n--zoom: 1;\n--zoompx: 1px;\n--moveable-line-padding: 0;\n--moveable-control-padding: 0;\nwill-change: transform;\noutline: 1px solid transparent;\n}\n.control-box {\nz-index: 0;\n}\n.line, .control {\nposition: absolute;\nleft: 0;\ntop: 0;\nwill-change: transform;\n}\n.control {\nwidth: 14px;\nheight: 14px;\nborder-radius: 50%;\nborder: 2px solid #fff;\nbox-sizing: border-box;\nbackground: #4af;\nbackground: var(--moveable-color);\nmargin-top: -7px;\nmargin-left: -7px;\nborder: 2px solid #fff;\nz-index: 10;\n}\n.around-control {\nposition: absolute;\nwill-change: transform;\nwidth: calc(var(--moveable-control-padding, 20) * 1px);\nheight: calc(var(--moveable-control-padding, 20) * 1px);\nleft: calc(var(--moveable-control-padding, 20) * -0.5px);\ntop: calc(var(--moveable-control-padding, 20) * -0.5px);\nbox-sizing: border-box;\nbackground: transparent;\nz-index: 8;\ncursor: alias;\ntransform-origin: center center;\n}\n${directionCSS}\n.padding {\nposition: absolute;\ntop: 0px;\nleft: 0px;\nwidth: 100px;\nheight: 100px;\ntransform-origin: 0 0;\n}\n.line {\nwidth: 1px;\nheight: 1px;\nbackground: #4af;\nbackground: var(--moveable-color);\ntransform-origin: 0px 50%;\n}\n.line.edge {\nz-index: 1;\nbackground: transparent;\n}\n.line.dashed {\nbox-sizing: border-box;\nbackground: transparent;\n}\n.line.dashed.horizontal {\nborder-top: 1px dashed #4af;\nborder-top-color: #4af;\nborder-top-color: var(--moveable-color);\n}\n.line.dashed.vertical {\nborder-left: 1px dashed #4af;\nborder-left-color: #4af;\nborder-left-color: var(--moveable-color);\n}\n.line.vertical {\ntransform: translateX(-50%);\n}\n.line.horizontal {\ntransform: translateY(-50%);\n}\n.line.vertical.bold {\nwidth: 2px;\n}\n.line.horizontal.bold {\nheight: 2px;\n}\n\n.control.origin {\nborder-color: #f55;\nbackground: #fff;\nwidth: 12px;\nheight: 12px;\nmargin-top: -6px;\nmargin-left: -6px;\npointer-events: none;\n}\n${[0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(degree => `\n.direction[data-rotation=\"${degree}\"], :global .view-control-rotation${degree} {\n${getCursorCSS(degree)}\n}\n`).join(\"\\n\")}\n\n.line.direction:before {\ncontent: \"\";\nposition: absolute;\nwidth: 100%;\nheight: calc(var(--moveable-line-padding, 0) * 1px);\nbottom: 0;\nleft: 0;\n}\n.group {\nz-index: -1;\n}\n.area {\nposition: absolute;\n}\n.area-pieces {\nposition: absolute;\ntop: 0;\nleft: 0;\ndisplay: none;\n}\n.area.avoid, .area.pass {\npointer-events: none;\n}\n.area.avoid+.area-pieces {\ndisplay: block;\n}\n.area-piece {\nposition: absolute;\n}\n\n${IS_WEBKIT605 ? `:global svg *:before {\ncontent:\"\";\ntransform-origin: inherit;\n}` : \"\"}\n`;\n\nexport const NEARBY_POS = [\n    [0, 1, 2],\n    [1, 0, 3],\n    [2, 0, 3],\n    [3, 1, 2],\n];\n\nexport const FLOAT_POINT_NUM = 0.0001;\nexport const TINY_NUM = 0.0000001;\nexport const MIN_SCALE = 0.000000001;\nexport const MAX_NUM = Math.pow(10, 10);\nexport const MIN_NUM = -MAX_NUM;\n\nexport const DIRECTION_REGION_TO_DIRECTION: Record<string, number[]> = {\n    n: [0, -1],\n    e: [1, 0],\n    s: [0, 1],\n    w: [-1, 0],\n    nw: [-1, -1],\n    ne: [1, -1],\n    sw: [-1, 1],\n    se: [1, 1],\n};\n\nexport const DIRECTION_INDEXES: IObject<number[]> = {\n    n: [0, 1],\n    e: [1, 3],\n    s: [3, 2],\n    w: [2, 0],\n    nw: [0],\n    ne: [1],\n    sw: [2],\n    se: [3],\n};\nexport const DIRECTION_ROTATIONS: IObject<number> = {\n    n: 0,\n    s: 180,\n    w: 270,\n    e: 90,\n    nw: 315,\n    ne: 45,\n    sw: 225,\n    se: 135,\n};\n\nexport const MOVEABLE_METHODS: Array<keyof MoveableInterface> = [\n    \"isMoveableElement\",\n    \"updateRect\",\n    \"updateTarget\",\n    \"destroy\",\n    \"dragStart\",\n    \"isInside\",\n    \"hitTest\",\n    \"setState\",\n    \"getRect\",\n    \"request\",\n    \"isDragging\",\n    \"getManager\",\n    \"forceUpdate\",\n    \"waitToChangeTarget\",\n    \"updateSelectors\",\n    \"getTargets\",\n    \"stopDrag\",\n    \"getControlBoxElement\",\n    \"getMoveables\",\n    \"getDragElement\",\n];\n", "export function prefixNames(prefix: string, ...classNames: string[]) {\n  return classNames\n    .map((className) =>\n      className\n        .split(' ')\n        .map((name) => (name ? `${prefix}${name}` : ''))\n        .join(' '),\n    )\n    .join(' ');\n}\n\nexport function prefixCSS(prefix: string, css: string) {\n  return css.replace(/([^}{]*){/gm, (_, selector) => {\n    return `${selector.replace(/\\.([^{,\\s\\d.]+)/g, `.${prefix}$1`)}{`;\n  });\n}\n\n/* react */\nexport function ref(target: any, name: string) {\n  return (e: any) => {\n    e && (target[name] = e);\n  };\n}\nexport function refs(target: any, name: string, i: number) {\n  return (e: any) => {\n    e && (target[name][i] = e);\n  };\n}\n", "/*\nCopyright (c) 2018 Daybrush\n@name: @daybrush/utils\nlicense: MIT\nauthor: Daybrush\nrepository: https://github.com/daybrush/utils\n@version 1.13.0\n*/\n/**\n* @namespace\n* @name Consts\n*/\n/**\n* get string \"rgb\"\n* @memberof Color\n* @example\nimport {RGB} from \"@daybrush/utils\";\n\nconsole.log(RGB); // \"rgb\"\n*/\nvar RGB = \"rgb\";\n/**\n* get string \"rgba\"\n* @memberof Color\n* @example\nimport {RGBA} from \"@daybrush/utils\";\n\nconsole.log(RGBA); // \"rgba\"\n*/\nvar RGBA = \"rgba\";\n/**\n* get string \"hsl\"\n* @memberof Color\n* @example\nimport {HSL} from \"@daybrush/utils\";\n\nconsole.log(HSL); // \"hsl\"\n*/\nvar HSL = \"hsl\";\n/**\n* get string \"hsla\"\n* @memberof Color\n* @example\nimport {HSLA} from \"@daybrush/utils\";\n\nconsole.log(HSLA); // \"hsla\"\n*/\nvar HSLA = \"hsla\";\n/**\n* gets an array of color models.\n* @memberof Color\n* @example\nimport {COLOR_MODELS} from \"@daybrush/utils\";\n\nconsole.log(COLOR_MODELS); // [\"rgb\", \"rgba\", \"hsl\", \"hsla\"];\n*/\nvar COLOR_MODELS = [RGB, RGBA, HSL, HSLA];\n/**\n* get string \"function\"\n* @memberof Consts\n* @example\nimport {FUNCTION} from \"@daybrush/utils\";\n\nconsole.log(FUNCTION); // \"function\"\n*/\nvar FUNCTION = \"function\";\n/**\n* get string \"property\"\n* @memberof Consts\n* @example\nimport {PROPERTY} from \"@daybrush/utils\";\n\nconsole.log(PROPERTY); // \"property\"\n*/\nvar PROPERTY = \"property\";\n/**\n* get string \"array\"\n* @memberof Consts\n* @example\nimport {ARRAY} from \"@daybrush/utils\";\n\nconsole.log(ARRAY); // \"array\"\n*/\nvar ARRAY = \"array\";\n/**\n* get string \"object\"\n* @memberof Consts\n* @example\nimport {OBJECT} from \"@daybrush/utils\";\n\nconsole.log(OBJECT); // \"object\"\n*/\nvar OBJECT = \"object\";\n/**\n* get string \"string\"\n* @memberof Consts\n* @example\nimport {STRING} from \"@daybrush/utils\";\n\nconsole.log(STRING); // \"string\"\n*/\nvar STRING = \"string\";\n/**\n* get string \"number\"\n* @memberof Consts\n* @example\nimport {NUMBER} from \"@daybrush/utils\";\n\nconsole.log(NUMBER); // \"number\"\n*/\nvar NUMBER = \"number\";\n/**\n* get string \"undefined\"\n* @memberof Consts\n* @example\nimport {UNDEFINED} from \"@daybrush/utils\";\n\nconsole.log(UNDEFINED); // \"undefined\"\n*/\nvar UNDEFINED = \"undefined\";\n/**\n* Check whether the environment is window or node.js.\n* @memberof Consts\n* @example\nimport {IS_WINDOW} from \"@daybrush/utils\";\n\nconsole.log(IS_WINDOW); // false in node.js\nconsole.log(IS_WINDOW); // true in browser\n*/\nvar IS_WINDOW = typeof window !== UNDEFINED;\n/**\n* Check whether the environment is window or node.js.\n* @memberof Consts\n* @name document\n* @example\nimport {IS_WINDOW} from \"@daybrush/utils\";\n\nconsole.log(IS_WINDOW); // false in node.js\nconsole.log(IS_WINDOW); // true in browser\n*/\nvar doc = typeof document !== UNDEFINED && document; // FIXME: this type maybe false\nvar prefixes = [\"webkit\", \"ms\", \"moz\", \"o\"];\n/**\n * @namespace CrossBrowser\n */\n/**\n* Get a CSS property with a vendor prefix that supports cross browser.\n* @function\n* @param {string} property - A CSS property\n* @return {string} CSS property with cross-browser vendor prefix\n* @memberof CrossBrowser\n* @example\nimport {getCrossBrowserProperty} from \"@daybrush/utils\";\n\nconsole.log(getCrossBrowserProperty(\"transform\")); // \"transform\", \"-ms-transform\", \"-webkit-transform\"\nconsole.log(getCrossBrowserProperty(\"filter\")); // \"filter\", \"-webkit-filter\"\n*/\nvar getCrossBrowserProperty = /*#__PURE__*/function (property) {\n  if (!doc) {\n    return \"\";\n  }\n  var styles = (doc.body || doc.documentElement).style;\n  var length = prefixes.length;\n  if (typeof styles[property] !== UNDEFINED) {\n    return property;\n  }\n  for (var i = 0; i < length; ++i) {\n    var name = \"-\" + prefixes[i] + \"-\" + property;\n    if (typeof styles[name] !== UNDEFINED) {\n      return name;\n    }\n  }\n  return \"\";\n};\n/**\n* get string \"transfrom\" with the vendor prefix.\n* @memberof CrossBrowser\n* @example\nimport {TRANSFORM} from \"@daybrush/utils\";\n\nconsole.log(TRANSFORM); // \"transform\", \"-ms-transform\", \"-webkit-transform\"\n*/\nvar TRANSFORM = /*#__PURE__*/getCrossBrowserProperty(\"transform\");\n/**\n* get string \"filter\" with the vendor prefix.\n* @memberof CrossBrowser\n* @example\nimport {FILTER} from \"@daybrush/utils\";\n\nconsole.log(FILTER); // \"filter\", \"-ms-filter\", \"-webkit-filter\"\n*/\nvar FILTER = /*#__PURE__*/getCrossBrowserProperty(\"filter\");\n/**\n* get string \"animation\" with the vendor prefix.\n* @memberof CrossBrowser\n* @example\nimport {ANIMATION} from \"@daybrush/utils\";\n\nconsole.log(ANIMATION); // \"animation\", \"-ms-animation\", \"-webkit-animation\"\n*/\nvar ANIMATION = /*#__PURE__*/getCrossBrowserProperty(\"animation\");\n/**\n* get string \"keyframes\" with the vendor prefix.\n* @memberof CrossBrowser\n* @example\nimport {KEYFRAMES} from \"@daybrush/utils\";\n\nconsole.log(KEYFRAMES); // \"keyframes\", \"-ms-keyframes\", \"-webkit-keyframes\"\n*/\nvar KEYFRAMES = /*#__PURE__*/ANIMATION.replace(\"animation\", \"keyframes\");\nvar OPEN_CLOSED_CHARACTERS = [{\n  open: \"(\",\n  close: \")\"\n}, {\n  open: \"\\\"\",\n  close: \"\\\"\"\n}, {\n  open: \"'\",\n  close: \"'\"\n}, {\n  open: \"\\\\\\\"\",\n  close: \"\\\\\\\"\"\n}, {\n  open: \"\\\\'\",\n  close: \"\\\\'\"\n}];\nvar TINY_NUM = 0.0000001;\nvar REVERSE_TINY_NUM = 1 / TINY_NUM;\nvar DEFAULT_UNIT_PRESETS = {\n  \"cm\": function (pos) {\n    return pos * 96 / 2.54;\n  },\n  \"mm\": function (pos) {\n    return pos * 96 / 254;\n  },\n  \"in\": function (pos) {\n    return pos * 96;\n  },\n  \"pt\": function (pos) {\n    return pos * 96 / 72;\n  },\n  \"pc\": function (pos) {\n    return pos * 96 / 6;\n  },\n  \"%\": function (pos, size) {\n    return pos * size / 100;\n  },\n  \"vw\": function (pos, size) {\n    if (size === void 0) {\n      size = window.innerWidth;\n    }\n    return pos / 100 * size;\n  },\n  \"vh\": function (pos, size) {\n    if (size === void 0) {\n      size = window.innerHeight;\n    }\n    return pos / 100 * size;\n  },\n  \"vmax\": function (pos, size) {\n    if (size === void 0) {\n      size = Math.max(window.innerWidth, window.innerHeight);\n    }\n    return pos / 100 * size;\n  },\n  \"vmin\": function (pos, size) {\n    if (size === void 0) {\n      size = Math.min(window.innerWidth, window.innerHeight);\n    }\n    return pos / 100 * size;\n  }\n};\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n  return r;\n}\n\n/**\n* @namespace\n* @name Utils\n*/\n/**\n * Returns the inner product of two numbers(`a1`, `a2`) by two criteria(`b1`, `b2`).\n * @memberof Utils\n * @param - The first number\n * @param - The second number\n * @param - The first number to base on the inner product\n * @param - The second number to base on the inner product\n * @return - Returns the inner product\nimport { dot } from \"@daybrush/utils\";\n\nconsole.log(dot(0, 15, 2, 3)); // 6\nconsole.log(dot(5, 15, 2, 3)); // 9\nconsole.log(dot(5, 15, 1, 1)); // 10\n */\nfunction dot(a1, a2, b1, b2) {\n  return (a1 * b2 + a2 * b1) / (b1 + b2);\n}\n/**\n* Check the type that the value is undefined.\n* @memberof Utils\n* @param {string} value - Value to check the type\n* @return {boolean} true if the type is correct, false otherwise\n* @example\nimport {isUndefined} from \"@daybrush/utils\";\n\nconsole.log(isUndefined(undefined)); // true\nconsole.log(isUndefined(\"\")); // false\nconsole.log(isUndefined(1)); // false\nconsole.log(isUndefined(null)); // false\n*/\nfunction isUndefined(value) {\n  return typeof value === UNDEFINED;\n}\n/**\n* Check the type that the value is object.\n* @memberof Utils\n* @param {string} value - Value to check the type\n* @return {} true if the type is correct, false otherwise\n* @example\nimport {isObject} from \"@daybrush/utils\";\n\nconsole.log(isObject({})); // true\nconsole.log(isObject(undefined)); // false\nconsole.log(isObject(\"\")); // false\nconsole.log(isObject(null)); // false\n*/\nfunction isObject(value) {\n  return value && typeof value === OBJECT;\n}\n/**\n* Check the type that the value is isArray.\n* @memberof Utils\n* @param {string} value - Value to check the type\n* @return {} true if the type is correct, false otherwise\n* @example\nimport {isArray} from \"@daybrush/utils\";\n\nconsole.log(isArray([])); // true\nconsole.log(isArray({})); // false\nconsole.log(isArray(undefined)); // false\nconsole.log(isArray(null)); // false\n*/\nfunction isArray(value) {\n  return Array.isArray(value);\n}\n/**\n* Check the type that the value is string.\n* @memberof Utils\n* @param {string} value - Value to check the type\n* @return {} true if the type is correct, false otherwise\n* @example\nimport {isString} from \"@daybrush/utils\";\n\nconsole.log(isString(\"1234\")); // true\nconsole.log(isString(undefined)); // false\nconsole.log(isString(1)); // false\nconsole.log(isString(null)); // false\n*/\nfunction isString(value) {\n  return typeof value === STRING;\n}\nfunction isNumber(value) {\n  return typeof value === NUMBER;\n}\n/**\n* Check the type that the value is function.\n* @memberof Utils\n* @param {string} value - Value to check the type\n* @return {} true if the type is correct, false otherwise\n* @example\nimport {isFunction} from \"@daybrush/utils\";\n\nconsole.log(isFunction(function a() {})); // true\nconsole.log(isFunction(() => {})); // true\nconsole.log(isFunction(\"1234\")); // false\nconsole.log(isFunction(1)); // false\nconsole.log(isFunction(null)); // false\n*/\nfunction isFunction(value) {\n  return typeof value === FUNCTION;\n}\nfunction isEqualSeparator(character, separator) {\n  var isCharacterSpace = character === \"\" || character == \" \";\n  var isSeparatorSpace = separator === \"\" || separator == \" \";\n  return isSeparatorSpace && isCharacterSpace || character === separator;\n}\nfunction findOpen(openCharacter, texts, index, length, openCloseCharacters) {\n  var isIgnore = findIgnore(openCharacter, texts, index);\n  if (!isIgnore) {\n    return findClose(openCharacter, texts, index + 1, length, openCloseCharacters);\n  }\n  return index;\n}\nfunction findIgnore(character, texts, index) {\n  if (!character.ignore) {\n    return null;\n  }\n  var otherText = texts.slice(Math.max(index - 3, 0), index + 3).join(\"\");\n  return new RegExp(character.ignore).exec(otherText);\n}\nfunction findClose(closeCharacter, texts, index, length, openCloseCharacters) {\n  var _loop_1 = function (i) {\n    var character = texts[i].trim();\n    if (character === closeCharacter.close && !findIgnore(closeCharacter, texts, i)) {\n      return {\n        value: i\n      };\n    }\n    var nextIndex = i;\n    // re open\n    var openCharacter = find(openCloseCharacters, function (_a) {\n      var open = _a.open;\n      return open === character;\n    });\n    if (openCharacter) {\n      nextIndex = findOpen(openCharacter, texts, i, length, openCloseCharacters);\n    }\n    if (nextIndex === -1) {\n      return out_i_1 = i, \"break\";\n    }\n    i = nextIndex;\n    out_i_1 = i;\n  };\n  var out_i_1;\n  for (var i = index; i < length; ++i) {\n    var state_1 = _loop_1(i);\n    i = out_i_1;\n    if (typeof state_1 === \"object\") return state_1.value;\n    if (state_1 === \"break\") break;\n  }\n  return -1;\n}\nfunction splitText(text, splitOptions) {\n  var _a = isString(splitOptions) ? {\n      separator: splitOptions\n    } : splitOptions,\n    _b = _a.separator,\n    separator = _b === void 0 ? \",\" : _b,\n    isSeparateFirst = _a.isSeparateFirst,\n    isSeparateOnlyOpenClose = _a.isSeparateOnlyOpenClose,\n    _c = _a.isSeparateOpenClose,\n    isSeparateOpenClose = _c === void 0 ? isSeparateOnlyOpenClose : _c,\n    _d = _a.openCloseCharacters,\n    openCloseCharacters = _d === void 0 ? OPEN_CLOSED_CHARACTERS : _d;\n  var openClosedText = openCloseCharacters.map(function (_a) {\n    var open = _a.open,\n      close = _a.close;\n    if (open === close) {\n      return open;\n    }\n    return open + \"|\" + close;\n  }).join(\"|\");\n  var regexText = \"(\\\\s*\" + separator + \"\\\\s*|\" + openClosedText + \"|\\\\s+)\";\n  var regex = new RegExp(regexText, \"g\");\n  var texts = text.split(regex).filter(function (chr) {\n    return chr && chr !== \"undefined\";\n  });\n  var length = texts.length;\n  var values = [];\n  var tempValues = [];\n  function resetTemp() {\n    if (tempValues.length) {\n      values.push(tempValues.join(\"\"));\n      tempValues = [];\n      return true;\n    }\n    return false;\n  }\n  var _loop_2 = function (i) {\n    var character = texts[i].trim();\n    var nextIndex = i;\n    var openCharacter = find(openCloseCharacters, function (_a) {\n      var open = _a.open;\n      return open === character;\n    });\n    var closeCharacter = find(openCloseCharacters, function (_a) {\n      var close = _a.close;\n      return close === character;\n    });\n    if (openCharacter) {\n      nextIndex = findOpen(openCharacter, texts, i, length, openCloseCharacters);\n      if (nextIndex !== -1 && isSeparateOpenClose) {\n        if (resetTemp() && isSeparateFirst) {\n          return out_i_2 = i, \"break\";\n        }\n        values.push(texts.slice(i, nextIndex + 1).join(\"\"));\n        i = nextIndex;\n        if (isSeparateFirst) {\n          return out_i_2 = i, \"break\";\n        }\n        return out_i_2 = i, \"continue\";\n      }\n    } else if (closeCharacter && !findIgnore(closeCharacter, texts, i)) {\n      var nextOpenCloseCharacters = __spreadArrays(openCloseCharacters);\n      nextOpenCloseCharacters.splice(openCloseCharacters.indexOf(closeCharacter), 1);\n      return {\n        value: splitText(text, {\n          separator: separator,\n          isSeparateFirst: isSeparateFirst,\n          isSeparateOnlyOpenClose: isSeparateOnlyOpenClose,\n          isSeparateOpenClose: isSeparateOpenClose,\n          openCloseCharacters: nextOpenCloseCharacters\n        })\n      };\n    } else if (isEqualSeparator(character, separator) && !isSeparateOnlyOpenClose) {\n      resetTemp();\n      if (isSeparateFirst) {\n        return out_i_2 = i, \"break\";\n      }\n      return out_i_2 = i, \"continue\";\n    }\n    if (nextIndex === -1) {\n      nextIndex = length - 1;\n    }\n    tempValues.push(texts.slice(i, nextIndex + 1).join(\"\"));\n    i = nextIndex;\n    out_i_2 = i;\n  };\n  var out_i_2;\n  for (var i = 0; i < length; ++i) {\n    var state_2 = _loop_2(i);\n    i = out_i_2;\n    if (typeof state_2 === \"object\") return state_2.value;\n    if (state_2 === \"break\") break;\n  }\n  if (tempValues.length) {\n    values.push(tempValues.join(\"\"));\n  }\n  return values;\n}\n/**\n* divide text by space.\n* @memberof Utils\n* @param {string} text - text to divide\n* @return {Array} divided texts\n* @example\nimport {spliceSpace} from \"@daybrush/utils\";\n\nconsole.log(splitSpace(\"a b c d e f g\"));\n// [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]\nconsole.log(splitSpace(\"'a,b' c 'd,e' f g\"));\n// [\"'a,b'\", \"c\", \"'d,e'\", \"f\", \"g\"]\n*/\nfunction splitSpace(text) {\n  // divide comma(space)\n  return splitText(text, \"\");\n}\n/**\n* divide text by comma.\n* @memberof Utils\n* @param {string} text - text to divide\n* @return {Array} divided texts\n* @example\nimport {splitComma} from \"@daybrush/utils\";\n\nconsole.log(splitComma(\"a,b,c,d,e,f,g\"));\n// [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]\nconsole.log(splitComma(\"'a,b',c,'d,e',f,g\"));\n// [\"'a,b'\", \"c\", \"'d,e'\", \"f\", \"g\"]\n*/\nfunction splitComma(text) {\n  // divide comma(,)\n  // \"[^\"]*\"|'[^']*'\n  return splitText(text, \",\");\n}\n/**\n* divide text by bracket \"(\", \")\".\n* @memberof Utils\n* @param {string} text - text to divide\n* @return {object} divided texts\n* @example\nimport {splitBracket} from \"@daybrush/utils\";\n\nconsole.log(splitBracket(\"a(1, 2)\"));\n// {prefix: \"a\", value: \"1, 2\", suffix: \"\"}\nconsole.log(splitBracket(\"a(1, 2)b\"));\n// {prefix: \"a\", value: \"1, 2\", suffix: \"b\"}\n*/\nfunction splitBracket(text) {\n  var matches = /([^(]*)\\(([\\s\\S]*)\\)([\\s\\S]*)/g.exec(text);\n  if (!matches || matches.length < 4) {\n    return {};\n  } else {\n    return {\n      prefix: matches[1],\n      value: matches[2],\n      suffix: matches[3]\n    };\n  }\n}\n/**\n* divide text by number and unit.\n* @memberof Utils\n* @param {string} text - text to divide\n* @return {} divided texts\n* @example\nimport {splitUnit} from \"@daybrush/utils\";\n\nconsole.log(splitUnit(\"10px\"));\n// {prefix: \"\", value: 10, unit: \"px\"}\nconsole.log(splitUnit(\"-10px\"));\n// {prefix: \"\", value: -10, unit: \"px\"}\nconsole.log(splitUnit(\"a10%\"));\n// {prefix: \"a\", value: 10, unit: \"%\"}\n*/\nfunction splitUnit(text) {\n  var matches = /^([^\\d|e|\\-|\\+]*)((?:\\d|\\.|-|e-|e\\+)+)(\\S*)$/g.exec(text);\n  if (!matches) {\n    return {\n      prefix: \"\",\n      unit: \"\",\n      value: NaN\n    };\n  }\n  var prefix = matches[1];\n  var value = matches[2];\n  var unit = matches[3];\n  return {\n    prefix: prefix,\n    unit: unit,\n    value: parseFloat(value)\n  };\n}\n/**\n* transform strings to camel-case\n* @memberof Utils\n* @param {String} text - string\n* @return {String} camel-case string\n* @example\nimport {camelize} from \"@daybrush/utils\";\n\nconsole.log(camelize(\"transform-origin\")); // transformOrigin\nconsole.log(camelize(\"abcd_efg\")); // abcdEfg\nconsole.log(camelize(\"abcd efg\")); // abcdEfg\n*/\nfunction camelize(str) {\n  return str.replace(/[\\s-_]+([^\\s-_])/g, function (all, letter) {\n    return letter.toUpperCase();\n  });\n}\n/**\n* transform a camelized string into a lowercased string.\n* @memberof Utils\n* @param {string} text - a camel-cased string\n* @param {string} [separator=\"-\"] - a separator\n* @return {string}  a lowercased string\n* @example\nimport {decamelize} from \"@daybrush/utils\";\n\nconsole.log(decamelize(\"transformOrigin\")); // transform-origin\nconsole.log(decamelize(\"abcdEfg\", \"_\")); // abcd_efg\n*/\nfunction decamelize(str, separator) {\n  if (separator === void 0) {\n    separator = \"-\";\n  }\n  return str.replace(/([a-z])([A-Z])/g, function (all, letter, letter2) {\n    return \"\" + letter + separator + letter2.toLowerCase();\n  });\n}\n/**\n* transforms something in an array into an array.\n* @memberof Utils\n* @param - Array form\n* @return an array\n* @example\nimport {toArray} from \"@daybrush/utils\";\n\nconst arr1 = toArray(document.querySelectorAll(\".a\")); // Element[]\nconst arr2 = toArray(document.querySelectorAll<HTMLElement>(\".a\")); // HTMLElement[]\n*/\nfunction toArray(value) {\n  return [].slice.call(value);\n}\n/**\n* Date.now() method\n* @memberof CrossBrowser\n* @return {number} milliseconds\n* @example\nimport {now} from \"@daybrush/utils\";\n\nconsole.log(now()); // 12121324241(milliseconds)\n*/\nfunction now() {\n  return Date.now ? Date.now() : new Date().getTime();\n}\n/**\n* Returns the index of the first element in the array that satisfies the provided testing function.\n* @function\n* @memberof CrossBrowser\n* @param - The array `findIndex` was called upon.\n* @param - A function to execute on each value in the array until the function returns true, indicating that the satisfying element was found.\n* @param - Returns defaultIndex if not found by the function.\n* @example\nimport { findIndex } from \"@daybrush/utils\";\n\nfindIndex([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // 1\n*/\nfunction findIndex(arr, callback, defaultIndex) {\n  if (defaultIndex === void 0) {\n    defaultIndex = -1;\n  }\n  var length = arr.length;\n  for (var i = 0; i < length; ++i) {\n    if (callback(arr[i], i, arr)) {\n      return i;\n    }\n  }\n  return defaultIndex;\n}\n/**\n* Returns the reverse direction index of the first element in the array that satisfies the provided testing function.\n* @function\n* @memberof CrossBrowser\n* @param - The array `findLastIndex` was called upon.\n* @param - A function to execute on each value in the array until the function returns true, indicating that the satisfying element was found.\n* @param - Returns defaultIndex if not found by the function.\n* @example\nimport { findLastIndex } from \"@daybrush/utils\";\n\nfindLastIndex([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // 1\n*/\nfunction findLastIndex(arr, callback, defaultIndex) {\n  if (defaultIndex === void 0) {\n    defaultIndex = -1;\n  }\n  var length = arr.length;\n  for (var i = length - 1; i >= 0; --i) {\n    if (callback(arr[i], i, arr)) {\n      return i;\n    }\n  }\n  return defaultIndex;\n}\n/**\n* Returns the value of the reverse direction element in the array that satisfies the provided testing function.\n* @function\n* @memberof CrossBrowser\n* @param - The array `findLast` was called upon.\n* @param - A function to execute on each value in the array,\n* @param - Returns defalutValue if not found by the function.\n* @example\nimport { find } from \"@daybrush/utils\";\n\nfind([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // {a: 2}\n*/\nfunction findLast(arr, callback, defalutValue) {\n  var index = findLastIndex(arr, callback);\n  return index > -1 ? arr[index] : defalutValue;\n}\n/**\n* Returns the value of the first element in the array that satisfies the provided testing function.\n* @function\n* @memberof CrossBrowser\n* @param - The array `find` was called upon.\n* @param - A function to execute on each value in the array,\n* @param - Returns defalutValue if not found by the function.\n* @example\nimport { find } from \"@daybrush/utils\";\n\nfind([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // {a: 2}\n*/\nfunction find(arr, callback, defalutValue) {\n  var index = findIndex(arr, callback);\n  return index > -1 ? arr[index] : defalutValue;\n}\n/**\n* window.requestAnimationFrame() method with cross browser.\n* @function\n* @memberof CrossBrowser\n* @param {FrameRequestCallback} callback - The function to call when it's time to update your animation for the next repaint.\n* @return {number} id\n* @example\nimport {requestAnimationFrame} from \"@daybrush/utils\";\n\nrequestAnimationFrame((timestamp) => {\n  console.log(timestamp);\n});\n*/\nvar requestAnimationFrame = /*#__PURE__*/function () {\n  var firstTime = now();\n  var raf = IS_WINDOW && (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame);\n  return raf ? raf.bind(window) : function (callback) {\n    var currTime = now();\n    var id = setTimeout(function () {\n      callback(currTime - firstTime);\n    }, 1000 / 60);\n    return id;\n  };\n}();\n/**\n* window.cancelAnimationFrame() method with cross browser.\n* @function\n* @memberof CrossBrowser\n* @param {number} handle - the id obtained through requestAnimationFrame method\n* @return {void}\n* @example\nimport { requestAnimationFrame, cancelAnimationFrame } from \"@daybrush/utils\";\n\nconst id = requestAnimationFrame((timestamp) => {\n  console.log(timestamp);\n});\n\ncancelAnimationFrame(id);\n*/\nvar cancelAnimationFrame = /*#__PURE__*/function () {\n  var caf = IS_WINDOW && (window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame);\n  return caf ? caf.bind(window) : function (handle) {\n    clearTimeout(handle);\n  };\n}();\n/**\n* @function\n* @memberof Utils\n*/\nfunction getKeys(obj) {\n  return Object.keys(obj);\n}\n/**\n* @function\n* @memberof Utils\n*/\nfunction getValues(obj) {\n  var keys = getKeys(obj);\n  return keys.map(function (key) {\n    return obj[key];\n  });\n}\n/**\n* @function\n* @memberof Utils\n*/\nfunction getEntries(obj) {\n  var keys = getKeys(obj);\n  return keys.map(function (key) {\n    return [key, obj[key]];\n  });\n}\n/**\n* @function\n* @memberof Utils\n*/\nfunction sortOrders(keys, orders) {\n  if (orders === void 0) {\n    orders = [];\n  }\n  keys.sort(function (a, b) {\n    var index1 = orders.indexOf(a);\n    var index2 = orders.indexOf(b);\n    if (index2 === -1 && index1 === -1) {\n      return 0;\n    }\n    if (index1 === -1) {\n      return 1;\n    }\n    if (index2 === -1) {\n      return -1;\n    }\n    return index1 - index2;\n  });\n}\n/**\n* convert unit size to px size\n* @function\n* @memberof Utils\n*/\nfunction convertUnitSize(pos, size) {\n  var _a = splitUnit(pos),\n    value = _a.value,\n    unit = _a.unit;\n  if (isObject(size)) {\n    var sizeFunction = size[unit];\n    if (sizeFunction) {\n      if (isFunction(sizeFunction)) {\n        return sizeFunction(value);\n      } else if (DEFAULT_UNIT_PRESETS[unit]) {\n        return DEFAULT_UNIT_PRESETS[unit](value, sizeFunction);\n      }\n    }\n  } else if (unit === \"%\") {\n    return value * size / 100;\n  }\n  if (DEFAULT_UNIT_PRESETS[unit]) {\n    return DEFAULT_UNIT_PRESETS[unit](value);\n  }\n  return value;\n}\n/**\n* calculate between min, max\n* @function\n* @memberof Utils\n*/\nfunction between(value, min, max) {\n  return Math.max(min, Math.min(value, max));\n}\nfunction checkBoundSize(targetSize, compareSize, isMax, ratio) {\n  if (ratio === void 0) {\n    ratio = targetSize[0] / targetSize[1];\n  }\n  return [[throttle(compareSize[0], TINY_NUM), throttle(compareSize[0] / ratio, TINY_NUM)], [throttle(compareSize[1] * ratio, TINY_NUM), throttle(compareSize[1], TINY_NUM)]].filter(function (size) {\n    return size.every(function (value, i) {\n      var defaultSize = compareSize[i];\n      var throttledSize = throttle(defaultSize, TINY_NUM);\n      return isMax ? value <= defaultSize || value <= throttledSize : value >= defaultSize || value >= throttledSize;\n    });\n  })[0] || targetSize;\n}\n/**\n* calculate bound size\n* @function\n* @memberof Utils\n*/\nfunction calculateBoundSize(size, minSize, maxSize, keepRatio) {\n  if (!keepRatio) {\n    return size.map(function (value, i) {\n      return between(value, minSize[i], maxSize[i]);\n    });\n  }\n  var width = size[0],\n    height = size[1];\n  var ratio = keepRatio === true ? width / height : keepRatio;\n  // width : height = minWidth : minHeight;\n  var _a = checkBoundSize(size, minSize, false, ratio),\n    minWidth = _a[0],\n    minHeight = _a[1];\n  var _b = checkBoundSize(size, maxSize, true, ratio),\n    maxWidth = _b[0],\n    maxHeight = _b[1];\n  if (width < minWidth || height < minHeight) {\n    width = minWidth;\n    height = minHeight;\n  } else if (width > maxWidth || height > maxHeight) {\n    width = maxWidth;\n    height = maxHeight;\n  }\n  return [width, height];\n}\n/**\n* Add all the numbers.\n* @function\n* @memberof Utils\n*/\nfunction sum(nums) {\n  var length = nums.length;\n  var total = 0;\n  for (var i = length - 1; i >= 0; --i) {\n    total += nums[i];\n  }\n  return total;\n}\n/**\n* Average all numbers.\n* @function\n* @memberof Utils\n*/\nfunction average(nums) {\n  var length = nums.length;\n  var total = 0;\n  for (var i = length - 1; i >= 0; --i) {\n    total += nums[i];\n  }\n  return length ? total / length : 0;\n}\n/**\n* Get the angle of two points. (0 <= rad < 359)\n* @function\n* @memberof Utils\n*/\nfunction getRad(pos1, pos2) {\n  var distX = pos2[0] - pos1[0];\n  var distY = pos2[1] - pos1[1];\n  var rad = Math.atan2(distY, distX);\n  return rad >= 0 ? rad : rad + Math.PI * 2;\n}\n/**\n* Get the average point of all points.\n* @function\n* @memberof Utils\n*/\nfunction getCenterPoint(points) {\n  return [0, 1].map(function (i) {\n    return average(points.map(function (pos) {\n      return pos[i];\n    }));\n  });\n}\n/**\n* Gets the direction of the shape.\n* @function\n* @memberof Utils\n*/\nfunction getShapeDirection(points) {\n  var center = getCenterPoint(points);\n  var pos1Rad = getRad(center, points[0]);\n  var pos2Rad = getRad(center, points[1]);\n  return pos1Rad < pos2Rad && pos2Rad - pos1Rad < Math.PI || pos1Rad > pos2Rad && pos2Rad - pos1Rad < -Math.PI ? 1 : -1;\n}\n/**\n* Get the distance between two points.\n* @function\n* @memberof Utils\n*/\nfunction getDist(a, b) {\n  return Math.sqrt(Math.pow((b ? b[0] : 0) - a[0], 2) + Math.pow((b ? b[1] : 0) - a[1], 2));\n}\n/**\n* throttle number depending on the unit.\n* @function\n* @memberof Utils\n*/\nfunction throttle(num, unit) {\n  if (!unit) {\n    return num;\n  }\n  var reverseUnit = 1 / unit;\n  return Math.round(num / unit) / reverseUnit;\n}\n/**\n* throttle number array depending on the unit.\n* @function\n* @memberof Utils\n*/\nfunction throttleArray(nums, unit) {\n  nums.forEach(function (_, i) {\n    nums[i] = throttle(nums[i], unit);\n  });\n  return nums;\n}\n/**\n* @function\n* @memberof Utils\n*/\nfunction counter(num) {\n  var nums = [];\n  for (var i = 0; i < num; ++i) {\n    nums.push(i);\n  }\n  return nums;\n}\n/**\n* @function\n* @memberof Utils\n*/\nfunction replaceOnce(text, fromText, toText) {\n  var isOnce = false;\n  return text.replace(fromText, function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    if (isOnce) {\n      return args[0];\n    }\n    isOnce = true;\n    return isString(toText) ? toText : toText.apply(void 0, args);\n  });\n}\n/**\n* @function\n* @memberof Utils\n*/\nfunction flat(arr) {\n  return arr.reduce(function (prev, cur) {\n    return prev.concat(cur);\n  }, []);\n}\n/**\n* @function\n* @memberof Utils\n*/\nfunction deepFlat(arr) {\n  return arr.reduce(function (prev, cur) {\n    if (isArray(cur)) {\n      prev.push.apply(prev, deepFlat(cur));\n    } else {\n      prev.push(cur);\n    }\n    return prev;\n  }, []);\n}\n/**\n * @function\n * @memberof Utils\n */\nfunction pushSet(elements, element) {\n  if (elements.indexOf(element) === -1) {\n    elements.push(element);\n  }\n}\n\n/**\n* @namespace\n* @name Color\n*/\n/**\n* Remove the # from the hex color.\n* @memberof Color\n* @param {} hex - hex color\n* @return {} hex color\n* @example\nimport {cutHex} from \"@daybrush/utils\";\n\nconsole.log(cutHex(\"#000000\")) // \"000000\"\n*/\nfunction cutHex(hex) {\n  return hex.replace(\"#\", \"\");\n}\n/**\n* convert hex color to rgb color.\n* @memberof Color\n* @param {} hex - hex color\n* @return {} rgb color\n* @example\nimport {hexToRGBA} from \"@daybrush/utils\";\n\nconsole.log(hexToRGBA(\"#00000005\"));\n// [0, 0, 0, 1]\nconsole.log(hexToRGBA(\"#201045\"));\n// [32, 16, 69, 1]\n*/\nfunction hexToRGBA(hex) {\n  var h = cutHex(hex);\n  var r = parseInt(h.substring(0, 2), 16);\n  var g = parseInt(h.substring(2, 4), 16);\n  var b = parseInt(h.substring(4, 6), 16);\n  var a = parseInt(h.substring(6, 8), 16) / 255;\n  if (isNaN(a)) {\n    a = 1;\n  }\n  return [r, g, b, a];\n}\n/**\n* convert 3(or 4)-digit hex color to 6(or 8)-digit hex color.\n* @memberof Color\n* @param {} hex - 3(or 4)-digit hex color\n* @return {} 6(or 8)-digit hex color\n* @example\nimport {toFullHex} from \"@daybrush/utils\";\n\nconsole.log(toFullHex(\"#123\")); // \"#112233\"\nconsole.log(toFullHex(\"#123a\")); // \"#112233aa\"\n*/\nfunction toFullHex(h) {\n  var r = h.charAt(1);\n  var g = h.charAt(2);\n  var b = h.charAt(3);\n  var a = h.charAt(4);\n  var arr = [\"#\", r, r, g, g, b, b, a, a];\n  return arr.join(\"\");\n}\n/**\n* convert hsl color to rgba color.\n* @memberof Color\n* @param {} hsl - hsl color(hue: 0 ~ 360, saturation: 0 ~ 1, lightness: 0 ~ 1, alpha: 0 ~ 1)\n* @return {} rgba color\n* @example\nimport {hslToRGBA} from \"@daybrush/utils\";\n\nconsole.log(hslToRGBA([150, 0.5, 0.4]));\n// [51, 153, 102, 1]\n*/\nfunction hslToRGBA(hsl) {\n  var _a;\n  var h = hsl[0];\n  var s = hsl[1];\n  var l = hsl[2];\n  if (h < 0) {\n    h += Math.floor((Math.abs(h) + 360) / 360) * 360;\n  }\n  h %= 360;\n  var c = (1 - Math.abs(2 * l - 1)) * s;\n  var x = c * (1 - Math.abs(h / 60 % 2 - 1));\n  var m = l - c / 2;\n  var rgb;\n  if (h < 60) {\n    rgb = [c, x, 0];\n  } else if (h < 120) {\n    rgb = [x, c, 0];\n  } else if (h < 180) {\n    rgb = [0, c, x];\n  } else if (h < 240) {\n    rgb = [0, x, c];\n  } else if (h < 300) {\n    rgb = [x, 0, c];\n  } else if (h < 360) {\n    rgb = [c, 0, x];\n  } else {\n    rgb = [0, 0, 0];\n  }\n  return [Math.round((rgb[0] + m) * 255), Math.round((rgb[1] + m) * 255), Math.round((rgb[2] + m) * 255), (_a = hsl[3]) !== null && _a !== void 0 ? _a : 1];\n}\n/**\n* convert string to rgba color.\n* @memberof Color\n* @param {} - 3-hex(#000), 4-hex(#0000) 6-hex(#000000), 8-hex(#00000000) or RGB(A), or HSL(A)\n* @return {} rgba color\n* @example\nimport {stringToRGBA} from \"@daybrush/utils\";\n\nconsole.log(stringToRGBA(\"#000000\")); // [0, 0, 0, 1]\nconsole.log(stringToRGBA(\"rgb(100, 100, 100)\")); // [100, 100, 100, 1]\nconsole.log(stringToRGBA(\"hsl(150, 0.5, 0.4)\")); // [51, 153, 102, 1]\n*/\nfunction stringToRGBA(color) {\n  if (color.charAt(0) === \"#\") {\n    if (color.length === 4 || color.length === 5) {\n      return hexToRGBA(toFullHex(color));\n    } else {\n      return hexToRGBA(color);\n    }\n  } else if (color.indexOf(\"(\") !== -1) {\n    // in bracket.\n    var _a = splitBracket(color),\n      prefix = _a.prefix,\n      value = _a.value;\n    if (!prefix || !value) {\n      return undefined;\n    }\n    var arr = splitComma(value);\n    var colorArr = [0, 0, 0, 1];\n    var length = arr.length;\n    switch (prefix) {\n      case RGB:\n      case RGBA:\n        for (var i = 0; i < length; ++i) {\n          colorArr[i] = parseFloat(arr[i]);\n        }\n        return colorArr;\n      case HSL:\n      case HSLA:\n        for (var i = 0; i < length; ++i) {\n          if (arr[i].indexOf(\"%\") !== -1) {\n            colorArr[i] = parseFloat(arr[i]) / 100;\n          } else {\n            colorArr[i] = parseFloat(arr[i]);\n          }\n        }\n        // hsl, hsla to rgba\n        return hslToRGBA(colorArr);\n    }\n  }\n  return undefined;\n}\n\n/**\n * Returns all element descendants of node that\n * match selectors.\n */\n/**\n * Checks if the specified class value exists in the element's class attribute.\n * @memberof DOM\n * @param - A DOMString containing one or more selectors to match\n * @param - If multi is true, a DOMString containing one or more selectors to match against.\n * @example\nimport {$} from \"@daybrush/utils\";\n\nconsole.log($(\"div\")); // div element\nconsole.log($(\"div\", true)); // [div, div] elements\n*/\nfunction $(selectors, multi) {\n  if (!doc) {\n    return multi ? [] : null;\n  }\n  return multi ? doc.querySelectorAll(selectors) : doc.querySelector(selectors);\n}\n/**\n* Checks if the specified class value exists in the element's class attribute.\n* @memberof DOM\n* @param element - target\n* @param className - the class name to search\n* @return {boolean} return false if the class is not found.\n* @example\nimport {hasClass} from \"@daybrush/utils\";\n\nconsole.log(hasClass(element, \"start\")); // true or false\n*/\nfunction hasClass(element, className) {\n  if (element.classList) {\n    return element.classList.contains(className);\n  }\n  return !!element.className.match(new RegExp(\"(\\\\s|^)\" + className + \"(\\\\s|$)\"));\n}\n/**\n* Add the specified class value. If these classe already exist in the element's class attribute they are ignored.\n* @memberof DOM\n* @param element - target\n* @param className - the class name to add\n* @example\nimport {addClass} from \"@daybrush/utils\";\n\naddClass(element, \"start\");\n*/\nfunction addClass(element, className) {\n  if (element.classList) {\n    element.classList.add(className);\n  } else {\n    element.className += \" \" + className;\n  }\n}\n/**\n* Removes the specified class value.\n* @memberof DOM\n* @param element - target\n* @param className - the class name to remove\n* @example\nimport {removeClass} from \"@daybrush/utils\";\n\nremoveClass(element, \"start\");\n*/\nfunction removeClass(element, className) {\n  if (element.classList) {\n    element.classList.remove(className);\n  } else {\n    var reg = new RegExp(\"(\\\\s|^)\" + className + \"(\\\\s|$)\");\n    element.className = element.className.replace(reg, \" \");\n  }\n}\n/**\n* Gets the CSS properties from the element.\n* @memberof DOM\n* @param elements - elements\n* @param properites - the CSS properties\n* @return returns CSS properties and values.\n* @example\nimport {fromCSS} from \"@daybrush/utils\";\n\nconsole.log(fromCSS(element, [\"left\", \"opacity\", \"top\"])); // {\"left\": \"10px\", \"opacity\": 1, \"top\": \"10px\"}\n*/\nfunction fromCSS(elements, properties) {\n  if (!elements || !properties || !properties.length) {\n    return {};\n  }\n  var element;\n  if (elements instanceof Element) {\n    element = elements;\n  } else if (elements.length) {\n    element = elements[0];\n  } else {\n    return {};\n  }\n  var cssObject = {};\n  var styles = getWindow(element).getComputedStyle(element);\n  var length = properties.length;\n  for (var i = 0; i < length; ++i) {\n    cssObject[properties[i]] = styles[properties[i]];\n  }\n  return cssObject;\n}\n/**\n* Sets up a function that will be called whenever the specified event is delivered to the target\n* @memberof DOM\n* @param - event target\n* @param - A case-sensitive string representing the event type to listen for.\n* @param - The object which receives a notification (an object that implements the Event interface) when an event of the specified type occurs\n* @param - An options object that specifies characteristics about the event listener.\n* @example\nimport {addEvent} from \"@daybrush/utils\";\n\naddEvent(el, \"click\", e => {\n  console.log(e);\n});\n*/\nfunction addEvent(el, type, listener, options) {\n  el.addEventListener(type, listener, options);\n}\n/**\n* removes from the EventTarget an event listener previously registered with EventTarget.addEventListener()\n* @memberof DOM\n* @param - event target\n* @param - A case-sensitive string representing the event type to listen for.\n* @param - The EventListener function of the event handler to remove from the event target.\n* @param - An options object that specifies characteristics about the event listener.\n* @example\nimport {addEvent, removeEvent} from \"@daybrush/utils\";\nconst listener = e => {\n  console.log(e);\n};\naddEvent(el, \"click\", listener);\nremoveEvent(el, \"click\", listener);\n*/\nfunction removeEvent(el, type, listener, options) {\n  el.removeEventListener(type, listener, options);\n}\nfunction getDocument(el) {\n  return (el === null || el === void 0 ? void 0 : el.ownerDocument) || doc;\n}\nfunction getDocumentElement(el) {\n  return getDocument(el).documentElement;\n}\nfunction getDocumentBody(el) {\n  return getDocument(el).body;\n}\nfunction getWindow(el) {\n  var _a;\n  return ((_a = el === null || el === void 0 ? void 0 : el.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView) || window;\n}\nfunction isWindow(val) {\n  return val && \"postMessage\" in val && \"blur\" in val && \"self\" in val;\n}\nfunction isNode(el) {\n  return isObject(el) && el.nodeName && el.nodeType && \"ownerDocument\" in el;\n}\n\nexport { RGB, RGBA, HSL, HSLA, COLOR_MODELS, FUNCTION, PROPERTY, ARRAY, OBJECT, STRING, NUMBER, UNDEFINED, IS_WINDOW, doc as document, getCrossBrowserProperty, TRANSFORM, FILTER, ANIMATION, KEYFRAMES, OPEN_CLOSED_CHARACTERS, TINY_NUM, REVERSE_TINY_NUM, DEFAULT_UNIT_PRESETS, cutHex, hexToRGBA, toFullHex, hslToRGBA, stringToRGBA, dot, isUndefined, isObject, isArray, isString, isNumber, isFunction, splitText, splitSpace, splitComma, splitBracket, splitUnit, camelize, decamelize, toArray, now, findIndex, findLastIndex, findLast, find, requestAnimationFrame, cancelAnimationFrame, getKeys, getValues, getEntries, sortOrders, convertUnitSize, between, checkBoundSize, calculateBoundSize, sum, average, getRad, getCenterPoint, getShapeDirection, getDist, throttle, throttleArray, counter, replaceOnce, flat, deepFlat, pushSet, $, hasClass, addClass, removeClass, fromCSS, addEvent, removeEvent, getDocument, getDocumentElement, getDocumentBody, getWindow, isWindow, isNode };\n//# sourceMappingURL=utils.esm.js.map\n", "/*\nCopyright (c) 2020 Daybrush\nname: @scena/matrix\nlicense: MIT\nauthor: Daybrush\nrepository: git+https://github.com/daybrush/matrix\nversion: 1.1.1\n*/\nimport { throttle, TINY_NUM, average } from '@daybrush/utils';\n\nfunction add(matrix, inverseMatrix, startIndex, fromIndex, n, k) {\n  for (var i = 0; i < n; ++i) {\n    var x = startIndex + i * n;\n    var fromX = fromIndex + i * n;\n    matrix[x] += matrix[fromX] * k;\n    inverseMatrix[x] += inverseMatrix[fromX] * k;\n  }\n}\n\nfunction swap(matrix, inverseMatrix, startIndex, fromIndex, n) {\n  for (var i = 0; i < n; ++i) {\n    var x = startIndex + i * n;\n    var fromX = fromIndex + i * n;\n    var v = matrix[x];\n    var iv = inverseMatrix[x];\n    matrix[x] = matrix[fromX];\n    matrix[fromX] = v;\n    inverseMatrix[x] = inverseMatrix[fromX];\n    inverseMatrix[fromX] = iv;\n  }\n}\n\nfunction divide(matrix, inverseMatrix, startIndex, n, k) {\n  for (var i = 0; i < n; ++i) {\n    var x = startIndex + i * n;\n    matrix[x] /= k;\n    inverseMatrix[x] /= k;\n  }\n}\n/**\n *\n * @namespace Matrix\n */\n\n/**\n * @memberof Matrix\n */\n\n\nfunction ignoreDimension(matrix, m, n) {\n  if (n === void 0) {\n    n = Math.sqrt(matrix.length);\n  }\n\n  var newMatrix = matrix.slice();\n\n  for (var i = 0; i < n; ++i) {\n    newMatrix[i * n + m - 1] = 0;\n    newMatrix[(m - 1) * n + i] = 0;\n  }\n\n  newMatrix[(m - 1) * (n + 1)] = 1;\n  return newMatrix;\n}\n/**\n * @memberof Matrix\n */\n\nfunction invert(matrix, n) {\n  if (n === void 0) {\n    n = Math.sqrt(matrix.length);\n  }\n\n  var newMatrix = matrix.slice();\n  var inverseMatrix = createIdentityMatrix(n);\n\n  for (var i = 0; i < n; ++i) {\n    // diagonal\n    var identityIndex = n * i + i;\n\n    if (!throttle(newMatrix[identityIndex], TINY_NUM)) {\n      // newMatrix[identityIndex] = 0;\n      for (var j = i + 1; j < n; ++j) {\n        if (newMatrix[n * i + j]) {\n          swap(newMatrix, inverseMatrix, i, j, n);\n          break;\n        }\n      }\n    }\n\n    if (!throttle(newMatrix[identityIndex], TINY_NUM)) {\n      // no inverse matrix\n      return [];\n    }\n\n    divide(newMatrix, inverseMatrix, i, n, newMatrix[identityIndex]);\n\n    for (var j = 0; j < n; ++j) {\n      var targetStartIndex = j;\n      var targetIndex = j + i * n;\n      var target = newMatrix[targetIndex];\n\n      if (!throttle(target, TINY_NUM) || i === j) {\n        continue;\n      }\n\n      add(newMatrix, inverseMatrix, targetStartIndex, i, n, -target);\n    }\n  }\n\n  return inverseMatrix;\n}\n/**\n * @memberof Matrix\n */\n\nfunction transpose(matrix, n) {\n  if (n === void 0) {\n    n = Math.sqrt(matrix.length);\n  }\n\n  var newMatrix = [];\n\n  for (var i = 0; i < n; ++i) {\n    for (var j = 0; j < n; ++j) {\n      newMatrix[j * n + i] = matrix[n * i + j];\n    }\n  }\n\n  return newMatrix;\n}\n/**\n * @memberof Matrix\n */\n\nfunction getOrigin(matrix, n) {\n  if (n === void 0) {\n    n = Math.sqrt(matrix.length);\n  }\n\n  var originMatrix = [];\n  var w = matrix[n * n - 1];\n\n  for (var i = 0; i < n - 1; ++i) {\n    originMatrix[i] = matrix[n * (n - 1) + i] / w;\n  }\n\n  originMatrix[n - 1] = 0;\n  return originMatrix;\n}\n/**\n * @memberof Matrix\n */\n\nfunction fromTranslation(pos, n) {\n  var newMatrix = createIdentityMatrix(n);\n\n  for (var i = 0; i < n - 1; ++i) {\n    newMatrix[n * (n - 1) + i] = pos[i] || 0;\n  }\n\n  return newMatrix;\n}\n/**\n * @memberof Matrix\n */\n\nfunction convertPositionMatrix(matrix, n) {\n  var newMatrix = matrix.slice();\n\n  for (var i = matrix.length; i < n - 1; ++i) {\n    newMatrix[i] = 0;\n  }\n\n  newMatrix[n - 1] = 1;\n  return newMatrix;\n}\n/**\n * @memberof Matrix\n */\n\nfunction convertDimension(matrix, n, m) {\n  if (n === void 0) {\n    n = Math.sqrt(matrix.length);\n  } // n < m\n\n\n  if (n === m) {\n    return matrix;\n  }\n\n  var newMatrix = createIdentityMatrix(m);\n  var length = Math.min(n, m);\n\n  for (var i = 0; i < length - 1; ++i) {\n    for (var j = 0; j < length - 1; ++j) {\n      newMatrix[i * m + j] = matrix[i * n + j];\n    }\n\n    newMatrix[(i + 1) * m - 1] = matrix[(i + 1) * n - 1];\n    newMatrix[(m - 1) * m + i] = matrix[(n - 1) * n + i];\n  }\n\n  newMatrix[m * m - 1] = matrix[n * n - 1];\n  return newMatrix;\n}\n/**\n * @memberof Matrix\n */\n\nfunction multiplies(n) {\n  var matrixes = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    matrixes[_i - 1] = arguments[_i];\n  }\n\n  var m = createIdentityMatrix(n);\n  matrixes.forEach(function (matrix) {\n    m = multiply(m, matrix, n);\n  });\n  return m;\n}\n/**\n * @memberof Matrix\n */\n\nfunction multiply(matrix, matrix2, n) {\n  if (n === void 0) {\n    n = Math.sqrt(matrix.length);\n  }\n\n  var newMatrix = []; // 1 y: n\n  // 1 x: m\n  // 2 x: m\n  // 2 y: k\n  // n * m X m * k\n\n  var m = matrix.length / n;\n  var k = matrix2.length / m;\n\n  if (!m) {\n    return matrix2;\n  } else if (!k) {\n    return matrix;\n  }\n\n  for (var i = 0; i < n; ++i) {\n    for (var j = 0; j < k; ++j) {\n      newMatrix[j * n + i] = 0;\n\n      for (var l = 0; l < m; ++l) {\n        // m1 x: m(l), y: n(i)\n        // m2 x: k(j):  y: m(l)\n        // nw x: n(i), y: k(j)\n        newMatrix[j * n + i] += matrix[l * n + i] * matrix2[j * m + l];\n      }\n    }\n  } // n * k\n\n\n  return newMatrix;\n}\n/**\n * @memberof Matrix\n */\n\nfunction plus(pos1, pos2) {\n  var length = Math.min(pos1.length, pos2.length);\n  var nextPos = pos1.slice();\n\n  for (var i = 0; i < length; ++i) {\n    nextPos[i] = nextPos[i] + pos2[i];\n  }\n\n  return nextPos;\n}\n/**\n * @memberof Matrix\n */\n\nfunction minus(pos1, pos2) {\n  var length = Math.min(pos1.length, pos2.length);\n  var nextPos = pos1.slice();\n\n  for (var i = 0; i < length; ++i) {\n    nextPos[i] = nextPos[i] - pos2[i];\n  }\n\n  return nextPos;\n}\n/**\n * @memberof Matrix\n */\n\nfunction convertCSStoMatrix(a, is2d) {\n  if (is2d === void 0) {\n    is2d = a.length === 6;\n  }\n\n  if (is2d) {\n    return [a[0], a[1], 0, a[2], a[3], 0, a[4], a[5], 1];\n  }\n\n  return a;\n}\n/**\n * @memberof Matrix\n */\n\nfunction convertMatrixtoCSS(a, is2d) {\n  if (is2d === void 0) {\n    is2d = a.length === 9;\n  }\n\n  if (is2d) {\n    return [a[0], a[1], a[3], a[4], a[6], a[7]];\n  }\n\n  return a;\n}\n/**\n * @memberof Matrix\n */\n\nfunction calculate(matrix, matrix2, n) {\n  if (n === void 0) {\n    n = matrix2.length;\n  }\n\n  var result = multiply(matrix, matrix2, n);\n  var k = result[n - 1];\n  return result.map(function (v) {\n    return v / k;\n  });\n}\n/**\n * @memberof Matrix\n */\n\nfunction rotateX3d(matrix, rad) {\n  return multiply(matrix, [1, 0, 0, 0, 0, Math.cos(rad), Math.sin(rad), 0, 0, -Math.sin(rad), Math.cos(rad), 0, 0, 0, 0, 1], 4);\n}\n/**\n * @memberof Matrix\n */\n\nfunction rotateY3d(matrix, rad) {\n  return multiply(matrix, [Math.cos(rad), 0, -Math.sin(rad), 0, 0, 1, 0, 0, Math.sin(rad), 0, Math.cos(rad), 0, 0, 0, 0, 1], 4);\n}\n/**\n * @memberof Matrix\n */\n\nfunction rotateZ3d(matrix, rad) {\n  return multiply(matrix, createRotateMatrix(rad, 4));\n}\n/**\n * @memberof Matrix\n */\n\nfunction scale3d(matrix, _a) {\n  var _b = _a[0],\n      sx = _b === void 0 ? 1 : _b,\n      _c = _a[1],\n      sy = _c === void 0 ? 1 : _c,\n      _d = _a[2],\n      sz = _d === void 0 ? 1 : _d;\n  return multiply(matrix, [sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1], 4);\n}\n/**\n * @memberof Matrix\n */\n\nfunction rotate(pos, rad) {\n  return calculate(createRotateMatrix(rad, 3), convertPositionMatrix(pos, 3));\n}\n/**\n * @memberof Matrix\n */\n\nfunction translate3d(matrix, _a) {\n  var _b = _a[0],\n      tx = _b === void 0 ? 0 : _b,\n      _c = _a[1],\n      ty = _c === void 0 ? 0 : _c,\n      _d = _a[2],\n      tz = _d === void 0 ? 0 : _d;\n  return multiply(matrix, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1], 4);\n}\n/**\n * @memberof Matrix\n */\n\nfunction matrix3d(matrix1, matrix2) {\n  return multiply(matrix1, matrix2, 4);\n}\n/**\n * @memberof Matrix\n */\n\nfunction createRotateMatrix(rad, n) {\n  var cos = Math.cos(rad);\n  var sin = Math.sin(rad);\n  var m = createIdentityMatrix(n); // cos -sin\n  // sin cos\n\n  m[0] = cos;\n  m[1] = sin;\n  m[n] = -sin;\n  m[n + 1] = cos;\n  return m;\n}\n/**\n * @memberof Matrix\n */\n\nfunction createIdentityMatrix(n) {\n  var length = n * n;\n  var matrix = [];\n\n  for (var i = 0; i < length; ++i) {\n    matrix[i] = i % (n + 1) ? 0 : 1;\n  }\n\n  return matrix;\n}\n/**\n * @memberof Matrix\n */\n\nfunction createScaleMatrix(scale, n) {\n  var m = createIdentityMatrix(n);\n  var length = Math.min(scale.length, n - 1);\n\n  for (var i = 0; i < length; ++i) {\n    m[(n + 1) * i] = scale[i];\n  }\n\n  return m;\n}\n/**\n * @memberof Matrix\n */\n\nfunction createOriginMatrix(origin, n) {\n  var m = createIdentityMatrix(n);\n  var length = Math.min(origin.length, n - 1);\n\n  for (var i = 0; i < length; ++i) {\n    m[n * (n - 1) + i] = origin[i];\n  }\n\n  return m;\n}\n/**\n * @memberof Matrix\n */\n\nfunction createWarpMatrix(pos0, pos1, pos2, pos3, nextPos0, nextPos1, nextPos2, nextPos3) {\n  var x0 = pos0[0],\n      y0 = pos0[1];\n  var x1 = pos1[0],\n      y1 = pos1[1];\n  var x2 = pos2[0],\n      y2 = pos2[1];\n  var x3 = pos3[0],\n      y3 = pos3[1];\n  var u0 = nextPos0[0],\n      v0 = nextPos0[1];\n  var u1 = nextPos1[0],\n      v1 = nextPos1[1];\n  var u2 = nextPos2[0],\n      v2 = nextPos2[1];\n  var u3 = nextPos3[0],\n      v3 = nextPos3[1];\n  var matrix = [x0, 0, x1, 0, x2, 0, x3, 0, y0, 0, y1, 0, y2, 0, y3, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, x0, 0, x1, 0, x2, 0, x3, 0, y0, 0, y1, 0, y2, 0, y3, 0, 1, 0, 1, 0, 1, 0, 1, -u0 * x0, -v0 * x0, -u1 * x1, -v1 * x1, -u2 * x2, -v2 * x2, -u3 * x3, -v3 * x3, -u0 * y0, -v0 * y0, -u1 * y1, -v1 * y1, -u2 * y2, -v2 * y2, -u3 * y3, -v3 * y3];\n  var inverseMatrix = invert(matrix, 8);\n\n  if (!inverseMatrix.length) {\n    return [];\n  }\n\n  var h = multiply(inverseMatrix, [u0, v0, u1, v1, u2, v2, u3, v3], 8);\n  h[8] = 1;\n  return convertDimension(transpose(h), 3, 4);\n}\n/**\n * @memberof Matrix\n */\n\nfunction getCenter(points) {\n  return [0, 1].map(function (i) {\n    return average(points.map(function (pos) {\n      return pos[i];\n    }));\n  });\n}\n\nexport { calculate, convertCSStoMatrix, convertDimension, convertMatrixtoCSS, convertPositionMatrix, createIdentityMatrix, createOriginMatrix, createRotateMatrix, createScaleMatrix, createWarpMatrix, fromTranslation, getCenter, getOrigin, ignoreDimension, invert, matrix3d, minus, multiplies, multiply, plus, rotate, rotateX3d, rotateY3d, rotateZ3d, scale3d, translate3d, transpose };\n//# sourceMappingURL=matrix.esm.js.map\n", "/*\nCopyright (c) 2019 Daybrush\nname: css-to-mat\nlicense: MIT\nauthor: Daybrush\nrepository: git+https://github.com/daybrush/css-to-mat.git\nversion: 1.1.0\n*/\nimport { isArray, splitSpace, splitBracket, isObject, splitComma, convertUnitSize, splitUnit } from '@daybrush/utils';\nimport { calculate, matrix3d, invert, translate3d, scale3d, rotateZ3d, rotateX3d, rotateY3d } from '@scena/matrix';\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\n\nfunction createMatrix() {\n    return [\n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, 1, 0,\n        0, 0, 0, 1,\n    ];\n}\nfunction parseMat(transform, size) {\n    if (size === void 0) { size = 0; }\n    return toMat(parse(transform, size));\n}\nfunction getElementMatrix(el) {\n    return parseMat(getComputedStyle(el).transform);\n}\nfunction calculateMatrixDist(matrix, pos) {\n    var res = calculate(matrix, [pos[0], pos[1] || 0, pos[2] || 0, 1], 4);\n    var w = res[3] || 1;\n    return [\n        res[0] / w,\n        res[1] / w,\n        res[2] / w,\n    ];\n}\nfunction getDistElementMatrix(el, container) {\n    if (container === void 0) { container = document.body; }\n    var target = el;\n    var matrix = createMatrix();\n    while (target) {\n        var transform = getComputedStyle(target).transform;\n        matrix = matrix3d(parseMat(transform), matrix);\n        if (target === container) {\n            break;\n        }\n        target = target.parentElement;\n    }\n    matrix = invert(matrix, 4);\n    matrix[12] = 0;\n    matrix[13] = 0;\n    matrix[14] = 0;\n    return matrix;\n}\nfunction toMat(matrixInfos) {\n    var target = createMatrix();\n    matrixInfos.forEach(function (info) {\n        var matrixFunction = info.matrixFunction, functionValue = info.functionValue;\n        if (!matrixFunction) {\n            return;\n        }\n        target = matrixFunction(target, functionValue);\n    });\n    return target;\n}\nfunction parse(transform, size) {\n    if (size === void 0) { size = 0; }\n    var transforms = isArray(transform) ? transform : splitSpace(transform);\n    return transforms.map(function (t) {\n        var _a = splitBracket(t), name = _a.prefix, value = _a.value;\n        var matrixFunction = null;\n        var functionName = name;\n        var functionValue = \"\";\n        if (name === \"translate\" || name === \"translateX\" || name === \"translate3d\") {\n            var nextSize_1 = isObject(size) ? __assign(__assign({}, size), { \"o%\": size[\"%\"] }) : {\n                \"%\": size,\n                \"o%\": size,\n            };\n            var _b = splitComma(value).map(function (v, i) {\n                if (i === 0 && \"x%\" in nextSize_1) {\n                    nextSize_1[\"%\"] = size[\"x%\"];\n                }\n                else if (i === 1 && \"y%\" in nextSize_1) {\n                    nextSize_1[\"%\"] = size[\"y%\"];\n                }\n                else {\n                    nextSize_1[\"%\"] = size[\"o%\"];\n                }\n                return convertUnitSize(v, nextSize_1);\n            }), posX = _b[0], _c = _b[1], posY = _c === void 0 ? 0 : _c, _d = _b[2], posZ = _d === void 0 ? 0 : _d;\n            matrixFunction = translate3d;\n            functionValue = [posX, posY, posZ];\n        }\n        else if (name === \"translateY\") {\n            var nextSize = isObject(size) ? __assign({ \"%\": size[\"y%\"] }, size) : {\n                \"%\": size,\n            };\n            var posY = convertUnitSize(value, nextSize);\n            matrixFunction = translate3d;\n            functionValue = [0, posY, 0];\n        }\n        else if (name === \"translateZ\") {\n            var posZ = parseFloat(value);\n            matrixFunction = translate3d;\n            functionValue = [0, 0, posZ];\n        }\n        else if (name === \"scale\" || name === \"scale3d\") {\n            var _e = splitComma(value).map(function (v) { return parseFloat(v); }), sx = _e[0], _f = _e[1], sy = _f === void 0 ? sx : _f, _g = _e[2], sz = _g === void 0 ? 1 : _g;\n            matrixFunction = scale3d;\n            functionValue = [sx, sy, sz];\n        }\n        else if (name === \"scaleX\") {\n            var sx = parseFloat(value);\n            matrixFunction = scale3d;\n            functionValue = [sx, 1, 1];\n        }\n        else if (name === \"scaleY\") {\n            var sy = parseFloat(value);\n            matrixFunction = scale3d;\n            functionValue = [1, sy, 1];\n        }\n        else if (name === \"scaleZ\") {\n            var sz = parseFloat(value);\n            matrixFunction = scale3d;\n            functionValue = [1, 1, sz];\n        }\n        else if (name === \"rotate\" || name === \"rotateZ\" || name === \"rotateX\" || name === \"rotateY\") {\n            var _h = splitUnit(value), unit = _h.unit, unitValue = _h.value;\n            var rad = unit === \"rad\" ? unitValue : unitValue * Math.PI / 180;\n            if (name === \"rotate\" || name === \"rotateZ\") {\n                functionName = \"rotateZ\";\n                matrixFunction = rotateZ3d;\n            }\n            else if (name === \"rotateX\") {\n                matrixFunction = rotateX3d;\n            }\n            else if (name === \"rotateY\") {\n                matrixFunction = rotateY3d;\n            }\n            functionValue = rad;\n        }\n        else if (name === \"matrix3d\") {\n            matrixFunction = matrix3d;\n            functionValue = splitComma(value).map(function (v) { return parseFloat(v); });\n        }\n        else if (name === \"matrix\") {\n            var m = splitComma(value).map(function (v) { return parseFloat(v); });\n            matrixFunction = matrix3d;\n            functionValue = [\n                m[0], m[1], 0, 0,\n                m[2], m[3], 0, 0,\n                0, 0, 1, 0,\n                m[4], m[5], 0, 1,\n            ];\n        }\n        else {\n            functionName = \"\";\n        }\n        return {\n            name: name,\n            functionName: functionName,\n            value: value,\n            matrixFunction: matrixFunction,\n            functionValue: functionValue,\n        };\n    });\n}\n\nexport { calculateMatrixDist, createMatrix, getDistElementMatrix, getElementMatrix, parse, parseMat, toMat };\n//# sourceMappingURL=css-to-mat.esm.js.map\n", "import { MoveableManagerState, OnCustomDrag } from \"../types\";\nimport { convertDragDist } from \"../utils\";\n\nexport function setCustomDrag(\n    e: any,\n    state: MoveableManagerState<any>,\n    delta: number[],\n    isPinch: boolean,\n    isConvert: boolean,\n    ableName = \"draggable\",\n) {\n    const result = state.gestos[ableName]?.move(delta, e.inputEvent) ?? {};\n    const datas = result.originalDatas || result.datas;\n    const ableDatas = datas[ableName] || (datas[ableName] = {});\n\n    return {\n        ...(isConvert ? convertDragDist(state, result) : result),\n        isPinch: !!isPinch,\n        parentEvent: true,\n        datas: ableDatas,\n        originalDatas: e.originalDatas,\n    };\n}\n\nexport default class CustomGesto {\n    private prevX = 0;\n    private prevY = 0;\n    private startX = 0;\n    private startY = 0;\n    private isDrag = false;\n    private isFlag = false;\n    private datas: any = {\n        draggable: {},\n    };\n    constructor(private ableName = \"draggable\") {\n        this.datas = {\n            [ableName]: {},\n        };\n    }\n\n    public dragStart(client: number[], e: any) {\n        this.isDrag = false;\n        this.isFlag = false;\n        const originalDatas = e.originalDatas;\n\n        this.datas = originalDatas;\n        if (!originalDatas[this.ableName]) {\n            originalDatas[this.ableName] = {};\n        }\n        return {\n            ...this.move(client, e.inputEvent),\n            type: \"dragstart\",\n        };\n    }\n    public drag(client: number[], inputEvent: any) {\n        return this.move([\n            client[0] - this.prevX,\n            client[1] - this.prevY,\n        ], inputEvent);\n    }\n    public move(delta: number[], inputEvent: any): OnCustomDrag {\n        let clientX!: number;\n        let clientY!: number;\n        let isFirstDrag = false;\n\n        if (!this.isFlag) {\n            this.prevX = delta[0];\n            this.prevY = delta[1];\n            this.startX = delta[0];\n            this.startY = delta[1];\n\n            clientX = delta[0];\n            clientY = delta[1];\n\n            this.isFlag = true;\n        } else {\n            const isPrevDrag = this.isDrag;\n\n            clientX = this.prevX + delta[0];\n            clientY = this.prevY + delta[1];\n\n            if (delta[0] || delta[1]) {\n                this.isDrag = true;\n            }\n\n            if (!isPrevDrag && this.isDrag) {\n                isFirstDrag = true;\n            }\n        }\n\n        this.prevX = clientX;\n        this.prevY = clientY;\n\n        return {\n            type: \"drag\",\n            clientX,\n            clientY,\n            inputEvent,\n            isFirstDrag,\n            isDrag: this.isDrag,\n            distX: clientX - this.startX,\n            distY: clientY - this.startY,\n            deltaX: delta[0],\n            deltaY: delta[1],\n            datas: this.datas[this.ableName],\n            originalDatas: this.datas,\n            parentEvent: true,\n            parentGesto: this,\n        };\n    }\n}\n", "import { MoveablePosition } from '../types';\nimport { calculatePoses, calculatePosition, sign } from '../utils';\n\nexport function calculateElementPosition(\n  matrix: number[],\n  origin: number[],\n  width: number,\n  height: number,\n): MoveablePosition {\n  const is3d = matrix.length === 16;\n  const n = is3d ? 4 : 3;\n  const poses = calculatePoses(matrix, width, height, n);\n  let [[x1, y1], [x2, y2], [x3, y3], [x4, y4]] = poses;\n  let [originX, originY] = calculatePosition(matrix, origin, n);\n\n  const left = Math.min(x1, x2, x3, x4);\n  const top = Math.min(y1, y2, y3, y4);\n  const right = Math.max(x1, x2, x3, x4);\n  const bottom = Math.max(y1, y2, y3, y4);\n\n  x1 = x1 - left || 0;\n  x2 = x2 - left || 0;\n  x3 = x3 - left || 0;\n  x4 = x4 - left || 0;\n\n  y1 = y1 - top || 0;\n  y2 = y2 - top || 0;\n  y3 = y3 - top || 0;\n  y4 = y4 - top || 0;\n\n  originX = originX - left || 0;\n  originY = originY - top || 0;\n\n  const sx = matrix[0];\n  const sy = matrix[n + 1];\n  const direction = sign(sx * sy);\n\n  return {\n    left,\n    top,\n    right,\n    bottom,\n    origin: [originX, originY],\n    pos1: [x1, y1],\n    pos2: [x2, y2],\n    pos3: [x3, y3],\n    pos4: [x4, y4],\n    direction,\n  };\n}\n", "\nimport {\n    invert, calculate, minus, plus,\n    convertPositionMatrix,\n    createScaleMatrix, multiply, fromTranslation, convertDimension,\n} from \"@scena/matrix\";\nimport {\n    calculatePoses, getAbsoluteMatrix, getAbsolutePosesByState,\n    calculatePosition, calculateInversePosition, convertTransformInfo, fillCSSObject,\n} from \"../utils\";\nimport { splitUnit, isArray, splitSpace, findIndex, dot, find, isString } from \"@daybrush/utils\";\nimport {\n    MoveableManagerState, ResizableProps, MoveableManagerInterface,\n    OnTransformEvent, OnTransformStartEvent, DraggableProps, OnDrag,\n} from \"../types\";\nimport { setCustomDrag } from \"./CustomGesto\";\nimport { parse, parseMat } from \"css-to-mat\";\nimport { Draggable } from \"../index.esm\";\nimport { calculateElementPosition } from \"../utils/calculateElementPosition\";\n\nexport function calculatePointerDist(moveable: MoveableManagerInterface, e: any) {\n    const { clientX, clientY, datas } = e;\n    const {\n        moveableClientRect,\n        rootMatrix,\n        is3d,\n        pos1,\n    } = moveable.state;\n    const { left, top } = moveableClientRect;\n    const n = is3d ? 4 : 3;\n    const [posX, posY] = minus(calculateInversePosition(rootMatrix, [clientX - left, clientY - top], n), pos1);\n    const [distX, distY] = getDragDist({ datas, distX: posX, distY: posY });\n\n    return [distX, distY];\n}\n\nexport function setDragStart(moveable: MoveableManagerInterface<any>, { datas }: any) {\n    const {\n        allMatrix,\n        beforeMatrix,\n        is3d,\n        left,\n        top,\n        origin,\n        offsetMatrix,\n        targetMatrix,\n        transformOrigin,\n    } = moveable.state;\n    const n = is3d ? 4 : 3;\n\n    datas.is3d = is3d;\n    datas.matrix = allMatrix;\n    datas.targetMatrix = targetMatrix;\n    datas.beforeMatrix = beforeMatrix;\n    datas.offsetMatrix = offsetMatrix;\n    datas.transformOrigin = transformOrigin;\n    datas.inverseMatrix = invert(allMatrix, n);\n    datas.inverseBeforeMatrix = invert(beforeMatrix, n);\n    datas.absoluteOrigin = convertPositionMatrix(plus([left, top], origin), n);\n    datas.startDragBeforeDist = calculate(datas.inverseBeforeMatrix, datas.absoluteOrigin, n);\n    datas.startDragDist = calculate(datas.inverseMatrix, datas.absoluteOrigin, n);\n}\n\nexport function getTransformDirection(e: any) {\n    return calculateElementPosition(e.datas.beforeTransform, [50, 50], 100, 100).direction;\n}\n\n\nexport interface OriginalDataTransformInfos {\n    startTransforms: string[];\n    nextTransforms: string[];\n    nextTransformAppendedIndexes: number[];\n}\n\nexport function resolveTransformEvent(moveable: MoveableManagerInterface, event: any, functionName: string) {\n    const {\n        datas,\n        originalDatas: {\n            beforeRenderable: originalDatas,\n        },\n    } = event;\n\n    const index = datas.transformIndex;\n\n    const nextTransforms = originalDatas.nextTransforms as string[];\n    const length = nextTransforms.length;\n    const nextTransformAppendedIndexes: any[] = originalDatas.nextTransformAppendedIndexes;\n    let nextIndex = -1;\n\n    if (index === -1) {\n        // translate => rotate => scale\n        if (functionName === \"translate\") {\n            nextIndex = 0;\n        } else if (functionName === \"rotate\") {\n            nextIndex = findIndex(nextTransforms, text => text.match(/scale\\(/g,));\n        }\n        if (nextIndex === -1) {\n            nextIndex = nextTransforms.length;\n        }\n        datas.transformIndex = nextIndex;\n    } else if (find(nextTransformAppendedIndexes, info => info.index === index && info.functionName === functionName)) {\n        nextIndex = index;\n    } else {\n        nextIndex = index + nextTransformAppendedIndexes.filter(info => info.index < index).length;\n    }\n\n    const result = convertTransformInfo(nextTransforms, moveable.state, nextIndex);\n    const targetFunction = result.targetFunction;\n    const matFunctionName = functionName === \"rotate\" ? \"rotateZ\" : functionName;\n\n    datas.beforeFunctionTexts = result.beforeFunctionTexts;\n    datas.afterFunctionTexts = result.afterFunctionTexts;\n    datas.beforeTransform = result.beforeFunctionMatrix;\n    datas.beforeTransform2 = result.beforeFunctionMatrix2;\n    datas.targetTansform = result.targetFunctionMatrix;\n    datas.afterTransform = result.afterFunctionMatrix;\n    datas.afterTransform2 = result.afterFunctionMatrix2;\n    datas.targetAllTransform = result.allFunctionMatrix;\n\n    if (targetFunction.functionName === matFunctionName) {\n        datas.afterFunctionTexts.splice(0, 1);\n        datas.isAppendTransform = false;\n    } else if (length > nextIndex) {\n        datas.isAppendTransform = true;\n\n        originalDatas.nextTransformAppendedIndexes = [...nextTransformAppendedIndexes, {\n            functionName,\n            index: nextIndex,\n            isAppend: true,\n        }];\n    }\n}\n\nexport function convertTransformFormat(datas: any, value: any, dist: any) {\n    return `${datas.beforeFunctionTexts.join(\" \")} ${datas.isAppendTransform ? dist : value} ${datas.afterFunctionTexts.join(\" \")}`;\n}\nexport function getTransformDist({ datas, distX, distY }: any) {\n    const [bx, by] = getBeforeDragDist({ datas, distX, distY });\n    // B * [tx, ty] * A = [bx, by] * targetMatrix;\n    // [tx, ty] = B-1 * [bx, by] * targetMatrix * A-1 * [0, 0];\n\n    const res = getTransfromMatrix(datas, fromTranslation([bx, by], 4));\n\n    return calculate(res, convertPositionMatrix([0, 0, 0], 4), 4);\n}\nexport function getTransfromMatrix(datas: any, targetMatrix: number[], isAfter?: boolean) {\n    const {\n        beforeTransform,\n        afterTransform,\n        beforeTransform2,\n        afterTransform2,\n        targetAllTransform,\n    } = datas;\n\n    // B * afterTargetMatrix * A = (targetMatrix * targetAllTransform)\n    // afterTargetMatrix = B-1 * targetMatrix * targetAllTransform * A-1\n    // nextTargetMatrix = (targetMatrix * targetAllTransform)\n    const nextTargetMatrix\n        = isAfter\n            ? multiply(targetAllTransform, targetMatrix, 4)\n            : multiply(targetMatrix, targetAllTransform, 4);\n\n    // res1 = B-1 * nextTargetMatrix\n    const res1 = multiply(invert(isAfter ? beforeTransform2 : beforeTransform, 4), nextTargetMatrix, 4);\n\n    // res3 = res2 * A-1\n    const afterTargetMatrix = multiply(res1, invert(isAfter ? afterTransform2 : afterTransform, 4), 4);\n\n    return afterTargetMatrix;\n}\nexport function getBeforeDragDist({ datas, distX, distY }: any) {\n    // TT = BT\n    const {\n        inverseBeforeMatrix,\n        is3d,\n        startDragBeforeDist,\n        absoluteOrigin,\n    } = datas;\n    const n = is3d ? 4 : 3;\n\n    // ABS_ORIGIN * [distX, distY] = BM * (ORIGIN + [tx, ty])\n    // BM -1 * ABS_ORIGIN * [distX, distY] - ORIGIN = [tx, ty]\n    return minus(\n        calculate(\n            inverseBeforeMatrix,\n            plus(absoluteOrigin, [distX, distY]),\n            n,\n        ),\n        startDragBeforeDist,\n    );\n}\nexport function getDragDist({ datas, distX, distY }: any, isBefore?: boolean) {\n    const {\n        inverseBeforeMatrix,\n        inverseMatrix,\n        is3d,\n        startDragBeforeDist,\n        startDragDist,\n        absoluteOrigin,\n    } = datas;\n    const n = is3d ? 4 : 3;\n\n    return minus(\n        calculate(\n            isBefore ? inverseBeforeMatrix : inverseMatrix,\n            plus(absoluteOrigin, [distX, distY]),\n            n,\n        ),\n        isBefore ? startDragBeforeDist : startDragDist,\n    );\n}\nexport function getInverseDragDist({ datas, distX, distY }: any, isBefore?: boolean) {\n    const {\n        beforeMatrix,\n        matrix,\n        is3d,\n        startDragBeforeDist,\n        startDragDist,\n        absoluteOrigin,\n    } = datas;\n    const n = is3d ? 4 : 3;\n\n    return minus(\n        calculate(\n            isBefore ? beforeMatrix : matrix,\n            plus(isBefore ? startDragBeforeDist : startDragDist, [distX, distY]),\n            n,\n        ),\n        absoluteOrigin,\n    );\n}\n\nexport function calculateTransformOrigin(\n    transformOrigin: string[],\n    width: number,\n    height: number,\n    prevWidth: number = width,\n    prevHeight: number = height,\n    prevOrigin: number[] = [0, 0],\n) {\n\n    if (!transformOrigin) {\n        return prevOrigin;\n    }\n    return transformOrigin.map((pos, i) => {\n        const { value, unit } = splitUnit(pos);\n\n        const prevSize = (i ? prevHeight : prevWidth);\n        const size = (i ? height : width);\n        if (pos === \"%\" || isNaN(value)) {\n            // no value but %\n\n            const measureRatio = prevSize ? prevOrigin[i] / prevSize : 0;\n\n            return size * measureRatio;\n        } else if (unit !== \"%\") {\n            return value;\n        }\n        return size * value / 100;\n    });\n}\n\nexport function getPosIndexesByDirection(direction: number[]) {\n    const indexes: number[] = [];\n\n    if (direction[1] >= 0) {\n        if (direction[0] >= 0) {\n            indexes.push(3);\n        }\n        if (direction[0] <= 0) {\n            indexes.push(2);\n        }\n    }\n    if (direction[1] <= 0) {\n        if (direction[0] >= 0) {\n            indexes.push(1);\n        }\n        if (direction[0] <= 0) {\n            indexes.push(0);\n        }\n    }\n    return indexes;\n}\nexport function getPosesByDirection(\n    poses: number[][],\n    direction: number[],\n) {\n    /*\n    [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)\n    [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)\n    [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)\n    */\n    return getPosIndexesByDirection(direction).map(index => poses[index]);\n}\n\nexport function getPosBySingleDirection(\n    poses: number[][],\n    direction: number,\n) {\n    const ratio = (direction + 1) / 2;\n    return [\n        dot(poses[0][0], poses[1][0], ratio, 1 - ratio),\n        dot(poses[0][1], poses[1][1], ratio, 1 - ratio),\n    ];\n}\n\nexport function getPosByDirection(\n    poses: number[][],\n    direction: number[],\n) {\n    const top = getPosBySingleDirection([poses[0], poses[1]], direction[0]);\n    const bottom = getPosBySingleDirection([poses[2], poses[3]], direction[0]);\n\n    return getPosBySingleDirection([top, bottom], direction[1]);\n}\n\nfunction getDist(\n    startPos: number[],\n    matrix: number[],\n    width: number,\n    height: number,\n    n: number,\n    fixedDirection: number[],\n) {\n    const poses = calculatePoses(matrix, width, height, n);\n    const fixedPos = getPosByDirection(poses, fixedDirection);\n    const distX = startPos[0] - fixedPos[0];\n    const distY = startPos[1] - fixedPos[1];\n\n    return [distX, distY];\n}\nexport function getNextMatrix(\n    offsetMatrix: number[],\n    targetMatrix: number[],\n    origin: number[],\n    n: number,\n) {\n    return multiply(\n        offsetMatrix,\n        getAbsoluteMatrix(targetMatrix, n, origin),\n        n,\n    );\n}\nexport function getNextTransformMatrix(\n    state: MoveableManagerState<any>,\n    datas: any,\n    transform: string | number[],\n    isAllTransform?: boolean,\n) {\n    const {\n        transformOrigin,\n        offsetMatrix,\n        is3d,\n    } = state;\n    const n = is3d ? 4 : 3;\n    let targetTransform!: number[];\n\n    if (isString(transform)) {\n        const {\n            beforeTransform,\n            afterTransform,\n        } = datas;\n\n        if (isAllTransform) {\n            targetTransform = convertDimension(parseMat(transform), 4, n);\n        } else {\n            targetTransform = convertDimension(\n                multiply(multiply(beforeTransform, parseMat([transform]), 4), afterTransform, 4),\n                4, n,\n            );\n        }\n    } else {\n        targetTransform = transform;\n    }\n\n    return getNextMatrix(\n        offsetMatrix,\n        targetTransform,\n        transformOrigin,\n        n,\n    );\n}\nexport function scaleMatrix(\n    state: any,\n    scale: number[],\n) {\n    const {\n        transformOrigin,\n        offsetMatrix,\n        is3d,\n        targetMatrix,\n        targetAllTransform,\n    } = state;\n    const n = is3d ? 4 : 3;\n\n    return getNextMatrix(\n        offsetMatrix,\n        multiply(targetAllTransform || targetMatrix, createScaleMatrix(scale, n), n),\n        transformOrigin,\n        n,\n    );\n}\n\nexport function fillTransformStartEvent(moveable: MoveableManagerInterface, e: any): OnTransformStartEvent {\n    const originalDatas = getBeforeRenderableDatas(e);\n    return {\n        setTransform: (transform: string | string[], index = -1) => {\n            originalDatas.startTransforms = isArray(transform) ? transform : splitSpace(transform);\n            setTransformIndex(moveable, e, index);\n        },\n        setTransformIndex: (index: number) => {\n            setTransformIndex(moveable, e, index);\n        },\n    };\n}\nexport function setDefaultTransformIndex(moveable: MoveableManagerInterface, e: any, property: string) {\n    const originalDatas = getBeforeRenderableDatas(e);\n    const startTransforms = originalDatas.startTransforms;\n\n    setTransformIndex(moveable, e, findIndex<string>(startTransforms, func => func.indexOf(`${property}(`) === 0));\n}\nexport function setTransformIndex(moveable: MoveableManagerInterface, e: any, index: number) {\n    const originalDatas = getBeforeRenderableDatas(e);\n    const datas = e.datas;\n\n    datas.transformIndex = index;\n    if (index === -1) {\n        return;\n    }\n    const transform = originalDatas.startTransforms[index];\n\n    if (!transform) {\n        return;\n    }\n    const state = moveable.state;\n    const info = parse([transform], {\n        \"x%\": v => v / 100 * state.offsetWidth,\n        \"y%\": v => v / 100 * state.offsetHeight,\n    });\n\n    datas.startValue = info[0].functionValue;\n}\nexport function fillOriginalTransform(\n    e: any,\n    transform: string,\n) {\n    const originalDatas = getBeforeRenderableDatas(e);\n\n    originalDatas.nextTransforms = splitSpace(transform);\n    // originalDatas.nextTargetMatrix = parseMat(transform);\n}\nexport function getBeforeRenderableDatas(e: any) {\n    return e.originalDatas.beforeRenderable;\n}\nexport function getNextTransforms(e: any) {\n    const {\n        originalDatas: {\n            beforeRenderable: originalDatas,\n        },\n    } = e;\n\n    return originalDatas.nextTransforms as string[];\n}\nexport function getNextTransformText(e: any) {\n    return (getNextTransforms(e) || []).join(\" \");\n}\n\nexport function getNextStyle(e: any) {\n    return getBeforeRenderableDatas(e).nextStyle;\n}\n\nexport function fillTransformEvent(\n    moveable: MoveableManagerInterface<DraggableProps>,\n    nextTransform: string,\n    delta: number[],\n    isPinch: boolean,\n    e: any,\n): OnTransformEvent {\n    fillOriginalTransform(e, nextTransform);\n\n    const drag = Draggable.drag!(\n        moveable,\n        setCustomDrag(e, moveable.state, delta, isPinch, false),\n    ) as OnDrag;\n    const afterTransform = drag ? drag.transform : nextTransform;\n    return {\n        transform: nextTransform,\n        drag: drag as OnDrag,\n        ...fillCSSObject({\n            transform: afterTransform,\n        }, e),\n        afterTransform,\n    };\n}\n\nexport function getTranslateFixedPosition(\n    moveable: MoveableManagerInterface<any>,\n    transform: string | number[],\n    fixedDirection: number[],\n    fixedOffset: number[],\n    datas: any,\n    isAllTransform?: boolean,\n) {\n    const nextMatrix = getNextTransformMatrix(moveable.state, datas, transform, isAllTransform);\n    const nextFixedPosition = getDirectionOffset(\n        moveable,\n        fixedDirection,\n        fixedOffset,\n        nextMatrix,\n    );\n\n    return nextFixedPosition;\n}\n\nexport function getTranslateDist(\n    moveable: MoveableManagerInterface<any>,\n    transform: string,\n    fixedDirection: number[],\n    fixedPosition: number[],\n    fixedOffset: number[],\n    datas: any,\n    isAllTransform?: boolean,\n) {\n    const nextFixedPosition = getTranslateFixedPosition(\n        moveable,\n        transform,\n        fixedDirection,\n        fixedOffset,\n        datas,\n        isAllTransform,\n    );\n    const state = moveable.state;\n    const {\n        left,\n        top,\n    } = state;\n\n    const groupable = moveable.props.groupable;\n    const groupLeft = groupable ? left : 0;\n    const groupTop = groupable ? top : 0;\n    const dist = minus(fixedPosition, nextFixedPosition);\n\n    return minus(dist, [groupLeft, groupTop]);\n}\nexport function getScaleDist(\n    moveable: MoveableManagerInterface<any>,\n    transform: string,\n    fixedDirection: number[],\n    fixedPosition: number[],\n    fixedOffset: number[],\n    datas: any,\n    isAllTransform?: boolean,\n) {\n    const dist = getTranslateDist(\n        moveable,\n        transform,\n        fixedDirection,\n        fixedPosition,\n        fixedOffset,\n        datas,\n        isAllTransform,\n    );\n\n    return dist;\n}\nexport function getOriginDirection(moveable: MoveableManagerInterface<any>) {\n    const {\n        width,\n        height,\n        transformOrigin,\n    } = moveable.state;\n    return [\n        -1 + transformOrigin[0] / (width / 2),\n        -1 + transformOrigin[1] / (height / 2),\n    ];\n}\nexport function getDirectionByPos(\n    pos: number[],\n    width: number,\n    height: number,\n) {\n    return [\n        width ? -1 + pos[0] / (width / 2) : 0,\n        height ? -1 + pos[1] / (height / 2) : 0,\n    ];\n}\nexport function getDirectionOffset(\n    moveable: MoveableManagerInterface,\n    fixedDirection: number[],\n    fixedOffset: number[],\n    nextMatrix: number[] = moveable.state.allMatrix,\n) {\n    const {\n        width,\n        height,\n        is3d,\n    } = moveable.state;\n    const n = is3d ? 4 : 3;\n    const fixedOffsetPosition = [\n        width / 2 * (1 + fixedDirection[0]) + fixedOffset[0],\n        height / 2 * (1 + fixedDirection[1]) + fixedOffset[1],\n    ];\n    return calculatePosition(nextMatrix, fixedOffsetPosition, n);\n}\nexport function getRotateDist(\n    moveable: MoveableManagerInterface<any>,\n    rotateDist: number,\n    datas: any,\n) {\n    const fixedDirection = datas.fixedDirection;\n    const fixedPosition = datas.fixedPosition;\n    const fixedOffset = datas.fixedOffset;\n\n    return getTranslateDist(\n        moveable,\n        `rotate(${rotateDist}deg)`,\n        fixedDirection,\n        fixedPosition,\n        fixedOffset,\n        datas,\n    );\n}\nexport function getResizeDist(\n    moveable: MoveableManagerInterface<any>,\n    width: number,\n    height: number,\n    fixedPosition: number[],\n    transformOrigin: string[],\n    datas: any,\n) {\n    const {\n        groupable,\n    } = moveable.props;\n    const state = moveable.state;\n    const {\n        transformOrigin: prevOrigin,\n        offsetMatrix,\n        is3d,\n        width: prevWidth,\n        height: prevHeight,\n        left,\n        top,\n    } = state;\n    const fixedDirection = datas.fixedDirection;\n    const targetMatrix = datas.nextTargetMatrix || state.targetMatrix;\n    const n = is3d ? 4 : 3;\n    const nextOrigin = calculateTransformOrigin(\n        transformOrigin!,\n        width,\n        height,\n        prevWidth,\n        prevHeight,\n        prevOrigin,\n    );\n    const groupLeft = groupable ? left : 0;\n    const groupTop = groupable ? top : 0;\n    const nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, nextOrigin, n);\n    const dist = getDist(fixedPosition, nextMatrix, width, height, n, fixedDirection);\n\n    return minus(dist, [groupLeft, groupTop]);\n}\nexport function getAbsolutePosition(\n    moveable: MoveableManagerInterface<ResizableProps>,\n    direction: number[],\n) {\n    return getPosByDirection(getAbsolutePosesByState(moveable.state), direction);\n}\n", "import { MoveableManagerInterface } from \"../types\";\n\nexport function getGestoData(moveable: MoveableManagerInterface, ableName: string) {\n    const targetGesto = moveable.targetGesto;\n    const controlGesto = moveable.controlGesto;\n    let data!: Record<string, any>;\n\n    if (targetGesto?.isFlag()) {\n        data = targetGesto.getEventData()[ableName];\n    }\n\n    if (!data && controlGesto?.isFlag()) {\n        data = controlGesto.getEventData()[ableName];\n    }\n\n    return data || {};\n}\n", "import {\n    convertCSStoMatrix, convertDimension,\n    createIdentityMatrix, createOriginMatrix, createScaleMatrix,\n} from \"@scena/matrix\";\nimport { getCachedStyle } from \"../store/Store\";\nimport { IS_WEBKIT, IS_SAFARI_ABOVE15, IS_FIREFOX, IS_CHROMIUM109 } from \"../consts\";\nimport { MatrixInfo } from \"../types\";\nimport {\n    getOffsetInfo, getElementTransform,\n    getTransformMatrix, getPositionFixedInfo,\n    convert3DMatrixes, getOffsetPosInfo,\n    getSVGMatrix, getBodyOffset, getAbsoluteMatrix,\n} from \"../utils\";\nimport { getDocumentBody, getDocumentElement } from \"@daybrush/utils\";\nimport { parseMat } from \"css-to-mat\";\n\n\nexport function getShadowRoot(parentElement: HTMLElement | SVGElement) {\n    if (parentElement && parentElement.getRootNode) {\n        const rootNode = parentElement.getRootNode();\n\n        if (rootNode.nodeType === 11) {\n            return rootNode;\n        }\n    }\n    return;\n}\n\n\nfunction getIndividualTransforms(getStyle: (property: string) => any) {\n    const scale = getStyle(\"scale\") as string;\n    const rotate = getStyle(\"rotate\") as string;\n    const translate = getStyle(\"translate\") as string;\n    const individualTransforms: string[] = [];\n\n    if (translate && translate !== \"0px\" && translate !== \"none\") {\n        individualTransforms.push(`translate(${translate.split(/\\s+/).join(\",\")})`);\n    }\n    if (rotate && rotate !== \"1\" && rotate !== \"none\") {\n        individualTransforms.push(`rotate(${rotate})`);\n    }\n    if (scale && scale !== \"1\" && scale !== \"none\") {\n        individualTransforms.push(`scale(${scale.split(/\\s+/).join(\",\")})`);\n    }\n    return individualTransforms;\n}\n\nexport interface MatrixStackInfo {\n    zoom: number;\n    offsetContainer: HTMLElement;\n    matrixes: MatrixInfo[];\n    targetMatrix: number[];\n    transformOrigin: number[];\n    targetOrigin: number[];\n    is3d: boolean;\n    hasFixed: boolean;\n}\nexport function getMatrixStackInfo(\n    target: SVGElement | HTMLElement,\n    container?: SVGElement | HTMLElement | null,\n    checkContainer?: boolean,\n): MatrixStackInfo {\n    let el: SVGElement | HTMLElement | null = target;\n    const matrixes: MatrixInfo[] = [];\n    const documentElement = getDocumentElement(target) || getDocumentBody(target);\n    let requestEnd = !checkContainer && target === container || target === documentElement;\n    let isEnd = requestEnd;\n    let is3d = false;\n    let n = 3;\n    let transformOrigin!: number[];\n    let targetTransformOrigin!: number[];\n    let targetMatrix!: number[];\n\n    let hasFixed = false;\n    let offsetContainer = getOffsetInfo(container, container, true).offsetParent;\n    let zoom = 1;\n\n    while (el && !isEnd) {\n        isEnd = requestEnd;\n        const getStyle = getCachedStyle(el);\n        const position = getStyle(\"position\");\n        const transform = getElementTransform(el);\n        const isFixed = position === \"fixed\";\n        const individualTransforms = getIndividualTransforms(getStyle);\n        let matrix: number[] = convertCSStoMatrix(getTransformMatrix(transform));\n        let offsetParent: HTMLElement;\n        let isOffsetEnd = false;\n        let isStatic = false;\n        let parentClientLeft = 0;\n        let parentClientTop = 0;\n        let fixedClientLeft = 0;\n        let fixedClientTop = 0;\n        let fixedInfo: {\n            hasTransform: boolean;\n            fixedContainer: HTMLElement | null;\n        } = {\n            hasTransform: false,\n            fixedContainer: null,\n        };\n\n        if (isFixed) {\n            hasFixed = true;\n            fixedInfo = getPositionFixedInfo(el);\n            offsetContainer = fixedInfo.fixedContainer!;\n        }\n\n        // convert 3 to 4\n        const length = matrix.length;\n\n        if (!is3d && (length === 16 || individualTransforms.length)) {\n            is3d = true;\n            n = 4;\n\n            convert3DMatrixes(matrixes);\n            if (targetMatrix) {\n                targetMatrix = convertDimension(targetMatrix, 3, 4);\n            }\n        }\n        if (is3d && length === 9) {\n            matrix = convertDimension(matrix, 3, 4);\n        }\n        const {\n            tagName,\n            hasOffset,\n            isSVG,\n            origin,\n            targetOrigin,\n            offset: offsetPos,\n        } = getOffsetPosInfo(el, target);\n        let [\n            offsetLeft,\n            offsetTop,\n        ] = offsetPos;\n\n        // no target with svg\n        if (tagName === \"svg\" && !(el as SVGSVGElement).ownerSVGElement && targetMatrix) {\n            // scale matrix for svg's SVGElements.\n            matrixes.push({\n                type: \"target\",\n                target: el,\n                matrix: getSVGMatrix(el as SVGSVGElement, n),\n            });\n            matrixes.push({\n                type: \"offset\",\n                target: el,\n                matrix: createIdentityMatrix(n),\n            });\n        }\n\n\n        const targetZoom = parseFloat(getStyle(\"zoom\")) || 1;\n\n        if (isFixed) {\n            offsetParent = fixedInfo.fixedContainer!;\n            isOffsetEnd = true;\n        } else {\n            const offsetInfo = getOffsetInfo(el, container, false, true, getStyle);\n            const offsetZoom = offsetInfo.offsetZoom;\n\n            offsetParent = offsetInfo.offsetParent;\n            isOffsetEnd = offsetInfo.isEnd;\n            isStatic = offsetInfo.isStatic;\n            zoom *= offsetZoom;\n\n            if ((offsetInfo.isCustomElement || offsetZoom !== 1) && isStatic) {\n                offsetLeft -= offsetParent.offsetLeft;\n                offsetTop -= offsetParent.offsetTop;\n            } else if (IS_FIREFOX || IS_CHROMIUM109) {\n                const parentSlotElement = offsetInfo.parentSlotElement;\n\n                if (parentSlotElement) {\n                    let customOffsetParent: HTMLElement | null = offsetParent;\n                    let customOffsetLeft = 0;\n                    let customOffsetTop = 0;\n\n                    while (customOffsetParent) {\n                        if (!getShadowRoot(customOffsetParent)) {\n                            break;\n                        }\n                        customOffsetLeft += customOffsetParent.offsetLeft;\n                        customOffsetTop += customOffsetParent.offsetTop;\n                        customOffsetParent = customOffsetParent.offsetParent as HTMLElement;\n                    }\n                    offsetLeft -= customOffsetLeft;\n                    offsetTop -= customOffsetTop;\n                }\n            }\n        }\n\n        if (\n            IS_WEBKIT && !IS_SAFARI_ABOVE15\n            && hasOffset && !isSVG && isStatic\n            && (position === \"relative\" || position === \"static\")\n        ) {\n            offsetLeft -= offsetParent.offsetLeft;\n            offsetTop -= offsetParent.offsetTop;\n            requestEnd = requestEnd || isOffsetEnd;\n        }\n\n\n        if (isFixed) {\n            if (hasOffset && fixedInfo.hasTransform) {\n                // border\n                fixedClientLeft = offsetParent.clientLeft;\n                fixedClientTop = offsetParent.clientTop;\n            }\n        } else {\n            if (hasOffset && offsetContainer !== offsetParent) {\n                // border\n                parentClientLeft = offsetParent.clientLeft;\n                parentClientTop = offsetParent.clientTop;\n            }\n            if (hasOffset && offsetParent === documentElement) {\n                const margin = getBodyOffset(el, false);\n\n                offsetLeft += margin[0];\n                offsetTop += margin[1];\n            }\n        }\n\n        matrixes.push({\n            type: \"target\",\n            target: el,\n            matrix: getAbsoluteMatrix(matrix, n, origin),\n        });\n\n        if (individualTransforms.length) {\n            matrixes.push({\n                type: \"offset\",\n                target: el,\n                matrix: createIdentityMatrix(n),\n            });\n\n            matrixes.push({\n                type: \"target\",\n                target: el,\n                matrix: getAbsoluteMatrix(parseMat(individualTransforms), n, origin),\n            });\n        }\n        if (hasOffset) {\n            const isElementTarget = el === target;\n            const scrollLeft = isElementTarget ? 0 : el.scrollLeft;\n            const scrollTop = isElementTarget ? 0 : el.scrollTop;\n\n            matrixes.push({\n                type: \"offset\",\n                target: el,\n                matrix: createOriginMatrix([\n                    offsetLeft - scrollLeft + parentClientLeft - fixedClientLeft,\n                    offsetTop - scrollTop + parentClientTop - fixedClientTop,\n                ], n),\n            });\n        } else {\n            // svg\n            matrixes.push({\n                type: \"offset\",\n                target: el,\n                origin,\n            });\n        }\n        // transform으로 계산되지 않는 zoom을 위한 (0, 0) 을 기준 matrix 추가.\n        if (targetZoom !== 1) {\n            matrixes.push({\n                type: \"zoom\",\n                target: el,\n                matrix: getAbsoluteMatrix(createScaleMatrix([targetZoom, targetZoom], n), n, [0, 0]),\n            });\n        }\n        if (!targetMatrix) {\n            targetMatrix = matrix;\n        }\n        if (!transformOrigin) {\n            transformOrigin = origin;\n        }\n        if (!targetTransformOrigin) {\n            targetTransformOrigin = targetOrigin;\n        }\n\n        if (isEnd || isFixed) {\n            break;\n        } else {\n            el = offsetParent;\n            requestEnd = isOffsetEnd;\n        }\n        if (!checkContainer || el === documentElement) {\n            isEnd = requestEnd;\n        }\n    }\n    if (!targetMatrix) {\n        targetMatrix = createIdentityMatrix(n);\n    }\n    if (!transformOrigin) {\n        transformOrigin = [0, 0];\n    }\n    if (!targetTransformOrigin) {\n        targetTransformOrigin = [0, 0];\n    }\n\n    return {\n        zoom,\n        offsetContainer,\n        matrixes,\n        targetMatrix,\n        transformOrigin,\n        targetOrigin: targetTransformOrigin,\n        is3d,\n        hasFixed,\n    };\n}\n", "import { find, getWindow } from \"@daybrush/utils\";\nimport { getClientRect } from \"../utils\";\nimport { MoveableClientRect } from \"../types\";\nimport { getMatrixStackInfo, MatrixStackInfo } from \"../utils/getMatrixStackInfo\";\n\nlet cacheStyleMap: Map<Element, {\n    style: CSSStyleDeclaration;\n    cached: Record<string, any>;\n}> | null = null;\nlet clientRectStyleMap: Map<Element, MoveableClientRect> | null = null;\n\nlet matrixContainerInfos: Array<[\n    [SVGElement | HTMLElement, SVGElement | HTMLElement | null | undefined],\n    MatrixStackInfo\n]> | null = null;\n\nexport type GetStyle = (propertyName: string) => any;\nexport function setStoreCache(useCache?: boolean) {\n    if (useCache) {\n        if (window.Map) {\n            cacheStyleMap = new Map();\n            clientRectStyleMap = new Map();\n        }\n        matrixContainerInfos = [];\n    } else {\n        cacheStyleMap = null;\n        matrixContainerInfos = null;\n        clientRectStyleMap = null;\n    }\n}\n\nexport function getCachedClientRect(el: HTMLElement | SVGElement): MoveableClientRect {\n    const clientRect = clientRectStyleMap?.get(el);\n\n    if (clientRect) {\n        return clientRect;\n    }\n    const nextClientRect = getClientRect(el, true);\n\n    if (clientRectStyleMap) {\n        clientRectStyleMap.set(el, nextClientRect);\n    }\n    return nextClientRect;\n}\n\nexport function getCachedMatrixContainerInfo(\n    target: SVGElement | HTMLElement,\n    container?: SVGElement | HTMLElement | null,\n) {\n    if (matrixContainerInfos) {\n        const result = find(matrixContainerInfos, info => info[0][0] == target && info[0][1] == container);\n\n        if (result) {\n            return result[1];\n        }\n    }\n    const result = getMatrixStackInfo(target, container, true);\n\n    if (matrixContainerInfos) {\n        matrixContainerInfos.push([[target, container], result]);\n    }\n    return result;\n}\nexport function getCachedStyle(element: Element): GetStyle {\n    let cache = cacheStyleMap?.get(element);\n\n    if (!cache) {\n        const nextStyle = getWindow(element).getComputedStyle(element);\n\n        if (!cacheStyleMap) {\n            return (property: string) => {\n                return (nextStyle as any)[property];\n            };\n        }\n        cache = {\n            style: nextStyle,\n            cached: {},\n        };\n        cacheStyleMap.set(element, cache);\n    }\n    const cached = cache.cached;\n    const style = cache.style;\n\n    return (property: string) => {\n        if (!(property in cached)) {\n            cached[property] = (style as any)[property];\n        }\n        return cached[property];\n    };\n}\n", "/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var f=require(\"react\"),k=Symbol.for(\"react.element\"),l=Symbol.for(\"react.fragment\"),m=Object.prototype.hasOwnProperty,n=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p={key:!0,ref:!0,__self:!0,__source:!0};\nfunction q(c,a,g){var b,d={},e=null,h=null;void 0!==g&&(e=\"\"+g);void 0!==a.key&&(e=\"\"+a.key);void 0!==a.ref&&(h=a.ref);for(b in a)m.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return{$$typeof:k,type:c,key:e,ref:h,props:d,_owner:n.current}}exports.Fragment=l;exports.jsx=q;exports.jsxs=q;\n", "/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nvar React = require('react');\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_MODULE_REFERENCE;\n\n{\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n}\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      // eslint-disable-next-line no-fallthrough\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if ( !fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n    return type;\n  }\n} // $FlowFixMe only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner$1.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement$1(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement$1(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object') {\n      return;\n    }\n\n    if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else if (node) {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement$1(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement$1(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement$1(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement$1(null);\n    }\n  }\n}\n\nvar didWarnAboutKeySpread = {};\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    {\n      if (hasOwnProperty.call(props, 'key')) {\n        var componentName = getComponentNameFromType(type);\n        var keys = Object.keys(props).filter(function (k) {\n          return k !== 'key';\n        });\n        var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n        if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n          var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n          error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n          didWarnAboutKeySpread[componentName + beforeExample] = true;\n        }\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n// even with the prod transform. This means that jsxDEV is purely\n// opt-in behavior for better messages but that we won't stop\n// giving you warnings if you use production apis.\n\nfunction jsxWithValidationStatic(type, props, key) {\n  {\n    return jsxWithValidation(type, props, key, true);\n  }\n}\nfunction jsxWithValidationDynamic(type, props, key) {\n  {\n    return jsxWithValidation(type, props, key, false);\n  }\n}\n\nvar jsx =  jsxWithValidationDynamic ; // we may want to special case jsxs internally to take advantage of static children.\n// for now we can ship identical prod functions\n\nvar jsxs =  jsxWithValidationStatic ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsx = jsx;\nexports.jsxs = jsxs;\n  })();\n}\n", "'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-jsx-runtime.production.min.js');\n} else {\n  module.exports = require('./cjs/react-jsx-runtime.development.js');\n}\n", "import { Able, MoveableGroupInterface, MoveableManagerInterface, MoveableManagerState } from \"./types\";\nimport CustomGesto, { setCustomDrag } from \"./gesto/CustomGesto\";\nimport { getAbsolutePosesByState } from \"./utils\";\nimport { calculate, createRotateMatrix } from \"@scena/matrix\";\nimport { getPosByDirection } from \"./gesto/GestoUtils\";\n\nexport function fillChildEvents(\n    moveable: MoveableGroupInterface<any, any>,\n    name: string,\n    e: any,\n): any[] {\n    const datas = e.originalDatas;\n\n    datas.groupable = datas.groupable || {};\n\n    const groupableDatas = datas.groupable;\n\n    groupableDatas.childDatas = groupableDatas.childDatas || [];\n\n    const childDatas = groupableDatas.childDatas;\n\n    return moveable.moveables.map((_, i) => {\n        childDatas[i] = childDatas[i] || {};\n        childDatas[i][name] = childDatas[i][name] || {};\n\n        return {\n            ...e,\n            isRequestChild: true,\n            datas: childDatas[i][name],\n            originalDatas: childDatas[i],\n        };\n    });\n}\nexport function triggerChildGesto(\n    moveable: MoveableGroupInterface<any, any>,\n    able: Able,\n    type: string,\n    delta: number[],\n    e: any,\n    isConvert: boolean,\n    ableName: string,\n) {\n    const isStart = !!type.match(/Start$/g);\n    const isEnd = !!type.match(/End$/g);\n    const isPinch = e.isPinch;\n    const datas = e.datas;\n    const events = fillChildEvents(moveable, able.name, e);\n    const moveables = moveable.moveables;\n\n    const childEvents: any[] = [];\n    const eventParams = events.map((ev, i) => {\n        const childMoveable = moveables[i];\n        const state = childMoveable.state as MoveableManagerState<any>;\n        const gestos = state.gestos;\n        let childEvent: any = ev;\n\n        if (isStart) {\n            childEvent = new CustomGesto(ableName).dragStart(delta, ev);\n            childEvents.push(childEvent);\n        } else {\n            if (!gestos[ableName]) {\n                gestos[ableName] = datas.childGestos[i];\n            }\n            if (!gestos[ableName]) {\n                return;\n            }\n            childEvent = setCustomDrag(ev, state, delta, isPinch, isConvert, ableName);\n            childEvents.push(childEvent);\n        }\n        const result = (able as any)[type]!(childMoveable,  { ...childEvent, parentFlag: true });\n\n        if (isEnd) {\n            gestos[ableName] = null;\n        }\n        return result;\n    });\n    if (isStart) {\n        datas.childGestos = moveables.map(child => child.state.gestos[ableName]);\n    }\n    return {\n        eventParams,\n        childEvents,\n    };\n}\nexport function triggerChildAbles<T extends Able>(\n    moveable: MoveableGroupInterface<any, any>,\n    able: T,\n    type: keyof T & string,\n    e: any,\n    eachEvent: (movebale: MoveableManagerInterface<any, any>, ev: any) => any = (_, ev) => ev,\n    callback?: (moveable: MoveableManagerInterface<any, any>, ev: any, result: any, index: number) => any,\n) {\n    const isEnd = !!type.match(/End$/g);\n    const events = fillChildEvents(moveable, able.name, e);\n    const moveables = moveable.moveables;\n    const childs = events.map((ev, i) => {\n        const childMoveable = moveables[i];\n        let childEvent = ev;\n\n        childEvent = eachEvent(childMoveable, ev);\n\n        const result = (able as any)[type]!(childMoveable,  { ...childEvent, parentFlag: true });\n\n        result && callback && callback(childMoveable, ev, result, i);\n\n        if (isEnd) {\n            childMoveable.state.gestos = {};\n        }\n        return result;\n    });\n\n    return childs;\n}\n\n\nexport function startChildDist(\n    moveable: MoveableGroupInterface,\n    child: MoveableManagerInterface,\n    parentDatas: any,\n    childEvent: any,\n) {\n    const fixedDirection = parentDatas.fixedDirection;\n    const fixedPosition = parentDatas.fixedPosition;\n\n    const startPositions = childEvent.datas.startPositions || getAbsolutePosesByState(child.state);\n    const pos = getPosByDirection(startPositions, fixedDirection);\n    const [originalX, originalY] = calculate(\n        createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3),\n        [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1],\n        3,\n    );\n    childEvent.datas.originalX = originalX;\n    childEvent.datas.originalY = originalY;\n\n    return childEvent;\n}\n", "import {\n  prefix,\n  getControlTransform,\n  getLineStyle,\n  getProps,\n  sign,\n} from './utils';\nimport { Renderer, MoveableManagerInterface, RenderDirections } from './types';\nimport {\n  DIRECTION_INDEXES,\n  DIRECTION_ROTATIONS,\n  DIRECTIONS,\n  DIRECTIONS4,\n} from './consts';\nimport { IObject, throttle, getRad, getKeys } from '@daybrush/utils';\nimport { absDegree } from './ables/Snappable';\n\nexport interface DirectionControlInfo {\n  data: Record<string, any>;\n  classNames: string[];\n  dir: string;\n}\n\nexport function renderDirectionControlsByInfos(\n  moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n  ableName: string,\n  renderDirections: DirectionControlInfo[],\n  React: Renderer,\n): any[] {\n  const { renderPoses, rotation: rotationRad, direction } = moveable.getState();\n\n  const { zoom } = getProps(moveable.props, ableName as any);\n\n  const degRotation = absDegree((rotationRad / Math.PI) * 180);\n  const directionMap: IObject<boolean> = {};\n  const renderState = moveable.renderState;\n  if (!renderState.renderDirectionMap) {\n    renderState.renderDirectionMap = {};\n  }\n  const renderDirectionMap = renderState.renderDirectionMap;\n\n  renderDirections.forEach(({ dir }) => {\n    directionMap[dir] = true;\n  });\n\n  const directionSign = sign(direction);\n  return renderDirections.map(({ data, classNames, dir }) => {\n    const indexes = DIRECTION_INDEXES[dir];\n\n    if (!indexes || !directionMap[dir]) {\n      return null;\n    }\n    renderDirectionMap[dir] = true;\n    const directionRotation =\n      (throttle(degRotation, 15) +\n        directionSign * DIRECTION_ROTATIONS[dir] +\n        720) %\n      180;\n\n    const dataAttrs: Record<string, string> = {};\n\n    getKeys(data).forEach((name) => {\n      dataAttrs[`data-${name}`] = data[name];\n    });\n    return (\n      <div\n        className={prefix('control', 'direction', dir, ableName, ...classNames)}\n        data-rotation={directionRotation}\n        data-direction={dir}\n        {...dataAttrs}\n        key={`direction-${dir}`}\n        style={getControlTransform(\n          rotationRad,\n          zoom!,\n          ...indexes.map((index) => renderPoses[index]),\n        )}\n      ></div>\n    );\n  });\n}\nexport function renderDirectionControls(\n  moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n  defaultDirections: string[],\n  ableName: string,\n  React: Renderer,\n): any[] {\n  const {\n    renderDirections: directions = defaultDirections,\n    displayAroundControls,\n  } = getProps(moveable.props, ableName as any);\n\n  if (!directions) {\n    return [];\n  }\n  const renderDirections = directions === true ? DIRECTIONS : directions;\n\n  return [\n    ...(displayAroundControls\n      ? renderAroundControls(moveable, React, ableName, renderDirections)\n      : []),\n    ...renderDirectionControlsByInfos(\n      moveable,\n      ableName,\n      renderDirections.map((dir) => {\n        return {\n          data: {},\n          classNames: [],\n          dir,\n        };\n      }),\n      React,\n    ),\n  ];\n}\n\nexport function renderLine(\n  React: Renderer,\n  direction: string,\n  pos1: number[],\n  pos2: number[],\n  zoom: number,\n  key: number | string,\n  ...classNames: string[]\n): any {\n  const rad = getRad(pos1, pos2);\n  const rotation = direction ? throttle((rad / Math.PI) * 180, 15) % 180 : -1;\n\n  return (\n    <div\n      key={`line-${key}`}\n      className={prefix(\n        'line',\n        'direction',\n        direction ? 'edge' : '',\n        direction,\n        ...classNames,\n      )}\n      data-rotation={rotation}\n      data-line-key={key}\n      data-direction={direction}\n      style={getLineStyle(pos1, pos2, zoom, rad)}\n    ></div>\n  );\n}\n\nexport function renderEdgeLines(\n  React: Renderer,\n  ableName: string,\n  edge: true | string[],\n  poses: number[][],\n  zoom: number,\n): any[] {\n  const directions = edge === true ? DIRECTIONS4 : edge;\n\n  return directions\n    .map((direction, i) => {\n      const [index1, index2] = DIRECTION_INDEXES[direction];\n\n      if (index2 == null) {\n        return;\n      }\n      return renderLine(\n        React,\n        direction,\n        poses[index1],\n        poses[index2],\n        zoom,\n        `${ableName}Edge${i}`,\n        ableName,\n      );\n    })\n    .filter(Boolean);\n}\n\nexport function getRenderDirections(ableName: string) {\n  return (\n    moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n    React: Renderer,\n  ) => {\n    const edge = getProps(moveable.props, ableName as any).edge;\n\n    if (edge && (edge === true || edge.length)) {\n      return [\n        ...renderEdgeLines(\n          React,\n          ableName,\n          edge,\n          moveable.getState().renderPoses,\n          moveable.props.zoom!,\n        ),\n        ...renderDiagonalDirections(moveable, ableName, React),\n      ];\n    }\n    return renderAllDirections(moveable, ableName, React);\n  };\n}\n\nexport function renderAllDirections(\n  moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n  ableName: string,\n  React: Renderer,\n) {\n  return renderDirectionControls(moveable, DIRECTIONS, ableName, React);\n}\n\nexport function renderDiagonalDirections(\n  moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n  ableName: string,\n  React: Renderer,\n): any[] {\n  return renderDirectionControls(\n    moveable,\n    ['nw', 'ne', 'sw', 'se'],\n    ableName,\n    React,\n  );\n}\n\nexport function renderAroundControls(\n  moveable: MoveableManagerInterface<Partial<RenderDirections>>,\n  React: Renderer,\n  ableName?: string,\n  renderDirections?: string[],\n): any[] {\n  const renderState = moveable.renderState;\n  if (!renderState.renderDirectionMap) {\n    renderState.renderDirectionMap = {};\n  }\n  const { renderPoses, rotation: rotationRad, direction } = moveable.getState();\n\n  const renderDirectionMap = renderState.renderDirectionMap;\n\n  const { zoom } = moveable.props;\n  const directionSign = sign(direction);\n  const degRotation = (rotationRad / Math.PI) * 180;\n\n  return (renderDirections || getKeys(renderDirectionMap)).map((dir) => {\n    const indexes = DIRECTION_INDEXES[dir];\n\n    if (!indexes) {\n      return null;\n    }\n    const directionRotation =\n      (throttle(degRotation, 15) +\n        directionSign * DIRECTION_ROTATIONS[dir] +\n        720) %\n      180;\n\n    const classNames: string[] = ['around-control'];\n\n    if (ableName) {\n      classNames.push('direction', ableName);\n    }\n    return (\n      <div\n        className={prefix(...classNames)}\n        data-rotation={directionRotation}\n        data-direction={dir}\n        key={`direction-around-${dir}`}\n        style={getControlTransform(\n          rotationRad,\n          zoom!,\n          ...indexes.map((index) => renderPoses[index]),\n        )}\n      ></div>\n    );\n  });\n}\n", "import { getRad, throttle } from \"@daybrush/utils\";\nimport {\n    BoundInfo, SnappableProps, BoundType,\n    RotatableProps, MoveableManagerInterface, SnappableState,\n} from \"../../types\";\nimport { rotate, minus } from \"@scena/matrix\";\nimport { abs, getDistSize } from \"../../utils\";\nimport { TINY_NUM } from \"../../consts\";\n\nexport function checkBoundPoses(\n    bounds: BoundType | false | undefined,\n    verticalPoses: number[],\n    horizontalPoses: number[],\n) {\n    const {\n        position = \"client\",\n        left = -Infinity,\n        top = -Infinity,\n        right = Infinity,\n        bottom = Infinity,\n    } = bounds || {};\n    const nextBounds = {\n        position,\n        left,\n        top,\n        right,\n        bottom,\n    };\n\n    return {\n        vertical: checkBounds(nextBounds, verticalPoses, true),\n        horizontal: checkBounds(nextBounds, horizontalPoses, false),\n    };\n}\nexport function getBounds(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    externalBounds?: BoundType | false | null,\n) {\n    const {\n        containerClientRect: {\n            clientHeight: containerHeight,\n            clientWidth: containerWidth,\n            clientLeft,\n            clientTop,\n        },\n        snapOffset: {\n            left: snapOffsetLeft,\n            top: snapOffsetTop,\n            right: snapOffsetRight,\n            bottom: snapOffsetBottom,\n        },\n    } = moveable.state;\n    const bounds = externalBounds || moveable.props.bounds || {} as BoundType;\n    const position = bounds.position || \"client\";\n    const isCSS = position === \"css\";\n    const {\n        left = -Infinity,\n        top = -Infinity,\n    } = bounds;\n    let {\n        right = isCSS ? -Infinity : Infinity,\n        bottom = isCSS ? -Infinity : Infinity,\n    } = bounds;\n\n    if (isCSS) {\n        right = containerWidth! + snapOffsetRight - snapOffsetLeft - right;\n        bottom = containerHeight! + snapOffsetBottom - snapOffsetTop - bottom;\n    }\n\n    return {\n        left: left + snapOffsetLeft - clientLeft!,\n        right: right + snapOffsetLeft - clientLeft!,\n        top: top + snapOffsetTop - clientTop!,\n        bottom: bottom + snapOffsetTop - clientTop!,\n    };\n}\nexport function checkBoundKeepRatio(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    startPos: number[],\n    endPos: number[],\n) {\n    const {\n        left,\n        top,\n        right,\n        bottom,\n    } = getBounds(moveable);\n\n    const [endX, endY] = endPos;\n    let [dx, dy] = minus(endPos, startPos);\n\n    if (abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n    const isBottom = dy > 0;\n    const isRight = dx > 0;\n\n    const verticalInfo = {\n        isBound: false,\n        offset: 0,\n        pos: 0,\n    };\n    const horizontalInfo = {\n        isBound: false,\n        offset: 0,\n        pos: 0,\n    };\n    if (dx === 0 && dy === 0) {\n        return {\n            vertical: verticalInfo,\n            horizontal: horizontalInfo,\n        };\n    } else if (dx === 0) {\n        if (isBottom) {\n            if (bottom < endY) {\n                horizontalInfo.pos = bottom;\n                horizontalInfo.offset = endY - bottom;\n            }\n        } else {\n            if (top > endY) {\n                horizontalInfo.pos = top;\n                horizontalInfo.offset = endY - top;\n            }\n        }\n    } else if (dy === 0) {\n        if (isRight) {\n            if (right < endX) {\n                verticalInfo.pos = right;\n                verticalInfo.offset = endX - right;\n            }\n        } else {\n            if (left > endX) {\n                verticalInfo.pos = left;\n                verticalInfo.offset = endX - left;\n            }\n        }\n    } else {\n        // y - y1 = a * (x - x1)\n        const a = dy / dx;\n        const b = endPos[1] - a * endX;\n        let y = 0;\n        let x = 0;\n        let isBound = false;\n\n        if (isRight && right <= endX) {\n            y = a * right + b;\n            x = right;\n            isBound = true;\n        } else if (!isRight && endX <= left) {\n            y = a * left + b;\n            x = left;\n            isBound = true;\n        }\n        if (isBound) {\n            if (y < top || y > bottom) {\n                isBound = false;\n            }\n        }\n        if (!isBound) {\n            if (isBottom && bottom <= endY) {\n                y = bottom;\n                x = (y - b) / a;\n                isBound = true;\n            } else if (!isBottom &&  endY <= top) {\n                y = top;\n                x = (y - b) / a;\n                isBound = true;\n            }\n        }\n        if (isBound) {\n            verticalInfo.isBound = true;\n            verticalInfo.pos = x;\n            verticalInfo.offset = endX - x;\n\n            horizontalInfo.isBound = true;\n            horizontalInfo.pos = y;\n            horizontalInfo.offset = endY - y;\n        }\n    }\n\n    return {\n        vertical: verticalInfo,\n        horizontal: horizontalInfo,\n    };\n}\nfunction checkBounds(\n    bounds: Required<BoundType>,\n    poses: number[],\n    isVertical: boolean,\n): BoundInfo[] {\n    // 0   [100 - 200]  300\n    const startBoundPos = bounds[isVertical ? \"left\" : \"top\"];\n    const endBoundPos = bounds[isVertical ? \"right\" : \"bottom\"];\n\n    // 450\n    const minPos = Math.min(...poses);\n    const maxPos = Math.max(...poses);\n    const boundInfos: BoundInfo[] = [];\n\n    if (startBoundPos + 1 > minPos) {\n        boundInfos.push({\n            direction: \"start\",\n            isBound: true,\n            offset: minPos - startBoundPos,\n            pos: startBoundPos,\n        });\n    }\n    if (endBoundPos - 1 < maxPos) {\n        boundInfos.push({\n            direction: \"end\",\n            isBound: true,\n            offset: maxPos - endBoundPos,\n            pos: endBoundPos,\n        });\n    }\n\n    if (!boundInfos.length) {\n        boundInfos.push({\n            isBound: false,\n            offset: 0,\n            pos: 0,\n        });\n    }\n\n    return boundInfos.sort((a, b) => abs(b.offset) - abs(a.offset));\n}\nexport function isBoundRotate(\n    relativePoses: number[][],\n    boundRect: { left: number, top: number, right: number, bottom: number },\n    rad: number,\n) {\n    const nextPoses = rad ? relativePoses.map(pos => rotate(pos, rad)) : relativePoses;\n\n    return nextPoses.some(pos => {\n        return (pos[0] < boundRect.left && abs(pos[0] - boundRect.left) > 0.1)\n            || (pos[0] > boundRect.right && abs(pos[0] - boundRect.right) > 0.1)\n            || (pos[1] < boundRect.top && abs(pos[1] - boundRect.top) > 0.1)\n            || (pos[1] > boundRect.bottom && abs(pos[1] - boundRect.bottom) > 0.1);\n    });\n}\nexport function boundRotate(\n    vec: number[],\n    boundPos: number,\n    index: number,\n) {\n    const r = getDistSize(vec);\n    const nextPos = Math.sqrt(r * r - boundPos * boundPos) || 0;\n\n    return [nextPos, -nextPos].sort((a, b) => {\n        return abs(a - vec[index ? 0 : 1]) - abs(b - vec[index ? 0 : 1]);\n    }).map(pos => {\n        return getRad([0, 0], index ? [pos, boundPos] : [boundPos, pos]);\n    });\n}\n\nexport function checkRotateBounds(\n    moveable: MoveableManagerInterface<SnappableProps & RotatableProps, SnappableState>,\n    prevPoses: number[][],\n    nextPoses: number[][],\n    origin: number[],\n    rotation: number,\n) {\n    if (!moveable.props.bounds) {\n        return [];\n    }\n    const rad = rotation * Math.PI / 180;\n\n    const {\n        left,\n        top,\n        right,\n        bottom,\n    } = getBounds(moveable);\n\n    const relativeLeft = left - origin[0];\n    const relativeRight = right - origin[0];\n    const relativeTop = top - origin[1];\n    const relativeBottom = bottom - origin[1];\n    const boundRect = {\n        left: relativeLeft,\n        top: relativeTop,\n        right: relativeRight,\n        bottom: relativeBottom,\n    };\n\n    if (!isBoundRotate(nextPoses, boundRect, 0)) {\n        return [];\n    }\n    const result: number[] = [];\n    [\n        [relativeLeft, 0],\n        [relativeRight, 0],\n        [relativeTop, 1],\n        [relativeBottom, 1],\n    ].forEach(([boundPos, index]) => {\n        nextPoses.forEach(nextPos => {\n            const relativeRad1 = getRad([0, 0], nextPos);\n\n            result.push(...boundRotate(nextPos, boundPos, index)\n                .map(relativeRad2 => rad + relativeRad2 - relativeRad1)\n                .filter(nextRad => !isBoundRotate(prevPoses, boundRect, nextRad))\n                .map(nextRad => throttle(nextRad * 180 / Math.PI, TINY_NUM)));\n        });\n    });\n\n    return result;\n}\n", "import { TINY_NUM } from \"@daybrush/utils\";\nimport { throttle } from \"@daybrush/utils\";\nimport {\n    MoveableClientRect, MoveableManagerInterface,\n    SnapDirectionPoses,\n    SnapDirections, SnappableProps,\n    SnappableState,\n} from \"../../types\";\nimport {\n    calculatePosition,\n} from \"../../utils\";\nexport const VERTICAL_NAMES = [\"left\", \"right\", \"center\"] as const;\nexport const HORIZONTAL_NAMES = [\"top\", \"bottom\", \"middle\"] as const;\nexport const SNAP_SKIP_NAMES_MAP = {\n    \"left\": \"start\",\n    \"right\": \"end\",\n    \"center\": \"center\",\n    \"top\": \"start\",\n    \"bottom\": \"end\",\n    \"middle\": \"center\",\n};\n\nexport const VERTICAL_NAMES_MAP = {\n    start: \"left\",\n    end: \"right\",\n    center: \"center\",\n} as const;\nexport const HORIZONTAL_NAMES_MAP = {\n    start: \"top\",\n    end: \"bottom\",\n    center: \"middle\",\n} as const;\n\n\n\nexport function getInitialBounds() {\n    return {\n        left: false,\n        top: false,\n        right: false,\n        bottom: false,\n    };\n}\n\n\nexport function hasGuidelines(\n    moveable: MoveableManagerInterface<any, any>,\n    ableName: string\n): moveable is MoveableManagerInterface<SnappableProps, SnappableState> {\n    const {\n        props: {\n            snappable,\n            bounds,\n            innerBounds,\n            verticalGuidelines,\n            horizontalGuidelines,\n            snapGridWidth,\n            snapGridHeight,\n        },\n        state: { guidelines, enableSnap },\n    } = moveable;\n\n    if (\n        !snappable ||\n        !enableSnap ||\n        (ableName && snappable !== true && snappable.indexOf(ableName) < 0)\n    ) {\n        return false;\n    }\n    if (\n        snapGridWidth ||\n        snapGridHeight ||\n        bounds ||\n        innerBounds ||\n        (guidelines && guidelines.length) ||\n        (verticalGuidelines && verticalGuidelines.length) ||\n        (horizontalGuidelines && horizontalGuidelines.length)\n    ) {\n        return true;\n    }\n    return false;\n}\n\nexport function getSnapDirections(snapDirections: SnapDirections | boolean | undefined): SnapDirections {\n    if (snapDirections === false) {\n        return {};\n    } else if (snapDirections === true || !snapDirections) {\n        return { left: true, right: true, top: true, bottom: true };\n    }\n    return snapDirections;\n}\n\nexport function mapSnapDirectionPoses(\n    snapDirections: SnapDirections | boolean | undefined,\n    snapPoses: SnapDirectionPoses,\n) {\n    const nextSnapDirections = getSnapDirections(snapDirections);\n    const nextSnapPoses: SnapDirectionPoses = {};\n\n    for (const name in nextSnapDirections) {\n        if (name in snapPoses && (nextSnapDirections as any)[name]) {\n            (nextSnapPoses as any)[name] = (snapPoses as any)[name];\n        }\n    }\n    return nextSnapPoses;\n}\n\nexport function splitSnapDirectionPoses(\n    snapDirections: SnapDirections | boolean | undefined,\n    snapPoses: SnapDirectionPoses,\n) {\n    const nextSnapPoses = mapSnapDirectionPoses(snapDirections, snapPoses);\n    const horizontalNames = HORIZONTAL_NAMES.filter(name => name in nextSnapPoses);\n    const verticalNames = VERTICAL_NAMES.filter(name => name in nextSnapPoses);\n\n    return {\n        horizontalNames,\n        verticalNames,\n        horizontal: horizontalNames.map(name => nextSnapPoses[name]!),\n        vertical: verticalNames.map(name => nextSnapPoses[name]!),\n    };\n}\n\nexport function calculateContainerPos(\n    rootMatrix: number[],\n    containerRect: MoveableClientRect,\n    n: number,\n) {\n    const clientPos = calculatePosition(\n        rootMatrix, [containerRect.clientLeft!, containerRect.clientTop!], n);\n\n    return [\n        containerRect.left + clientPos[0],\n        containerRect.top + clientPos[1],\n    ];\n}\n\nexport function solveLineConstants([point1, point2]: number[][]): [number, number, number] {\n    let dx = point2[0] - point1[0];\n    let dy = point2[1] - point1[1];\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n\n    // b > 0\n    // ax + by + c = 0\n    let a = 0;\n    let b = 0;\n    let c = 0;\n\n    if (!dx) {\n        // -x + 1 = 0\n        a = -1;\n        c = point1[0];\n    } else if (!dy) {\n        // y - 1 = 0\n        b = 1;\n        c = -point1[1];\n    } else {\n        // y = -a(x - x1) + y1\n        // ax + y + a * x1 - y1 = 0\n        a = -dy / dx;\n        b = 1;\n        c = a * point1[0] - point1[1];\n    }\n\n    return [a, b, c].map(v => throttle(v, TINY_NUM)) as [number, number, number];\n}\n", "export const NAME_snapRotationThreshold = \"snapRotationThreshold\";\nexport const NAME_snapRotationDegrees = \"snapRotationDegrees\";\nexport const NAME_snapHorizontalThreshold = \"snapHorizontalThreshold\";\nexport const NAME_snapVerticalThreshold = \"snapVerticalThreshold\";\n", "import {\n    SnapInfo, SnappableProps, SnappableState,\n    SnapGuideline, ResizableProps, ScalableProps,\n    SnapOffsetInfo, MoveableManagerInterface, SnapDirectionPoses, SnapDirectionInfo,\n} from \"../../types\";\nimport {\n    selectValue, getTinyDist, abs,\n} from \"../../utils\";\nimport { getPosByDirection, getPosesByDirection } from \"../../gesto/GestoUtils\";\nimport { TINY_NUM } from \"../../consts\";\nimport { minus } from \"@scena/matrix\";\nimport { splitSnapDirectionPoses } from \"./utils\";\nimport { NAME_snapHorizontalThreshold, NAME_snapVerticalThreshold } from \"./names\";\n\n\n\nexport function checkMoveableSnapPoses(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    posesX: number[],\n    posesY: number[],\n    dirXs: string[] = [],\n    dirYs: string[] = [],\n    customSnapVerticalThreshold: number | undefined,\n    customSnapHorizontalThreshold: number | undefined,\n) {\n    const props = moveable.props;\n    const snapThresholdMultiples = moveable.state.snapThresholdInfo?.multiples || [1, 1];\n    const snapHorizontalThreshold = selectValue<number>(\n        customSnapHorizontalThreshold,\n        props[NAME_snapHorizontalThreshold],\n        5,\n    );\n    const snapVerticalThreshold = selectValue<number>(\n        customSnapVerticalThreshold,\n        props[NAME_snapVerticalThreshold],\n        5,\n    );\n\n    return checkSnapPoses(\n        moveable.state.guidelines,\n        posesX,\n        posesY,\n        dirXs,\n        dirYs,\n        snapHorizontalThreshold,\n        snapVerticalThreshold,\n        snapThresholdMultiples,\n    );\n}\n\nexport function checkSnapPoses(\n    guidelines: SnapGuideline[],\n    posesX: number[],\n    posesY: number[],\n    dirXs: string[],\n    dirYs: string[],\n    snapHorizontalThreshold: number,\n    snapVerticalThreshold: number,\n    multiples: number[],\n) {\n    return {\n        vertical: checkSnap(guidelines, \"vertical\", posesX, snapVerticalThreshold * multiples[0], dirXs),\n        horizontal: checkSnap(guidelines, \"horizontal\", posesY, snapHorizontalThreshold * multiples[1], dirYs),\n    };\n}\nexport function checkSnapKeepRatio(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    startPos: number[],\n    endPos: number[],\n): { vertical: SnapOffsetInfo, horizontal: SnapOffsetInfo } {\n    const [endX, endY] = endPos;\n    const [startX, startY] = startPos;\n    let [dx, dy] = minus(endPos, startPos);\n    const isBottom = dy > 0;\n    const isRight = dx > 0;\n\n    dx = getTinyDist(dx);\n    dy = getTinyDist(dy);\n\n    const verticalInfo: SnapOffsetInfo = {\n        isSnap: false,\n        offset: 0,\n        pos: 0,\n    };\n    const horizontalInfo: SnapOffsetInfo = {\n        isSnap: false,\n        offset: 0,\n        pos: 0,\n    };\n\n    if (dx === 0 && dy === 0) {\n        return {\n            vertical: verticalInfo,\n            horizontal: horizontalInfo,\n        };\n    }\n    const {\n        vertical: verticalSnapInfo,\n        horizontal: horizontalSnapInfo,\n    } = checkMoveableSnapPoses(\n        moveable,\n        dx ? [endX] : [],\n        dy ? [endY] : [],\n        [],\n        [],\n        undefined,\n        undefined,\n    );\n\n    verticalSnapInfo.posInfos.filter(({ pos }) => {\n        return isRight ? pos >= startX : pos <= startX;\n    });\n    horizontalSnapInfo.posInfos.filter(({ pos }) => {\n        return isBottom ? pos >= startY : pos <= startY;\n    });\n    verticalSnapInfo.isSnap = verticalSnapInfo.posInfos.length > 0;\n    horizontalSnapInfo.isSnap = horizontalSnapInfo.posInfos.length > 0;\n\n    const {\n        isSnap: isVerticalSnap,\n        guideline: verticalGuideline,\n    } = getNearestSnapGuidelineInfo(verticalSnapInfo);\n    const {\n        isSnap: isHorizontalSnap,\n        guideline: horizontalGuideline,\n    } = getNearestSnapGuidelineInfo(horizontalSnapInfo);\n    const horizontalPos = isHorizontalSnap ? horizontalGuideline!.pos[1] : 0;\n    const verticalPos = isVerticalSnap ? verticalGuideline!.pos[0] : 0;\n\n    if (dx === 0) {\n        if (isHorizontalSnap) {\n            horizontalInfo.isSnap = true;\n            horizontalInfo.pos = horizontalGuideline!.pos[1];\n            horizontalInfo.offset = endY - horizontalInfo.pos;\n        }\n    } else if (dy === 0) {\n        if (isVerticalSnap) {\n            verticalInfo.isSnap = true;\n            verticalInfo.pos = verticalPos;\n            verticalInfo.offset = endX - verticalPos;\n        }\n    } else {\n        // y - y1 = a * (x - x1)\n        const a = dy / dx;\n        const b = endPos[1] - a * endX;\n        let y = 0;\n        let x = 0;\n        let isSnap = false;\n\n        if (isVerticalSnap) {\n            x = verticalPos;\n            y = a * x + b;\n            isSnap = true;\n        } else if (isHorizontalSnap) {\n            y = horizontalPos;\n            x = (y - b) / a;\n            isSnap = true;\n        }\n        if (isSnap) {\n            verticalInfo.isSnap = true;\n            verticalInfo.pos = x;\n            verticalInfo.offset = endX - x;\n\n            horizontalInfo.isSnap = true;\n            horizontalInfo.pos = y;\n            horizontalInfo.offset = endY - y;\n        }\n    }\n    return {\n        vertical: verticalInfo,\n        horizontal: horizontalInfo,\n    };\n}\n\n\nfunction getStringDirection(dir: number | string) {\n    let stringDirection = \"\";\n\n    if (dir === -1 || dir === \"top\" || dir === \"left\") {\n        stringDirection = \"start\";\n    } else if (dir === 0 || dir === \"center\" || dir === \"middle\") {\n        stringDirection = \"center\";\n    } else if (dir === 1 || dir === \"right\" || dir === \"bottom\") {\n        stringDirection = \"end\";\n    }\n    return stringDirection;\n}\n\n\nexport function checkSnaps(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    rect: SnapDirectionPoses,\n    customSnapVerticalThreshold: number | undefined,\n    customSnapHorizontalThreshold: number | undefined,\n): { vertical: SnapDirectionInfo; horizontal: SnapDirectionInfo } {\n    const poses = splitSnapDirectionPoses(moveable.props.snapDirections, rect);\n\n    const result = checkMoveableSnapPoses(\n        moveable,\n        poses.vertical,\n        poses.horizontal,\n        poses.verticalNames.map(name => getStringDirection(name)),\n        poses.horizontalNames.map(name => getStringDirection(name)),\n        customSnapVerticalThreshold,\n        customSnapHorizontalThreshold,\n    );\n    const horizontalDirection = getStringDirection(poses.horizontalNames[result.horizontal.index]);\n    const verticalDirection = getStringDirection(poses.verticalNames[result.vertical.index]);\n\n    return {\n        vertical: {\n            ...result.vertical,\n            direction: verticalDirection,\n        },\n        horizontal: {\n            ...result.horizontal,\n            direction: horizontalDirection,\n        },\n    };\n}\n\nexport function getNearestSnapGuidelineInfo(\n    snapInfo: SnapInfo,\n) {\n    const isSnap = snapInfo.isSnap;\n\n    if (!isSnap) {\n        return {\n            isSnap: false,\n            offset: 0,\n            dist: -1,\n            pos: 0,\n            guideline: null,\n        };\n    }\n    const posInfo = snapInfo.posInfos[0];\n    const guidelineInfo = posInfo!.guidelineInfos[0];\n    const offset = guidelineInfo!.offset;\n    const dist = guidelineInfo!.dist;\n    const guideline = guidelineInfo!.guideline;\n\n    return {\n        isSnap,\n        offset,\n        dist,\n        pos: posInfo!.pos,\n        guideline,\n    };\n}\n\nfunction checkSnap(\n    guidelines: SnapGuideline[],\n    targetType: \"horizontal\" | \"vertical\",\n    targetPoses: number[],\n    snapThreshold: number,\n    dirs: string[] = [],\n): SnapInfo {\n    if (!guidelines || !guidelines.length) {\n        return {\n            isSnap: false,\n            index: -1,\n            direction: \"\",\n            posInfos: [],\n        };\n    }\n    const isVertical = targetType === \"vertical\";\n    const posType = isVertical ? 0 : 1;\n\n    const snapPosInfos = targetPoses.map((targetPos, index) => {\n        const direction = dirs[index] || \"\";\n\n        const guidelineInfos = guidelines.map(guideline => {\n            const { pos } = guideline;\n            const offset = targetPos - pos[posType];\n\n            return {\n                offset,\n                dist: abs(offset),\n                guideline,\n                direction,\n            };\n        }).filter(({ guideline, dist }) => {\n            const { type } = guideline;\n            if (\n                type !== targetType\n                || dist > snapThreshold\n            ) {\n                return false;\n            }\n            return true;\n        }).sort(\n            (a, b) => a.dist - b.dist,\n        );\n\n\n        return {\n            pos: targetPos,\n            index,\n            guidelineInfos,\n            direction,\n        };\n    }).filter(snapPosInfo => {\n        return snapPosInfo.guidelineInfos.length > 0;\n    }).sort((a, b) => {\n        return a.guidelineInfos[0].dist - b.guidelineInfos[0].dist;\n    });\n\n    const isSnap = snapPosInfos.length > 0;\n    return {\n        isSnap,\n        index: isSnap ? snapPosInfos[0].index : -1,\n        direction: snapPosInfos[0]?.direction ?? \"\",\n        posInfos: snapPosInfos,\n    };\n}\n\nexport function getSnapInfosByDirection(\n    moveable: MoveableManagerInterface<SnappableProps & (ResizableProps | ScalableProps), SnappableState>,\n    // pos1 pos2 pos3 pos4\n    poses: number[][],\n    snapDirection: number[],\n    customSnapVerticalThreshold: number | undefined,\n    customSnapHorizontalThreshold: number | undefined,\n): { vertical: SnapDirectionInfo; horizontal: SnapDirectionInfo } {\n    let dirs: number[][] = [];\n\n    if (snapDirection[0] && snapDirection[1]) {\n        dirs = [\n            snapDirection,\n            [-snapDirection[0], snapDirection[1]],\n            [snapDirection[0], -snapDirection[1]],\n        ];\n    } else if (!snapDirection[0] && !snapDirection[1]) {\n        [\n            [-1, -1],\n            [1, -1],\n            [1, 1],\n            [-1, 1],\n        ].forEach((dir, i, arr) => {\n            const nextDir = (arr[i + 1] || arr[0]);\n            dirs.push(dir);\n            dirs.push([\n                (dir[0] + nextDir[0]) / 2,\n                (dir[1] + nextDir[1]) / 2,\n            ]);\n        });\n    } else {\n        if (moveable.props.keepRatio) {\n            dirs.push(\n                [-1, -1],\n                [-1, 1],\n                [1, -1],\n                [1, 1],\n                snapDirection,\n            );\n        } else {\n            dirs.push(...getPosesByDirection([\n                [-1, -1],\n                [1, -1],\n                [-1, -1],\n                [1, 1],\n            ], snapDirection));\n\n            if (dirs.length > 1) {\n                dirs.push([\n                    (dirs[0][0] + dirs[1][0]) / 2,\n                    (dirs[0][1] + dirs[1][1]) / 2,\n                ]);\n            }\n        }\n    }\n    const nextPoses = dirs.map(dir => getPosByDirection(poses, dir));\n    const xs = nextPoses.map(pos => pos[0]);\n    const ys = nextPoses.map(pos => pos[1]);\n    const result = checkMoveableSnapPoses(\n        moveable,\n        xs, ys,\n        dirs.map(dir => getStringDirection(dir[0])),\n        dirs.map(dir => getStringDirection(dir[1])),\n        customSnapVerticalThreshold,\n        customSnapHorizontalThreshold,\n    );\n    const verticalDirection = getStringDirection(dirs.map(dir => dir[0])[result.vertical.index]);\n    const horizontalDirection = getStringDirection(dirs.map(dir => dir[1])[result.horizontal.index]);\n\n    return {\n        vertical: {\n            ...result.vertical,\n            direction: verticalDirection,\n        },\n        horizontal: {\n            ...result.horizontal,\n            direction: horizontalDirection,\n        },\n    };\n}\n\nexport function checkSnapBoundPriority(\n    a: { isBound: boolean, isSnap: boolean, offset: number },\n    b: { isBound: boolean, isSnap: boolean, offset: number },\n) {\n    const aDist = abs(a.offset);\n    const bDist = abs(b.offset);\n\n    if (a.isBound && b.isBound) {\n        return bDist - aDist;\n    } else if (a.isBound) {\n        return -1;\n    } else if (b.isBound) {\n        return 1;\n    } else if (a.isSnap && b.isSnap) {\n        return bDist - aDist;\n    } else if (a.isSnap) {\n        return -1;\n    } else if (b.isSnap) {\n        return 1;\n    } else if (aDist < TINY_NUM) {\n        return 1;\n    } else if (bDist < TINY_NUM) {\n        return -1;\n    }\n    return aDist - bDist;\n}\nexport function getNearOffsetInfo<T extends { offset: number[], isBound: boolean, isSnap: boolean, sign: number[] }>(\n    offsets: T[],\n    index: number,\n) {\n    return offsets.slice().sort((a, b) => {\n        const aSign = a.sign[index];\n        const bSign = b.sign[index];\n        const aOffset = a.offset[index];\n        const bOffset = b.offset[index];\n        // -1 The positions of a and b do not change.\n        // 1 The positions of a and b are reversed.\n        if (!aSign) {\n            return 1;\n        } else if (!bSign) {\n            return -1;\n        }\n        return checkSnapBoundPriority(\n            { isBound: a.isBound, isSnap: a.isSnap, offset: aOffset },\n            { isBound: b.isBound, isSnap: b.isSnap, offset: bOffset },\n        );\n    })[0];\n}\n\n\nexport function getCheckSnapDirections(\n    direction: number[],\n    fixedDirection: number[],\n    keepRatio: boolean\n) {\n    const directions: number[][][] = [];\n    // const fixedDirection = [-direction[0], -direction[1]];\n\n    if (keepRatio) {\n        if (abs(fixedDirection[0]) !== 1 || abs(fixedDirection[1]) !== 1) {\n            directions.push(\n                [fixedDirection, [-1, -1]],\n                [fixedDirection, [-1, 1]],\n                [fixedDirection, [1, -1]],\n                [fixedDirection, [1, 1]],\n            );\n        } else {\n            directions.push(\n                [fixedDirection, [direction[0], -direction[1]]],\n                [fixedDirection, [-direction[0], direction[1]]],\n            );\n        }\n        directions.push([fixedDirection, direction]);\n    } else {\n        if ((direction[0] && direction[1]) || (!direction[0] && !direction[1])) {\n            const endDirection = direction[0] ? direction : [1, 1];\n\n            [1, -1].forEach(signX => {\n                [1, -1].forEach(signY => {\n                    const nextDirection = [signX * endDirection[0], signY * endDirection[1]];\n\n                    if (\n                        fixedDirection[0] === nextDirection[0]\n                        && fixedDirection[1] === nextDirection[1]\n                    ) {\n                        return;\n                    }\n                    directions.push([fixedDirection, nextDirection]);\n                });\n            });\n        } else if (direction[0]) {\n            const signs = abs(fixedDirection[0]) === 1 ? [1] : [1, -1];\n\n            signs.forEach(sign => {\n                directions.push(\n                    [\n                        [fixedDirection[0], -1],\n                        [sign * direction[0], -1],\n                    ],\n                    [\n                        [fixedDirection[0], 0],\n                        [sign * direction[0], 0],\n                    ],\n                    [\n                        [fixedDirection[0], 1],\n                        [sign * direction[0], 1],\n                    ]\n                );\n            });\n        } else if (direction[1]) {\n            const signs = abs(fixedDirection[1]) === 1 ? [1] : [1, -1];\n\n            signs.forEach(sign => {\n                directions.push(\n                    [\n                        [-1, fixedDirection[1]],\n                        [-1, sign * direction[1]],\n                    ],\n                    [\n                        [0, fixedDirection[1]],\n                        [0, sign * direction[1]],\n                    ],\n                    [\n                        [1, fixedDirection[1]],\n                        [1, sign * direction[1]],\n                    ]\n                );\n            });\n        }\n    }\n    return directions;\n}\n", "import { average, getRad, throttle } from \"@daybrush/utils\";\nimport { rotate } from \"@scena/matrix\";\nimport { maxOffset, getDistSize, getTinyDist, calculatePoses, abs } from \"../../utils\";\n\nimport { SnappableProps, DraggableProps, RotatableProps, MoveableManagerInterface } from \"../../types\";\nimport { getDragDist, getPosByDirection, getInverseDragDist } from \"../../gesto/GestoUtils\";\nimport { getNearOffsetInfo } from \"./snap\";\nimport { TINY_NUM } from \"../../consts\";\nimport { getInitialBounds, solveLineConstants } from \"./utils\";\n\nfunction isStartLine(dot: number[], line: number[][]) {\n    // l    o     => true\n    // o    l    => false\n    const cx = average([line[0][0], line[1][0]]);\n    const cy = average([line[0][1], line[1][1]]);\n\n    return {\n        vertical: cx <= dot[0],\n        horizontal: cy <= dot[1],\n    };\n}\nfunction hitTestLine(\n    dot: number[],\n    [pos1, pos2]: number[][],\n) {\n    let dx = pos2[0] - pos1[0];\n    let dy = pos2[1] - pos1[1];\n\n    if (abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n    let test1: number;\n    let test2: number;\n    if (!dx) {\n        test1 = pos1[0];\n        test2 = dot[0];\n    } else if (!dy) {\n        test1 = pos1[1];\n        test2 = dot[1];\n    } else {\n        const a = dy / dx;\n\n        // y = a * (x - pos1) + pos1\n        test1 = a * (dot[0] - pos1[0]) + pos1[1];\n        test2 = dot[1];\n    }\n    return test1 - test2;\n}\nfunction isSameStartLine(dots: number[][], line: number[][], centerSign: boolean, error: number = TINY_NUM) {\n    return dots.every(dot => {\n        const value = hitTestLine(dot, line);\n        const sign = value <= 0;\n        return sign === centerSign || abs(value) <= error;\n    });\n}\nfunction checkInnerBoundDot(\n    pos: number,\n    start: number,\n    end: number,\n    isStart: boolean,\n    threshold = 0,\n) {\n    if (\n        (isStart && start - threshold <= pos)\n        || (!isStart && pos <= end + threshold)\n    ) {\n        // false 402 565 602 => 37 ([0, 37])\n        // true 400 524.9712603540036 600 => 124 ([124, 0])\n        // true 400 410 600 => 10 ([10, 0])\n        return {\n            isBound: true,\n            offset: isStart ? start - pos : end - pos,\n        };\n    }\n    return {\n        isBound: false,\n        offset: 0,\n    };\n}\n\nfunction checkInnerBound(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    { line, centerSign, verticalSign, horizontalSign, lineConstants }: InnerBoundLineInfo,\n) {\n    const bounds = moveable.props.innerBounds;\n\n    if (!bounds) {\n        return {\n            isAllBound: false,\n            isBound: false,\n            isVerticalBound: false,\n            isHorizontalBound: false,\n            offset: [0, 0],\n        };\n    }\n    const { left, top, width, height } = bounds;\n    const leftLine = [[left, top], [left, top + height]];\n    const topLine = [[left, top], [left + width, top]];\n    const rightLine = [[left + width, top], [left + width, top + height]];\n    const bottomLine = [[left, top + height], [left + width, top + height]];\n\n    if (isSameStartLine([\n        [left, top],\n        [left + width, top],\n        [left, top + height],\n        [left + width, top + height],\n    ], line, centerSign)) {\n        return {\n            isAllBound: false,\n            isBound: false,\n            isVerticalBound: false,\n            isHorizontalBound: false,\n            offset: [0, 0],\n        };\n    }\n    // test vertical\n\n    const topBoundInfo = checkLineBoundCollision(line, lineConstants, topLine, verticalSign);\n    const bottomBoundInfo = checkLineBoundCollision(line, lineConstants, bottomLine, verticalSign);\n\n    // test horizontal\n    const leftBoundInfo = checkLineBoundCollision(line, lineConstants, leftLine, horizontalSign);\n    const rightBoundInfo = checkLineBoundCollision(line, lineConstants, rightLine, horizontalSign);\n\n    const isAllVerticalBound = topBoundInfo.isBound && bottomBoundInfo.isBound;\n    const isVerticalBound = topBoundInfo.isBound || bottomBoundInfo.isBound;\n    const isAllHorizontalBound = leftBoundInfo.isBound && rightBoundInfo.isBound;\n    const isHorizontalBound = leftBoundInfo.isBound || rightBoundInfo.isBound;\n    const verticalOffset = maxOffset(topBoundInfo.offset, bottomBoundInfo.offset);\n    const horizontalOffset = maxOffset(leftBoundInfo.offset, rightBoundInfo.offset);\n    let offset = [0, 0];\n    let isBound = false;\n    let isAllBound = false;\n\n    if (abs(horizontalOffset) < abs(verticalOffset)) {\n        offset = [verticalOffset, 0];\n        isBound = isVerticalBound;\n        isAllBound = isAllVerticalBound;\n    } else {\n        offset = [0, horizontalOffset];\n        isBound = isHorizontalBound;\n        isAllBound = isAllHorizontalBound;\n    }\n    return {\n        isAllBound,\n        isVerticalBound,\n        isHorizontalBound,\n        isBound,\n        offset,\n    };\n}\n\nfunction checkLineBoundCollision(\n    line: number[][],\n    [a, b]: [number, number, number],\n    boundLine: number[][],\n    isStart: boolean,\n    threshold?: number,\n    isRender?: boolean,\n) {\n    const dot1 = line[0];\n    // const dot2 = line[1];\n    const boundDot1 = boundLine[0];\n    const boundDot2 = boundLine[1];\n\n    // const dy1 = getTinyDist(dot2[1] - dot1[1]);\n    // const dx1 = getTinyDist(dot2[0] - dot1[0]);\n    const dy2 = getTinyDist(boundDot2[1] - boundDot1[1]);\n    const dx2 = getTinyDist(boundDot2[0] - boundDot1[0]);\n\n    const hasDx = b;\n    const hasDy = a;\n    const slope = - a / b;\n    // lineConstants\n    // ax + by + c = 0\n    // dx2 or dy2 is zero\n    if (!dx2) {\n        // vertical\n        // by + c = 0\n        if (isRender && !hasDy) {\n            // 90deg\n            return {\n                isBound: false,\n                offset: 0,\n            };\n        } else if (hasDx) {\n            // ax + by + c = 0\n            // const y = dy1 ? dy1 / dx1 * (boundDot1[0] - dot1[0]) + dot1[1] : dot1[1];\n            const y = slope * (boundDot1[0] - dot1[0]) + dot1[1];\n\n            // boundDot1[1] <= y  <= boundDot2[1]\n            return checkInnerBoundDot(y, boundDot1[1], boundDot2[1], isStart, threshold);\n        } else {\n            // ax + c = 0\n            const offset = boundDot1[0] - dot1[0];\n\n            const isBound = abs(offset) <= (threshold || 0);\n\n            return {\n                isBound,\n                offset: isBound ? offset : 0,\n            };\n        }\n    } else if (!dy2) {\n        // horizontal\n        if (isRender && !hasDx) {\n            // 90deg\n            return {\n                isBound: false,\n                offset: 0,\n            };\n        } else if (hasDy) {\n            // y = a * (x - x1) + y1\n            // x = (y - y1) / a + x1\n            // const a = dy1 / dx1;\n            // const x = dx1 ? (boundDot1[1] - dot1[1]) / a + dot1[0] : dot1[0];\n            const x = (boundDot1[1] - dot1[1]) / slope + dot1[0];\n\n            // boundDot1[0] <= x && x <= boundDot2[0]\n            return checkInnerBoundDot(x, boundDot1[0], boundDot2[0], isStart, threshold);\n        } else {\n            const offset = boundDot1[1] - dot1[1];\n\n            const isBound = abs(offset) <= (threshold || 0);\n\n            return {\n                isBound,\n                offset: isBound ? offset : 0,\n            };\n        }\n    }\n    return {\n        isBound: false,\n        offset: 0,\n    };\n}\nexport function getInnerBoundInfo(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    lineInfos: InnerBoundLineInfo[],\n    datas: any,\n) {\n    return lineInfos.map(info => {\n        const {\n            isBound,\n            offset,\n            isVerticalBound,\n            isHorizontalBound,\n        } = checkInnerBound(moveable, info);\n\n        const multiple = info.multiple;\n\n        const sizeOffset = getDragDist({\n            datas,\n            distX: offset[0],\n            distY: offset[1],\n        }).map((size, i) => size * (multiple[i] ? 2 / multiple[i] : 0));\n\n        return {\n            sign: multiple,\n            isBound,\n            isVerticalBound,\n            isHorizontalBound,\n            isSnap: false,\n            offset: sizeOffset,\n        };\n    });\n}\n\nexport function getInnerBoundDragInfo(\n    moveable: MoveableManagerInterface<SnappableProps & DraggableProps, any>,\n    poses: number[][],\n    datas: any,\n) {\n    const lines = getCheckInnerBoundLineInfos(moveable, poses, [0, 0], false).map(info => {\n        return {\n            ...info,\n            multiple: info.multiple.map(dir => abs(dir) * 2),\n        };\n    });\n    const innerBoundInfo = getInnerBoundInfo(moveable, lines, datas);\n    const widthOffsetInfo = getNearOffsetInfo(innerBoundInfo, 0);\n    const heightOffsetInfo = getNearOffsetInfo(innerBoundInfo, 1);\n    let verticalOffset = 0;\n    let horizontalOffset = 0;\n    const isVerticalBound = widthOffsetInfo.isVerticalBound || heightOffsetInfo.isVerticalBound;\n    const isHorizontalBound = widthOffsetInfo.isHorizontalBound || heightOffsetInfo.isHorizontalBound;\n\n    if (isVerticalBound || isHorizontalBound) {\n        [verticalOffset, horizontalOffset] = getInverseDragDist({\n            datas,\n            distX: -widthOffsetInfo.offset[0],\n            distY: -heightOffsetInfo.offset[1],\n        });\n    }\n\n    return {\n        vertical: {\n            isBound: isVerticalBound,\n            offset: verticalOffset,\n        },\n        horizontal: {\n            isBound: isHorizontalBound,\n            offset: horizontalOffset,\n        },\n    };\n}\nexport function getCheckSnapLineDirections(\n    direction: number[],\n    keepRatio: boolean,\n) {\n    const lineDirections: number[][][] = [];\n    const x = direction[0];\n    const y = direction[1];\n    if (x && y) {\n        lineDirections.push(\n            [[0, y * 2], direction, [-x, y]],\n            [[x * 2, 0], direction, [x, -y]],\n        );\n    } else if (x) {\n        // vertcal\n        lineDirections.push(\n            [[x * 2, 0], [x, 1], [x, -1]],\n        );\n        if (keepRatio) {\n            lineDirections.push(\n                [[0, -1], [x, -1], [-x, -1]],\n                [[0, 1], [x, 1], [-x, 1]],\n            );\n        }\n    } else if (y) {\n        // horizontal\n        lineDirections.push(\n            [[0, y * 2], [1, y], [-1, y]],\n        );\n        if (keepRatio) {\n            lineDirections.push(\n                [[-1, 0], [-1, y], [-1, -y]],\n                [[1, 0], [1, y], [1, -y]],\n            );\n        }\n    } else {\n        // [0, 0] to all direction\n        lineDirections.push(\n            [[-1, 0], [-1, -1], [-1, 1]],\n            [[1, 0], [1, -1], [1, 1]],\n            [[0, -1], [-1, -1], [1, -1]],\n            [[0, 1], [-1, 1], [1, 1]],\n        );\n    }\n\n    return lineDirections;\n}\nexport interface InnerBoundLineInfo {\n    line: number[][];\n    multiple: number[];\n    horizontalSign: boolean;\n    verticalSign: boolean;\n    centerSign: boolean;\n    lineConstants: [number, number, number];\n}\nexport function getCheckInnerBoundLineInfos(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    poses: number[][],\n    direction: number[],\n    keepRatio: boolean,\n): InnerBoundLineInfo[] {\n    const {\n        allMatrix,\n        is3d,\n    } = moveable.state;\n    const virtualPoses = calculatePoses(allMatrix, 100, 100, is3d ? 4 : 3);\n    const center = getPosByDirection(virtualPoses, [0, 0]);\n\n    return getCheckSnapLineDirections(direction, keepRatio).map(([multiple, dir1, dir2]) => {\n        const virtualLine = [\n            getPosByDirection(virtualPoses, dir1),\n            getPosByDirection(virtualPoses, dir2),\n        ];\n        const lineConstants = solveLineConstants(virtualLine);\n        const {\n            vertical: verticalSign,\n            horizontal: horizontalSign,\n        } = isStartLine(center, virtualLine);\n        const centerSign = hitTestLine(center, virtualLine) <= 0;\n\n        return {\n            multiple,\n            centerSign,\n            verticalSign,\n            horizontalSign,\n            lineConstants,\n            line: [\n                getPosByDirection(poses, dir1),\n                getPosByDirection(poses, dir2),\n            ],\n        };\n    });\n}\n\nfunction isBoundRotate(\n    relativePoses: number[][],\n    boundDots: number[][],\n    center: number[],\n    rad: number,\n) {\n    const nextPoses = rad ? relativePoses.map(pos => rotate(pos, rad)) : relativePoses;\n    return [\n        [nextPoses[0], nextPoses[1]],\n        [nextPoses[1], nextPoses[3]],\n        [nextPoses[3], nextPoses[2]],\n        [nextPoses[2], nextPoses[0]],\n    ].some(line => {\n        const centerSign = hitTestLine(center, line) <= 0;\n\n        return !isSameStartLine(boundDots, line, centerSign);\n    });\n}\nfunction getDistPointLine([pos1, pos2]: number[][]) {\n    // x = 0, y = 0\n    // d = (ax + by + c) / root(a2 + b2)\n\n    const dx = pos2[0] - pos1[0];\n    const dy = pos2[1] - pos1[1];\n\n    if (!dx) {\n        return abs(pos1[0]);\n    }\n    if (!dy) {\n        return abs(pos1[1]);\n    }\n    // y - y1 = a(x - x1)\n    // 0 = ax -y + -a * x1 + y1\n\n    const a = dy / dx;\n\n    return abs((-a * pos1[0] + pos1[1]) / Math.sqrt(Math.pow(a, 2) + 1));\n}\nfunction solveReverseLine([pos1, pos2]: number[][]) {\n    const dx = pos2[0] - pos1[0];\n    const dy = pos2[1] - pos1[1];\n\n    if (!dx) {\n        return [pos1[0], 0];\n    }\n    if (!dy) {\n        return [0, pos1[1]];\n    }\n    const a = dy / dx;\n    // y - y1 = a (x  - x1)\n    // y = ax - a * x1 + y1\n    const b = -a * pos1[0] + pos1[1];\n    // y = ax + b = -1/a x\n    // x = -b / (a + 1 / a)\n    // y = b / (1 + 1 / a^2)\n\n    return [\n        -b / (a + 1 / a),\n        b / ((a * a) + 1),\n    ];\n}\nexport function checkRotateInnerBounds(\n    moveable: MoveableManagerInterface<SnappableProps & RotatableProps, any>,\n    prevPoses: number[][],\n    nextPoses: number[][],\n    origin: number[],\n    rotation: number,\n) {\n    const bounds = moveable.props.innerBounds;\n    const rad = rotation * Math.PI / 180;\n\n    if (!bounds) {\n        return [];\n    }\n    const {\n        left,\n        top,\n        width,\n        height,\n    } = bounds;\n\n    const relativeLeft = left - origin[0];\n    const relativeRight = left + width - origin[0];\n    const relativeTop = top - origin[1];\n    const relativeBottom = top + height - origin[1];\n    const dots = [\n        [relativeLeft, relativeTop],\n        [relativeRight, relativeTop],\n        [relativeLeft, relativeBottom],\n        [relativeRight, relativeBottom],\n    ];\n    const center = getPosByDirection(nextPoses, [0, 0]);\n\n    if (!isBoundRotate(nextPoses, dots, center, 0)) {\n        return [];\n    }\n    const result: number[] = [];\n    const dotInfos = dots.map(dot => [\n        getDistSize(dot),\n        getRad([0, 0], dot),\n    ]);\n    [\n        [nextPoses[0], nextPoses[1]],\n        [nextPoses[1], nextPoses[3]],\n        [nextPoses[3], nextPoses[2]],\n        [nextPoses[2], nextPoses[0]],\n    ].forEach(line => {\n        const lineRad = getRad([0, 0], solveReverseLine(line));\n        const lineDist = getDistPointLine(line);\n\n        result.push(...dotInfos\n            .filter(([dotDist]) => {\n                return dotDist && lineDist <= dotDist;\n            })\n            .map(([dotDist, dotRad]) => {\n                const distRad = Math.acos(dotDist ? lineDist / dotDist : 0);\n                const nextRad1 = dotRad + distRad;\n                const nextRad2 = dotRad - distRad;\n\n                return [\n                    rad + nextRad1 - lineRad,\n                    rad + nextRad2 - lineRad,\n                ];\n            })\n            .reduce((prev, cur) => {\n                prev.push(...cur);\n                return prev;\n            }, [])\n            .filter(nextRad => !isBoundRotate(prevPoses, dots, center, nextRad))\n            .map(nextRad => throttle(nextRad * 180 / Math.PI, TINY_NUM)));\n    });\n    return result;\n}\n\nexport function checkInnerBoundPoses(\n    moveable: MoveableManagerInterface<SnappableProps>,\n) {\n    const innerBounds = moveable.props.innerBounds;\n    const boundMap = getInitialBounds();\n\n    if (!innerBounds) {\n        return {\n            boundMap,\n            vertical: [],\n            horizontal: [],\n        };\n    }\n    const {\n        pos1,\n        pos2,\n        pos3,\n        pos4,\n    } = moveable.getRect();\n    const poses = [pos1, pos2, pos3, pos4];\n    const center = getPosByDirection(poses, [0, 0]);\n    const { left, top, width, height } = innerBounds;\n    const leftLine = [[left, top], [left, top + height]];\n    const topLine = [[left, top], [left + width, top]];\n    const rightLine = [[left + width, top], [left + width, top + height]];\n    const bottomLine = [[left, top + height], [left + width, top + height]];\n    const lineInfos = getCheckInnerBoundLineInfos(moveable, poses, [0, 0], false);\n\n    const horizontalPoses: number[] = [];\n    const verticalPoses: number[] = [];\n\n\n    lineInfos.forEach(lineInfo => {\n        const { line, lineConstants } = lineInfo;\n        const {\n            horizontal: isHorizontalStart,\n            vertical: isVerticalStart,\n        } = isStartLine(center, line);\n\n        // test vertical\n        const topBoundInfo = checkLineBoundCollision(line, lineConstants, topLine, isVerticalStart, 1, true);\n        const bottomBoundInfo = checkLineBoundCollision(line, lineConstants, bottomLine, isVerticalStart, 1, true);\n\n        // test horizontal\n        const leftBoundInfo = checkLineBoundCollision(line, lineConstants, leftLine, isHorizontalStart, 1, true);\n        const rightBoundInfo = checkLineBoundCollision(line, lineConstants, rightLine, isHorizontalStart, 1, true);\n\n        if (topBoundInfo.isBound && !boundMap.top) {\n            horizontalPoses.push(top);\n            boundMap.top = true;\n        }\n        if (bottomBoundInfo.isBound && !boundMap.bottom) {\n            horizontalPoses.push(top + height);\n            boundMap.bottom = true;\n        }\n        if (leftBoundInfo.isBound && !boundMap.left) {\n            verticalPoses.push(left);\n            boundMap.left = true;\n        }\n        if (rightBoundInfo.isBound && !boundMap.right) {\n            verticalPoses.push(left + width);\n            boundMap.right = true;\n        }\n    });\n\n    return {\n        boundMap,\n        horizontal: horizontalPoses,\n        vertical: verticalPoses,\n    };\n}\n", "import { getDist, getRad, IObject, TINY_NUM } from \"@daybrush/utils\";\nimport { minus } from \"@scena/matrix\";\nimport { abs, getAbsolutePoses, getDistSize, getRect, maxOffset } from \"../../utils\";\nimport { getDragDist, getPosByDirection } from \"../../gesto/GestoUtils\";\nimport {\n    BoundInfo, SnapInfo, MoveableManagerInterface, SnappableProps,\n    SnappableState, SnapBoundInfo, SnapGuideline, BoundType, SnapOffsetInfo, DraggableProps,\n} from \"../../types\";\nimport { checkBoundKeepRatio, checkBoundPoses, getBounds } from \"./bounds\";\nimport { getInnerBoundDragInfo } from \"./innerBounds\";\nimport {\n    getNearestSnapGuidelineInfo, checkMoveableSnapPoses,\n    checkSnapPoses, checkSnapKeepRatio,\n} from \"./snap\";\nimport { hasGuidelines, getSnapDirections, splitSnapDirectionPoses } from \"./utils\";\n\ninterface DirectionSnapType<T> {\n    vertical: T;\n    horizontal: T;\n}\n\nexport function solveEquation(\n    pos1: number[],\n    pos2: number[],\n    snapOffset: number,\n    isVertical: boolean\n) {\n    let dx = pos2[0] - pos1[0];\n    let dy = pos2[1] - pos1[1];\n\n    if (abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n    if (!dx) {\n        // y = 0 * x + b\n        // only horizontal\n        if (!isVertical) {\n            return [0, snapOffset];\n        }\n        return [0, 0];\n    }\n    if (!dy) {\n        // only vertical\n        if (isVertical) {\n            return [snapOffset, 0];\n        }\n        return [0, 0];\n    }\n    // y = ax + b\n    const a = dy / dx;\n    const b = pos1[1] - a * pos1[0];\n\n    if (isVertical) {\n        // y = a * x + b\n        const y = a * (pos2[0] + snapOffset) + b;\n\n        return [snapOffset, y - pos2[1]];\n    } else {\n        // x = (y - b) / a\n        const x = (pos2[1] + snapOffset - b) / a;\n\n        return [x - pos2[0], snapOffset];\n    }\n}\n\n\nfunction solveNextOffset(\n    pos1: number[],\n    pos2: number[],\n    offset: number,\n    isVertical: boolean,\n    datas: IObject<any>\n) {\n    const sizeOffset = solveEquation(pos1, pos2, offset, isVertical);\n\n    if (!sizeOffset) {\n        return {\n            isOutside: false,\n            offset: [0, 0],\n        };\n    }\n    const size = getDist(pos1, pos2);\n    const dist1 = getDist(sizeOffset, pos1);\n    const dist2 = getDist(sizeOffset, pos2);\n\n    const isOutside = dist1 > size || dist2 > size;\n    const [widthOffset, heightOffset] = getDragDist({\n        datas,\n        distX: sizeOffset[0],\n        distY: sizeOffset[1],\n    });\n\n    return {\n        offset: [widthOffset, heightOffset],\n        isOutside,\n    };\n}\n\nfunction getSnapBound(boundInfo: BoundInfo, snapInfo: SnapInfo) {\n    if (boundInfo.isBound) {\n        return boundInfo.offset;\n    } else if (snapInfo.isSnap) {\n        return getNearestSnapGuidelineInfo(snapInfo).offset;\n    }\n    return 0;\n}\n\n\nexport function checkThrottleDragRotate(\n    throttleDragRotate: number,\n    [distX, distY]: number[],\n    [isVerticalBound, isHorizontalBound]: boolean[],\n    [isVerticalSnap, isHorizontalSnap]: boolean[],\n    [verticalOffset, horizontalOffset]: number[]\n) {\n    let offsetX = -verticalOffset;\n    let offsetY = -horizontalOffset;\n\n    if (throttleDragRotate && distX && distY) {\n        offsetX = 0;\n        offsetY = 0;\n        const adjustPoses: number[][] = [];\n        if (isVerticalBound && isHorizontalBound) {\n            adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);\n        } else if (isVerticalBound) {\n            adjustPoses.push([verticalOffset, 0]);\n        } else if (isHorizontalBound) {\n            adjustPoses.push([0, horizontalOffset]);\n        } else if (isVerticalSnap && isHorizontalSnap) {\n            adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);\n        } else if (isVerticalSnap) {\n            adjustPoses.push([verticalOffset, 0]);\n        } else if (isHorizontalSnap) {\n            adjustPoses.push([0, horizontalOffset]);\n        }\n        if (adjustPoses.length) {\n            adjustPoses.sort((a, b) => {\n                return (\n                    getDistSize(minus([distX, distY], a)) -\n                    getDistSize(minus([distX, distY], b))\n                );\n            });\n            const adjustPos = adjustPoses[0];\n\n            if (adjustPos[0] && abs(distX) > TINY_NUM) {\n                offsetX = -adjustPos[0];\n                offsetY =\n                    (distY * abs(distX + offsetX)) / abs(distX) -\n                    distY;\n            } else if (adjustPos[1] && abs(distY) > TINY_NUM) {\n                const prevDistY = distY;\n                offsetY = -adjustPos[1];\n                offsetX =\n                    (distX * abs(distY + offsetY)) / abs(prevDistY) -\n                    distX;\n            }\n            if (throttleDragRotate && isHorizontalBound && isVerticalBound) {\n                if (\n                    abs(offsetX) > TINY_NUM &&\n                    abs(offsetX) < abs(verticalOffset)\n                ) {\n                    const scale = abs(verticalOffset) / abs(offsetX);\n\n                    offsetX *= scale;\n                    offsetY *= scale;\n                } else if (\n                    abs(offsetY) > TINY_NUM &&\n                    abs(offsetY) < abs(horizontalOffset)\n                ) {\n                    const scale =\n                        abs(horizontalOffset) / abs(offsetY);\n\n                    offsetX *= scale;\n                    offsetY *= scale;\n                } else {\n                    offsetX = maxOffset(-verticalOffset, offsetX);\n                    offsetY = maxOffset(-horizontalOffset, offsetY);\n                }\n            }\n        }\n    } else {\n        offsetX = distX || isVerticalBound ? -verticalOffset : 0;\n        offsetY = distY || isHorizontalBound ? -horizontalOffset : 0;\n    }\n    return [offsetX, offsetY];\n}\n\nexport function checkSnapBoundsDrag(\n    moveable: MoveableManagerInterface<SnappableProps & DraggableProps, any>,\n    distX: number,\n    distY: number,\n    throttleDragRotate: number,\n    ignoreSnap: boolean,\n    datas: any\n) {\n    if (!hasGuidelines(moveable, \"draggable\")) {\n        return [\n            {\n                isSnap: false,\n                isBound: false,\n                offset: 0,\n            },\n            {\n                isSnap: false,\n                isBound: false,\n                offset: 0,\n            },\n        ];\n    }\n    const poses = getAbsolutePoses(datas.absolutePoses, [distX, distY]);\n    const { left, right, top, bottom } = getRect(poses);\n    const boundPoses = {\n        horizontal: poses.map((pos) => pos[1]),\n        vertical: poses.map((pos) => pos[0]),\n    };\n    const snapDirections = getSnapDirections(moveable.props.snapDirections);\n    const snapPoses = splitSnapDirectionPoses(snapDirections, {\n        left,\n        right,\n        top,\n        bottom,\n        center: (left + right) / 2,\n        middle: (top + bottom) / 2,\n    });\n    const {\n        vertical: verticalSnapBoundInfo,\n        horizontal: horizontalSnapBoundInfo,\n    } = checkMoveableSnapBounds(moveable, ignoreSnap, snapPoses, boundPoses);\n    const {\n        vertical: verticalInnerBoundInfo,\n        horizontal: horizontalInnerBoundInfo,\n    } = getInnerBoundDragInfo(moveable, poses, datas);\n\n    const isVerticalSnap = verticalSnapBoundInfo.isSnap;\n    const isHorizontalSnap = horizontalSnapBoundInfo.isSnap;\n    const isVerticalBound =\n        verticalSnapBoundInfo.isBound || verticalInnerBoundInfo.isBound;\n    const isHorizontalBound =\n        horizontalSnapBoundInfo.isBound || horizontalInnerBoundInfo.isBound;\n    const verticalOffset = maxOffset(\n        verticalSnapBoundInfo.offset,\n        verticalInnerBoundInfo.offset\n    );\n    const horizontalOffset = maxOffset(\n        horizontalSnapBoundInfo.offset,\n        horizontalInnerBoundInfo.offset\n    );\n\n    const [offsetX, offsetY] = checkThrottleDragRotate(\n        throttleDragRotate,\n        [distX, distY],\n        [isVerticalBound, isHorizontalBound],\n        [isVerticalSnap, isHorizontalSnap],\n        [verticalOffset, horizontalOffset]\n    );\n\n    return [\n        {\n            isBound: isVerticalBound,\n            isSnap: isVerticalSnap,\n            offset: offsetX,\n        },\n        {\n            isBound: isHorizontalBound,\n            isSnap: isHorizontalSnap,\n            offset: offsetY,\n        },\n    ];\n}\n\nexport function checkMoveableSnapBounds(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    ignoreSnap: boolean,\n    poses: { vertical: number[]; horizontal: number[]; },\n    boundPoses: { vertical: number[]; horizontal: number[]; } = poses,\n): DirectionSnapType<Required<SnapBoundInfo>> {\n    const {\n        horizontal: horizontalBoundInfos,\n        vertical: verticalBoundInfos,\n    } = checkBoundPoses(\n        getBounds(moveable),\n        boundPoses.vertical,\n        boundPoses.horizontal,\n    );\n    const {\n        horizontal: horizontalSnapInfo,\n        vertical: verticalSnapInfo,\n    } = ignoreSnap ? {\n        horizontal: { isSnap: false, index: -1 } as SnapInfo,\n        vertical: { isSnap: false, index: -1 } as SnapInfo,\n    } : checkMoveableSnapPoses(\n        moveable,\n        poses.vertical,\n        poses.horizontal,\n        undefined,\n        undefined,\n        undefined,\n        undefined,\n    );\n    const horizontalOffset = getSnapBound(\n        horizontalBoundInfos[0],\n        horizontalSnapInfo\n    );\n    const verticalOffset = getSnapBound(\n        verticalBoundInfos[0],\n        verticalSnapInfo\n    );\n\n    const horizontalDist = abs(horizontalOffset);\n    const verticalDist = abs(verticalOffset);\n\n    return {\n        horizontal: {\n            isBound: horizontalBoundInfos[0].isBound,\n            isSnap: horizontalSnapInfo.isSnap,\n            snapIndex: horizontalSnapInfo.index,\n            offset: horizontalOffset,\n            dist: horizontalDist,\n            bounds: horizontalBoundInfos,\n            snap: horizontalSnapInfo,\n        },\n        vertical: {\n            isBound: verticalBoundInfos[0].isBound,\n            isSnap: verticalSnapInfo.isSnap,\n            snapIndex: verticalSnapInfo.index,\n            offset: verticalOffset,\n            dist: verticalDist,\n            bounds: verticalBoundInfos,\n            snap: verticalSnapInfo,\n        },\n    };\n}\nexport function checkSnapBounds(\n    guideines: SnapGuideline[],\n    bounds: BoundType | undefined | false,\n    posesX: number[],\n    posesY: number[],\n    snapHorizontalThreshold: number,\n    snapVerticalThreshold: number,\n    multiples = [1, 1],\n): DirectionSnapType<Required<SnapBoundInfo>> {\n    const {\n        horizontal: horizontalBoundInfos,\n        vertical: verticalBoundInfos,\n    } = checkBoundPoses(bounds, posesX, posesY);\n\n    // options.isRequest ? {\n    //     horizontal: { isSnap: false, index: -1 } as SnapInfo,\n    //     vertical: { isSnap: false, index: -1 } as SnapInfo,\n    // } :\n    const {\n        horizontal: horizontalSnapInfo,\n        vertical: verticalSnapInfo,\n    } = checkSnapPoses(\n        guideines, posesX, posesY, [], [],\n        snapHorizontalThreshold,\n        snapVerticalThreshold,\n        multiples,\n    );\n\n    const horizontalOffset = getSnapBound(\n        horizontalBoundInfos[0],\n        horizontalSnapInfo\n    );\n    const verticalOffset = getSnapBound(\n        verticalBoundInfos[0],\n        verticalSnapInfo\n    );\n\n    const horizontalDist = abs(horizontalOffset);\n    const verticalDist = abs(verticalOffset);\n\n    return {\n        horizontal: {\n            isBound: horizontalBoundInfos[0].isBound,\n            isSnap: horizontalSnapInfo.isSnap,\n            snapIndex: horizontalSnapInfo.index,\n            offset: horizontalOffset,\n            dist: horizontalDist,\n            bounds: horizontalBoundInfos,\n            snap: horizontalSnapInfo,\n        },\n        vertical: {\n            isBound: verticalBoundInfos[0].isBound,\n            isSnap: verticalSnapInfo.isSnap,\n            snapIndex: verticalSnapInfo.index,\n            offset: verticalOffset,\n            dist: verticalDist,\n            bounds: verticalBoundInfos,\n            snap: verticalSnapInfo,\n        },\n    };\n}\n\n\nfunction checkSnapRightLine(\n    startPos: number[],\n    endPos: number[],\n    snapBoundInfo: { vertical: SnapBoundInfo; horizontal: SnapBoundInfo },\n    keepRatio: boolean\n) {\n    const rad = (getRad(startPos, endPos) / Math.PI) * 180;\n    const {\n        vertical: {\n            isBound: isVerticalBound,\n            isSnap: isVerticalSnap,\n            dist: verticalDist,\n        },\n        horizontal: {\n            isBound: isHorizontalBound,\n            isSnap: isHorizontalSnap,\n            dist: horizontalDist,\n        },\n    } = snapBoundInfo;\n\n    const rad180 = rad % 180;\n    const isHorizontalLine = rad180 < 3 || rad180 > 177;\n    const isVerticalLine = rad180 > 87 && rad180 < 93;\n\n    if (horizontalDist < verticalDist) {\n        if (\n            isVerticalBound ||\n            (isVerticalSnap &&\n                !isVerticalLine &&\n                (!keepRatio || !isHorizontalLine))\n        ) {\n            return \"vertical\";\n        }\n    }\n    if (\n        isHorizontalBound ||\n        (isHorizontalSnap &&\n            !isHorizontalLine &&\n            (!keepRatio || !isVerticalLine))\n    ) {\n        return \"horizontal\";\n    }\n    return \"\";\n}\n\n\nexport function getSnapBoundInfo(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    poses: number[][],\n    directions: number[][][],\n    keepRatio: boolean,\n    isRequest: boolean,\n    datas: any\n) {\n    return directions.map(([startDirection, endDirection]) => {\n        const otherStartPos = getPosByDirection(poses, startDirection);\n        const otherEndPos = getPosByDirection(poses, endDirection);\n        const snapBoundInfo = keepRatio\n            ? checkSnapBoundsKeepRatio(\n                moveable,\n                otherStartPos,\n                otherEndPos,\n                isRequest\n            )\n            : checkMoveableSnapBounds(moveable, isRequest, {\n                vertical: [otherEndPos[0]],\n                horizontal: [otherEndPos[1]],\n            });\n\n        const {\n            horizontal: {\n                // dist: otherHorizontalDist,\n                offset: otherHorizontalOffset,\n                isBound: isOtherHorizontalBound,\n                isSnap: isOtherHorizontalSnap,\n            },\n            vertical: {\n                // dist: otherVerticalDist,\n                offset: otherVerticalOffset,\n                isBound: isOtherVerticalBound,\n                isSnap: isOtherVerticalSnap,\n            },\n        } = snapBoundInfo;\n\n        const multiple = minus(endDirection, startDirection);\n\n        if (!otherVerticalOffset && !otherHorizontalOffset) {\n            return {\n                isBound: isOtherVerticalBound || isOtherHorizontalBound,\n                isSnap: isOtherVerticalSnap || isOtherHorizontalSnap,\n                sign: multiple,\n                offset: [0, 0],\n            };\n        }\n        const snapLine = checkSnapRightLine(\n            otherStartPos,\n            otherEndPos,\n            snapBoundInfo,\n            keepRatio\n        );\n\n        if (!snapLine) {\n            return {\n                sign: multiple,\n                isBound: false,\n                isSnap: false,\n                offset: [0, 0],\n            };\n        }\n\n        const isVertical = snapLine === \"vertical\";\n        let sizeOffset = [0, 0];\n\n        if (\n            !keepRatio\n            && abs(endDirection[0]) === 1\n            && abs(endDirection[1]) === 1\n            && startDirection[0] !== endDirection[0]\n            && startDirection[1] !== endDirection[1]\n        ) {\n            sizeOffset = getDragDist({\n                datas,\n                distX: -otherVerticalOffset,\n                distY: -otherHorizontalOffset,\n            });\n        } else {\n            sizeOffset = solveNextOffset(\n                otherStartPos,\n                otherEndPos,\n                -(isVertical ? otherVerticalOffset : otherHorizontalOffset),\n                isVertical,\n                datas,\n            ).offset;\n        }\n        sizeOffset = sizeOffset.map((size, i) => size * (multiple[i] ? 2 / multiple[i] : 0));\n\n\n        return {\n            sign: multiple,\n            isBound: isVertical ? isOtherVerticalBound : isOtherHorizontalBound,\n            isSnap: isVertical ? isOtherVerticalSnap : isOtherHorizontalSnap,\n            offset: sizeOffset,\n        };\n    });\n}\n\n\nfunction getSnapBoundOffset(boundInfo: BoundInfo, snapInfo: SnapOffsetInfo) {\n    if (boundInfo.isBound) {\n        return boundInfo.offset;\n    } else if (snapInfo.isSnap) {\n        return snapInfo.offset;\n    }\n    return 0;\n}\n\nexport function checkSnapBoundsKeepRatio(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    startPos: number[],\n    endPos: number[],\n    isRequest: boolean\n): DirectionSnapType<SnapBoundInfo> {\n    const {\n        horizontal: horizontalBoundInfo,\n        vertical: verticalBoundInfo,\n    } = checkBoundKeepRatio(moveable, startPos, endPos);\n    const {\n        horizontal: horizontalSnapInfo,\n        vertical: verticalSnapInfo,\n    } = isRequest ? ({\n        horizontal: { isSnap: false },\n        vertical: { isSnap: false },\n    } as any) : checkSnapKeepRatio(moveable, startPos, endPos);\n\n    const horizontalOffset = getSnapBoundOffset(\n        horizontalBoundInfo,\n        horizontalSnapInfo\n    );\n    const verticalOffset = getSnapBoundOffset(\n        verticalBoundInfo,\n        verticalSnapInfo\n    );\n\n    const horizontalDist = abs(horizontalOffset);\n    const verticalDist = abs(verticalOffset);\n\n    return {\n        horizontal: {\n            isBound: horizontalBoundInfo.isBound,\n            isSnap: horizontalSnapInfo.isSnap,\n            offset: horizontalOffset,\n            dist: horizontalDist,\n        },\n        vertical: {\n            isBound: verticalBoundInfo.isBound,\n            isSnap: verticalSnapInfo.isSnap,\n            offset: verticalOffset,\n            dist: verticalDist,\n        },\n    };\n}\n\nexport function checkMaxBounds(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    poses: number[][],\n    direction: number[],\n    fixedPosition: number[],\n    datas: any\n) {\n    const fixedDirection = [-direction[0], -direction[1]];\n    const { width, height } = moveable.state;\n    const bounds = moveable.props.bounds;\n    let maxWidth = Infinity;\n    let maxHeight = Infinity;\n\n    if (bounds) {\n        const directions = [\n            [direction[0], -direction[1]],\n            [-direction[0], direction[1]],\n        ];\n        const {\n            left = -Infinity,\n            top = -Infinity,\n            right = Infinity,\n            bottom = Infinity,\n        } = bounds;\n\n        directions.forEach((otherDirection) => {\n            const isCheckVertical = otherDirection[0] !== fixedDirection[0];\n            const isCheckHorizontal = otherDirection[1] !== fixedDirection[1];\n            const otherPos = getPosByDirection(poses, otherDirection);\n            const deg = (getRad(fixedPosition, otherPos) * 360) / Math.PI;\n\n            if (isCheckHorizontal) {\n                const nextOtherPos = otherPos.slice();\n\n                if (abs(deg - 360) < 2 || abs(deg - 180) < 2) {\n                    nextOtherPos[1] = fixedPosition[1];\n                }\n                const {\n                    offset: [, heightOffset],\n                    isOutside: isHeightOutside,\n                } = solveNextOffset(\n                    fixedPosition,\n                    nextOtherPos,\n                    (fixedPosition[1] < otherPos[1] ? bottom : top) -\n                    otherPos[1],\n                    false,\n                    datas\n                );\n                if (!isNaN(heightOffset)) {\n                    maxHeight = height + (isHeightOutside ? 1 : -1) * abs(heightOffset);\n                }\n            }\n            if (isCheckVertical) {\n                const nextOtherPos = otherPos.slice();\n\n                if (abs(deg - 90) < 2 || abs(deg - 270) < 2) {\n                    nextOtherPos[0] = fixedPosition[0];\n                }\n                const {\n                    offset: [widthOffset],\n                    isOutside: isWidthOutside,\n                } = solveNextOffset(\n                    fixedPosition,\n                    nextOtherPos,\n                    (fixedPosition[0] < otherPos[0] ? right : left) - otherPos[0],\n                    true,\n                    datas\n                );\n                if (!isNaN(widthOffset)) {\n                    maxWidth = width + (isWidthOutside ? 1 : -1) * abs(widthOffset);\n                }\n            }\n        });\n    }\n    return {\n        maxWidth,\n        maxHeight,\n    };\n}\n", "import {\n    setDragStart, getBeforeDragDist, getTransformDist,\n    convertTransformFormat, resolveTransformEvent, fillTransformStartEvent,\n    setDefaultTransformIndex, fillOriginalTransform,\n} from \"../gesto/GestoUtils\";\nimport {\n    triggerEvent, fillParams,\n    getDistSize, prefix,\n    fillEndParams,\n    fillCSSObject,\n} from \"../utils\";\nimport { minus, plus } from \"@scena/matrix\";\nimport {\n    DraggableProps, OnDrag, OnDragGroup,\n    OnDragGroupStart, OnDragStart, OnDragEnd, DraggableState,\n    Renderer, OnDragGroupEnd, MoveableManagerInterface, MoveableGroupInterface,\n} from \"../types\";\nimport { triggerChildGesto } from \"../groupUtils\";\nimport { startCheckSnapDrag } from \"./Snappable\";\nimport { getRad, throttle, throttleArray } from \"@daybrush/utils\";\nimport { checkSnapBoundsDrag } from \"./snappable/snapBounds\";\nimport { TINY_NUM } from \"../consts\";\n\n/**\n * @namespace Draggable\n * @memberof Moveable\n * @description Draggable refers to the ability to drag and move targets.\n */\nexport default {\n    name: \"draggable\",\n    props: [\n        \"draggable\",\n        \"throttleDrag\",\n        \"throttleDragRotate\",\n        \"hideThrottleDragRotateLine\",\n        \"startDragRotate\",\n        \"edgeDraggable\",\n    ] as const,\n    events: [\n        \"dragStart\",\n        \"drag\",\n        \"dragEnd\",\n        \"dragGroupStart\",\n        \"dragGroup\",\n        \"dragGroupEnd\",\n    ] as const,\n    requestStyle(): string[] {\n        return [\"left\", \"top\", \"right\", \"bottom\"];\n    },\n    requestChildStyle(): string[] {\n        return [\"left\", \"top\", \"right\", \"bottom\"];\n    },\n    render(\n        moveable: MoveableManagerInterface<DraggableProps, DraggableState>,\n        React: Renderer,\n    ): any[] {\n        const { hideThrottleDragRotateLine, throttleDragRotate, zoom } = moveable.props;\n        const { dragInfo, beforeOrigin } = moveable.getState();\n\n        if (hideThrottleDragRotateLine || !throttleDragRotate || !dragInfo) {\n            return [];\n        }\n        const dist = dragInfo.dist;\n\n        if (!dist[0] && !dist[1]) {\n            return [];\n        }\n\n        const width = getDistSize(dist);\n        const rad = getRad(dist, [0, 0]);\n\n        return [<div className={prefix(\n            \"line\",\n            \"horizontal\",\n            \"dragline\",\n            \"dashed\",\n        )} key={`dragRotateGuideline`} style={{\n            width: `${width}px`,\n            transform: `translate(${beforeOrigin[0]}px, ${beforeOrigin[1]}px) rotate(${rad}rad) scaleY(${zoom})`,\n        }} />];\n    },\n    dragStart(\n        moveable: MoveableManagerInterface<DraggableProps, any>,\n        e: any,\n    ) {\n        const { datas, parentEvent, parentGesto } = e;\n        const state = moveable.state;\n        const {\n            gestos,\n            style,\n        } = state;\n\n        if (gestos.draggable) {\n            return false;\n        }\n        gestos.draggable = parentGesto || moveable.targetGesto;\n\n        datas.datas = {};\n        datas.left = parseFloat(style.left || \"\") || 0;\n        datas.top = parseFloat(style.top || \"\") || 0;\n        datas.bottom = parseFloat(style.bottom || \"\") || 0;\n        datas.right = parseFloat(style.right || \"\") || 0;\n        datas.startValue = [0, 0];\n\n        setDragStart(moveable, e);\n        setDefaultTransformIndex(moveable, e, \"translate\");\n        startCheckSnapDrag(moveable, datas);\n\n        datas.prevDist = [0, 0];\n        datas.prevBeforeDist = [0, 0];\n        datas.isDrag = false;\n        datas.deltaOffset = [0, 0];\n\n        const params = fillParams<OnDragStart>(moveable, e, {\n            set: (translate: number[]) => {\n                datas.startValue = translate;\n            },\n            ...fillTransformStartEvent(moveable, e),\n        });\n        const result = parentEvent || triggerEvent(moveable, \"onDragStart\", params);\n\n        if (result !== false) {\n            datas.isDrag = true;\n            moveable.state.dragInfo = {\n                startRect: moveable.getRect(),\n                dist: [0, 0],\n            };\n        } else {\n            gestos.draggable = null;\n            datas.isPinch = false;\n        }\n        return datas.isDrag ? params : false;\n    },\n    drag(\n        moveable: MoveableManagerInterface<DraggableProps, any>,\n        e: any,\n    ): OnDrag | undefined {\n        if (!e) {\n            return;\n        }\n        resolveTransformEvent(moveable, e, \"translate\");\n\n        const {\n            datas, parentEvent,\n            parentFlag, isPinch, deltaOffset,\n            useSnap,\n            isRequest,\n            isGroup,\n            parentThrottleDrag,\n        } = e;\n        let { distX, distY } = e;\n        const { isDrag, prevDist, prevBeforeDist, startValue } = datas;\n\n        if (!isDrag) {\n            return;\n        }\n\n        if (deltaOffset) {\n            distX += deltaOffset[0];\n            distY += deltaOffset[1];\n        }\n        const props = moveable.props;\n\n        const parentMoveable = props.parentMoveable;\n        const throttleDrag = isGroup ? 0 : (props.throttleDrag || parentThrottleDrag || 0);\n        const throttleDragRotate = parentEvent ? 0 : (props.throttleDragRotate || 0);\n\n        let dragRotateRad = 0;\n        let isVerticalSnap = false;\n        let isVerticalBound = false;\n        let isHorizontalSnap = false;\n        let isHorizontalBound = false;\n\n        if (!parentEvent && throttleDragRotate > 0 && (distX || distY)) {\n            const startDragRotate = props.startDragRotate || 0;\n            const deg\n                = throttle(startDragRotate + getRad([0, 0], [distX, distY]) * 180 / Math.PI, throttleDragRotate)\n                - startDragRotate;\n            const ry = distY * Math.abs(Math.cos((deg - 90) / 180 * Math.PI));\n            const rx = distX * Math.abs(Math.cos(deg / 180 * Math.PI));\n            const r = getDistSize([rx, ry]);\n            dragRotateRad = deg * Math.PI / 180;\n\n            distX = r * Math.cos(dragRotateRad);\n            distY = r * Math.sin(dragRotateRad);\n        }\n\n        if (!isPinch && !parentEvent && !parentFlag) {\n            const [verticalInfo, horizontalInfo] = checkSnapBoundsDrag(\n                moveable, distX, distY,\n                throttleDragRotate,\n                (!useSnap && isRequest) || deltaOffset,\n                datas,\n            );\n            isVerticalSnap = verticalInfo.isSnap;\n            isVerticalBound = verticalInfo.isBound;\n            isHorizontalSnap = horizontalInfo.isSnap;\n            isHorizontalBound = horizontalInfo.isBound;\n\n            const verticalOffset = verticalInfo.offset;\n            const horizontalOffset = horizontalInfo.offset;\n\n            distX += verticalOffset;\n            distY += horizontalOffset;\n        }\n\n        const beforeTranslate = plus(getBeforeDragDist({ datas, distX, distY }), startValue);\n        const translate = plus(getTransformDist({ datas, distX, distY }), startValue);\n\n        throttleArray(translate, TINY_NUM);\n        throttleArray(beforeTranslate, TINY_NUM);\n\n        if (!throttleDragRotate) {\n            if (!isVerticalSnap && !isVerticalBound) {\n                translate[0] = throttle(translate[0], throttleDrag);\n                beforeTranslate[0] = throttle(beforeTranslate[0], throttleDrag);\n            }\n            if (!isHorizontalSnap && !isHorizontalBound) {\n                translate[1] = throttle(translate[1], throttleDrag);\n                beforeTranslate[1] = throttle(beforeTranslate[1], throttleDrag);\n            }\n        }\n\n\n        const beforeDist = minus(beforeTranslate, startValue);\n        const dist = minus(translate, startValue);\n        const delta = minus(dist, prevDist);\n        const beforeDelta = minus(beforeDist, prevBeforeDist);\n\n        datas.prevDist = dist;\n        datas.prevBeforeDist = beforeDist;\n\n\n        datas.passDelta = delta; //distX - (datas.passDistX || 0);\n        // datas.passDeltaY = distY - (datas.passDistY || 0);\n        datas.passDist = dist; //distX;\n        // datas.passDistY = distY;\n\n        const left = datas.left + beforeDist[0];\n        const top = datas.top + beforeDist[1];\n        const right = datas.right - beforeDist[0];\n        const bottom = datas.bottom - beforeDist[1];\n        const nextTransform = convertTransformFormat(datas,\n            `translate(${translate[0]}px, ${translate[1]}px)`, `translate(${dist[0]}px, ${dist[1]}px)`);\n\n        fillOriginalTransform(e, nextTransform);\n\n        moveable.state.dragInfo.dist = parentEvent ? [0, 0] : dist;\n        if (!parentEvent && !parentMoveable && delta.every(num => !num) && beforeDelta.some(num => !num)) {\n            return;\n        }\n\n        const {\n            width,\n            height,\n        } = moveable.state;\n        const params = fillParams<OnDrag>(moveable, e, {\n            transform: nextTransform,\n            dist,\n            delta,\n            translate,\n            beforeDist,\n            beforeDelta,\n            beforeTranslate,\n            left,\n            top,\n            right,\n            bottom,\n            width,\n            height,\n            isPinch,\n            ...fillCSSObject({\n                transform: nextTransform,\n            }, e),\n        });\n\n        !parentEvent && triggerEvent(moveable, \"onDrag\", params);\n        return params;\n    },\n    dragAfter(\n        moveable: MoveableManagerInterface<DraggableProps, DraggableState>,\n        e: any,\n    ) {\n        const datas = e.datas;\n        const {\n            deltaOffset,\n        } = datas;\n\n        if (deltaOffset[0] || deltaOffset[1]) {\n            datas.deltaOffset = [0, 0];\n            return this.drag(moveable, {...e, deltaOffset });\n        }\n        return false;\n    },\n    dragEnd(\n        moveable: MoveableManagerInterface<DraggableProps, DraggableState>,\n        e: any,\n    ) {\n        const { parentEvent, datas } = e;\n\n        moveable.state.dragInfo = null;\n        if (!datas.isDrag) {\n            return;\n        }\n        datas.isDrag = false;\n        const param = fillEndParams<OnDragEnd>(moveable, e, {});\n        !parentEvent && triggerEvent(moveable, \"onDragEnd\", param);\n        return param;\n    },\n    dragGroupStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas, clientX, clientY } = e;\n\n        const params = this.dragStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const {\n            childEvents,\n            eventParams,\n        } = triggerChildGesto(moveable, this, \"dragStart\", [\n            clientX || 0,\n            clientY || 0,\n        ], e, false, \"draggable\");\n\n        const nextParams: OnDragGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events: eventParams,\n        };\n        const result = triggerEvent(moveable, \"onDragGroupStart\", nextParams);\n\n        datas.isDrag = result !== false;\n\n\n        // find data.startValue and based on first child moveable\n        const startValue = childEvents[0]?.datas.startValue ?? [0, 0];\n\n\n        datas.throttleOffset = [startValue[0] % 1, startValue[1] % 1];\n\n        return datas.isDrag ? params : false;\n    },\n    dragGroup(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n\n        if (!datas.isDrag) {\n            return;\n        }\n        const params = this.drag(moveable, {\n            ...e,\n            parentThrottleDrag: moveable.props.throttleDrag,\n        });\n        const { passDelta } = e.datas;\n        const {\n            eventParams,\n        } = triggerChildGesto(moveable, this, \"drag\", passDelta, e, false, \"draggable\");\n\n        if (!params) {\n            return;\n        }\n\n        const nextParams: OnDragGroup = {\n            targets: moveable.props.targets!,\n            events: eventParams,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onDragGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isDrag) {\n            return;\n        }\n        this.dragEnd(moveable, e);\n        const {\n            eventParams,\n        } = triggerChildGesto(moveable, this, \"dragEnd\", [0, 0], e, false, \"draggable\");\n        triggerEvent(moveable, \"onDragGroupEnd\", fillEndParams<OnDragGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n            events: eventParams,\n        }));\n\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Draggable#request\n     * @param {object} [e] - the draggable's request parameter\n     * @param {number} [e.x] - x position\n     * @param {number} [e.y] - y position\n     * @param {number} [e.deltaX] - X number to move\n     * @param {number} [e.deltaY] - Y number to move\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * // Use Relative Value\n     * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10 }, true);\n     * // Use Absolute Value\n     * moveable.request(\"draggable\", { x: 200, y: 100 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"draggable\");\n     *\n     * // request\n     * // Use Relative Value\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * // Use Absolute Value\n     * moveable.request(\"draggable\", { x: 200, y: 100 });\n     * moveable.request(\"draggable\", { x: 220, y: 100 });\n     * moveable.request(\"draggable\", { x: 240, y: 100 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request(moveable: MoveableManagerInterface<any, any>) {\n        const datas = {};\n        const rect = moveable.getRect();\n        let distX = 0;\n        let distY = 0;\n        let useSnap = false;\n\n        return {\n            isControl: false,\n            requestStart(e: Record<string, any>) {\n                useSnap = e.useSnap;\n                return { datas, useSnap };\n            },\n            request(e: Record<string, any>) {\n                if (\"x\" in e) {\n                    distX = e.x - rect.left;\n                } else if (\"deltaX\" in e) {\n                    distX += e.deltaX;\n                }\n                if (\"y\" in e) {\n                    distY = e.y - rect.top;\n                } else if (\"deltaY\" in e) {\n                    distY += e.deltaY;\n                }\n\n                return { datas, distX, distY, useSnap };\n            },\n            requestEnd() {\n                return { datas, isDrag: true, useSnap };\n            },\n        };\n    },\n    unset(moveable: MoveableManagerInterface<any, Record<string, any>>) {\n        moveable.state.gestos.draggable = null;\n        moveable.state.dragInfo = null;\n    },\n};\n\n/**\n * Whether or not target can be dragged. (default: false)\n * @name Moveable.Draggable#draggable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.draggable = true;\n */\n\n/**\n * throttle of x, y when drag.\n * @name Moveable.Draggable#throttleDrag\n * @default 0\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleDrag = 1;\n */\n\n/**\n* throttle of angle of x, y when drag.\n* @name Moveable.Draggable#throttleDragRotate\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body);\n*\n* moveable.throttleDragRotate = 45;\n*/\n\n/**\n* start angle of throttleDragRotate of x, y when drag.\n* @name Moveable.Draggable#startDragRotate\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body);\n*\n* // 45, 135, 225, 315\n* moveable.throttleDragRotate = 90;\n* moveable.startDragRotate = 45;\n*/\n\n/**\n * When the drag starts, the dragStart event is called.\n * @memberof Moveable.Draggable\n * @event dragStart\n * @param {Moveable.Draggable.OnDragStart} - Parameters for the dragStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"dragStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When dragging, the drag event is called.\n * @memberof Moveable.Draggable\n * @event drag\n * @param {Moveable.Draggable.OnDrag} - Parameters for the drag event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"drag\", ({ target, transform }) => {\n *     target.style.transform = transform;\n * });\n */\n/**\n * When the drag finishes, the dragEnd event is called.\n * @memberof Moveable.Draggable\n * @event dragEnd\n * @param {Moveable.Draggable.OnDragEnd} - Parameters for the dragEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"dragEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n* When the group drag starts, the `dragGroupStart` event is called.\n* @memberof Moveable.Draggable\n* @event dragGroupStart\n* @param {Moveable.Draggable.OnDragGroupStart} - Parameters for the `dragGroupStart` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     draggable: true\n* });\n* moveable.on(\"dragGroupStart\", ({ targets }) => {\n*     console.log(\"onDragGroupStart\", targets);\n* });\n*/\n\n/**\n* When the group drag, the `dragGroup` event is called.\n* @memberof Moveable.Draggable\n* @event dragGroup\n* @param {Moveable.Draggable.OnDragGroup} - Parameters for the `dragGroup` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     draggable: true\n* });\n* moveable.on(\"dragGroup\", ({ targets, events }) => {\n*     console.log(\"onDragGroup\", targets);\n*     events.forEach(ev => {\n*          // drag event\n*          console.log(\"onDrag left, top\", ev.left, ev.top);\n*          // ev.target!.style.left = `${ev.left}px`;\n*          // ev.target!.style.top = `${ev.top}px`;\n*          console.log(\"onDrag translate\", ev.dist);\n*          ev.target!.style.transform = ev.transform;)\n*     });\n* });\n*/\n\n/**\n * When the group drag finishes, the `dragGroupEnd` event is called.\n * @memberof Moveable.Draggable\n * @event dragGroupEnd\n * @param {Moveable.Draggable.OnDragGroupEnd} - Parameters for the `dragGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     draggable: true\n * });\n * moveable.on(\"dragGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onDragGroupEnd\", targets, isDrag);\n * });\n */\n", "import { calculatePosition } from \"../utils\";\nimport { getDirectionByPos, getPosByDirection } from \"../gesto/GestoUtils\";\n\n\nexport function getFixedDirectionInfo(\n    startPositions: number[][],\n    fixedDirection: number[],\n) {\n    const fixedPosition = getPosByDirection(startPositions, fixedDirection);\n    const fixedOffset = [0, 0];\n\n    return {\n        fixedPosition,\n        fixedDirection,\n        fixedOffset,\n    };\n}\n\nexport function getOffsetFixedDirectionInfo(\n    state: {\n        allMatrix: number[];\n        is3d: boolean;\n        width: number;\n        height: number;\n    },\n    fixedDirection: number[],\n) {\n    // for start\n    const {\n        allMatrix,\n        is3d,\n        width,\n        height,\n    } = state;\n    const n = is3d ? 4 : 3;\n    const nextFixedOffset = [\n        width / 2 * (1 + fixedDirection[0]),\n        height / 2 * (1 + fixedDirection[1]),\n    ];\n    const fixedPosition = calculatePosition(allMatrix, nextFixedOffset, n);\n    const fixedOffset = [0, 0];\n\n    return {\n        fixedPosition,\n        fixedDirection,\n        fixedOffset,\n    };\n}\n\n\nexport function getOffsetFixedPositionInfo(\n    state: {\n        allMatrix: number[];\n        is3d: boolean;\n        width: number;\n        height: number;\n    },\n    offsetFixedPosition: number[],\n) {\n    // for start\n    const {\n        allMatrix,\n        is3d,\n        width,\n        height,\n    } = state;\n    const n = is3d ? 4 : 3;\n    const fixedDirection = getDirectionByPos(offsetFixedPosition, width, height);\n    const nextFixedPosition = calculatePosition(allMatrix, offsetFixedPosition, n);\n    const fixedOffset = [\n        width ? 0 : offsetFixedPosition[0],\n        height ? 0 : offsetFixedPosition[1],\n    ];\n\n    return {\n        fixedPosition: nextFixedPosition,\n        fixedDirection,\n        fixedOffset,\n    };\n}\n", "import {\n  triggerEvent,\n  fillParams,\n  fillEndParams,\n  getAbsolutePosesByState,\n  catchEvent,\n  getOffsetSizeDist,\n  getProps,\n  getDirectionCondition,\n  calculatePoses,\n  fillAfterTransform,\n  getDirectionViewClassName,\n  getTotalDirection,\n  abs,\n} from '../utils';\nimport {\n  setDragStart,\n  getResizeDist,\n  getAbsolutePosition,\n  getNextMatrix,\n  getNextTransforms,\n} from '../gesto/GestoUtils';\nimport {\n  ResizableProps,\n  OnResizeGroup,\n  OnResizeGroupEnd,\n  OnResizeGroupStart,\n  DraggableProps,\n  OnDrag,\n  OnResizeStart,\n  SnappableState,\n  OnResize,\n  OnResizeEnd,\n  MoveableManagerInterface,\n  MoveableGroupInterface,\n  SnappableProps,\n  OnBeforeResize,\n  OnBeforeResizeGroup,\n  ResizableRequestParam,\n} from '../types';\nimport { getRenderDirections } from '../render-directions';\nimport {\n  fillChildEvents,\n  startChildDist,\n  triggerChildAbles,\n} from '../groupUtils';\nimport Draggable from './Draggable';\nimport {\n  calculate,\n  convertDimension,\n  createRotateMatrix,\n  plus,\n} from '@scena/matrix';\nimport CustomGesto, { setCustomDrag } from '../gesto/CustomGesto';\nimport { checkSnapResize } from './Snappable';\nimport {\n  calculateBoundSize,\n  isString,\n  convertUnitSize,\n  throttle,\n  isNumber,\n} from '@daybrush/utils';\nimport { TINY_NUM } from '../consts';\nimport { parseMat } from 'css-to-mat';\nimport {\n  getFixedDirectionInfo,\n  getOffsetFixedPositionInfo,\n} from '../utils/getFixedDirection';\n\n/**\n * @namespace Resizable\n * @memberof Moveable\n * @description Resizable indicates whether the target's width and height can be increased or decreased.\n */\n\nconst directionCondition = getDirectionCondition('resizable');\n\nexport default {\n  name: 'resizable',\n  ableGroup: 'size',\n  canPinch: true,\n  props: [\n    'resizable',\n    'throttleResize',\n    'renderDirections',\n    'displayAroundControls',\n    'keepRatio',\n    'resizeFormat',\n    'keepRatioFinally',\n    'edge',\n    'checkResizableError',\n  ] as const,\n  events: [\n    'resizeStart',\n    'beforeResize',\n    'resize',\n    'resizeEnd',\n    'resizeGroupStart',\n    'beforeResizeGroup',\n    'resizeGroup',\n    'resizeGroupEnd',\n  ] as const,\n  render: getRenderDirections('resizable'),\n  dragControlCondition: directionCondition,\n  viewClassName: getDirectionViewClassName('resizable'),\n  dragControlStart(\n    moveable: MoveableManagerInterface<\n      ResizableProps & DraggableProps,\n      SnappableState\n    >,\n    e: any,\n  ) {\n    const {\n      inputEvent,\n      isPinch,\n      isGroup,\n      parentDirection,\n      parentGesto,\n      datas,\n      parentFixedDirection,\n      parentEvent,\n    } = e;\n\n    const direction = getTotalDirection(\n      parentDirection,\n      isPinch,\n      inputEvent,\n      datas,\n    );\n\n    const state = moveable.state;\n    const { target, width, height, gestos } = state;\n\n    if (!direction || !target) {\n      return false;\n    }\n    if (gestos.resizable) {\n      return false;\n    }\n    gestos.resizable = parentGesto || moveable.controlGesto;\n    !isPinch && setDragStart(moveable, e);\n\n    datas.datas = {};\n    datas.direction = direction;\n    datas.startOffsetWidth = width;\n    datas.startOffsetHeight = height;\n    datas.prevWidth = 0;\n    datas.prevHeight = 0;\n\n    datas.minSize = [0, 0];\n\n    datas.startWidth = state.inlineCSSWidth || state.cssWidth;\n    datas.startHeight = state.inlineCSSHeight || state.cssHeight;\n    datas.maxSize = [Infinity, Infinity];\n\n    if (!isGroup) {\n      datas.minSize = [state.minOffsetWidth, state.minOffsetHeight];\n      datas.maxSize = [state.maxOffsetWidth, state.maxOffsetHeight];\n    }\n    const transformOrigin = moveable.props.transformOrigin || '% %';\n\n    datas.transformOrigin =\n      transformOrigin && isString(transformOrigin)\n        ? transformOrigin.split(' ')\n        : transformOrigin;\n\n    datas.startOffsetMatrix = state.offsetMatrix;\n    datas.startTransformOrigin = state.transformOrigin;\n\n    datas.isWidth =\n      e?.parentIsWidth ??\n      ((!direction[0] && !direction[1]) || direction[0] || !direction[1]);\n\n    function setRatio(ratio: number) {\n      datas.ratio = ratio && isFinite(ratio) ? ratio : 0;\n    }\n\n    datas.startPositions = getAbsolutePosesByState(moveable.state);\n\n    function setFixedDirection(fixedDirection: number[]) {\n      const result = getFixedDirectionInfo(\n        datas.startPositions,\n        fixedDirection,\n      );\n\n      datas.fixedDirection = result.fixedDirection;\n      datas.fixedPosition = result.fixedPosition;\n      datas.fixedOffset = result.fixedOffset;\n    }\n    function setFixedPosition(fixedPosition: number[]) {\n      const result = getOffsetFixedPositionInfo(moveable.state, fixedPosition);\n\n      datas.fixedDirection = result.fixedDirection;\n      datas.fixedPosition = result.fixedPosition;\n      datas.fixedOffset = result.fixedOffset;\n    }\n    function setMin(minSize: Array<string | number>) {\n      datas.minSize = [\n        convertUnitSize(`${minSize[0]}`, 0) || 0,\n        convertUnitSize(`${minSize[1]}`, 0) || 0,\n      ];\n    }\n    function setMax(maxSize: Array<string | number>) {\n      const nextMaxSize = [maxSize[0] || Infinity, maxSize[1] || Infinity];\n      if (!isNumber(nextMaxSize[0]) || isFinite(nextMaxSize[0])) {\n        nextMaxSize[0] = convertUnitSize(`${nextMaxSize[0]}`, 0) || Infinity;\n      }\n      if (!isNumber(nextMaxSize[1]) || isFinite(nextMaxSize[1])) {\n        nextMaxSize[1] = convertUnitSize(`${nextMaxSize[1]}`, 0) || Infinity;\n      }\n      datas.maxSize = nextMaxSize;\n    }\n\n    setRatio(width / height);\n    setFixedDirection(parentFixedDirection || [-direction[0], -direction[1]]);\n\n    datas.setFixedDirection = setFixedDirection;\n    datas.setFixedPosition = setFixedPosition;\n    datas.setMin = setMin;\n    datas.setMax = setMax;\n    const params = fillParams<OnResizeStart>(moveable, e, {\n      direction,\n      startRatio: datas.ratio,\n      set: ([startWidth, startHeight]: number[]) => {\n        datas.startWidth = startWidth;\n        datas.startHeight = startHeight;\n      },\n      setMin,\n      setMax,\n      setRatio,\n      setFixedDirection,\n      setFixedPosition,\n      setOrigin: (origin: Array<string | number>) => {\n        datas.transformOrigin = origin;\n      },\n      dragStart: Draggable.dragStart(\n        moveable,\n        new CustomGesto().dragStart([0, 0], e),\n      ),\n    });\n    const result =\n      parentEvent || triggerEvent(moveable, 'onResizeStart', params);\n\n    datas.startFixedDirection = datas.fixedDirection;\n    datas.startFixedPosition = datas.fixedPosition;\n    if (result !== false) {\n      datas.isResize = true;\n      moveable.state.snapRenderInfo = {\n        request: e.isRequest,\n        direction,\n      };\n    }\n    return datas.isResize ? params : false;\n  },\n  dragControl(\n    moveable: MoveableManagerInterface<\n      ResizableProps & DraggableProps & SnappableProps\n    >,\n    e: any,\n  ) {\n    const {\n      datas,\n      parentFlag,\n      isPinch,\n      parentKeepRatio,\n      dragClient,\n      parentDist,\n      useSnap,\n      isRequest,\n      isGroup,\n      parentEvent,\n      resolveMatrix,\n    } = e;\n\n    const {\n      isResize,\n      transformOrigin,\n      startWidth,\n      startHeight,\n      prevWidth,\n      prevHeight,\n      minSize,\n      maxSize,\n      ratio,\n      startOffsetWidth,\n      startOffsetHeight,\n      isWidth,\n    } = datas;\n\n    if (!isResize) {\n      return;\n    }\n    if (resolveMatrix) {\n      const { is3d } = moveable.state;\n      const { startOffsetMatrix, startTransformOrigin } = datas;\n      const n = is3d ? 4 : 3;\n      let targetMatrix = parseMat(getNextTransforms(e));\n      const targetN = Math.sqrt(targetMatrix.length);\n\n      if (n !== targetN) {\n        targetMatrix = convertDimension(targetMatrix, targetN, n);\n      }\n\n      const nextAllMatrix = getNextMatrix(\n        startOffsetMatrix,\n        targetMatrix,\n        startTransformOrigin,\n        n,\n      );\n      const poses = calculatePoses(\n        nextAllMatrix,\n        startOffsetWidth,\n        startOffsetHeight,\n        n,\n      );\n\n      datas.startPositions = poses;\n      datas.nextTargetMatrix = targetMatrix;\n      datas.nextAllMatrix = nextAllMatrix;\n    }\n    const props = getProps(moveable.props, 'resizable');\n    const {\n      resizeFormat,\n      throttleResize = parentFlag ? 0 : 1,\n      parentMoveable,\n      keepRatioFinally,\n    } = props;\n    const direction = datas.direction;\n    let sizeDirection = direction;\n    let distWidth = 0;\n    let distHeight = 0;\n\n    if (!direction[0] && !direction[1]) {\n      sizeDirection = [1, 1];\n    }\n    const keepRatio =\n      (ratio &&\n        (parentKeepRatio != null ? parentKeepRatio : props.keepRatio)) ||\n      false;\n\n    function getNextBoundingSize() {\n      const fixedDirection = datas.fixedDirection;\n      const nextSize = getOffsetSizeDist(sizeDirection, keepRatio, datas, e);\n\n      distWidth = nextSize.distWidth;\n      distHeight = nextSize.distHeight;\n\n      let nextWidth =\n        sizeDirection[0] - fixedDirection[0] || keepRatio\n          ? Math.max(startOffsetWidth + distWidth, TINY_NUM)\n          : startOffsetWidth;\n      let nextHeight =\n        sizeDirection[1] - fixedDirection[1] || keepRatio\n          ? Math.max(startOffsetHeight + distHeight, TINY_NUM)\n          : startOffsetHeight;\n\n      if (keepRatio && startOffsetWidth && startOffsetHeight) {\n        // startOffsetWidth : startOffsetHeight = nextWidth : nextHeight\n        if (isWidth) {\n          nextHeight = nextWidth / ratio;\n        } else {\n          nextWidth = nextHeight * ratio;\n        }\n      }\n      return [nextWidth, nextHeight];\n    }\n\n    let [boundingWidth, boundingHeight] = getNextBoundingSize();\n\n    if (!parentEvent) {\n      datas.setFixedDirection(datas.fixedDirection);\n\n      triggerEvent(\n        moveable,\n        'onBeforeResize',\n        fillParams<OnBeforeResize>(\n          moveable,\n          e,\n          {\n            startFixedDirection: datas.startFixedDirection,\n            startFixedPosition: datas.startFixedPosition,\n            setFixedDirection(nextFixedDirection: number[]) {\n              datas.setFixedDirection(nextFixedDirection);\n\n              [boundingWidth, boundingHeight] = getNextBoundingSize();\n\n              return [boundingWidth, boundingHeight];\n            },\n            setFixedPosition(nextFixedPosition: number[]) {\n              datas.setFixedPosition(nextFixedPosition);\n\n              [boundingWidth, boundingHeight] = getNextBoundingSize();\n\n              return [boundingWidth, boundingHeight];\n            },\n            boundingWidth,\n            boundingHeight,\n            setSize(size: number[]) {\n              [boundingWidth, boundingHeight] = size;\n            },\n          },\n          true,\n        ),\n      );\n    }\n\n    let fixedPosition = dragClient;\n\n    if (!dragClient) {\n      if (!parentFlag && isPinch) {\n        fixedPosition = getAbsolutePosition(moveable, [0, 0]);\n      } else {\n        fixedPosition = datas.fixedPosition;\n      }\n    }\n\n    let snapDist = [0, 0];\n\n    if (!isPinch) {\n      snapDist = checkSnapResize(\n        moveable,\n        boundingWidth,\n        boundingHeight,\n        direction,\n        fixedPosition,\n        !useSnap && isRequest,\n        datas,\n      );\n    }\n    if (parentDist) {\n      !parentDist[0] && (snapDist[0] = 0);\n      !parentDist[1] && (snapDist[1] = 0);\n    }\n\n    function computeSize() {\n      if (resizeFormat) {\n        [boundingWidth, boundingHeight] = resizeFormat([\n          boundingWidth,\n          boundingHeight,\n        ]);\n      }\n      boundingWidth = throttle(boundingWidth, throttleResize!);\n      boundingHeight = throttle(boundingHeight, throttleResize!);\n    }\n    if (keepRatio) {\n      if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {\n        if (abs(snapDist[0]) > abs(snapDist[1])) {\n          snapDist[1] = 0;\n        } else {\n          snapDist[0] = 0;\n        }\n      }\n      const isNoSnap = !snapDist[0] && !snapDist[1];\n\n      if (isNoSnap) {\n        // pre-compute before maintaining the ratio\n        computeSize();\n      }\n      if (\n        (sizeDirection[0] && !sizeDirection[1]) ||\n        (snapDist[0] && !snapDist[1]) ||\n        (isNoSnap && isWidth)\n      ) {\n        boundingWidth += snapDist[0];\n        boundingHeight = boundingWidth / ratio;\n      } else if (\n        (!sizeDirection[0] && sizeDirection[1]) ||\n        (!snapDist[0] && snapDist[1]) ||\n        (isNoSnap && !isWidth)\n      ) {\n        boundingHeight += snapDist[1];\n        boundingWidth = boundingHeight * ratio;\n      }\n    } else {\n      boundingWidth += snapDist[0];\n      boundingHeight += snapDist[1];\n\n      boundingWidth = Math.max(0, boundingWidth);\n      boundingHeight = Math.max(0, boundingHeight);\n    }\n\n    [boundingWidth, boundingHeight] = calculateBoundSize(\n      [boundingWidth, boundingHeight],\n      minSize,\n      maxSize,\n      keepRatio ? ratio : false,\n    );\n    computeSize();\n\n    if (keepRatio && (isGroup || keepRatioFinally)) {\n      if (isWidth) {\n        boundingHeight = boundingWidth / ratio;\n      } else {\n        boundingWidth = boundingHeight * ratio;\n      }\n    }\n    distWidth = boundingWidth - startOffsetWidth;\n    distHeight = boundingHeight - startOffsetHeight;\n\n    const delta = [distWidth - prevWidth, distHeight - prevHeight];\n\n    datas.prevWidth = distWidth;\n    datas.prevHeight = distHeight;\n\n    const inverseDelta = getResizeDist(\n      moveable,\n      boundingWidth,\n      boundingHeight,\n      fixedPosition,\n      transformOrigin,\n      datas,\n    );\n\n    if (\n      !parentMoveable &&\n      delta.every((num) => !num) &&\n      inverseDelta.every((num) => !num)\n    ) {\n      return;\n    }\n    const drag = Draggable.drag(\n      moveable,\n      setCustomDrag(\n        e,\n        moveable.state,\n        inverseDelta,\n        !!isPinch,\n        false,\n        'draggable',\n      ),\n    ) as OnDrag;\n    const transform = drag.transform;\n\n    const nextWidth = startWidth + distWidth;\n    const nextHeight = startHeight + distHeight;\n\n    const params = fillParams<OnResize>(moveable, e, {\n      width: nextWidth,\n      height: nextHeight,\n      offsetWidth: Math.round(boundingWidth),\n      offsetHeight: Math.round(boundingHeight),\n      startRatio: ratio,\n      boundingWidth,\n      boundingHeight,\n      direction,\n      dist: [distWidth, distHeight],\n      delta,\n      isPinch: !!isPinch,\n      drag,\n      ...fillAfterTransform(\n        {\n          style: {\n            width: `${nextWidth}px`,\n            height: `${nextHeight}px`,\n          },\n          transform,\n        },\n        drag,\n        e,\n      ),\n    });\n    !parentEvent && triggerEvent(moveable, 'onResize', params);\n    return params;\n  },\n  dragControlAfter(\n    moveable: MoveableManagerInterface<ResizableProps & DraggableProps>,\n    e: any,\n  ) {\n    const datas = e.datas;\n    const {\n      isResize,\n      startOffsetWidth,\n      startOffsetHeight,\n      prevWidth,\n      prevHeight,\n    } = datas;\n\n    if (!isResize || moveable.props.checkResizableError === false) {\n      return;\n    }\n    const { width, height } = moveable.state;\n    const errorWidth = width - (startOffsetWidth + prevWidth);\n    const errorHeight = height - (startOffsetHeight + prevHeight);\n    const isErrorWidth = abs(errorWidth) > 3;\n    const isErrorHeight = abs(errorHeight) > 3;\n\n    if (isErrorWidth) {\n      datas.startWidth += errorWidth;\n      datas.startOffsetWidth += errorWidth;\n      datas.prevWidth += errorWidth;\n    }\n    if (isErrorHeight) {\n      datas.startHeight += errorHeight;\n      datas.startOffsetHeight += errorHeight;\n      datas.prevHeight += errorHeight;\n    }\n    if (isErrorWidth || isErrorHeight) {\n      return this.dragControl(moveable, e);\n    }\n  },\n  dragControlEnd(\n    moveable: MoveableManagerInterface<ResizableProps & DraggableProps>,\n    e: any,\n  ) {\n    const { datas, parentEvent } = e;\n    if (!datas.isResize) {\n      return;\n    }\n    datas.isResize = false;\n\n    const params = fillEndParams<OnResizeEnd>(moveable, e, {});\n    !parentEvent && triggerEvent(moveable, 'onResizeEnd', params);\n    return params;\n  },\n  dragGroupControlCondition: directionCondition,\n  dragGroupControlStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n    const { datas } = e;\n    const params = this.dragControlStart(moveable, { ...e, isGroup: true });\n\n    if (!params) {\n      return false;\n    }\n    const originalEvents = fillChildEvents(moveable, 'resizable', e);\n    const {\n      startOffsetWidth: parentStartOffsetWidth,\n      startOffsetHeight: parentStartOffsetHeight,\n    } = datas;\n\n    function updateGroupMin() {\n      const originalMinSize = datas.minSize;\n      originalEvents.forEach((ev) => {\n        const {\n          minSize: childMinSize,\n          startOffsetWidth: childStartOffsetWidth,\n          startOffsetHeight: childStartOffsetHeight,\n        } = ev.datas;\n\n        const parentMinWidth =\n          parentStartOffsetWidth *\n          (childStartOffsetWidth ? childMinSize[0] / childStartOffsetWidth : 0);\n        const parentMinHeight =\n          parentStartOffsetHeight *\n          (childStartOffsetHeight\n            ? childMinSize[1] / childStartOffsetHeight\n            : 0);\n\n        originalMinSize[0] = Math.max(originalMinSize[0], parentMinWidth);\n        originalMinSize[1] = Math.max(originalMinSize[1], parentMinHeight);\n      });\n    }\n\n    function updateGroupMax() {\n      const originalMaxSize = datas.maxSize;\n      originalEvents.forEach((ev) => {\n        const {\n          maxSize: childMaxSize,\n          startOffsetWidth: childStartOffsetWidth,\n          startOffsetHeight: childStartOffsetHeight,\n        } = ev.datas;\n\n        const parentMaxWidth =\n          parentStartOffsetWidth *\n          (childStartOffsetWidth ? childMaxSize[0] / childStartOffsetWidth : 0);\n        const parentMaxHeight =\n          parentStartOffsetHeight *\n          (childStartOffsetHeight\n            ? childMaxSize[1] / childStartOffsetHeight\n            : 0);\n\n        originalMaxSize[0] = Math.min(originalMaxSize[0], parentMaxWidth);\n        originalMaxSize[1] = Math.min(originalMaxSize[1], parentMaxHeight);\n      });\n    }\n    const events = triggerChildAbles(\n      moveable,\n      this,\n      'dragControlStart',\n      e,\n      (child, ev) => {\n        return startChildDist(moveable, child, datas, ev);\n      },\n    );\n\n    updateGroupMin();\n    updateGroupMax();\n\n    const setFixedDirection = (fixedDirection: number[]) => {\n      params.setFixedDirection(fixedDirection);\n      events.forEach((ev, i) => {\n        ev.setFixedDirection(fixedDirection);\n        startChildDist(moveable, ev.moveable, datas, originalEvents[i]);\n      });\n    };\n\n    datas.setFixedDirection = setFixedDirection;\n\n    const nextParams: OnResizeGroupStart = {\n      ...params,\n      targets: moveable.props.targets!,\n      events: events.map((ev) => {\n        return {\n          ...ev,\n          setMin: (minSize: Array<number | string>) => {\n            ev.setMin(minSize);\n            updateGroupMin();\n          },\n          setMax: (maxSize: Array<number | string>) => {\n            ev.setMax(maxSize);\n            updateGroupMax();\n          },\n        };\n      }),\n      setFixedDirection,\n      setMin: (minSize: Array<number | string>) => {\n        params.setMin(minSize);\n        updateGroupMin();\n      },\n      setMax: (maxSize: Array<number | string>) => {\n        params.setMax(maxSize);\n        updateGroupMax();\n      },\n    };\n    const result = triggerEvent(moveable, 'onResizeGroupStart', nextParams);\n\n    datas.isResize = result !== false;\n    return datas.isResize ? params : false;\n  },\n  dragGroupControl(moveable: MoveableGroupInterface<any, any>, e: any) {\n    const { datas } = e;\n    if (!datas.isResize) {\n      return;\n    }\n    const props = getProps(moveable.props, 'resizable');\n\n    catchEvent(moveable, 'onBeforeResize', (parentEvent) => {\n      triggerEvent(\n        moveable,\n        'onBeforeResizeGroup',\n        fillParams<OnBeforeResizeGroup>(\n          moveable,\n          e,\n          {\n            ...parentEvent,\n            targets: props.targets!,\n          },\n          true,\n        ),\n      );\n    });\n\n    const params = this.dragControl(moveable, { ...e, isGroup: true });\n\n    if (!params) {\n      return;\n    }\n    const { boundingWidth, boundingHeight, dist } = params;\n\n    const keepRatio = props.keepRatio;\n\n    const parentScale = [\n      boundingWidth / (boundingWidth - dist[0]),\n      boundingHeight / (boundingHeight - dist[1]),\n    ];\n    const fixedPosition = datas.fixedPosition;\n\n    const events = triggerChildAbles(\n      moveable,\n      this,\n      'dragControl',\n      e,\n      (_, ev) => {\n        const [clientX, clientY] = calculate(\n          createRotateMatrix((moveable.rotation / 180) * Math.PI, 3),\n          [\n            ev.datas.originalX * parentScale[0],\n            ev.datas.originalY * parentScale[1],\n            1,\n          ],\n          3,\n        );\n\n        return {\n          ...ev,\n          parentDist: null,\n          parentScale,\n          dragClient: plus(fixedPosition, [clientX, clientY]),\n          parentKeepRatio: keepRatio,\n        };\n      },\n    );\n    const nextParams: OnResizeGroup = {\n      targets: props.targets!,\n      events,\n      ...params,\n    };\n\n    triggerEvent(moveable, 'onResizeGroup', nextParams);\n    return nextParams;\n  },\n  dragGroupControlEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n    const { isDrag, datas } = e;\n\n    if (!datas.isResize) {\n      return;\n    }\n\n    this.dragControlEnd(moveable, e);\n    const events = triggerChildAbles(moveable, this, 'dragControlEnd', e);\n\n    const nextParams: OnResizeGroupEnd = fillEndParams<OnResizeGroupEnd>(\n      moveable,\n      e,\n      {\n        targets: moveable.props.targets!,\n        events,\n      },\n    );\n\n    triggerEvent(moveable, 'onResizeGroupEnd', nextParams);\n    return isDrag;\n  },\n  /**\n     * @method Moveable.Resizable#request\n     * @param {Moveable.Resizable.ResizableRequestParam} e - the Resizable's request parameter\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * // Use Relative Value\n     * moveable.request(\"resizable\", { deltaWidth: 10, deltaHeight: 10 }, true);\n     *\n     * // Use Absolute Value\n     * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"resizable\");\n     *\n     * // request\n     * // Use Relative Value\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     *\n     * // Use Absolute Value\n     * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100 });\n     * moveable.request(\"resizable\", { offsetWidth: 110, offsetHeight: 100 });\n     * moveable.request(\"resizable\", { offsetWidth: 120, offsetHeight: 100 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n  request(moveable: MoveableManagerInterface<any>) {\n    const datas: Record<string, any> = {};\n    let distWidth = 0;\n    let distHeight = 0;\n    let useSnap = false;\n    const rect = moveable.getRect();\n\n    return {\n      isControl: true,\n      requestStart(e: ResizableRequestParam) {\n        useSnap = e.useSnap!;\n\n        return {\n          datas,\n          parentDirection: e.direction || [1, 1],\n          parentIsWidth: e?.horizontal ?? true,\n          useSnap,\n        };\n      },\n      request(e: ResizableRequestParam) {\n        if ('offsetWidth' in e) {\n          distWidth = e.offsetWidth! - rect.offsetWidth;\n        } else if ('deltaWidth' in e) {\n          distWidth += e.deltaWidth!;\n        }\n        if ('offsetHeight' in e) {\n          distHeight = e.offsetHeight! - rect.offsetHeight;\n        } else if ('deltaHeight' in e) {\n          distHeight += e.deltaHeight!;\n        }\n\n        return {\n          datas,\n          parentDist: [distWidth, distHeight],\n          parentKeepRatio: e.keepRatio,\n          useSnap,\n        };\n      },\n      requestEnd() {\n        return { datas, isDrag: true, useSnap };\n      },\n    };\n  },\n  unset(moveable: MoveableManagerInterface<any, {}>) {\n    moveable.state.gestos.resizable = null;\n  },\n};\n\n/**\n * Whether or not target can be resized.\n * @name Moveable.Resizable#resizable\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     resizable: false,\n * });\n *\n * moveable.resizable = true;\n */\n\n/**\n * throttle of width, height when resize. If throttleResize is set to less than 1, the target may shake.\n * @name Moveable.Resizable#throttleResize\n * @default 1\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n *   throttleResize: 1,\n * });\n *\n * moveable.throttleResize = 0;\n */\n/**\n * When resize or scale, keeps a ratio of the width, height.\n * @name Moveable.Resizable#keepRatio\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n * });\n *\n * moveable.keepRatio = true;\n */\n/**\n * Set directions to show the control box.\n * @name Moveable.Resizable#renderDirections\n * @default [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"]\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n *   renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n * });\n *\n * moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n */\n\n/**\n * Function to convert size for resize\n * @name Moveable.Resizable#resizeFormat\n * @default oneself\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n *   resizeFormat: v => v,\n * });\n *\n * moveable.resizeFormat = (size: number[]) => ([Math.trunc(size[0]), Math.trunc(size[1])];\n */\n\n/**\n * When the resize starts, the resizeStart event is called.\n * @memberof Moveable.Resizable\n * @event resizeStart\n * @param {Moveable.Resizable.OnResizeStart} - Parameters for the resizeStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resizeStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n * When resizing, `beforeResize` is called before `resize` occurs. In `beforeResize`, you can get and set the pre-value before resizing.\n * @memberof Moveable.Resizable\n * @event beforeResize\n * @param {Moveable.Resizable.OnBeforeResize} - Parameters for the `beforeResize` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"beforeResize\", ({ setFixedDirection }) => {\n *     if (shiftKey) {\n *        setFixedDirection([0, 0]);\n *     }\n * });\n * moveable.on(\"resize\", ({ target, width, height, drag }) => {\n *     target.style.width = `${width}px`;\n *     target.style.height = `${height}px`;\n *     target.style.transform = drag.transform;\n * });\n */\n\n/**\n * When resizing, the resize event is called.\n * @memberof Moveable.Resizable\n * @event resize\n * @param {Moveable.Resizable.OnResize} - Parameters for the resize event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resize\", ({ target, width, height }) => {\n *     target.style.width = `${e.width}px`;\n *     target.style.height = `${e.height}px`;\n * });\n */\n/**\n * When the resize finishes, the resizeEnd event is called.\n * @memberof Moveable.Resizable\n * @event resizeEnd\n * @param {Moveable.Resizable.OnResizeEnd} - Parameters for the resizeEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resizeEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n * When the group resize starts, the `resizeGroupStart` event is called.\n * @memberof Moveable.Resizable\n * @event resizeGroupStart\n * @param {Moveable.Resizable.OnResizeGroupStart} - Parameters for the `resizeGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     resizable: true\n * });\n * moveable.on(\"resizeGroupStart\", ({ targets }) => {\n *     console.log(\"onResizeGroupStart\", targets);\n * });\n */\n\n/**\n * When the group resize, the `resizeGroup` event is called.\n * @memberof Moveable.Resizable\n * @event resizeGroup\n * @param {Moveable.Resizable.onResizeGroup} - Parameters for the `resizeGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     resizable: true\n * });\n * moveable.on(\"resizeGroup\", ({ targets, events }) => {\n *     console.log(\"onResizeGroup\", targets);\n *     events.forEach(ev => {\n *         const offset = [\n *             direction[0] < 0 ? -ev.delta[0] : 0,\n *             direction[1] < 0 ? -ev.delta[1] : 0,\n *         ];\n *         // ev.drag is a drag event that occurs when the group resize.\n *         const left = offset[0] + ev.drag.beforeDist[0];\n *         const top = offset[1] + ev.drag.beforeDist[1];\n *         const width = ev.width;\n *         const top = ev.top;\n *     });\n * });\n */\n\n/**\n * When the group resize finishes, the `resizeGroupEnd` event is called.\n * @memberof Moveable.Resizable\n * @event resizeGroupEnd\n * @param {Moveable.Resizable.OnResizeGroupEnd} - Parameters for the `resizeGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     resizable: true\n * });\n * moveable.on(\"resizeGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onResizeGroupEnd\", targets, isDrag);\n * });\n */\n", "import {\n  prefix,\n  triggerEvent,\n  fillParams,\n  calculatePosition,\n  fillEndParams,\n  getRotationRad,\n  getRefTargets,\n  catchEvent,\n  getProps,\n  calculateMoveableClientPositions,\n  fillAfterTransform,\n  getTotalOrigin,\n} from '../utils';\nimport {\n  IObject,\n  hasClass,\n  getRad,\n  throttle,\n  getDist,\n  getKeys,\n  isArray,\n} from '@daybrush/utils';\nimport {\n  RotatableProps,\n  OnRotateGroup,\n  OnRotateGroupEnd,\n  Renderer,\n  OnRotateGroupStart,\n  OnRotateStart,\n  OnRotate,\n  OnRotateEnd,\n  MoveableClientRect,\n  SnappableProps,\n  SnappableState,\n  MoveableManagerInterface,\n  MoveableGroupInterface,\n  DraggableProps,\n  OnBeforeRotate,\n  OnBeforeRotateGroup,\n  OnResizeStart,\n  OnResize,\n  TransformObject,\n  OnDragStart,\n} from '../types';\nimport { triggerChildAbles } from '../groupUtils';\nimport {\n  calculate,\n  convertPositionMatrix,\n  getOrigin,\n  minus,\n  plus,\n  rotate as rotateMatrix,\n} from '@scena/matrix';\nimport CustomGesto, { setCustomDrag } from '../gesto/CustomGesto';\nimport { checkSnapRotate } from './Snappable';\nimport {\n  fillTransformStartEvent,\n  convertTransformFormat,\n  getRotateDist,\n  fillTransformEvent,\n  setDefaultTransformIndex,\n  resolveTransformEvent,\n  getTransformDirection,\n  getPosByDirection,\n  getTranslateFixedPosition,\n} from '../gesto/GestoUtils';\nimport {\n  DirectionControlInfo,\n  renderAroundControls,\n  renderDirectionControlsByInfos,\n} from '../render-directions';\nimport { DIRECTION_REGION_TO_DIRECTION } from '../consts';\nimport Resizable from './Resizable';\nimport Draggable from './Draggable';\nimport {\n  getOffsetFixedDirectionInfo,\n  getOffsetFixedPositionInfo,\n} from '../utils/getFixedDirection';\n\n/**\n * @namespace Rotatable\n * @memberof Moveable\n * @description Rotatable indicates whether the target can be rotated.\n */\n\nfunction setRotateStartInfo(\n  moveable: MoveableManagerInterface<any, any>,\n  datas: IObject<any>,\n  clientX: number,\n  clientY: number,\n  rect: MoveableClientRect,\n) {\n  const groupable = moveable.props.groupable;\n  const state = moveable.state;\n  const n = state.is3d ? 4 : 3;\n  const origin = datas.origin;\n  const nextOrigin = calculatePosition(\n    moveable.state.rootMatrix,\n    // TO-DO #710\n    minus([origin[0], origin[1]], groupable ? [0, 0] : [state.left, state.top]),\n    n,\n  );\n  const startAbsoluteOrigin = plus([rect.left, rect.top], nextOrigin);\n\n  datas.startAbsoluteOrigin = startAbsoluteOrigin;\n  datas.prevDeg =\n    (getRad(startAbsoluteOrigin, [clientX, clientY]) / Math.PI) * 180;\n  datas.defaultDeg = datas.prevDeg;\n  datas.prevSnapDeg = 0;\n  datas.loop = 0;\n  datas.startDist = getDist(startAbsoluteOrigin, [clientX, clientY]);\n}\n\nfunction getAbsoluteDist(deg: number, direction: number, datas: IObject<any>) {\n  const { defaultDeg, prevDeg } = datas;\n\n  let normalizedPrevDeg = prevDeg % 360;\n  let loop = Math.floor(prevDeg / 360);\n\n  if (normalizedPrevDeg < 0) {\n    normalizedPrevDeg += 360;\n  }\n\n  if (normalizedPrevDeg > deg && normalizedPrevDeg > 270 && deg < 90) {\n    // 360 => 0\n    ++loop;\n  } else if (normalizedPrevDeg < deg && normalizedPrevDeg < 90 && deg > 270) {\n    // 0 => 360\n    --loop;\n  }\n  const dist = direction * (loop * 360 + deg - defaultDeg);\n\n  datas.prevDeg = defaultDeg + dist;\n\n  return dist;\n}\nfunction getAbsoluteDistByClient(\n  clientX: number,\n  clientY: number,\n  direction: number,\n  datas: IObject<any>,\n) {\n  return getAbsoluteDist(\n    (getRad(datas.startAbsoluteOrigin, [clientX, clientY]) / Math.PI) * 180,\n    direction,\n    datas,\n  );\n}\nfunction getRotateInfo(\n  moveable: MoveableManagerInterface<any, any>,\n  moveableRect: any,\n  datas: IObject<any>,\n  dist: number,\n  startValue: number,\n  checkSnap?: boolean,\n) {\n  const { throttleRotate = 0 } = moveable.props;\n  const prevSnapDeg = datas.prevSnapDeg;\n  let snapRotation = 0;\n  let isSnap = false;\n\n  if (checkSnap) {\n    const result = checkSnapRotate(\n      moveable,\n      moveableRect,\n      dist,\n      startValue + dist,\n    );\n\n    isSnap = result.isSnap;\n    snapRotation = startValue + result.dist;\n  }\n\n  if (!isSnap) {\n    snapRotation = throttle(startValue + dist, throttleRotate);\n  }\n  const snapDeg = snapRotation - startValue;\n\n  datas.prevSnapDeg = snapDeg;\n\n  return [snapDeg - prevSnapDeg, snapDeg, snapRotation];\n}\n\nexport function getReversePositionX(dir: string) {\n  if (dir === 'left') {\n    return 'right';\n  } else if (dir === 'right') {\n    return 'left';\n  }\n  return dir;\n}\nexport function getReversePositionY(dir: string) {\n  if (dir === 'top') {\n    return 'bottom';\n  } else if (dir === 'bottom') {\n    return 'top';\n  }\n  return dir;\n}\nexport function getRotationPositions(\n  rotationPosition: RotatableProps['rotationPosition'],\n  [pos1, pos2, pos3, pos4]: number[][],\n  direction: number,\n): [number[], number][] {\n  if (rotationPosition === 'none') {\n    return [];\n  }\n  if (isArray(rotationPosition)) {\n    return rotationPosition.map(\n      (child) =>\n        getRotationPositions(child, [pos1, pos2, pos3, pos4], direction)[0],\n    );\n  }\n  const [dir1, dir2] = (rotationPosition || 'top').split('-');\n  let radPoses = [pos1, pos2];\n\n  if (dir1 === 'left') {\n    radPoses = [pos3, pos1];\n  } else if (dir1 === 'right') {\n    radPoses = [pos2, pos4];\n  } else if (dir1 === 'bottom') {\n    radPoses = [pos4, pos3];\n  }\n  let pos = [\n    (radPoses[0][0] + radPoses[1][0]) / 2,\n    (radPoses[0][1] + radPoses[1][1]) / 2,\n  ];\n  const rad = getRotationRad(radPoses, direction);\n  if (dir2) {\n    const isStart = dir2 === 'top' || dir2 === 'left';\n    const isReverse = dir1 === 'bottom' || dir1 === 'left';\n\n    pos = radPoses[(isStart && !isReverse) || (!isStart && isReverse) ? 0 : 1];\n  }\n  return [[pos, rad]];\n}\n\nexport function dragControlCondition(\n  moveable: MoveableManagerInterface<RotatableProps>,\n  e: any,\n) {\n  if (e.isRequest) {\n    return e.requestAble === 'rotatable';\n  }\n  const target = e.inputEvent.target as HTMLElement;\n  if (\n    hasClass(target, prefix('rotation-control')) ||\n    (moveable.props.rotateAroundControls &&\n      hasClass(target, prefix('around-control'))) ||\n    (hasClass(target, prefix('control')) &&\n      hasClass(target, prefix('rotatable')))\n  ) {\n    return true;\n  }\n  const rotationTarget = moveable.props.rotationTarget;\n\n  if (rotationTarget) {\n    return getRefTargets(rotationTarget, true).some((element) => {\n      if (!element) {\n        return false;\n      }\n      return target === element || target.contains(element);\n    });\n  }\n  return false;\n}\n\nconst css = `.rotation {\nposition: absolute;\nheight: 40px;\nwidth: 1px;\ntransform-origin: 50% 100%;\nheight: calc(40px * var(--zoom));\ntop: auto;\nleft: 0;\nbottom: 100%;\nwill-change: transform;\n}\n.rotation .rotation-line {\ndisplay: block;\nwidth: 100%;\nheight: 100%;\ntransform-origin: 50% 50%;\n}\n.rotation .rotation-control {\nborder-color: #4af;\nborder-color: var(--moveable-color);\nbackground:#fff;\ncursor: alias;\n}\n:global .view-rotation-dragging, .rotatable.direction.control {\ncursor: alias;\n}\n.rotatable.direction.control.move {\ncursor: move;\n}\n`;\nexport default {\n  name: 'rotatable',\n  canPinch: true,\n  props: [\n    'rotatable',\n    'rotationPosition',\n    'throttleRotate',\n    'renderDirections',\n    'rotationTarget',\n    'rotateAroundControls',\n    'edge',\n    'resolveAblesWithRotatable',\n    'displayAroundControls',\n  ] as const,\n  events: [\n    'rotateStart',\n    'beforeRotate',\n    'rotate',\n    'rotateEnd',\n    'rotateGroupStart',\n    'beforeRotateGroup',\n    'rotateGroup',\n    'rotateGroupEnd',\n  ] as const,\n  css: [css],\n  viewClassName(moveable: MoveableManagerInterface<RotatableProps>) {\n    if (!moveable.isDragging('rotatable')) {\n      return '';\n    }\n    return prefix('view-rotation-dragging');\n  },\n  render(\n    moveable: MoveableManagerInterface<RotatableProps>,\n    React: Renderer,\n  ): any {\n    const {\n      rotatable,\n      rotationPosition,\n      zoom,\n      renderDirections,\n      rotateAroundControls,\n      resolveAblesWithRotatable,\n    } = getProps(moveable.props, 'rotatable');\n    const { renderPoses, direction } = moveable.getState();\n    if (!rotatable) {\n      return null;\n    }\n    const positions = getRotationPositions(\n      rotationPosition!,\n      renderPoses,\n      direction,\n    );\n    const jsxs: any[] = [];\n\n    positions.forEach(([pos, rad], i) => {\n      jsxs.push(\n        <div\n          key={`rotation${i}`}\n          className={prefix('rotation')}\n          style={{\n            // tslint:disable-next-line: max-line-length\n            transform: `translate(-50%) translate(${pos[0]}px, ${pos[1]}px) rotate(${rad}rad)`,\n          }}\n        >\n          <div\n            className={prefix('line rotation-line')}\n            style={{\n              transform: `scaleX(${zoom})`,\n            }}\n          ></div>\n          <div\n            className={prefix('control rotation-control')}\n            style={{\n              transform: `translate(0.5px) scale(${zoom})`,\n            }}\n          ></div>\n        </div>,\n      );\n    });\n    if (renderDirections) {\n      const ables = getKeys(resolveAblesWithRotatable || {});\n      const resolveMap: Record<string, string> = {};\n\n      ables.forEach((name) => {\n        resolveAblesWithRotatable![name]!.forEach((direction) => {\n          resolveMap[direction] = name;\n        });\n      });\n\n      let directionControlInfos: DirectionControlInfo[] = [];\n\n      if (isArray(renderDirections)) {\n        directionControlInfos = renderDirections.map((dir) => {\n          const able = resolveMap[dir];\n\n          return {\n            data: able ? { resolve: able } : {},\n            classNames: able ? [`move`] : [],\n            dir,\n          };\n        });\n      }\n\n      jsxs.push(\n        ...renderDirectionControlsByInfos(\n          moveable,\n          'rotatable',\n          directionControlInfos,\n          React,\n        ),\n      );\n    }\n    if (rotateAroundControls) {\n      jsxs.push(...renderAroundControls(moveable, React));\n    }\n\n    return jsxs;\n  },\n  dragControlCondition: dragControlCondition as (\n    moveable: any,\n    e: any,\n  ) => boolean,\n  dragControlStart(\n    moveable: MoveableManagerInterface<\n      RotatableProps & SnappableProps & DraggableProps,\n      SnappableState\n    >,\n    e: any,\n  ) {\n    const {\n      datas,\n      clientX,\n      clientY,\n      parentRotate,\n      parentFlag,\n      isPinch,\n      isRequest,\n    } = e;\n    const state = moveable.state;\n    const {\n      target,\n      left,\n      top,\n      direction,\n      beforeDirection,\n      targetTransform,\n      moveableClientRect,\n      offsetMatrix,\n      targetMatrix,\n      allMatrix,\n      width,\n      height,\n    } = state;\n\n    if (!isRequest && !target) {\n      return false;\n    }\n\n    const rect = moveable.getRect();\n    datas.rect = rect;\n    datas.transform = targetTransform;\n    datas.left = left;\n    datas.top = top;\n    let setFixedPosition = (fixedPosition: number[]) => {\n      const result = getOffsetFixedPositionInfo(moveable.state, fixedPosition);\n\n      datas.fixedDirection = result.fixedDirection;\n      datas.fixedOffset = result.fixedOffset;\n      datas.fixedPosition = result.fixedPosition;\n\n      if (resizeStart) {\n        resizeStart.setFixedPosition(fixedPosition);\n      }\n    };\n    let setFixedDirection: OnRotateStart['setFixedDirection'] = (\n      fixedDirection: number[],\n    ) => {\n      const result = getOffsetFixedDirectionInfo(\n        moveable.state,\n        fixedDirection,\n      );\n\n      datas.fixedDirection = result.fixedDirection;\n      datas.fixedOffset = result.fixedOffset;\n      datas.fixedPosition = result.fixedPosition;\n\n      if (resizeStart) {\n        resizeStart.setFixedDirection(fixedDirection);\n      }\n    };\n    let startClientX = clientX;\n    let startClientY = clientY;\n\n    if (isRequest || isPinch || parentFlag) {\n      const externalRotate = parentRotate || 0;\n\n      datas.beforeInfo = {\n        origin: rect.beforeOrigin,\n        prevDeg: externalRotate,\n        defaultDeg: externalRotate,\n        prevSnapDeg: 0,\n        startDist: 0,\n      };\n      datas.afterInfo = {\n        ...datas.beforeInfo,\n        origin: rect.origin,\n      };\n      datas.absoluteInfo = {\n        ...datas.beforeInfo,\n        origin: rect.origin,\n        startValue: externalRotate,\n      };\n    } else {\n      const inputTarget = e.inputEvent?.target;\n\n      if (inputTarget) {\n        const regionDirection =\n          inputTarget.getAttribute('data-direction') || '';\n        const controlDirection = DIRECTION_REGION_TO_DIRECTION[regionDirection];\n\n        if (controlDirection) {\n          datas.isControl = true;\n          datas.isAroundControl = hasClass(\n            inputTarget,\n            prefix('around-control'),\n          );\n          datas.controlDirection = controlDirection;\n          const resolve = inputTarget.getAttribute('data-resolve');\n\n          if (resolve) {\n            datas.resolveAble = resolve;\n          }\n\n          const clientPoses = calculateMoveableClientPositions(\n            state.rootMatrix,\n            state.renderPoses,\n            moveableClientRect,\n          );\n\n          [startClientX, startClientY] = getPosByDirection(\n            clientPoses,\n            controlDirection,\n          );\n        }\n      }\n      datas.beforeInfo = { origin: rect.beforeOrigin };\n      datas.afterInfo = { origin: rect.origin };\n      datas.absoluteInfo = {\n        origin: rect.origin,\n        startValue: rect.rotation,\n      };\n\n      const originalFixedPosition = setFixedPosition;\n\n      setFixedPosition = (fixedPosition: number[]) => {\n        const n = state.is3d ? 4 : 3;\n        const [originX, originY] = plus(\n          getOrigin(targetMatrix, n),\n          fixedPosition,\n        );\n        const fixedBeforeOrigin = calculate(\n          offsetMatrix,\n          convertPositionMatrix([originX, originY], n),\n        );\n        const fixedAfterOrigin = calculate(\n          allMatrix,\n          convertPositionMatrix([fixedPosition[0], fixedPosition[1]], n),\n        );\n        originalFixedPosition(fixedPosition);\n        const posDelta = state.posDelta;\n\n        datas.beforeInfo.origin = minus(fixedBeforeOrigin, posDelta);\n        datas.afterInfo.origin = minus(fixedAfterOrigin, posDelta);\n        datas.absoluteInfo.origin = minus(fixedAfterOrigin, posDelta);\n\n        setRotateStartInfo(\n          moveable,\n          datas.beforeInfo,\n          startClientX,\n          startClientY,\n          moveableClientRect,\n        );\n        setRotateStartInfo(\n          moveable,\n          datas.afterInfo,\n          startClientX,\n          startClientY,\n          moveableClientRect,\n        );\n        setRotateStartInfo(\n          moveable,\n          datas.absoluteInfo,\n          startClientX,\n          startClientY,\n          moveableClientRect,\n        );\n      };\n      setFixedDirection = (fixedDirection: number[]) => {\n        const fixedPosition = getPosByDirection(\n          [\n            [0, 0],\n            [width, 0],\n            [0, height],\n            [width, height],\n          ],\n          fixedDirection,\n        );\n\n        setFixedPosition(fixedPosition);\n      };\n    }\n\n    datas.startClientX = startClientX;\n    datas.startClientY = startClientY;\n    datas.direction = direction;\n    datas.beforeDirection = beforeDirection;\n    datas.startValue = 0;\n    datas.datas = {};\n\n    setDefaultTransformIndex(moveable, e, 'rotate');\n\n    let dragStart: OnDragStart | false = false;\n    let resizeStart: OnResizeStart | false = false;\n\n    if (datas.isControl && datas.resolveAble) {\n      const resolveAble = datas.resolveAble;\n\n      if (resolveAble === 'resizable') {\n        resizeStart = Resizable.dragControlStart(moveable, {\n          ...new CustomGesto('resizable').dragStart([0, 0], e),\n          parentPosition: datas.controlPosition,\n          parentFixedPosition: datas.fixedPosition,\n        });\n      }\n    }\n\n    if (!resizeStart) {\n      dragStart = Draggable.dragStart!(\n        moveable,\n        new CustomGesto().dragStart([0, 0], e),\n      );\n    }\n\n    setFixedPosition(getTotalOrigin(moveable));\n    const params = fillParams<OnRotateStart>(moveable, e, {\n      set: (rotatation: number) => {\n        datas.startValue = (rotatation * Math.PI) / 180;\n      },\n      setFixedDirection,\n      setFixedPosition,\n      ...fillTransformStartEvent(moveable, e),\n      dragStart,\n      resizeStart,\n    });\n    const result = triggerEvent(moveable, 'onRotateStart', params);\n    datas.isRotate = result !== false;\n    state.snapRenderInfo = {\n      request: e.isRequest,\n    };\n\n    return datas.isRotate ? params : false;\n  },\n  dragControl(\n    moveable: MoveableManagerInterface<RotatableProps & DraggableProps>,\n    e: any,\n  ) {\n    const {\n      datas,\n      clientDistX,\n      clientDistY,\n      parentRotate,\n      parentFlag,\n      isPinch,\n      groupDelta,\n      resolveMatrix,\n    } = e;\n    const {\n      beforeDirection,\n      beforeInfo,\n      afterInfo,\n      absoluteInfo,\n      isRotate,\n      startValue,\n      rect,\n      startClientX,\n      startClientY,\n    } = datas;\n\n    if (!isRotate) {\n      return;\n    }\n\n    resolveTransformEvent(moveable, e, 'rotate');\n\n    const targetDirection = getTransformDirection(e);\n    const direction = beforeDirection * targetDirection;\n    const { parentMoveable } = moveable.props;\n\n    let beforeDelta = 0;\n    let beforeDist: number;\n    let beforeRotation: number;\n\n    let delta = 0;\n    let dist: number;\n    let rotation: number;\n\n    let absoluteDelta = 0;\n    let absoluteDist: number;\n    let absoluteRotation: number;\n\n    const startRotation = (180 / Math.PI) * startValue;\n    const absoluteStartRotation = absoluteInfo.startValue;\n    let isSnap = false;\n    const nextClientX = startClientX + clientDistX;\n    const nextClientY = startClientY + clientDistY;\n\n    if (!parentFlag && 'parentDist' in e) {\n      const parentDist = e.parentDist;\n\n      beforeDist = parentDist;\n      dist = parentDist;\n      absoluteDist = parentDist;\n    } else if (isPinch || parentFlag) {\n      beforeDist = getAbsoluteDist(parentRotate, beforeDirection, beforeInfo);\n      dist = getAbsoluteDist(parentRotate, direction, afterInfo);\n      absoluteDist = getAbsoluteDist(parentRotate, direction, absoluteInfo);\n    } else {\n      beforeDist = getAbsoluteDistByClient(\n        nextClientX,\n        nextClientY,\n        beforeDirection,\n        beforeInfo,\n      );\n      dist = getAbsoluteDistByClient(\n        nextClientX,\n        nextClientY,\n        direction,\n        afterInfo,\n      );\n      absoluteDist = getAbsoluteDistByClient(\n        nextClientX,\n        nextClientY,\n        direction,\n        absoluteInfo,\n      );\n      isSnap = true;\n    }\n    beforeRotation = startRotation + beforeDist;\n    rotation = startRotation + dist;\n    absoluteRotation = absoluteStartRotation + absoluteDist;\n\n    triggerEvent(\n      moveable,\n      'onBeforeRotate',\n      fillParams<OnBeforeRotate>(\n        moveable,\n        e,\n        {\n          beforeRotation,\n          rotation,\n          absoluteRotation,\n          setRotation(nextRotation: number) {\n            dist = nextRotation - startRotation;\n            beforeDist = dist;\n            absoluteDist = dist;\n          },\n        },\n        true,\n      ),\n    );\n\n    [beforeDelta, beforeDist, beforeRotation] = getRotateInfo(\n      moveable,\n      rect,\n      beforeInfo,\n      beforeDist,\n      startRotation,\n      isSnap,\n    );\n\n    [delta, dist, rotation] = getRotateInfo(\n      moveable,\n      rect,\n      afterInfo,\n      dist,\n      startRotation,\n      isSnap,\n    );\n\n    [absoluteDelta, absoluteDist, absoluteRotation] = getRotateInfo(\n      moveable,\n      rect,\n      absoluteInfo,\n      absoluteDist,\n      absoluteStartRotation,\n      isSnap,\n    );\n\n    if (\n      !absoluteDelta &&\n      !delta &&\n      !beforeDelta &&\n      !parentMoveable &&\n      !resolveMatrix\n    ) {\n      return;\n    }\n\n    const nextTransform = convertTransformFormat(\n      datas,\n      `rotate(${rotation}deg)`,\n      `rotate(${dist}deg)`,\n    );\n    if (resolveMatrix) {\n      datas.fixedPosition = getTranslateFixedPosition(\n        moveable,\n        datas.targetAllTransform,\n        datas.fixedDirection,\n        datas.fixedOffset,\n        datas,\n      );\n    }\n\n    const inverseDist = getRotateDist(moveable, dist, datas);\n    const inverseDelta = minus(\n      plus(groupDelta || [0, 0], inverseDist),\n      datas.prevInverseDist || [0, 0],\n    );\n    datas.prevInverseDist = inverseDist;\n    datas.requestValue = null;\n\n    const dragEvent = fillTransformEvent(\n      moveable,\n      nextTransform,\n      inverseDelta,\n      isPinch,\n      e,\n    );\n\n    let transformEvent: TransformObject = dragEvent;\n    const parentDistance =\n      getDist([nextClientX, nextClientY], absoluteInfo.startAbsoluteOrigin) -\n      absoluteInfo.startDist;\n\n    let resize: OnResize | undefined = undefined;\n\n    if (datas.resolveAble === 'resizable') {\n      const resizeEvent = Resizable.dragControl(moveable, {\n        ...setCustomDrag(\n          e,\n          moveable.state,\n          [e.deltaX, e.deltaY],\n          !!isPinch,\n          false,\n          'resizable',\n        ),\n        resolveMatrix: true,\n        parentDistance,\n      });\n\n      if (resizeEvent) {\n        resize = resizeEvent;\n        transformEvent = fillAfterTransform(transformEvent, resizeEvent, e);\n      }\n    }\n\n    const params = fillParams<OnRotate>(moveable, e, {\n      delta,\n      dist,\n      rotate: rotation,\n      rotation,\n\n      beforeDist,\n      beforeDelta,\n      beforeRotate: beforeRotation,\n      beforeRotation,\n\n      absoluteDist,\n      absoluteDelta,\n      absoluteRotate: absoluteRotation,\n      absoluteRotation,\n\n      isPinch: !!isPinch,\n      resize,\n      ...dragEvent,\n      ...transformEvent,\n    });\n    triggerEvent(moveable, 'onRotate', params);\n\n    return params;\n  },\n  dragControlEnd(moveable: MoveableManagerInterface<RotatableProps>, e: any) {\n    const { datas } = e;\n\n    if (!datas.isRotate) {\n      return;\n    }\n    datas.isRotate = false;\n\n    const params = fillEndParams<OnRotateEnd>(moveable, e, {});\n\n    triggerEvent(moveable, 'onRotateEnd', params);\n    return params;\n  },\n  dragGroupControlCondition: dragControlCondition as (\n    moveable: any,\n    e: any,\n  ) => boolean,\n  dragGroupControlStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n    const { datas } = e;\n    const {\n      left: parentLeft,\n      top: parentTop,\n      beforeOrigin: parentBeforeOrigin,\n    } = moveable.state;\n\n    const params = this.dragControlStart(moveable, e);\n\n    if (!params) {\n      return false;\n    }\n\n    params.set(datas.beforeDirection * moveable.rotation);\n\n    const events = triggerChildAbles(\n      moveable,\n      this,\n      'dragControlStart',\n      e,\n      (child, ev) => {\n        const { left, top, beforeOrigin } = child.state;\n        const childClient = plus(\n          minus([left, top], [parentLeft, parentTop]),\n          minus(beforeOrigin, parentBeforeOrigin),\n        );\n\n        ev.datas.startGroupClient = childClient;\n        ev.datas.groupClient = childClient;\n        return { ...ev, parentRotate: 0 };\n      },\n    );\n\n    const nextParams: OnRotateGroupStart = {\n      ...params,\n      targets: moveable.props.targets!,\n      events,\n    };\n    const result = triggerEvent(moveable, 'onRotateGroupStart', nextParams);\n\n    datas.isRotate = result !== false;\n\n    return datas.isRotate ? params : false;\n  },\n  dragGroupControl(moveable: MoveableGroupInterface<any, any>, e: any) {\n    const { datas } = e;\n\n    if (!datas.isRotate) {\n      return;\n    }\n\n    catchEvent(moveable, 'onBeforeRotate', (parentEvent) => {\n      triggerEvent(\n        moveable,\n        'onBeforeRotateGroup',\n        fillParams<OnBeforeRotateGroup>(\n          moveable,\n          e,\n          {\n            ...parentEvent,\n            targets: moveable.props.targets!,\n          },\n          true,\n        ),\n      );\n    });\n    const params = this.dragControl(moveable, e);\n\n    if (!params) {\n      return;\n    }\n    const direction = datas.beforeDirection;\n    const parentRotate = params.beforeDist;\n    const rad = (parentRotate / 180) * Math.PI;\n    const events = triggerChildAbles(\n      moveable,\n      this,\n      'dragControl',\n      e,\n      (_, ev) => {\n        const startGroupClient = ev.datas.startGroupClient;\n        const [prevClientX, prevClientY] = ev.datas.groupClient;\n        const [clientX, clientY] = rotateMatrix(\n          startGroupClient,\n          rad * direction,\n        );\n        const delta = [clientX - prevClientX, clientY - prevClientY];\n\n        ev.datas.groupClient = [clientX, clientY];\n        return { ...ev, parentRotate, groupDelta: delta };\n      },\n    );\n    moveable.rotation = direction * params.beforeRotation;\n\n    const nextParams: OnRotateGroup = {\n      targets: moveable.props.targets!,\n      events,\n      set(rotation: number) {\n        moveable.rotation = rotation;\n      },\n      setGroupRotation(rotation: number) {\n        moveable.rotation = rotation;\n      },\n      ...params,\n    };\n\n    triggerEvent(moveable, 'onRotateGroup', nextParams);\n    return nextParams;\n  },\n  dragGroupControlEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n    const { isDrag, datas } = e;\n\n    if (!datas.isRotate) {\n      return;\n    }\n\n    this.dragControlEnd(moveable, e);\n    const events = triggerChildAbles(moveable, this, 'dragControlEnd', e);\n\n    const nextParams = fillEndParams<OnRotateGroupEnd>(moveable, e, {\n      targets: moveable.props.targets!,\n      events,\n    });\n\n    triggerEvent(moveable, 'onRotateGroupEnd', nextParams);\n    return isDrag;\n  },\n  /**\n     * @method Moveable.Rotatable#request\n     * @param {object} [e] - the Resizable's request parameter\n     * @param {number} [e.deltaRotate=0] -  delta number of rotation\n     * @param {number} [e.rotate=0] - absolute number of moveable's rotation\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * moveable.request(\"rotatable\", { deltaRotate: 10 }, true);\n     *\n     * * moveable.request(\"rotatable\", { rotate: 10 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"rotatable\");\n     *\n     * // request\n     * requester.request({ deltaRotate: 10 });\n     * requester.request({ deltaRotate: 10 });\n     * requester.request({ deltaRotate: 10 });\n     *\n     * requester.request({ rotate: 10 });\n     * requester.request({ rotate: 20 });\n     * requester.request({ rotate: 30 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n  request(moveable: MoveableManagerInterface<RotatableProps>) {\n    const datas = {};\n    let distRotate = 0;\n\n    const startRotation = moveable.getRotation();\n    return {\n      isControl: true,\n      requestStart() {\n        return { datas };\n      },\n      request(e: IObject<any>) {\n        if ('deltaRotate' in e) {\n          distRotate += e.deltaRotate;\n        } else if ('rotate' in e) {\n          distRotate = e.rotate - startRotation;\n        }\n\n        return { datas, parentDist: distRotate };\n      },\n      requestEnd() {\n        return { datas, isDrag: true };\n      },\n    };\n  },\n};\n/**\n * Whether or not target can be rotated. (default: false)\n * @name Moveable.Rotatable#rotatable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.rotatable = true;\n */\n/**\n * You can specify the position of the rotation. (default: \"top\")\n * @name Moveable.Rotatable#rotationPosition\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   rotationPosition: \"top\",\n * });\n *\n * moveable.rotationPosition = \"bottom\"\n */\n\n/**\n * throttle of angle(degree) when rotate.\n * @name Moveable.Rotatable#throttleRotate\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleRotate = 1;\n */\n\n/**\n * When the rotate starts, the rotateStart event is called.\n * @memberof Moveable.Rotatable\n * @event rotateStart\n * @param {Moveable.Rotatable.OnRotateStart} - Parameters for the rotateStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { rotatable: true });\n * moveable.on(\"rotateStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n * When rotating, the rotate event is called.\n * @memberof Moveable.Rotatable\n * @event rotate\n * @param {Moveable.Rotatable.OnRotate} - Parameters for the rotate event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { rotatable: true });\n * moveable.on(\"rotate\", ({ target, transform, dist }) => {\n *     target.style.transform = transform;\n * });\n */\n/**\n * When the rotate finishes, the rotateEnd event is called.\n * @memberof Moveable.Rotatable\n * @event rotateEnd\n * @param {Moveable.Rotatable.OnRotateEnd} - Parameters for the rotateEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { rotatable: true });\n * moveable.on(\"rotateEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n * When the group rotate starts, the `rotateGroupStart` event is called.\n * @memberof Moveable.Rotatable\n * @event rotateGroupStart\n * @param {Moveable.Rotatable.OnRotateGroupStart} - Parameters for the `rotateGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     rotatable: true\n * });\n * moveable.on(\"rotateGroupStart\", ({ targets }) => {\n *     console.log(\"onRotateGroupStart\", targets);\n * });\n */\n\n/**\n * When the group rotate, the `rotateGroup` event is called.\n * @memberof Moveable.Rotatable\n * @event rotateGroup\n * @param {Moveable.Rotatable.OnRotateGroup} - Parameters for the `rotateGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     rotatable: true\n * });\n * moveable.on(\"rotateGroup\", ({ targets, events }) => {\n *     console.log(\"onRotateGroup\", targets);\n *     events.forEach(ev => {\n *         const target = ev.target;\n *         // ev.drag is a drag event that occurs when the group rotate.\n *         const left = ev.drag.beforeDist[0];\n *         const top = ev.drag.beforeDist[1];\n *         const deg = ev.beforeDist;\n *     });\n * });\n */\n\n/**\n * When the group rotate finishes, the `rotateGroupEnd` event is called.\n * @memberof Moveable.Rotatable\n * @event rotateGroupEnd\n * @param {Moveable.Rotatable.OnRotateGroupEnd} - Parameters for the `rotateGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     rotatable: true\n * });\n * moveable.on(\"rotateGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onRotateGroupEnd\", targets, isDrag);\n * });\n */\n", "import { throttle } from \"@daybrush/utils\";\nimport {\n    RenderGuidelineInfo, Renderer, RenderGuidelineInnerInfo,\n    MoveableManagerInterface, SnappableProps, SnapGuideline,\n    SnappableRenderType, SnappableState,\n    SnapDirectionPoses,\n} from \"../../types\";\nimport { prefix, groupBy } from \"../../utils\";\nimport { HORIZONTAL_NAMES_MAP, VERTICAL_NAMES_MAP } from \"./utils\";\n\nexport function renderGuideline(info: RenderGuidelineInfo, React: Renderer): any {\n    const { direction, classNames, size, pos, zoom, key } = info;\n    const isHorizontal = direction === \"horizontal\";\n    const scaleType = isHorizontal ? \"Y\" : \"X\";\n    // const scaleType2 = isHorizontal ? \"Y\" : \"X\";\n\n    return React.createElement(\"div\", {\n        key,\n        className: classNames.join(\" \"),\n        style: {\n            [isHorizontal ? \"width\" : \"height\"]: `${size}`,\n            transform: `translate(${pos[0]}, ${pos[1]}) translate${scaleType}(-50%) scale${scaleType}(${zoom})`,\n        },\n    });\n}\n\nexport function renderInnerGuideline(info: RenderGuidelineInnerInfo, React: Renderer): any {\n    return renderGuideline({\n        ...info,\n        classNames: [\n            prefix(\"line\", \"guideline\", info.direction),\n            ...info.classNames,\n        ].filter(className => className) as string[],\n        size: info.size || `${info.sizeValue}px`,\n        pos: info.pos || info.posValue.map(v => `${throttle(v, 0.1)}px`),\n    }, React);\n}\n\nexport function renderSnapPoses(\n    moveable: MoveableManagerInterface,\n    direction: string,\n    snapPoses: SnappableRenderType[],\n    minPos: number,\n    targetPos: number,\n    size: number,\n    index: number,\n    React: Renderer\n) {\n    const { zoom } = moveable.props;\n    return snapPoses.map(({ type, pos }, i) => {\n        const renderPos = [0, 0];\n\n        renderPos[index] = minPos;\n        renderPos[index ? 0 : 1] = -targetPos + pos;\n\n        return renderInnerGuideline(\n            {\n                key: `${direction}TargetGuideline${i}`,\n                classNames: [prefix(\"target\", \"bold\", type)],\n                posValue: renderPos,\n                sizeValue: size,\n                zoom: zoom!,\n                direction: direction,\n            },\n            React\n        );\n    });\n}\nexport function renderGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    type: \"vertical\" | \"horizontal\",\n    guidelines: SnapGuideline[],\n    targetPos: number[],\n    targetRect: SnapDirectionPoses,\n    React: Renderer\n): any[] {\n    const { zoom, isDisplayInnerSnapDigit } = moveable.props;\n\n    const mainNames = type === \"horizontal\" ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\n    const targetStart = targetRect[mainNames.start]!;\n    const targetEnd = targetRect[mainNames.end]!;\n    return guidelines.filter(({ hide, elementRect }) => {\n        if (hide) {\n            return false;\n        }\n        if (isDisplayInnerSnapDigit && elementRect) {\n            // inner\n            const rect = elementRect.rect;\n\n            if (rect[mainNames.start]! <= targetStart && targetEnd <= rect[mainNames.end]!) {\n                return false;\n            }\n        }\n        return true;\n    }).map((guideline, i) => {\n        const { pos, size, element, className } = guideline;\n\n        const renderPos = [\n            -targetPos[0] + pos[0],\n            -targetPos[1] + pos[1],\n        ];\n\n        return renderInnerGuideline(\n            {\n                key: `${type}-default-guideline-${i}`,\n                classNames: element ? [prefix(\"bold\"), className] : [prefix(\"normal\"), className],\n                direction: type,\n                posValue: renderPos,\n                sizeValue: size,\n                zoom: zoom!,\n            },\n            React\n        );\n    });\n}\n\nexport function renderDigitLine(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    type: \"vertical\" | \"horizontal\",\n    lineType: \"dashed\" | \"gap\",\n    index: number,\n    gap: number,\n    renderPos: number[],\n    className: string | undefined,\n    React: Renderer,\n): any {\n    const {\n        snapDigit = 0,\n        isDisplaySnapDigit = true,\n        snapDistFormat = (v: number, type: \"vertical\" | \"horizontal\") => {\n            // Type can be used render different values.\n            if (type === 'vertical') {\n                return v;\n            }\n            return v;\n        },\n        zoom,\n    } = moveable.props;\n    const scaleType = type === \"horizontal\" ? \"X\" : \"Y\";\n    const sizeName = type === \"vertical\" ? \"height\" : \"width\";\n    const absGap = Math.abs(gap!);\n    const snapSize = isDisplaySnapDigit\n        ? parseFloat(absGap.toFixed(snapDigit))\n        : 0;\n    return <div\n        key={`${type}-${lineType}-guideline-${index}`}\n        className={prefix(\"guideline-group\", type)}\n        style={{\n            left: `${renderPos[0]}px`,\n            top: `${renderPos[1]}px`,\n            [sizeName]: `${absGap}px`,\n        }}\n    >\n        {renderInnerGuideline(\n            {\n                direction: type,\n                classNames: [prefix(lineType), className],\n                size: \"100%\",\n                posValue: [0, 0],\n                sizeValue: absGap,\n                zoom: zoom!,\n            },\n            React\n        )}\n        <div\n            className={prefix(\"size-value\", \"gap\")}\n            style={{\n                transform: `translate${scaleType}(-50%) scale(${zoom})`,\n            }}\n        >\n            {snapSize > 0 ? snapDistFormat(snapSize, type) : \"\"}\n        </div>\n    </div>;\n}\n\nexport function groupByElementGuidelines(\n    type: \"vertical\" | \"horizontal\",\n    guidelines: SnapGuideline[],\n    targetRect: SnapDirectionPoses,\n    isDisplayInnerSnapDigit: boolean,\n) {\n    const index = type === \"vertical\" ? 0 : 1;\n    const otherIndex = type === \"vertical\" ? 1 : 0;\n    const names = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\n    const targetStart = targetRect[names.start]!;\n    const targetEnd = targetRect[names.end]!;\n    return groupBy(guidelines, (guideline) => {\n        return guideline.pos[index];\n    }).map(nextGuidelines => {\n        const start: SnapGuideline[] = [];\n        const end: SnapGuideline[] = [];\n        const inner: SnapGuideline[] = [];\n\n        nextGuidelines.forEach(guideline => {\n            const element = guideline.element!;\n            const rect = guideline.elementRect!.rect;\n            if (rect[names.end]! < targetStart) {\n                start.push(guideline);\n            } else if (targetEnd < rect[names.start]!) {\n                end.push(guideline);\n            } else if (rect[names.start]! <= targetStart && targetEnd <= rect[names.end]! && isDisplayInnerSnapDigit) {\n                const pos = guideline.pos;\n                const elementRect1 = { element, rect: { ...rect, [names.end]: rect[names.start]! } };\n                const elementRect2 = { element, rect: { ...rect, [names.start]: rect[names.end]! } };\n                const nextPos1 = [0, 0];\n                const nextPos2 = [0, 0];\n                nextPos1[index] = pos[index];\n                nextPos1[otherIndex] = pos[otherIndex];\n\n                nextPos2[index] = pos[index];\n                nextPos2[otherIndex] = pos[otherIndex] + guideline.size;\n\n\n                start.push({\n                    type,\n                    pos: nextPos1,\n                    size: 0,\n                    elementRect: elementRect1,\n                    direction: \"\",\n                    elementDirection: \"end\",\n                });\n                end.push({\n                    type,\n                    pos: nextPos2,\n                    size: 0,\n                    elementRect: elementRect2,\n                    direction: \"\",\n                    elementDirection: \"start\",\n                });\n                // inner.push(guideline);\n            }\n        });\n\n        start.sort((a, b) => {\n            return b.pos[otherIndex] - a.pos[otherIndex];\n        });\n        end.sort((a, b) => {\n            return a.pos[otherIndex] - b.pos[otherIndex];\n        });\n        return {\n            total: nextGuidelines,\n            start,\n            end,\n            inner,\n        };\n    });\n}\nexport function renderDashedGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    guidelines: SnapGuideline[],\n    targetPos: number[],\n    targetRect: SnapDirectionPoses,\n    React: Renderer,\n): any[] {\n    const {\n        isDisplayInnerSnapDigit,\n    } = moveable.props;\n    const rendered: any[] = [];\n\n    ([\"vertical\", \"horizontal\"] as const).forEach(type => {\n        const nextGuidelines = guidelines.filter(guideline => guideline.type === type);\n        const index = type === \"vertical\" ? 1 : 0;\n        const otherIndex = index ? 0 : 1;\n\n        const groups = groupByElementGuidelines(type, nextGuidelines, targetRect, isDisplayInnerSnapDigit!);\n        const mainNames = index ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP;\n        const sideNames = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\n        const targetStart = targetRect[mainNames.start]!;\n        const targetEnd = targetRect[mainNames.end]!;\n\n        groups.forEach(({ total, start, end, inner }) => {\n            const sidePos = targetPos[otherIndex] + total[0].pos[otherIndex] - targetRect[sideNames.start]!;\n\n            let prevRect = targetRect;\n\n            start.forEach(guideline => {\n                const nextRect = guideline.elementRect!.rect;\n                const size = prevRect[mainNames.start]! - nextRect[mainNames.end]!;\n\n                if (size > 0) {\n                    const renderPos = [0, 0];\n\n                    renderPos[index] = targetPos[index] + prevRect[mainNames.start]! - targetStart - size;\n                    renderPos[otherIndex] = sidePos;\n\n                    rendered.push(renderDigitLine(\n                        moveable,\n                        type,\n                        \"dashed\",\n                        rendered.length,\n                        size,\n                        renderPos,\n                        guideline.className,\n                        React\n                    ));\n                }\n                prevRect = nextRect;\n            });\n\n            prevRect = targetRect;\n            end.forEach(guideline => {\n                const nextRect = guideline.elementRect!.rect;\n                const size = nextRect[mainNames.start]! - prevRect[mainNames.end]!;\n\n                if (size > 0) {\n                    const renderPos = [0, 0];\n\n                    renderPos[index] = targetPos[index] + prevRect[mainNames.end]! - targetStart;\n                    renderPos[otherIndex] = sidePos;\n\n                    rendered.push(renderDigitLine(\n                        moveable,\n                        type,\n                        \"dashed\",\n                        rendered.length,\n                        size,\n                        renderPos,\n                        guideline.className,\n                        React\n                    ));\n                }\n                prevRect = nextRect;\n            });\n\n            inner.forEach(guideline => {\n                const nextRect = guideline.elementRect!.rect;\n\n                const size1 = targetStart - nextRect[mainNames.start]!;\n                const size2 = nextRect[mainNames.end]! - targetEnd;\n                const renderPos1 = [0, 0];\n                const renderPos2 = [0, 0];\n\n                renderPos1[index] = targetPos[index] - size1;\n                renderPos1[otherIndex] = sidePos;\n\n                renderPos2[index] = targetPos[index] + targetEnd - targetStart;\n                renderPos2[otherIndex] = sidePos;\n\n                rendered.push(renderDigitLine(\n                    moveable,\n                    type,\n                    \"dashed\",\n                    rendered.length,\n                    size1,\n                    renderPos1,\n                    guideline.className,\n                    React\n                ));\n                rendered.push(renderDigitLine(\n                    moveable,\n                    type,\n                    \"dashed\",\n                    rendered.length,\n                    size2,\n                    renderPos2,\n                    guideline.className,\n                    React\n                ));\n            });\n        });\n    });\n    return rendered;\n}\nexport function renderGapGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    guidelines: SnapGuideline[],\n    targetPos: number[],\n    targetRect: SnapDirectionPoses,\n    React: any\n): any[] {\n    const rendered: any[] = [];\n    ([\"horizontal\", \"vertical\"] as const).forEach(type => {\n        const nextGuidelines = guidelines.filter(guideline => guideline.type === type).slice(0, 1);\n        const index = type === \"vertical\" ? 0 : 1;\n        const otherIndex = index ? 0 : 1;\n        const mainNames = index ? HORIZONTAL_NAMES_MAP : VERTICAL_NAMES_MAP;\n        const sideNames = index ? VERTICAL_NAMES_MAP : HORIZONTAL_NAMES_MAP;\n        const targetStart = targetRect[mainNames.start]!;\n        const targetEnd = targetRect[mainNames.end]!;\n        const targetSideStart = targetRect[sideNames.start]!;\n        const targetSideEnd = targetRect[sideNames.end]!;\n\n\n        nextGuidelines.forEach(({ gap, gapRects }) => {\n            const sideStartPos = Math.max(\n                targetSideStart,\n                ...gapRects!.map(({ rect }) => rect[sideNames.start]!),\n            );\n            const sideEndPos = Math.min(\n                targetSideEnd,\n                ...gapRects!.map(({ rect }) => rect[sideNames.end]!),\n            );\n            const sideCenterPos = (sideStartPos + sideEndPos) / 2;\n\n            if (sideStartPos === sideEndPos || sideCenterPos === (targetSideStart + targetSideEnd)/ 2) {\n                return;\n            }\n            gapRects!.forEach(({ rect, className }) => {\n                const renderPos = [targetPos[0], targetPos[1]];\n\n                if (rect[mainNames.end]! < targetStart) {\n                    renderPos[index] += rect[mainNames.end]! - targetStart;\n                } else if (targetEnd < rect[mainNames.start]!) {\n                    renderPos[index] += rect[mainNames.start]! - targetStart - gap!;\n                } else {\n                    return;\n                }\n\n                renderPos[otherIndex] += sideCenterPos - targetSideStart;\n                rendered.push(renderDigitLine(\n                    moveable,\n                    index ? \"vertical\" : \"horizontal\",\n                    \"gap\",\n                    rendered.length,\n                    gap!,\n                    renderPos,\n                    className,\n                    React\n                ));\n            });\n        });\n    });\n    return rendered;\n}\n", "/*\nCopyright (c) 2019-present NAVER Corp.\nname: @egjs/list-differ\nlicense: MIT\nauthor: NAVER Corp.\nrepository: https://github.com/naver/egjs-list-differ\nversion: 1.0.1\n*/\n/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nvar PolyMap =\n/*#__PURE__*/\nfunction () {\n  function PolyMap() {\n    this.keys = [];\n    this.values = [];\n  }\n\n  var __proto = PolyMap.prototype;\n\n  __proto.get = function (key) {\n    return this.values[this.keys.indexOf(key)];\n  };\n\n  __proto.set = function (key, value) {\n    var keys = this.keys;\n    var values = this.values;\n    var prevIndex = keys.indexOf(key);\n    var index = prevIndex === -1 ? keys.length : prevIndex;\n    keys[index] = key;\n    values[index] = value;\n  };\n\n  return PolyMap;\n}();\n\n/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nvar HashMap =\n/*#__PURE__*/\nfunction () {\n  function HashMap() {\n    this.object = {};\n  }\n\n  var __proto = HashMap.prototype;\n\n  __proto.get = function (key) {\n    return this.object[key];\n  };\n\n  __proto.set = function (key, value) {\n    this.object[key] = value;\n  };\n\n  return HashMap;\n}();\n\n/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nvar SUPPORT_MAP = typeof Map === \"function\";\n\n/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nvar Link =\n/*#__PURE__*/\nfunction () {\n  function Link() {}\n\n  var __proto = Link.prototype;\n\n  __proto.connect = function (prevLink, nextLink) {\n    this.prev = prevLink;\n    this.next = nextLink;\n    prevLink && (prevLink.next = this);\n    nextLink && (nextLink.prev = this);\n  };\n\n  __proto.disconnect = function () {\n    // In double linked list, diconnect the interconnected relationship.\n    var prevLink = this.prev;\n    var nextLink = this.next;\n    prevLink && (prevLink.next = nextLink);\n    nextLink && (nextLink.prev = prevLink);\n  };\n\n  __proto.getIndex = function () {\n    var link = this;\n    var index = -1;\n\n    while (link) {\n      link = link.prev;\n      ++index;\n    }\n\n    return index;\n  };\n\n  return Link;\n}();\n\n/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\n\nfunction orderChanged(changed, fixed) {\n  // It is roughly in the order of these examples.\n  // 4, 6, 0, 2, 1, 3, 5, 7\n  var fromLinks = []; // 0, 1, 2, 3, 4, 5, 6, 7\n\n  var toLinks = [];\n  changed.forEach(function (_a) {\n    var from = _a[0],\n        to = _a[1];\n    var link = new Link();\n    fromLinks[from] = link;\n    toLinks[to] = link;\n  }); // `fromLinks` are connected to each other by double linked list.\n\n  fromLinks.forEach(function (link, i) {\n    link.connect(fromLinks[i - 1]);\n  });\n  return changed.filter(function (_, i) {\n    return !fixed[i];\n  }).map(function (_a, i) {\n    var from = _a[0],\n        to = _a[1];\n\n    if (from === to) {\n      return [0, 0];\n    }\n\n    var fromLink = fromLinks[from];\n    var toLink = toLinks[to - 1];\n    var fromIndex = fromLink.getIndex(); // Disconnect the link connected to `fromLink`.\n\n    fromLink.disconnect(); // Connect `fromLink` to the right of `toLink`.\n\n    if (!toLink) {\n      fromLink.connect(undefined, fromLinks[0]);\n    } else {\n      fromLink.connect(toLink, toLink.next);\n    }\n\n    var toIndex = fromLink.getIndex();\n    return [fromIndex, toIndex];\n  });\n}\n\nvar Result =\n/*#__PURE__*/\nfunction () {\n  function Result(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed) {\n    this.prevList = prevList;\n    this.list = list;\n    this.added = added;\n    this.removed = removed;\n    this.changed = changed;\n    this.maintained = maintained;\n    this.changedBeforeAdded = changedBeforeAdded;\n    this.fixed = fixed;\n  }\n\n  var __proto = Result.prototype;\n  Object.defineProperty(__proto, \"ordered\", {\n    get: function () {\n      if (!this.cacheOrdered) {\n        this.caculateOrdered();\n      }\n\n      return this.cacheOrdered;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(__proto, \"pureChanged\", {\n    get: function () {\n      if (!this.cachePureChanged) {\n        this.caculateOrdered();\n      }\n\n      return this.cachePureChanged;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  __proto.caculateOrdered = function () {\n    var ordered = orderChanged(this.changedBeforeAdded, this.fixed);\n    var changed = this.changed;\n    var pureChanged = [];\n    this.cacheOrdered = ordered.filter(function (_a, i) {\n      var from = _a[0],\n          to = _a[1];\n      var _b = changed[i],\n          fromBefore = _b[0],\n          toBefore = _b[1];\n\n      if (from !== to) {\n        pureChanged.push([fromBefore, toBefore]);\n        return true;\n      }\n    });\n    this.cachePureChanged = pureChanged;\n  };\n\n  return Result;\n}();\n\n/**\n *\n * @memberof eg.ListDiffer\n * @static\n * @function\n * @param - Previous List <ko> 이전 목록 </ko>\n * @param - List to Update <ko> 업데이트 할 목록 </ko>\n * @param - This callback function returns the key of the item. <ko> 아이템의 키를 반환하는 콜백 함수입니다.</ko>\n * @return - Returns the diff between `prevList` and `list` <ko> `prevList`와 `list`의 다른 점을 반환한다.</ko>\n * @example\n * import { diff } from \"@egjs/list-differ\";\n * // script => eg.ListDiffer.diff\n * const result = diff([0, 1, 2, 3, 4, 5], [7, 8, 0, 4, 3, 6, 2, 1], e => e);\n * // List before update\n * // [1, 2, 3, 4, 5]\n * console.log(result.prevList);\n * // Updated list\n * // [4, 3, 6, 2, 1]\n * console.log(result.list);\n * // Index array of values added to `list`\n * // [0, 1, 5]\n * console.log(result.added);\n * // Index array of values removed in `prevList`\n * // [5]\n * console.log(result.removed);\n * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`\n * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n * console.log(result.changed);\n * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)\n * // [[4, 3], [3, 4], [2, 6]]\n * console.log(result.pureChanged);\n * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)\n * // [[4, 1], [4, 2], [4, 3]]\n * console.log(result.ordered);\n * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved\n * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n * console.log(result.maintained);\n */\n\nfunction diff(prevList, list, findKeyCallback) {\n  var mapClass = SUPPORT_MAP ? Map : findKeyCallback ? HashMap : PolyMap;\n\n  var callback = findKeyCallback || function (e) {\n    return e;\n  };\n\n  var added = [];\n  var removed = [];\n  var maintained = [];\n  var prevKeys = prevList.map(callback);\n  var keys = list.map(callback);\n  var prevKeyMap = new mapClass();\n  var keyMap = new mapClass();\n  var changedBeforeAdded = [];\n  var fixed = [];\n  var removedMap = {};\n  var changed = [];\n  var addedCount = 0;\n  var removedCount = 0; // Add prevKeys and keys to the hashmap.\n\n  prevKeys.forEach(function (key, prevListIndex) {\n    prevKeyMap.set(key, prevListIndex);\n  });\n  keys.forEach(function (key, listIndex) {\n    keyMap.set(key, listIndex);\n  }); // Compare `prevKeys` and `keys` and add them to `removed` if they are not in `keys`.\n\n  prevKeys.forEach(function (key, prevListIndex) {\n    var listIndex = keyMap.get(key); // In prevList, but not in list, it is removed.\n\n    if (typeof listIndex === \"undefined\") {\n      ++removedCount;\n      removed.push(prevListIndex);\n    } else {\n      removedMap[listIndex] = removedCount;\n    }\n  }); // Compare `prevKeys` and `keys` and add them to `added` if they are not in `prevKeys`.\n\n  keys.forEach(function (key, listIndex) {\n    var prevListIndex = prevKeyMap.get(key); // In list, but not in prevList, it is added.\n\n    if (typeof prevListIndex === \"undefined\") {\n      added.push(listIndex);\n      ++addedCount;\n    } else {\n      maintained.push([prevListIndex, listIndex]);\n      removedCount = removedMap[listIndex] || 0;\n      changedBeforeAdded.push([prevListIndex - removedCount, listIndex - addedCount]);\n      fixed.push(listIndex === prevListIndex);\n\n      if (prevListIndex !== listIndex) {\n        changed.push([prevListIndex, listIndex]);\n      }\n    }\n  }); // Sort by ascending order of 'to(list's index).\n\n  removed.reverse();\n  return new Result(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed);\n}\n\n/**\n * A module that checks diff when values are added, removed, or changed in an array.\n * @ko 배열 또는 오브젝트에서 값이 추가되거나 삭제되거나 순서가 변경사항을 체크하는 모듈입니다.\n * @memberof eg\n */\n\nvar ListDiffer =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param - Initializing Data Array. <ko> 초기 설정할 데이터 배열.</ko>\n   * @param - This callback function returns the key of the item. <ko> 아이템의 키를 반환하는 콜백 함수입니다.</ko>\n   * @example\n   * import ListDiffer from \"@egjs/list-differ\";\n   * // script => eg.ListDiffer\n   * const differ = new ListDiffer([0, 1, 2, 3, 4, 5], e => e);\n   * const result = differ.update([7, 8, 0, 4, 3, 6, 2, 1]);\n   * // List before update\n   * // [1, 2, 3, 4, 5]\n   * console.log(result.prevList);\n   * // Updated list\n   * // [4, 3, 6, 2, 1]\n   * console.log(result.list);\n   * // Index array of values added to `list`.\n   * // [0, 1, 5]\n   * console.log(result.added);\n   * // Index array of values removed in `prevList`.\n   * // [5]\n   * console.log(result.removed);\n   * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`.\n   * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n   * console.log(result.changed);\n   * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)\n   * // [[4, 3], [3, 4], [2, 6]]\n   * console.log(result.pureChanged);\n   * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)\n   * // [[4, 1], [4, 2], [4, 3]]\n   * console.log(result.ordered);\n   * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved.\n   * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n   * console.log(result.maintained);\n   */\n  function ListDiffer(list, findKeyCallback) {\n    if (list === void 0) {\n      list = [];\n    }\n\n    this.findKeyCallback = findKeyCallback;\n    this.list = [].slice.call(list);\n  }\n  /**\n   * Update list.\n   * @ko 리스트를 업데이트를 합니다.\n   * @param - List to update <ko> 업데이트할 리스트 </ko>\n   * @return - Returns the results of an update from `prevList` to `list`.<ko> `prevList`에서 `list`로 업데이트한 결과를 반환한다. </ko>\n   */\n\n\n  var __proto = ListDiffer.prototype;\n\n  __proto.update = function (list) {\n    var newData = [].slice.call(list);\n    var result = diff(this.list, newData, this.findKeyCallback);\n    this.list = newData;\n    return result;\n  };\n\n  return ListDiffer;\n}();\n\n/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\n\nexport default ListDiffer;\nexport { diff };\n//# sourceMappingURL=list-differ.esm.js.map\n", "/*\nCopyright (c) 2019-present NAVER Corp.\nname: @egjs/children-differ\nlicense: MIT\nauthor: NAVER Corp.\nrepository: https://github.com/naver/egjs-children-differ\nversion: 1.0.1\n*/\nimport ListDiffer, { diff as diff$1 } from '@egjs/list-differ';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\n/*\negjs-children-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nvar findKeyCallback = typeof Map === \"function\" ? undefined : function () {\n  var childrenCount = 0;\n  return function (el) {\n    return el.__DIFF_KEY__ || (el.__DIFF_KEY__ = ++childrenCount);\n  };\n}();\n\n/**\n * A module that checks diff when child are added, removed, or changed .\n * @ko 자식 노드들에서 자식 노드가 추가되거나 삭제되거나 순서가 변경된 사항을 체크하는 모듈입니다.\n * @memberof eg\n * @extends eg.ListDiffer\n */\n\nvar ChildrenDiffer =\n/*#__PURE__*/\nfunction (_super) {\n  __extends(ChildrenDiffer, _super);\n  /**\n   * @param - Initializing Children <ko> 초기 설정할 자식 노드들</ko>\n   */\n\n\n  function ChildrenDiffer(list) {\n    if (list === void 0) {\n      list = [];\n    }\n\n    return _super.call(this, list, findKeyCallback) || this;\n  }\n\n  return ChildrenDiffer;\n}(ListDiffer);\n\n/*\negjs-children-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\n/**\n *\n * @memberof eg.ChildrenDiffer\n * @static\n * @function\n * @param - Previous List <ko> 이전 목록 </ko>\n * @param - List to Update <ko> 업데이트 할 목록 </ko>\n * @return - Returns the diff between `prevList` and `list` <ko> `prevList`와 `list`의 다른 점을 반환한다.</ko>\n * @example\n * import { diff } from \"@egjs/children-differ\";\n * // script => eg.ChildrenDiffer.diff\n * const result = diff([0, 1, 2, 3, 4, 5], [7, 8, 0, 4, 3, 6, 2, 1]);\n * // List before update\n * // [1, 2, 3, 4, 5]\n * console.log(result.prevList);\n * // Updated list\n * // [4, 3, 6, 2, 1]\n * console.log(result.list);\n * // Index array of values added to `list`\n * // [0, 1, 5]\n * console.log(result.added);\n * // Index array of values removed in `prevList`\n * // [5]\n * console.log(result.removed);\n * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`\n * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n * console.log(result.changed);\n * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)\n * // [[4, 3], [3, 4], [2, 6]]\n * console.log(result.pureChanged);\n * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)\n * // [[4, 1], [4, 2], [4, 3]]\n * console.log(result.ordered);\n * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved\n * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n * console.log(result.maintained);\n */\n\nfunction diff(prevList, list) {\n  return diff$1(prevList, list, findKeyCallback);\n}\n\n/*\negjs-children-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\n\nexport default ChildrenDiffer;\nexport { diff };\n//# sourceMappingURL=children-differ.esm.js.map\n", "import { convertUnitSize, dot, flat, isNumber, isObject, throttle } from \"@daybrush/utils\";\nimport { diff } from \"@egjs/children-differ\";\nimport {\n    MoveableManagerInterface, SnappableProps,\n    SnappableState, SnapGuideline, SnapDirectionPoses,\n    PosGuideline, ElementGuidelineValue,\n    SnapElementRect,\n    NumericPosGuideline,\n} from \"../../types\";\nimport { getRect, getAbsolutePosesByState, getRefTarget, calculateInversePosition, prefix, abs } from \"../../utils\";\nimport {\n    splitSnapDirectionPoses, getSnapDirections,\n    HORIZONTAL_NAMES_MAP, VERTICAL_NAMES_MAP, calculateContainerPos, SNAP_SKIP_NAMES_MAP,\n} from \"./utils\";\n\nexport function getTotalGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n) {\n    const state = moveable.state;\n    const {\n        containerClientRect,\n        hasFixed,\n    } = state;\n    const {\n        overflow,\n        scrollHeight: containerHeight,\n        scrollWidth: containerWidth,\n        clientHeight: containerClientHeight,\n        clientWidth: containerClientWidth,\n        clientLeft,\n        clientTop,\n    } = containerClientRect;\n    const {\n        snapGap = true,\n        verticalGuidelines,\n        horizontalGuidelines,\n        snapThreshold = 5,\n        maxSnapElementGuidelineDistance = Infinity,\n        isDisplayGridGuidelines,\n    } = moveable.props;\n    const { top, left, bottom, right } = getRect(getAbsolutePosesByState(moveable.state));\n    const targetRect = { top, left, bottom, right, center: (left + right) / 2, middle: (top + bottom) / 2 };\n    const elementGuidelines = getElementGuidelines(moveable);\n    let totalGuidelines: SnapGuideline[] = [...elementGuidelines];\n\n    const snapThresholdMultiples = (state.snapThresholdInfo?.multiples ?? [1, 1]).map(n => n * snapThreshold);\n\n    if (snapGap) {\n        totalGuidelines.push(...getGapGuidelines(\n            moveable,\n            targetRect,\n            snapThresholdMultiples,\n        ));\n    }\n    const snapOffset = {\n        ...(state.snapOffset || {\n            left: 0,\n            top: 0,\n            bottom: 0,\n            right: 0,\n        }),\n    };\n\n    totalGuidelines.push(...getGridGuidelines(\n        moveable,\n        overflow ? containerWidth! : containerClientWidth!,\n        overflow ? containerHeight! : containerClientHeight!,\n        clientLeft,\n        clientTop,\n        snapOffset,\n        isDisplayGridGuidelines,\n    ));\n\n\n    if (hasFixed) {\n        const { left, top } = containerClientRect;\n\n        snapOffset.left += left;\n        snapOffset.top += top;\n        snapOffset.right += left;\n        snapOffset.bottom += top;\n    }\n\n    totalGuidelines.push(...getDefaultGuidelines(\n        horizontalGuidelines || false,\n        verticalGuidelines || false,\n        overflow ? containerWidth! : containerClientWidth!,\n        overflow ? containerHeight! : containerClientHeight!,\n        clientLeft,\n        clientTop,\n        snapOffset,\n    ));\n\n    totalGuidelines = totalGuidelines.filter(({ element, elementRect, type }) => {\n        if (!element || !elementRect) {\n            return true;\n        }\n        const rect = elementRect.rect;\n\n        return checkBetweenRects(targetRect, rect, type, maxSnapElementGuidelineDistance);\n    });\n\n    return totalGuidelines;\n}\n\nexport function getGapGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    targetRect: SnapDirectionPoses,\n    snapThresholds: number[],\n) {\n    const {\n        maxSnapElementGuidelineDistance = Infinity,\n        maxSnapElementGapDistance = Infinity,\n    } = moveable.props;\n    const elementRects = moveable.state.elementRects;\n    const gapGuidelines: SnapGuideline[] = [];\n    [\n        [\"vertical\", VERTICAL_NAMES_MAP, HORIZONTAL_NAMES_MAP] as const,\n        [\"horizontal\", HORIZONTAL_NAMES_MAP, VERTICAL_NAMES_MAP] as const,\n    ].forEach(([type, mainNames, sideNames]) => {\n        const targetStart = targetRect[mainNames.start]!;\n        const targetEnd = targetRect[mainNames.end]!;\n        const targetCenter = targetRect[mainNames.center]!;\n        const targetStart2 = targetRect[sideNames.start]!;\n        const targetEnd2 = targetRect[sideNames.end]!;\n\n        // element : moveable\n        const snapThresholdMap = {\n            left: snapThresholds[0],\n            top: snapThresholds[1],\n        };\n\n        function getDist(elementRect: SnapElementRect) {\n            const rect = elementRect.rect;\n            const snapThreshold = snapThresholdMap[mainNames.start];\n\n            if (rect[mainNames.end]! < targetStart + snapThreshold) {\n                return targetStart - rect[mainNames.end]!;\n            } else if (targetEnd - snapThreshold < rect[mainNames.start]!) {\n                return rect[mainNames.start]! - targetEnd;\n            } else {\n                return -1;\n            }\n        }\n        const nextElementRects = elementRects.filter(elementRect => {\n            const rect = elementRect.rect;\n\n            if (rect[sideNames.start]! > targetEnd2 || rect[sideNames.end]! < targetStart2) {\n                return false;\n            }\n\n            return getDist(elementRect) > 0;\n        }).sort((a, b) => {\n            return getDist(a) - getDist(b);\n        });\n\n        const groups: SnapElementRect[][] = [];\n\n        nextElementRects.forEach(snapRect1 => {\n            nextElementRects.forEach(snapRect2 => {\n                if (snapRect1 === snapRect2) {\n                    return;\n                }\n                const { rect: rect1 } = snapRect1;\n                const { rect: rect2 } = snapRect2;\n\n                const rect1Start = rect1[sideNames.start]!;\n                const rect1End = rect1[sideNames.end]!;\n                const rect2Start = rect2[sideNames.start]!;\n                const rect2End = rect2[sideNames.end]!;\n\n                if (rect1Start > rect2End || rect2Start > rect1End) {\n                    return;\n                }\n\n                groups.push([snapRect1, snapRect2]);\n            });\n        });\n\n        groups.forEach(([snapRect1, snapRect2]) => {\n            const { rect: rect1 } = snapRect1;\n            const { rect: rect2 } = snapRect2;\n\n            const rect1Start = rect1[mainNames.start]!;\n            const rect1End = rect1[mainNames.end]!;\n            const rect2Start = rect2[mainNames.start]!;\n            const rect2End = rect2[mainNames.end]!;\n            const snapThreshold = snapThresholdMap[mainNames.start];\n            let gap = 0;\n            let pos = 0;\n            let isStart = false;\n            let isCenter = false;\n            let isEnd = false;\n\n            if (rect1End <= targetStart && targetEnd <= rect2Start) {\n                // (l)element1(r) : (l)target(r) : (l)element2(r)\n                isCenter = true;\n                gap = ((rect2Start - rect1End) - (targetEnd - targetStart)) / 2;\n                pos = rect1End + gap + (targetEnd - targetStart) / 2;\n\n                if (abs(pos - targetCenter) > snapThreshold) {\n                    return;\n                }\n            } else if (rect1End < rect2Start && rect2End < targetStart + snapThreshold) {\n                // (l)element1(r) : (l)element2(r) : (l)target\n                isStart = true;\n\n                gap = rect2Start - rect1End;\n                pos = rect2End + gap;\n\n                if (abs(pos - targetStart) > snapThreshold) {\n                    return;\n                }\n            } else if (rect1End < rect2Start && targetEnd - snapThreshold < rect1Start) {\n                // target(r) : (l)element1(r) : (l)element2(r)\n\n                isEnd = true;\n                gap = rect2Start - rect1End;\n                pos = rect1Start - gap;\n\n                if (abs(pos - targetEnd) > snapThreshold) {\n                    return;\n                }\n            } else {\n                return;\n            }\n            if (!gap) {\n                return;\n            }\n            if (!checkBetweenRects(targetRect, rect2, type, maxSnapElementGuidelineDistance)) {\n                return;\n            }\n            if (gap > maxSnapElementGapDistance) {\n                return;\n            }\n            gapGuidelines.push({\n                type,\n                pos: type === \"vertical\" ? [pos, 0] : [0, pos],\n                element: snapRect2.element,\n                size: 0,\n                className: snapRect2.className,\n                isStart,\n                isCenter,\n                isEnd,\n                gap,\n                hide: true,\n                gapRects: [snapRect1, snapRect2],\n                direction: \"\",\n                elementDirection: \"\",\n            });\n        });\n    });\n    return gapGuidelines;\n}\n\nexport function startGridGroupGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    clientLeft: number,\n    clientTop: number,\n    snapOffset: { left: number, top: number, right: number, bottom: number },\n) {\n    const props = moveable.props;\n    const state = moveable.state;\n    const {\n        snapGridAll,\n    } = props;\n    const {\n        snapGridWidth = 0,\n        snapGridHeight = 0,\n    } = props;\n    const {\n        snapRenderInfo,\n    } = state;\n    const hasDirection = snapRenderInfo && (snapRenderInfo.direction?.[0] || snapRenderInfo.direction?.[1]);\n    const moveables = moveable.moveables;\n    const ignores = [false, false];\n\n    // snap group's all child to grid.\n    if (\n        snapGridAll\n        && moveables\n        && hasDirection\n        && (snapGridWidth || snapGridHeight)\n    ) {\n        if (state.snapThresholdInfo) {\n            return;\n        }\n        state.snapThresholdInfo = {\n            multiples: [1, 1],\n            offset: [0, 0],\n        };\n\n        const rect = moveable.getRect();\n        const children = rect.children;\n        const direction = snapRenderInfo.direction!;\n\n\n        if (children) {\n            const result = direction.map((dir, i) => {\n                const {\n                    snapSize,\n                    posName,\n                    sizeName,\n                    clientOffset,\n                } = i === 0 ? {\n                    snapSize: snapGridWidth,\n                    posName: \"left\",\n                    sizeName: \"width\",\n                    clientOffset: snapOffset.left - clientLeft,\n                } as const : {\n                    snapSize: snapGridHeight,\n                    posName: \"top\",\n                    sizeName: \"height\",\n                    clientOffset: snapOffset.top - clientTop,\n                } as const;\n\n                if (!snapSize) {\n                    return {\n                        dir,\n                        multiple: 1,\n                        snapSize,\n                        snapOffset: 0,\n                    };\n                }\n                const rectSize = rect[sizeName];\n                const rectPos = rect[posName];\n\n                // 사이즈보다 만약 작다면 어떻게 해야되죠?\n                const childSizes = flat(children.map(child => {\n                    return [\n                        (child[posName] - rectPos),\n                        (child[sizeName]),\n                        (rectSize - child[sizeName] - child[posName] + rectPos),\n                    ];\n                })).filter(v => v).sort((a, b) => {\n                    return a - b;\n                });\n\n                const firstChildSize = childSizes[0];\n                const childSnapSizes = childSizes.map(size => throttle(size / firstChildSize, 0.1) * snapSize);\n                let n = 1;\n\n                const rectRatio = throttle(rectSize / firstChildSize, 0.1);\n\n                for (n = 1; n <= 10; ++n) {\n                    if (childSnapSizes.every(childSize => {\n                        return childSize * n % 1 === 0;\n                    })) {\n                        break;\n                    }\n                }\n\n                // dir 1 (fixed -1)\n                // dir 0 (fixed 0)\n                // dir -1 (fixed 1)\n\n                const ratio = (-dir + 1) / 2;\n                const offsetPos = dot(\n                    rectPos - clientOffset,\n                    rectPos - clientOffset + rectSize,\n                    ratio, 1 - ratio,\n                );\n\n                return {\n                    multiple: rectRatio * n,\n                    dir,\n                    snapSize,\n                    snapOffset: Math.round(offsetPos / snapSize),\n                };\n            });\n\n            const multiples = result.map(r => r.multiple || 1);\n            state.snapThresholdInfo.multiples = multiples;\n            state.snapThresholdInfo.offset = result.map(r => r.snapOffset);\n\n            result.forEach((r, i) => {\n                if (r.snapSize) {\n                    ignores[i] = true;\n                }\n            });\n        }\n    } else {\n        state.snapThresholdInfo = null;\n    }\n}\n\n\nexport function getGridGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    containerWidth: number,\n    containerHeight: number,\n    clientLeft = 0,\n    clientTop = 0,\n    snapOffset: { left: number, top: number, right: number, bottom: number },\n    isDisplayGridGuidelines?: boolean,\n): SnapGuideline[] {\n    const props = moveable.props;\n    const state = moveable.state;\n    let {\n        snapGridWidth = 0,\n        snapGridHeight = 0,\n    } = props;\n    const guidelines: SnapGuideline[] = [];\n    const {\n        left: snapOffsetLeft,\n        top: snapOffsetTop,\n    } = snapOffset;\n    let startOffset = [0, 0];\n\n    startGridGroupGuidelines(\n        moveable,\n        clientLeft,\n        clientTop,\n        snapOffset,\n    );\n\n    const snapThresholdInfo = state.snapThresholdInfo;\n    const defaultSnapGridWidth = snapGridWidth;\n    const defaultSnapGridHeight = snapGridHeight;\n\n    if (snapThresholdInfo) {\n        snapGridWidth *= snapThresholdInfo.multiples[0] || 1;\n        snapGridHeight *= snapThresholdInfo.multiples[1] || 1;\n        startOffset = snapThresholdInfo.offset;\n    }\n\n    if (snapGridHeight) {\n        const pushGuideline = (pos: number) => {\n            guidelines.push({\n                type: \"horizontal\",\n                pos: [\n                    snapOffsetLeft,\n                    throttle(startOffset[1] * defaultSnapGridHeight + pos - clientTop + snapOffsetTop, 0.1),\n                ],\n                className: prefix(\"grid-guideline\"),\n                size: containerWidth!,\n                hide: !isDisplayGridGuidelines,\n                direction: \"\",\n                grid: true,\n            });\n        };\n        for (let pos = 0; pos <= containerHeight * 2; pos += snapGridHeight) {\n            pushGuideline(pos);\n        }\n        for (let pos = -snapGridHeight; pos >= -containerHeight; pos -= snapGridHeight) {\n            pushGuideline(pos);\n        }\n    }\n\n    if (snapGridWidth) {\n        const pushGuideline = (pos: number) => {\n            guidelines.push({\n                type: \"vertical\",\n                pos: [\n                    throttle(startOffset[0] * defaultSnapGridWidth + pos - clientLeft + snapOffsetLeft, 0.1),\n                    snapOffsetTop,\n                ],\n                className: prefix(\"grid-guideline\"),\n                size: containerHeight!,\n                hide: !isDisplayGridGuidelines,\n                direction: \"\",\n                grid: true,\n            });\n        };\n        for (let pos = 0; pos <= containerWidth * 2; pos += snapGridWidth) {\n            pushGuideline(pos);\n        }\n        for (let pos = -snapGridWidth; pos >= -containerWidth; pos -= snapGridWidth) {\n            pushGuideline(pos);\n        }\n    }\n\n    return guidelines;\n}\n\nexport function checkBetweenRects(\n    rect1: SnapDirectionPoses,\n    rect2: SnapDirectionPoses,\n    type: \"horizontal\" | \"vertical\",\n    distance: number,\n) {\n    if (type === \"horizontal\") {\n        return abs(rect1.right! - rect2.left!) <= distance\n            || abs(rect1.left! - rect2.right!) <= distance\n            || rect1.left! <= rect2.right! && rect2.left! <= rect1.right!;\n    } else if (type === \"vertical\") {\n        return abs(rect1.bottom! - rect2.top!) <= distance\n            || abs(rect1.top! - rect2.bottom!) <= distance\n            || rect1.top! <= rect2.bottom! && rect2.top! <= rect1.bottom!;\n    }\n    return true;\n}\n\n\nexport function getElementGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n) {\n    const state = moveable.state;\n\n    const {\n        elementGuidelines = [],\n    } = moveable.props;\n\n    if (!elementGuidelines.length) {\n        state.elementRects = [];\n        return [];\n    }\n\n    const prevValues = (state.elementRects || []).filter(snapRect => !snapRect.refresh);\n    const nextElementGuidelines = elementGuidelines.map(el => {\n        if (isObject(el) && \"element\" in el) {\n            return {\n                ...el,\n                element: getRefTarget(el.element, true)!,\n            };\n        }\n        return {\n            element: getRefTarget(el, true)!,\n        };\n    }).filter(value => {\n        return value.element;\n    }) as ElementGuidelineValue[];\n\n    const {\n        maintained,\n        added,\n    } = diff(prevValues.map(v => v.element), nextElementGuidelines.map(v => v.element));\n\n\n    const nextValues: SnapElementRect[] = [];\n    maintained.forEach(([prevIndex, nextIndex]) => {\n        nextValues[nextIndex] = prevValues[prevIndex];\n    });\n\n    getSnapElementRects(moveable, added.map(index => nextElementGuidelines[index])).map((rect, i) => {\n        nextValues[added[i]] = rect;\n    });\n\n\n    state.elementRects = nextValues;\n    const elementSnapDirections = getSnapDirections(moveable.props.elementSnapDirections);\n    const nextGuidelines: SnapGuideline[] = [];\n\n    nextValues.forEach(snapRect => {\n        const {\n            element,\n            top: topValue = elementSnapDirections.top,\n            left: leftValue = elementSnapDirections.left,\n            right: rightValue = elementSnapDirections.right,\n            bottom: bottomValue = elementSnapDirections.bottom,\n            center: centerValue = elementSnapDirections.center,\n            middle: middleValue = elementSnapDirections.middle,\n            className,\n            rect,\n        } = snapRect;\n        const {\n            horizontal,\n            vertical,\n            horizontalNames,\n            verticalNames,\n        } = splitSnapDirectionPoses({\n            top: topValue,\n            right: rightValue,\n            left: leftValue,\n            bottom: bottomValue,\n            center: centerValue,\n            middle: middleValue,\n        }, rect);\n        const rectTop = rect.top!;\n        const rectLeft = rect.left!;\n        const width = rect.right! - rectLeft;\n        const height = rect.bottom! - rectTop;\n        const sizes = [width, height];\n\n        vertical.forEach((pos, i) => {\n            nextGuidelines.push({\n                type: \"vertical\", element, pos: [\n                    throttle(pos, 0.1),\n                    rectTop,\n                ], size: height,\n                sizes,\n                className,\n                elementRect: snapRect,\n                elementDirection: SNAP_SKIP_NAMES_MAP[verticalNames[i]] || verticalNames[i],\n                direction: \"\",\n            });\n        });\n        horizontal.forEach((pos, i) => {\n            nextGuidelines.push({\n                type: \"horizontal\",\n                element,\n                pos: [\n                    rectLeft,\n                    throttle(pos, 0.1),\n                ],\n                size: width,\n                sizes,\n                className,\n                elementRect: snapRect,\n                elementDirection: SNAP_SKIP_NAMES_MAP[horizontalNames[i]] || horizontalNames[i],\n                direction: \"\",\n            });\n        });\n    });\n\n    return nextGuidelines;\n}\n\n\nfunction getObjectGuidelines(\n    guidelines: Array<PosGuideline | number | string> | false,\n    containerSize: number,\n): NumericPosGuideline[] {\n    return guidelines ? guidelines.map(info => {\n        const posGuideline = isObject(info) ? info : { pos: info };\n        const pos = posGuideline.pos;\n\n        if (isNumber(pos)) {\n            return posGuideline as NumericPosGuideline;\n        } else {\n            return {\n                ...posGuideline,\n                pos: convertUnitSize(pos, containerSize),\n            };\n        }\n    }) : [];\n}\n\nexport function getDefaultGuidelines(\n    horizontalGuidelines: Array<PosGuideline | number | string> | false,\n    verticalGuidelines: Array<PosGuideline | number | string> | false,\n    width: number,\n    height: number,\n    clientLeft = 0,\n    clientTop = 0,\n    snapOffset = { left: 0, top: 0, right: 0, bottom: 0 },\n): SnapGuideline[] {\n    const guidelines: SnapGuideline[] = [];\n    const {\n        left: snapOffsetLeft,\n        top: snapOffsetTop,\n        bottom: snapOffsetBottom,\n        right: snapOffsetRight,\n    } = snapOffset;\n    const snapWidth = width! + snapOffsetRight - snapOffsetLeft;\n    const snapHeight = height! + snapOffsetBottom - snapOffsetTop;\n\n    getObjectGuidelines(horizontalGuidelines, snapHeight).forEach(posInfo => {\n        guidelines.push({\n            type: \"horizontal\",\n            pos: [\n                snapOffsetLeft,\n                throttle(posInfo.pos - clientTop + snapOffsetTop, 0.1),\n            ],\n            size: snapWidth,\n            className: posInfo.className,\n            direction: \"\",\n        });\n    });\n    getObjectGuidelines(verticalGuidelines, snapWidth).forEach(posInfo => {\n        guidelines.push({\n            type: \"vertical\",\n            pos: [\n                throttle(posInfo.pos - clientLeft + snapOffsetLeft, 0.1),\n                snapOffsetTop,\n            ],\n            size: snapHeight,\n            className: posInfo.className,\n            direction: \"\",\n        });\n    });\n    return guidelines;\n}\n\n\n\nexport function getSnapElementRects(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    values: ElementGuidelineValue[],\n): SnapElementRect[] {\n    if (!values.length) {\n        return [];\n    }\n    const groupable = moveable.props.groupable;\n    const state = moveable.state;\n    const {\n        containerClientRect,\n        // targetClientRect: {\n        //     top: clientTop,\n        //     left: clientLeft,\n        // },\n        rootMatrix,\n        is3d,\n        offsetDelta,\n    } = state;\n    const n = is3d ? 4 : 3;\n    const [containerLeft, containerTop] = calculateContainerPos(rootMatrix, containerClientRect, n);\n    // const poses = getAbsolutePosesByState(state);\n    // const {\n    //     minX: targetLeft,\n    //     minY: targetTop,\n    // } = getMinMaxs(poses);\n    // const [distLeft, distTop] = minus([targetLeft, targetTop], calculateInversePosition(rootMatrix, [\n    //     clientLeft - containerLeft,\n    //     clientTop - containerTop,\n    // ], n)).map(pos => roundSign(pos));\n\n    const offsetLeft = groupable ? 0 : offsetDelta[0];\n    const offsetTop = groupable ? 0 : offsetDelta[1];\n\n    return values.map(value => {\n        const rect = value.element.getBoundingClientRect();\n        const left = rect.left - containerLeft - offsetLeft;\n        const top = rect.top - containerTop - offsetTop;\n        const bottom = top + rect.height;\n        const right = left + rect.width;\n        const [elementLeft, elementTop] = calculateInversePosition(rootMatrix, [left, top], n);\n        const [elementRight, elementBottom] = calculateInversePosition(rootMatrix, [right, bottom], n);\n\n        return {\n            ...value,\n            rect: {\n                left: elementLeft,\n                right: elementRight,\n                top: elementTop,\n                bottom: elementBottom,\n                center: (elementLeft + elementRight) / 2,\n                middle: (elementTop + elementBottom) / 2,\n            },\n        };\n    });\n}\n\n", "import {\n    Renderer,\n    SnappableProps,\n    SnappableState,\n    SnapGuideline,\n    ScalableProps,\n    SnapPosInfo,\n    RotatableProps,\n    RectInfo,\n    MoveableManagerInterface,\n    SnappableRenderType,\n    BoundType,\n    MoveableGroupInterface,\n    SnapDirectionInfo,\n} from \"../types\";\nimport {\n    prefix,\n    calculatePoses,\n    getRect,\n    getAbsolutePosesByState,\n    getAbsolutePoses,\n    getClientRect,\n    getRefTarget,\n    getDragDistByState,\n    triggerEvent,\n    getDirectionCondition,\n    abs,\n    watchValue,\n} from \"../utils\";\nimport {\n    find,\n    findIndex, hasClass, throttle,\n} from \"@daybrush/utils\";\nimport {\n    getDragDist,\n    scaleMatrix,\n    getPosByDirection,\n} from \"../gesto/GestoUtils\";\nimport { minus, rotate, plus } from \"@scena/matrix\";\nimport { dragControlCondition as rotatableDragControlCondtion } from \"./Rotatable\";\nimport { FLOAT_POINT_NUM } from \"../consts\";\nimport {\n    getInnerBoundInfo,\n    getCheckInnerBoundLineInfos,\n    checkRotateInnerBounds,\n    checkInnerBoundPoses,\n} from \"./snappable/innerBounds\";\nimport {\n    checkBoundPoses,\n    checkRotateBounds,\n    getBounds,\n} from \"./snappable/bounds\";\nimport {\n    checkSnaps,\n    getSnapInfosByDirection,\n    getNearOffsetInfo,\n    getCheckSnapDirections,\n} from \"./snappable/snap\";\nimport {\n    renderSnapPoses,\n    renderGuidelines,\n    renderDashedGuidelines,\n    renderGapGuidelines,\n} from \"./snappable/render\";\nimport {\n    getInitialBounds,\n    hasGuidelines,\n} from \"./snappable/utils\";\nimport {\n    checkMaxBounds,\n    checkMoveableSnapBounds,\n    getSnapBoundInfo,\n} from \"./snappable/snapBounds\";\nimport { getTotalGuidelines } from \"./snappable/getTotalGuidelines\";\nimport {\n    NAME_snapRotationThreshold, NAME_snapRotationDegrees,\n    NAME_snapHorizontalThreshold, NAME_snapVerticalThreshold,\n} from \"./snappable/names\";\n\n\nexport interface SnapPoses {\n    vertical: number[];\n    horizontal: number[];\n}\n\nexport function checkSnapInfo(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n) {\n    const state = moveable.state;\n    const container = state.container;\n    const snapContainer = moveable.props.snapContainer || container!;\n\n    if (state.snapContainer === snapContainer && state.guidelines && state.guidelines.length) {\n        return false;\n    }\n\n    const containerClientRect = state.containerClientRect;\n    const snapOffset = {\n        left: 0,\n        top: 0,\n        bottom: 0,\n        right: 0,\n    };\n\n    if (container !== snapContainer) {\n        const snapContainerTarget = getRefTarget(snapContainer, true);\n\n        if (snapContainerTarget) {\n            const snapContainerRect = getClientRect(snapContainerTarget);\n            const offset1 = getDragDistByState(state, [\n                snapContainerRect.left - containerClientRect.left,\n                snapContainerRect.top - containerClientRect.top,\n            ]);\n            const offset2 = getDragDistByState(state, [\n                snapContainerRect.right - containerClientRect.right,\n                snapContainerRect.bottom - containerClientRect.bottom,\n            ]);\n\n            snapOffset.left = throttle(offset1[0], 0.00001);\n            snapOffset.top = throttle(offset1[1], 0.00001);\n            snapOffset.right = throttle(offset2[0], 0.00001);\n            snapOffset.bottom = throttle(offset2[1], 0.00001);\n        }\n    }\n\n    state.snapContainer = snapContainer;\n    state.snapOffset = snapOffset;\n    state.guidelines = getTotalGuidelines(moveable);\n    state.enableSnap = true;\n    return true;\n}\n\nfunction getNextFixedPoses(\n    matrix: number[],\n    width: number,\n    height: number,\n    fixedDirection: number[],\n    fixedPos: number[],\n    is3d: boolean\n) {\n    const nextPoses = calculatePoses(matrix, width, height, is3d ? 4 : 3);\n    const nextFixedPos = getPosByDirection(nextPoses, fixedDirection);\n\n    return getAbsolutePoses(nextPoses, minus(fixedPos, nextFixedPos));\n}\n\nexport function normalized(value: number) {\n    return value ? value / abs(value) : 0;\n}\n\nexport function getSizeOffsetInfo(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    poses: number[][],\n    direction: number[],\n    keepRatio: boolean,\n    isRequest: boolean,\n    datas: any\n) {\n    const { fixedDirection } = datas;\n    const directions = getCheckSnapDirections(direction, fixedDirection, keepRatio);\n    const innerBoundLineInfos = getCheckInnerBoundLineInfos(moveable, poses, direction, keepRatio);\n    const offsets = [\n        ...getSnapBoundInfo(\n            moveable,\n            poses,\n            directions,\n            keepRatio,\n            isRequest,\n            datas\n        ),\n        ...getInnerBoundInfo(\n            moveable,\n            innerBoundLineInfos,\n            datas\n        ),\n    ];\n    const widthOffsetInfo = getNearOffsetInfo(offsets, 0);\n    const heightOffsetInfo = getNearOffsetInfo(offsets, 1);\n\n    return {\n        width: {\n            isBound: widthOffsetInfo.isBound,\n            offset: widthOffsetInfo.offset[0],\n        },\n        height: {\n            isBound: heightOffsetInfo.isBound,\n            offset: heightOffsetInfo.offset[1],\n        },\n    };\n}\n\nexport function recheckSizeByTwoDirection(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    poses: number[][],\n    width: number,\n    height: number,\n    maxWidth: number,\n    maxHeight: number,\n    direction: number[],\n    isRequest: boolean,\n    datas: any\n) {\n    const snapPos = getPosByDirection(poses, direction);\n\n    const {\n        horizontal: { offset: horizontalOffset },\n        vertical: { offset: verticalOffset },\n    } = checkMoveableSnapBounds(moveable, isRequest, {\n        vertical: [snapPos[0]],\n        horizontal: [snapPos[1]],\n    });\n\n    if (throttle(verticalOffset, FLOAT_POINT_NUM) || throttle(horizontalOffset, FLOAT_POINT_NUM)) {\n        const [nextWidthOffset, nextHeightOffset] = getDragDist({\n            datas,\n            distX: -verticalOffset,\n            distY: -horizontalOffset,\n        });\n        const nextWidth = Math.min(\n            maxWidth || Infinity,\n            width + direction[0] * nextWidthOffset\n        );\n        const nextHeight = Math.min(\n            maxHeight || Infinity,\n            height + direction[1] * nextHeightOffset\n        );\n\n        return [nextWidth - width, nextHeight - height];\n    }\n    return [0, 0];\n}\n\nexport function checkSizeDist(\n    moveable: MoveableManagerInterface<any, any>,\n    getNextPoses: (widthOffset: number, heightOffset: number) => number[][],\n    width: number,\n    height: number,\n    direction: number[],\n    fixedPosition: number[],\n    isRequest: boolean,\n    datas: any\n) {\n    const poses = getAbsolutePosesByState(moveable.state);\n    const keepRatio = moveable.props.keepRatio;\n\n    let widthOffset = 0;\n    let heightOffset = 0;\n\n    for (let i = 0; i < 2; ++i) {\n        const nextPoses = getNextPoses(widthOffset, heightOffset);\n        const {\n            width: widthOffsetInfo,\n            height: heightOffsetInfo,\n        } = getSizeOffsetInfo(\n            moveable,\n            nextPoses,\n            direction,\n            keepRatio,\n            isRequest,\n            datas\n        );\n\n        const isWidthBound = widthOffsetInfo.isBound;\n        const isHeightBound = heightOffsetInfo.isBound;\n        let nextWidthOffset = widthOffsetInfo.offset;\n        let nextHeightOffset = heightOffsetInfo.offset;\n\n\n        if (i === 1) {\n            if (!isWidthBound) {\n                nextWidthOffset = 0;\n            }\n            if (!isHeightBound) {\n                nextHeightOffset = 0;\n            }\n        }\n        if (i === 0 && isRequest && !isWidthBound && !isHeightBound) {\n            return [0, 0];\n        }\n        if (keepRatio) {\n            const widthDist =\n                abs(nextWidthOffset) * (width ? 1 / width : 1);\n            const heightDist =\n                abs(nextHeightOffset) * (height ? 1 / height : 1);\n            const isGetWidthOffset =\n                isWidthBound && isHeightBound\n                    ? widthDist < heightDist\n                    : isHeightBound ||\n                    (!isWidthBound && widthDist < heightDist);\n            if (isGetWidthOffset) {\n                // width : height = ? : heightOffset\n                nextWidthOffset = (width * nextHeightOffset) / height;\n            } else {\n                // width : height = widthOffset : ?\n                nextHeightOffset = (height * nextWidthOffset) / width;\n            }\n        }\n        widthOffset += nextWidthOffset;\n        heightOffset += nextHeightOffset;\n    }\n\n    if (!keepRatio && direction[0] && direction[1]) {\n        const { maxWidth, maxHeight } = checkMaxBounds(\n            moveable,\n            poses,\n            direction,\n            fixedPosition,\n            datas\n        );\n\n        const [nextWidthOffset, nextHeightOffset] = recheckSizeByTwoDirection(\n            moveable,\n            getNextPoses(widthOffset, heightOffset).map(pos => pos.map(p => throttle(p, FLOAT_POINT_NUM))),\n            width + widthOffset,\n            height + heightOffset,\n            maxWidth,\n            maxHeight,\n            direction,\n            isRequest,\n            datas\n        );\n\n        widthOffset += nextWidthOffset;\n        heightOffset += nextHeightOffset;\n    }\n\n    return [widthOffset, heightOffset];\n}\n\nexport function absDegree(deg: number) {\n    if (deg < 0) {\n        deg = deg % 360 + 360;\n    }\n    deg %= 360;\n    return deg;\n}\n\nexport function bumpDegree(baseDeg: number, snapDeg: number) {\n    // baseDeg -80\n    // snapDeg 270\n    // return -90\n    snapDeg = absDegree(snapDeg);\n\n    const count = Math.floor(baseDeg / 360);\n\n\n    const deg1 = count * 360 + 360 - snapDeg;\n    const deg2 = count * 360 + snapDeg;\n\n    return abs(baseDeg - deg1) < abs(baseDeg - deg2) ? deg1 : deg2;\n}\n\nexport function getMinDegreeDistance(deg1: number, deg2: number) {\n    deg1 = absDegree(deg1);\n    deg2 = absDegree(deg2);\n\n    const deg3 = absDegree(deg1 - deg2);\n\n    return Math.min(deg3, 360 - deg3);\n}\n\nexport function checkSnapRotate(\n    moveable: MoveableManagerInterface<SnappableProps & RotatableProps, any>,\n    rect: RectInfo,\n    dist: number,\n    rotation: number,\n) {\n    const props = moveable.props;\n    const snapRotationThreshold = props[NAME_snapRotationThreshold] ?? 5;\n    const snapRotationDegrees = props[NAME_snapRotationDegrees];\n\n    if (hasGuidelines(moveable, \"rotatable\")) {\n        const { pos1, pos2, pos3, pos4, origin: origin2 } = rect;\n        const rad = (dist * Math.PI) / 180;\n        const prevPoses = [pos1, pos2, pos3, pos4].map((pos) => minus(pos, origin2));\n        const nextPoses = prevPoses.map((pos) => rotate(pos, rad));\n\n        // console.log(moveable.state.left, moveable.state.top, moveable.state.origin);\n        // console.log(pos1, pos2, pos3, pos4, origin, rad, prevPoses, nextPoses);\n        const result = [\n            ...checkRotateBounds(moveable, prevPoses, nextPoses, origin2, dist),\n            ...checkRotateInnerBounds(\n                moveable,\n                prevPoses,\n                nextPoses,\n                origin2,\n                dist\n            ),\n        ];\n        result.sort((a, b) => abs(a - dist) - abs(b - dist));\n        const isSnap = result.length > 0;\n\n        if (isSnap) {\n            return {\n                isSnap,\n                dist: isSnap ? result[0] : dist,\n            };\n        }\n    }\n    if (snapRotationDegrees?.length && snapRotationThreshold) {\n\n\n        const sorted = snapRotationDegrees.slice().sort((a, b) => {\n            return getMinDegreeDistance(a, rotation) - getMinDegreeDistance(b, rotation);\n        });\n        const firstDegree = sorted[0];\n\n        if (getMinDegreeDistance(firstDegree, rotation) <= snapRotationThreshold) {\n\n            return {\n                isSnap: true,\n                dist: dist + bumpDegree(rotation, firstDegree) - rotation,\n            };\n        }\n    }\n    return {\n        isSnap: false,\n        dist,\n    };\n\n}\n\nexport function checkSnapResize(\n    moveable: MoveableManagerInterface<{}, {}>,\n    width: number,\n    height: number,\n    direction: number[],\n    fixedPosition: number[],\n    isRequest: boolean,\n    datas: any\n) {\n    if (!hasGuidelines(moveable, \"resizable\")) {\n        return [0, 0];\n    }\n    const { fixedDirection, nextAllMatrix } = datas;\n    const { allMatrix, is3d } = moveable.state;\n\n    return checkSizeDist(\n        moveable,\n        (widthOffset: number, heightOffset: number) => {\n            return getNextFixedPoses(\n                nextAllMatrix || allMatrix,\n                width + widthOffset,\n                height + heightOffset,\n                fixedDirection,\n                fixedPosition,\n                is3d\n            );\n        },\n        width,\n        height,\n        direction,\n        fixedPosition,\n        isRequest,\n        datas\n    );\n}\nexport function checkSnapScale(\n    moveable: MoveableManagerInterface<ScalableProps, any>,\n    scale: number[],\n    direction: number[],\n    isRequest: boolean,\n    datas: any\n) {\n    if (!hasGuidelines(moveable, \"scalable\")) {\n        return [0, 0];\n    }\n    const { startOffsetWidth, startOffsetHeight, fixedPosition, fixedDirection, is3d } = datas;\n    const sizeDist = checkSizeDist(\n        moveable,\n        (widthOffset: number, heightOffset: number) => {\n            return getNextFixedPoses(\n                scaleMatrix(\n                    datas,\n                    plus(scale, [widthOffset / startOffsetWidth, heightOffset / startOffsetHeight]),\n                ),\n                startOffsetWidth,\n                startOffsetHeight,\n                fixedDirection,\n                fixedPosition,\n                is3d\n            );\n        },\n        startOffsetWidth,\n        startOffsetHeight,\n        direction,\n        fixedPosition,\n        isRequest,\n        datas\n    );\n    return [sizeDist[0] / startOffsetWidth, sizeDist[1] / startOffsetHeight];\n}\n\nexport function startCheckSnapDrag(\n    moveable: MoveableManagerInterface<any, any>,\n    datas: any\n) {\n    datas.absolutePoses = getAbsolutePosesByState(moveable.state);\n}\n\n\n\nfunction getSnapGuidelines(posInfos: SnapPosInfo[]) {\n    const guidelines: Array<{ guideline: SnapGuideline, posInfo: SnapPosInfo }> = [];\n\n    posInfos.forEach((posInfo) => {\n        posInfo.guidelineInfos.forEach(({ guideline }) => {\n            if (find(guidelines, info => info.guideline === guideline)) {\n                return;\n            }\n            guideline.direction = \"\";\n            guidelines.push({ guideline, posInfo });\n        });\n    });\n\n    return guidelines.map(({ guideline, posInfo }) => {\n        return {\n            ...guideline,\n            direction: posInfo.direction,\n        };\n    });\n}\n\nfunction addBoundGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    verticalPoses: number[],\n    horizontalPoses: number[],\n    verticalSnapPoses: SnappableRenderType[],\n    horizontalSnapPoses: SnappableRenderType[],\n    externalBounds?: BoundType | false | null\n) {\n    const {\n        vertical: verticalBoundInfos,\n        horizontal: horizontalBoundInfos,\n    } = checkBoundPoses(\n        getBounds(moveable, externalBounds),\n        verticalPoses,\n        horizontalPoses\n    );\n\n    const boundMap = getInitialBounds();\n\n\n    verticalBoundInfos.forEach((info) => {\n        if (info.isBound) {\n            if (info.direction === \"start\") {\n                boundMap.left = true;\n            }\n            if (info.direction === \"end\") {\n                boundMap.right = true;\n            }\n            verticalSnapPoses.push({\n                type: \"bounds\",\n                pos: info.pos,\n            });\n        }\n    });\n    horizontalBoundInfos.forEach((info) => {\n        if (info.isBound) {\n            if (info.direction === \"start\") {\n                boundMap.top = true;\n            }\n            if (info.direction === \"end\") {\n                boundMap.bottom = true;\n            }\n            horizontalSnapPoses.push({\n                type: \"bounds\",\n                pos: info.pos,\n            });\n        }\n    });\n    const {\n        boundMap: innerBoundMap,\n        vertical: verticalInnerBoundPoses,\n        horizontal: horizontalInnerBoundPoses,\n    } = checkInnerBoundPoses(moveable);\n\n    verticalInnerBoundPoses.forEach((innerPos) => {\n        if (\n            findIndex(\n                verticalSnapPoses,\n                ({ type, pos }) => type === \"bounds\" && pos === innerPos\n            ) >= 0\n        ) {\n            return;\n        }\n        verticalSnapPoses.push({\n            type: \"bounds\",\n            pos: innerPos,\n        });\n    });\n\n    horizontalInnerBoundPoses.forEach((innerPos) => {\n        if (\n            findIndex(\n                horizontalSnapPoses,\n                ({ type, pos }) => type === \"bounds\" && pos === innerPos\n            ) >= 0\n        ) {\n            return;\n        }\n        horizontalSnapPoses.push({\n            type: \"bounds\",\n            pos: innerPos,\n        });\n    });\n\n    return {\n        boundMap,\n        innerBoundMap,\n    };\n}\n\nconst directionCondition = getDirectionCondition(\"\", [\"resizable\", \"scalable\"]);\n\n\n\n/**\n * @namespace Moveable.Snappable\n * @description Whether or not target can be snapped to the guideline. (default: false)\n * @sort 2\n */\nexport default {\n    name: \"snappable\",\n    dragRelation: \"strong\",\n    props: [\n        \"snappable\",\n        \"snapContainer\",\n        \"snapDirections\",\n        \"elementSnapDirections\",\n        \"snapGap\",\n        \"snapGridWidth\",\n        \"snapGridHeight\",\n        \"isDisplaySnapDigit\",\n        \"isDisplayInnerSnapDigit\",\n        \"isDisplayGridGuidelines\",\n        \"snapDigit\",\n        \"snapThreshold\",\n        \"snapRenderThreshold\",\n        \"snapGridAll\",\n        NAME_snapRotationThreshold,\n        NAME_snapRotationDegrees,\n        NAME_snapHorizontalThreshold,\n        NAME_snapVerticalThreshold,\n        \"horizontalGuidelines\",\n        \"verticalGuidelines\",\n        \"elementGuidelines\",\n        \"bounds\",\n        \"innerBounds\",\n        \"snapDistFormat\",\n        \"maxSnapElementGuidelineDistance\",\n        \"maxSnapElementGapDistance\",\n    ] as const,\n    events: [\"snap\", \"bound\"] as const,\n    css: [\n        `:host {\n--bounds-color: #d66;\n}\n.guideline {\npointer-events: none;\nz-index: 2;\n}\n.guideline.bounds {\nbackground: #d66;\nbackground: var(--bounds-color);\n}\n.guideline-group {\nposition: absolute;\ntop: 0;\nleft: 0;\n}\n.guideline-group .size-value {\nposition: absolute;\ncolor: #f55;\nfont-size: 12px;\nfont-size: calc(12px * var(--zoom));\nfont-weight: bold;\n}\n.guideline-group.horizontal .size-value {\ntransform-origin: 50% 100%;\ntransform: translateX(-50%);\nleft: 50%;\nbottom: 5px;\nbottom: calc(2px + 3px * var(--zoom));\n}\n.guideline-group.vertical .size-value {\ntransform-origin: 0% 50%;\ntop: 50%;\ntransform: translateY(-50%);\nleft: 5px;\nleft: calc(2px + 3px * var(--zoom));\n}\n.guideline.gap {\nbackground: #f55;\n}\n.size-value.gap {\ncolor: #f55;\n}\n`,\n    ],\n    render(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n        React: Renderer\n    ): any[] {\n        const state = moveable.state;\n        const {\n            top: targetTop,\n            left: targetLeft,\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n            snapRenderInfo,\n        } = state;\n        const {\n            snapRenderThreshold = 1,\n        } = moveable.props;\n\n        if (!snapRenderInfo || !snapRenderInfo.render || !hasGuidelines(moveable, \"\")) {\n            // reset store\n            watchValue(\n                moveable,\n                \"boundMap\",\n                getInitialBounds(),\n                v => JSON.stringify(v),\n            );\n            watchValue(\n                moveable,\n                \"innerBoundMap\",\n                getInitialBounds(),\n                v => JSON.stringify(v),\n            );\n            return [];\n        }\n        state.guidelines = getTotalGuidelines(moveable);\n\n\n        const minLeft = Math.min(pos1[0], pos2[0], pos3[0], pos4[0]);\n        const minTop = Math.min(pos1[1], pos2[1], pos3[1], pos4[1]);\n        const externalPoses = snapRenderInfo.externalPoses || [];\n        const poses = getAbsolutePosesByState(moveable.state);\n        const verticalSnapPoses: SnappableRenderType[] = [];\n        const horizontalSnapPoses: SnappableRenderType[] = [];\n        const verticalGuidelines: SnapGuideline[] = [];\n        const horizontalGuidelines: SnapGuideline[] = [];\n        const snapInfos: Array<{\n            vertical: SnapDirectionInfo;\n            horizontal: SnapDirectionInfo;\n        }> = [];\n        const { width, height, top, left, bottom, right } = getRect(poses);\n        const targetRect = { left, right, top, bottom, center: (left + right) / 2, middle: (top + bottom) / 2 };\n        const hasExternalPoses = externalPoses.length > 0;\n        const externalRect = hasExternalPoses\n            ? getRect(externalPoses)\n            : ({} as ReturnType<typeof getRect>);\n\n        if (!snapRenderInfo.request) {\n            if (snapRenderInfo.direction) {\n                snapInfos.push(\n                    getSnapInfosByDirection(\n                        moveable,\n                        poses,\n                        snapRenderInfo.direction,\n                        snapRenderThreshold,\n                        snapRenderThreshold,\n                    )\n                );\n            }\n            if (snapRenderInfo.snap) {\n                const rect = getRect(poses);\n                if (snapRenderInfo.center) {\n                    (rect as any).middle = (rect.top + rect.bottom) / 2;\n                    (rect as any).center = (rect.left + rect.right) / 2;\n                }\n                snapInfos.push(checkSnaps(moveable, rect, snapRenderThreshold, snapRenderThreshold));\n            }\n            if (hasExternalPoses) {\n                if (snapRenderInfo.center) {\n                    (externalRect as any).middle =\n                        (externalRect.top + externalRect.bottom) / 2;\n                    (externalRect as any).center =\n                        (externalRect.left + externalRect.right) / 2;\n                }\n                snapInfos.push(checkSnaps(moveable, externalRect, snapRenderThreshold, snapRenderThreshold));\n            }\n            snapInfos.forEach((snapInfo) => {\n                const {\n                    vertical: { posInfos: verticalPosInfos },\n                    horizontal: { posInfos: horizontalPosInfos },\n                } = snapInfo;\n                verticalSnapPoses.push(\n                    ...verticalPosInfos.filter(({ guidelineInfos }) => {\n                        return guidelineInfos.some(({ guideline }) => !guideline.hide);\n                    }).map(\n                        (posInfo) => ({\n                            type: \"snap\",\n                            pos: posInfo.pos,\n                        } as const)\n                    )\n                );\n                horizontalSnapPoses.push(\n                    ...horizontalPosInfos.filter(({ guidelineInfos }) => {\n                        return guidelineInfos.some(({ guideline }) => !guideline.hide);\n                    }).map(\n                        (posInfo) => ({\n                            type: \"snap\",\n                            pos: posInfo.pos,\n                        } as const)\n                    )\n                );\n\n                verticalGuidelines.push(...getSnapGuidelines(verticalPosInfos));\n                horizontalGuidelines.push(...getSnapGuidelines(horizontalPosInfos));\n            });\n        }\n\n        const {\n            boundMap,\n            innerBoundMap,\n        } = addBoundGuidelines(\n            moveable,\n            [left, right],\n            [top, bottom],\n            verticalSnapPoses,\n            horizontalSnapPoses\n        );\n        if (hasExternalPoses) {\n            addBoundGuidelines(\n                moveable,\n                [externalRect.left, externalRect.right],\n                [externalRect.top, externalRect.bottom],\n                verticalSnapPoses,\n                horizontalSnapPoses,\n                snapRenderInfo.externalBounds\n            );\n        }\n        const allGuidelines = [...verticalGuidelines, ...horizontalGuidelines];\n        const elementGuidelines = allGuidelines.filter(guideline => guideline.element && !guideline.gapRects);\n        const gapGuidelines = allGuidelines.filter(guideline => guideline.gapRects).sort((a, b) => {\n            return a.gap! - b.gap!;\n        });\n\n        triggerEvent(\n            moveable,\n            \"onSnap\",\n            {\n                guidelines: allGuidelines.filter(({ element }) => !element),\n                elements: elementGuidelines,\n                gaps: gapGuidelines,\n            },\n            true\n        );\n\n        const nextBoundMap = watchValue(\n            moveable,\n            \"boundMap\",\n            boundMap,\n            v => JSON.stringify(v),\n            getInitialBounds(),\n        );\n        const nextInnerBoundMap = watchValue(\n            moveable,\n            \"innerBoundMap\",\n            innerBoundMap,\n            v => JSON.stringify(v),\n            getInitialBounds(),\n        );\n\n        if (boundMap === nextBoundMap || innerBoundMap === nextInnerBoundMap) {\n            triggerEvent(\n                moveable,\n                \"onBound\",\n                {\n                    bounds: boundMap,\n                    innerBounds: innerBoundMap,\n                },\n                true\n            );\n        }\n\n\n\n        // verticalSnapPoses.\n        return [\n            ...renderDashedGuidelines(\n                moveable,\n                elementGuidelines,\n                [minLeft, minTop],\n                targetRect,\n                React,\n            ),\n            ...renderGapGuidelines(\n                moveable,\n                gapGuidelines,\n                [minLeft, minTop],\n                targetRect,\n                React,\n            ),\n            ...renderGuidelines(\n                moveable,\n                \"horizontal\",\n                horizontalGuidelines,\n                [targetLeft, targetTop],\n                targetRect,\n                React\n            ),\n            ...renderGuidelines(\n                moveable,\n                \"vertical\",\n                verticalGuidelines,\n                [targetLeft, targetTop],\n                targetRect,\n                React\n            ),\n            ...renderSnapPoses(\n                moveable,\n                \"horizontal\",\n                horizontalSnapPoses,\n                minLeft,\n                targetTop,\n                width,\n                0,\n                React\n            ),\n            ...renderSnapPoses(\n                moveable,\n                \"vertical\",\n                verticalSnapPoses,\n                minTop,\n                targetLeft,\n                height,\n                1,\n                React\n            ),\n        ];\n    },\n    dragStart(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n        e: any\n    ) {\n        moveable.state.snapRenderInfo = {\n            request: e.isRequest,\n            snap: true,\n            center: true,\n        };\n        checkSnapInfo(moveable);\n    },\n    drag(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        const state = moveable.state;\n        if (!checkSnapInfo(moveable)) {\n            state.guidelines = getTotalGuidelines(moveable);\n        }\n        if (state.snapRenderInfo) {\n            state.snapRenderInfo.render = true;\n        }\n    },\n    pinchStart(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        this.unset(moveable);\n    },\n    dragEnd(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        this.unset(moveable);\n    },\n    dragControlCondition(moveable: MoveableManagerInterface, e: any) {\n        if (directionCondition(moveable, e) || rotatableDragControlCondtion(moveable, e)) {\n            return true;\n        }\n        if (!e.isRequest && e.inputEvent) {\n            return hasClass(e.inputEvent.target, prefix(\"snap-control\"));\n        }\n    },\n    dragControlStart(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        moveable.state.snapRenderInfo = null;\n        checkSnapInfo(moveable);\n    },\n    dragControl(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        this.drag(moveable);\n    },\n    dragControlEnd(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        this.unset(moveable);\n    },\n    dragGroupStart(moveable: any, e: any) {\n        this.dragStart(moveable, e);\n    },\n    dragGroup(\n        moveable: MoveableGroupInterface<SnappableProps, SnappableState>\n    ) {\n        this.drag(moveable);\n    },\n    dragGroupEnd(\n        moveable: MoveableGroupInterface<SnappableProps, SnappableState>\n    ) {\n        this.unset(moveable);\n    },\n    dragGroupControlStart(\n        moveable: MoveableGroupInterface<SnappableProps, SnappableState>\n    ) {\n        moveable.state.snapRenderInfo = null;\n        checkSnapInfo(moveable);\n    },\n    dragGroupControl(\n        moveable: MoveableManagerInterface<SnappableProps, SnappableState>\n    ) {\n        this.drag(moveable);\n    },\n    dragGroupControlEnd(\n        moveable: MoveableGroupInterface<SnappableProps, SnappableState>\n    ) {\n        this.unset(moveable);\n    },\n    unset(moveable: any) {\n        const state = moveable.state;\n\n        state.enableSnap = false;\n        state.guidelines = [];\n        state.snapRenderInfo = null;\n        state.elementRects = [];\n    },\n};\n\n\n/**\n * Whether or not target can be snapped to the guideline. (default: false)\n * @name Moveable.Snappable#snappable\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snappable = true;\n */\n/**\n *  A snap container that is the basis for snap, bounds, and innerBounds. (default: null = container)\n * @name Moveable.Snappable#snapContainer\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.querySelector(\".container\"));\n *\n * moveable.snapContainer = document.body;\n */\n/**\n * You can specify the directions to snap to the target. (default: { left: true, top: true, right: true, bottom: true })\n * @name Moveable.Snappable#snapDirections\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   snapDirections: true,\n * });\n * // snap center\n * moveable.snapDirections = { left: true, top: true, right: true, bottom: true, center: true, middle: true };\n */\n\n/**\n * You can specify the snap directions of elements. (default: { left: true, ftrue, right: true, bottom: true })\n * @name Moveable.Snappable#elementSnapDirections\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   elementSnapDirections: true,\n * });\n * // snap center\n * moveable.elementSnapDirections = { left: true, top: true, right: true, bottom: true, center: true, middle: true };\n */\n/**\n * When you drag, make the gap snap in the element guidelines. (default: true)\n * @name Moveable.Snappable#snapGap\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   snapElement: true,\n *   snapGap: true,\n * });\n *\n * moveable.snapGap = false;\n */\n/**\n * Distance value that can snap to guidelines. (default: 5)\n * @name Moveable.Snappable#snapThreshold\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapThreshold = 5;\n */\n\n/**\n * Add guidelines in the horizontal direction. (default: [])\n * @name Moveable.Snappable#horizontalGuidelines\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.horizontalGuidelines = [100, 200, 500];\n */\n\n/**\n * Add guidelines in the vertical direction. (default: [])\n * @name Moveable.Snappable#verticalGuidelines\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.verticalGuidelines = [100, 200, 500];\n */\n/**\n * Add guidelines for the element. (default: [])\n * @name Moveable.Snappable#elementGuidelines\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.elementGuidelines = [\n *   document.querySelector(\".element\"),\n * ];\n */\n/**\n * You can set up boundaries.\n * @name Moveable.Snappable#bounds\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @default null\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.bounds = { left: 0, right: 1000, top: 0, bottom: 1000};\n */\n/**\n * You can set up inner boundaries.\n * @name Moveable.Snappable#innerBounds\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @default null\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.innerBounds = { left: 500, top: 500, width: 100, height: 100};\n */\n/**\n * snap distance digits (default: 0)\n * @name Moveable.Snappable#snapDigit\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapDigit = 0\n */\n\n/**\n * If width size is greater than 0, you can vertical snap to the grid. (default: 0)\n * @name Moveable.Snappable#snapGridWidth\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapGridWidth = 5;\n */\n\n/**\n * If height size is greater than 0, you can horizontal snap to the grid. (default: 0)\n * @name Moveable.Snappable#snapGridHeight\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapGridHeight = 5;\n */\n/**\n * Whether to show snap distance (default: true)\n * @name Moveable.Snappable#isDisplaySnapDigit\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.isDisplaySnapDigit = true;\n */\n\n/**\n * Whether to show element inner snap distance (default: false)\n * @name Moveable.Snappable#isDisplayInnerSnapDigit\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.isDisplayInnerSnapDigit = true;\n */\n\n\n/**\n * You can set the text format of the distance shown in the guidelines. (default: self)\n * @name Moveable.Snappable#snapDistFormat\n * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Snappable.html#.SnappableOptions}\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  snappable: true,\n *  snapDistFormat: (v, type) => v,\n * });\n * moveable.snapDistFormat = (v, type) => `${v}px`;\n */\n\n/**\n * When you drag or dragControl, the `snap` event is called.\n * @memberof Moveable.Snappable\n * @event snap\n * @param {Moveable.Snappable.OnSnap} - Parameters for the `snap` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     snappable: true\n * });\n * moveable.on(\"snap\", e => {\n *     console.log(\"onSnap\", e);\n * });\n */\n", "import { PREFIX, IS_WEBKIT605, TINY_NUM } from './consts';\nimport { prefixNames } from './utils/framework-utils';\nimport {\n  isUndefined,\n  isObject,\n  splitUnit,\n  IObject,\n  hasClass,\n  isArray,\n  isString,\n  getRad,\n  isFunction,\n  convertUnitSize,\n  between,\n  getKeys,\n  decamelize,\n  isNumber,\n  getDocumentBody,\n  getDocumentElement,\n  getWindow,\n  isNode,\n  isWindow,\n  counter,\n} from '@daybrush/utils';\nimport {\n  multiply,\n  invert,\n  convertDimension,\n  createIdentityMatrix,\n  createOriginMatrix,\n  convertPositionMatrix,\n  calculate,\n  multiplies,\n  minus,\n  createScaleMatrix,\n  plus,\n  convertMatrixtoCSS,\n  rotate,\n} from '@scena/matrix';\nimport {\n  MoveableManagerState,\n  Able,\n  MoveableClientRect,\n  MoveableProps,\n  ArrayFormat,\n  MoveableRefType,\n  MatrixInfo,\n  ExcludeEndParams,\n  ExcludeParams,\n  ElementSizes,\n  TransformObject,\n  MoveableRefTargetsResultType,\n  MoveableRefTargetType,\n  MoveableManagerInterface,\n  CSSObject,\n  PaddingBox,\n} from './types';\nimport { parse, toMat, calculateMatrixDist, parseMat } from 'css-to-mat';\nimport { getBeforeRenderableDatas, getDragDist } from './gesto/GestoUtils';\nimport { getGestoData } from './gesto/GestoData';\nimport { GetStyle, getCachedStyle } from './store/Store';\nimport { normalized } from './ables/Snappable';\n\nexport function round(num: number) {\n  return Math.round(num);\n}\nexport function multiply2(pos1: number[], pos2: number[]) {\n  return [pos1[0] * pos2[0], pos1[1] * pos2[1]];\n}\nexport function prefix(...classNames: string[]) {\n  return prefixNames(PREFIX, ...classNames);\n}\n\nexport function defaultSync(fn: () => void) {\n  fn();\n}\n\nexport function createIdentityMatrix3() {\n  return createIdentityMatrix(3);\n}\n\nexport function getTransformMatrix(transform: string | number[]) {\n  if (!transform || transform === 'none') {\n    return [1, 0, 0, 1, 0, 0];\n  }\n  if (isObject(transform)) {\n    return transform;\n  }\n  return parseMat(transform);\n}\nexport function getAbsoluteMatrix(\n  matrix: number[],\n  n: number,\n  origin: number[],\n) {\n  return multiplies(\n    n,\n    createOriginMatrix(origin, n),\n    matrix,\n    createOriginMatrix(\n      origin.map((a) => -a),\n      n,\n    ),\n  );\n}\nexport function measureSVGSize(\n  el: SVGElement,\n  unit: string,\n  isHorizontal: boolean,\n) {\n  if (unit === '%') {\n    const viewBox = getSVGViewBox(el.ownerSVGElement!);\n\n    return viewBox[isHorizontal ? 'width' : 'height'] / 100;\n  }\n  return 1;\n}\nexport function getBeforeTransformOrigin(el: SVGElement) {\n  const relativeOrigin = getTransformOrigin(getComputedStyle(el, ':before'));\n\n  return relativeOrigin.map((o, i) => {\n    const { value, unit } = splitUnit(o);\n\n    return value * measureSVGSize(el, unit, i === 0);\n  });\n}\nexport function getTransformOriginArray(transformOrigin: string) {\n  return transformOrigin ? transformOrigin.split(' ') : ['0', '0'];\n}\nexport function getTransformOrigin(style: CSSStyleDeclaration) {\n  return getTransformOriginArray(style.transformOrigin);\n}\nexport function getElementTransform(target: HTMLElement | SVGElement): string {\n  const getStyle = getCachedStyle(target);\n  const computedTransform = getStyle('transform');\n\n  if (computedTransform && computedTransform !== 'none') {\n    return computedTransform;\n  }\n  if ('transform' in target) {\n    const list = (target as any).transform as SVGAnimatedTransformList;\n    const baseVal = list.baseVal;\n\n    if (!baseVal) {\n      return '';\n    }\n    const length = baseVal.length;\n\n    if (!length) {\n      return '';\n    }\n\n    const matrixes: string[] = [];\n\n    for (let i = 0; i < length; ++i) {\n      const matrix = baseVal[i].matrix;\n\n      matrixes.push(\n        `matrix(${(['a', 'b', 'c', 'd', 'e', 'f'] as const).map((chr) => matrix[chr]).join(', ')})`,\n      );\n    }\n    return matrixes.join(' ');\n  }\n  return '';\n}\n\nexport function getOffsetInfo(\n  el: SVGElement | HTMLElement | null | undefined,\n  lastParent: SVGElement | HTMLElement | null | undefined,\n  isParent?: boolean,\n  checkZoom?: boolean,\n  getTargetStyle?: GetStyle,\n) {\n  const documentElement = getDocumentElement(el!) || getDocumentBody(el!);\n  let hasSlot = false;\n  let target: HTMLElement | SVGElement | null | undefined;\n  let parentSlotElement: HTMLElement | null | undefined;\n\n  if (!el || isParent) {\n    target = el;\n  } else {\n    const assignedSlotParentElement = el?.assignedSlot?.parentElement;\n    const parentElement = el.parentElement;\n\n    if (assignedSlotParentElement) {\n      hasSlot = true;\n      parentSlotElement = parentElement;\n      target = assignedSlotParentElement;\n    } else {\n      target = parentElement;\n    }\n  }\n\n  let isCustomElement = false;\n  let isEnd = el === lastParent || target === lastParent;\n  let position = 'relative';\n  let offsetZoom = 1;\n\n  const targetZoom = parseFloat(getTargetStyle?.('zoom')) || 1;\n  const targetPosition = getTargetStyle?.('position');\n\n  while (target && target !== documentElement) {\n    if (lastParent === target) {\n      isEnd = true;\n    }\n    const getStyle = getCachedStyle(target);\n    const tagName = target.tagName.toLowerCase();\n    const transform = getElementTransform(target as SVGElement);\n    const willChange = getStyle('willChange');\n    const zoom = parseFloat(getStyle('zoom')) || 1;\n\n    position = getStyle('position');\n    if (checkZoom && zoom !== 1) {\n      offsetZoom = zoom;\n      break;\n    }\n    if (\n      // offsetParent is the parentElement if the target's zoom is not 1 and not absolute.\n      (!isParent &&\n        checkZoom &&\n        targetZoom !== 1 &&\n        targetPosition &&\n        targetPosition !== 'absolute') ||\n      tagName === 'svg' ||\n      tagName === 'foreignobject' ||\n      position !== 'static' ||\n      (transform && transform !== 'none') ||\n      willChange === 'transform'\n    ) {\n      break;\n    }\n    const slotParentNode = el?.assignedSlot?.parentNode;\n    const targetParentNode = target.parentNode;\n\n    if (slotParentNode) {\n      hasSlot = true;\n      parentSlotElement = targetParentNode as HTMLElement;\n    }\n    const parentNode = targetParentNode;\n\n    if (parentNode && parentNode.nodeType === 11) {\n      // Shadow Root\n      target = (parentNode as ShadowRoot).host as HTMLElement;\n      isCustomElement = true;\n      position = getCachedStyle(target)('position');\n      break;\n    }\n    target = parentNode as HTMLElement | SVGElement;\n    position = 'relative';\n  }\n  return {\n    offsetZoom,\n    hasSlot,\n    parentSlotElement,\n    isCustomElement,\n    isStatic: position === 'static',\n    isEnd: isEnd || !target || target === documentElement,\n    offsetParent: (target as HTMLElement) || documentElement,\n  };\n}\n\nexport function getOffsetPosInfo(\n  el: HTMLElement | SVGElement,\n  target: HTMLElement | SVGElement,\n) {\n  const tagName = el.tagName.toLowerCase();\n  let offsetLeft = (el as HTMLElement).offsetLeft;\n  let offsetTop = (el as HTMLElement).offsetTop;\n  const getStyle = getCachedStyle(el);\n  // svg\n  const isSVG = isUndefined(offsetLeft);\n  let hasOffset = !isSVG;\n  let origin: number[];\n  let targetOrigin: number[];\n  // inner svg element\n  if (!hasOffset && (tagName !== 'svg' || (el as SVGElement).ownerSVGElement)) {\n    origin = IS_WEBKIT605\n      ? getBeforeTransformOrigin(el as SVGElement)\n      : getTransformOriginArray(getStyle('transformOrigin')).map((pos) =>\n          parseFloat(pos),\n        );\n\n    targetOrigin = origin.slice();\n    hasOffset = true;\n\n    if (tagName === 'svg') {\n      offsetLeft = 0;\n      offsetTop = 0;\n    } else {\n      [offsetLeft, offsetTop, origin[0], origin[1]] = getSVGGraphicsOffset(\n        el as SVGGraphicsElement,\n        origin,\n        el === target && target.tagName.toLowerCase() === 'g',\n      );\n    }\n  } else {\n    origin = getTransformOriginArray(getStyle('transformOrigin')).map((pos) =>\n      parseFloat(pos),\n    );\n\n    targetOrigin = origin.slice();\n    // console.log(getStyle(\"transformOrigin\"), targetOrigin);\n  }\n  return {\n    tagName,\n    isSVG,\n    hasOffset,\n    offset: [offsetLeft || 0, offsetTop || 0],\n    origin,\n    targetOrigin,\n  };\n}\nexport function getBodyOffset(el: HTMLElement | SVGElement, isSVG: boolean) {\n  const getStyle = getCachedStyle(el);\n  const getBodyStyle = getCachedStyle(getDocumentBody(el));\n  const bodyPosition = getBodyStyle('position');\n  if (!isSVG && (!bodyPosition || bodyPosition === 'static')) {\n    return [0, 0];\n  }\n\n  let marginLeft = parseInt(getBodyStyle('marginLeft'), 10);\n  let marginTop = parseInt(getBodyStyle('marginTop'), 10);\n\n  if (getStyle('position') === 'absolute') {\n    if (getStyle('top') !== 'auto' || getStyle('bottom') !== 'auto') {\n      marginTop = 0;\n    }\n    if (getStyle('left') !== 'auto' || getStyle('right') !== 'auto') {\n      marginLeft = 0;\n    }\n  }\n\n  return [marginLeft, marginTop];\n}\nexport function convert3DMatrixes(matrixes: MatrixInfo[]) {\n  matrixes.forEach((info) => {\n    const matrix = info.matrix;\n\n    if (matrix) {\n      info.matrix = convertDimension(matrix, 3, 4);\n    }\n  });\n}\n\nexport function getPositionFixedInfo(el: HTMLElement | SVGElement) {\n  let fixedContainer = el.parentElement;\n  let hasTransform = false;\n  const body = getDocumentBody(el);\n\n  while (fixedContainer) {\n    const transform = getComputedStyle(fixedContainer).transform;\n\n    if (transform && transform !== 'none') {\n      hasTransform = true;\n      break;\n    }\n    if (fixedContainer === body) {\n      break;\n    }\n    fixedContainer = fixedContainer.parentElement;\n  }\n\n  return {\n    fixedContainer: fixedContainer || body,\n    hasTransform,\n  };\n}\n\nexport function makeMatrixCSS(\n  matrix: number[],\n  is3d: boolean = matrix.length > 9,\n) {\n  return `${is3d ? 'matrix3d' : 'matrix'}(${convertMatrixtoCSS(matrix, !is3d).join(',')})`;\n}\nexport function getSVGViewBox(el: SVGSVGElement) {\n  const clientWidth = el.clientWidth;\n  const clientHeight = el.clientHeight;\n\n  if (!el) {\n    return { x: 0, y: 0, width: 0, height: 0, clientWidth, clientHeight };\n  }\n  const viewBox = el.viewBox;\n  const baseVal = (viewBox && viewBox.baseVal) || {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0,\n  };\n\n  return {\n    x: baseVal.x,\n    y: baseVal.y,\n    width: baseVal.width || clientWidth,\n    height: baseVal.height || clientHeight,\n    clientWidth,\n    clientHeight,\n  };\n}\nexport function getSVGMatrix(el: SVGSVGElement, n: number) {\n  const {\n    width: viewBoxWidth,\n    height: viewBoxHeight,\n    clientWidth,\n    clientHeight,\n  } = getSVGViewBox(el);\n  const scaleX = clientWidth / viewBoxWidth;\n  const scaleY = clientHeight / viewBoxHeight;\n\n  const preserveAspectRatio = el.preserveAspectRatio.baseVal;\n  // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/preserveAspectRatio\n  const align = preserveAspectRatio.align;\n  // 1 : meet 2: slice\n  const meetOrSlice = preserveAspectRatio.meetOrSlice;\n  const svgOrigin = [0, 0];\n  const scale = [scaleX, scaleY];\n  const translate = [0, 0];\n\n  if (align !== 1) {\n    const xAlign = (align - 2) % 3;\n    const yAlign = Math.floor((align - 2) / 3);\n\n    svgOrigin[0] = (viewBoxWidth * xAlign) / 2;\n    svgOrigin[1] = (viewBoxHeight * yAlign) / 2;\n\n    const scaleDimension =\n      meetOrSlice === 2 ? Math.max(scaleY, scaleX) : Math.min(scaleX, scaleY);\n\n    scale[0] = scaleDimension;\n    scale[1] = scaleDimension;\n\n    translate[0] = ((clientWidth - viewBoxWidth) / 2) * xAlign;\n    translate[1] = ((clientHeight - viewBoxHeight) / 2) * yAlign;\n  }\n  const scaleMatrix = createScaleMatrix(scale, n);\n  [scaleMatrix[n * (n - 1)], scaleMatrix[n * (n - 1) + 1]] = translate;\n\n  return getAbsoluteMatrix(scaleMatrix, n, svgOrigin);\n}\nexport function getSVGGraphicsOffset(\n  el: SVGGraphicsElement,\n  origin: number[],\n  isGTarget?: boolean,\n) {\n  const tagName = el.tagName.toLowerCase();\n\n  if (!el.getBBox || (!isGTarget && tagName === 'g')) {\n    return [0, 0, 0, 0];\n  }\n  const getStyle = getCachedStyle(el);\n  const isFillBox = getStyle('transform-box') === 'fill-box';\n\n  const bbox = el.getBBox();\n  const viewBox = getSVGViewBox(el.ownerSVGElement!);\n  let x = bbox.x;\n  let y = bbox.y;\n\n  // x, y가 0으로 나타나는 버그\n  if (tagName === 'foreignobject' && !x && !y) {\n    x = parseFloat(el.getAttribute('x')!) || 0;\n    y = parseFloat(el.getAttribute('y')!) || 0;\n  }\n  const left = x - viewBox.x;\n  const top = y - viewBox.y;\n  const originX = isFillBox ? origin[0] : origin[0] - left;\n  const originY = isFillBox ? origin[1] : origin[1] - top;\n\n  // if (isFillBox) {\n  //     const bbox = (el as SVGGraphicsElement).getBBox();\n  //     const x = parseFloat(getStyle(\"x\")) || bbox.x;\n  //     const y = parseFloat(getStyle(\"y\")) || bbox.y;\n\n  //     const xScale = bbox.x / x;\n  //     const yScale = bbox.y / y;\n\n  //     console.log(x, y);\n\n  //     originX *= xScale;\n  //     originY *= yScale;\n  // }\n\n  return [left, top, originX, originY];\n}\nexport function calculatePosition(matrix: number[], pos: number[], n: number) {\n  return calculate(matrix, convertPositionMatrix(pos, n), n);\n}\nexport function calculatePoses(\n  matrix: number[],\n  width: number,\n  height: number,\n  n: number,\n) {\n  return [\n    [0, 0],\n    [width, 0],\n    [0, height],\n    [width, height],\n  ].map((pos) => calculatePosition(matrix, pos, n));\n}\nexport function getRect(poses: number[][]) {\n  const posesX = poses.map((pos) => pos[0]);\n  const posesY = poses.map((pos) => pos[1]);\n  const left = Math.min(...posesX);\n  const top = Math.min(...posesY);\n  const right = Math.max(...posesX);\n  const bottom = Math.max(...posesY);\n  const rectWidth = right - left;\n  const rectHeight = bottom - top;\n\n  return {\n    left,\n    top,\n    right,\n    bottom,\n    width: rectWidth,\n    height: rectHeight,\n  };\n}\nexport function calculateRect(\n  matrix: number[],\n  width: number,\n  height: number,\n  n: number,\n) {\n  const poses = calculatePoses(matrix, width, height, n);\n\n  return getRect(poses);\n}\nexport function getSVGOffset(\n  offsetInfo: MatrixInfo,\n  targetInfo: MatrixInfo,\n  container: HTMLElement | SVGElement,\n  n: number,\n  beforeMatrix: number[],\n) {\n  const target = offsetInfo.target;\n  const origin = offsetInfo.origin!;\n  const targetMatrix = targetInfo.matrix!;\n  const { offsetWidth: width, offsetHeight: height } = getSize(target);\n  const containerClientRect = container.getBoundingClientRect();\n  let margin = [0, 0];\n\n  if (container === getDocumentBody(container)) {\n    margin = getBodyOffset(target, true);\n  }\n\n  const rect = target.getBoundingClientRect();\n  const rectLeft =\n    rect.left -\n    containerClientRect.left +\n    container.scrollLeft -\n    (container.clientLeft || 0) +\n    margin[0];\n  const rectTop =\n    rect.top -\n    containerClientRect.top +\n    container.scrollTop -\n    (container.clientTop || 0) +\n    margin[1];\n  const rectWidth = rect.width;\n  const rectHeight = rect.height;\n\n  const mat = multiplies(n, beforeMatrix, targetMatrix);\n  const {\n    left: prevLeft,\n    top: prevTop,\n    width: prevWidth,\n    height: prevHeight,\n  } = calculateRect(mat, width, height, n);\n  const posOrigin = calculatePosition(mat, origin, n);\n  const prevOrigin = minus(posOrigin, [prevLeft, prevTop]);\n  const rectOrigin = [\n    rectLeft + (prevOrigin[0] * rectWidth) / prevWidth,\n    rectTop + (prevOrigin[1] * rectHeight) / prevHeight,\n  ];\n  const offset = [0, 0];\n  let count = 0;\n\n  while (++count < 10) {\n    const inverseBeforeMatrix = invert(beforeMatrix, n);\n    [offset[0], offset[1]] = minus(\n      calculatePosition(inverseBeforeMatrix, rectOrigin, n),\n      calculatePosition(inverseBeforeMatrix, posOrigin, n),\n    );\n    const mat2 = multiplies(\n      n,\n      beforeMatrix,\n      createOriginMatrix(offset, n),\n      targetMatrix,\n    );\n    const { left: nextLeft, top: nextTop } = calculateRect(\n      mat2,\n      width,\n      height,\n      n,\n    );\n    const distLeft = nextLeft - rectLeft;\n    const distTop = nextTop - rectTop;\n\n    if (abs(distLeft) < 2 && abs(distTop) < 2) {\n      break;\n    }\n    rectOrigin[0] -= distLeft;\n    rectOrigin[1] -= distTop;\n  }\n  return offset.map((p) => Math.round(p));\n}\n\nexport function calculateMoveableClientPositions(\n  rootMatrix: number[],\n  poses: number[][],\n  rootClientRect: MoveableClientRect,\n) {\n  const is3d = rootMatrix.length === 16;\n  const n = is3d ? 4 : 3;\n  const rootPoses = poses.map((pos) => calculatePosition(rootMatrix, pos, n));\n  const { left, top } = rootClientRect;\n\n  return rootPoses.map((pos) => {\n    return [pos[0] + left, pos[1] + top];\n  });\n}\n\nexport function getDistSize(vec: number[]) {\n  return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);\n}\nexport function getDiagonalSize(pos1: number[], pos2: number[]) {\n  return getDistSize([pos2[0] - pos1[0], pos2[1] - pos1[1]]);\n}\nexport function getLineStyle(\n  pos1: number[],\n  pos2: number[],\n  zoom = 1,\n  rad: number = getRad(pos1, pos2),\n) {\n  const width = getDiagonalSize(pos1, pos2);\n\n  return {\n    transform: `translateY(-50%) translate(${pos1[0]}px, ${pos1[1]}px) rotate(${rad}rad) scaleY(${zoom})`,\n    width: `${width}px`,\n  };\n}\nexport function getControlTransform(\n  rotation: number,\n  zoom: number,\n  ...poses: number[][]\n) {\n  const length = poses.length;\n\n  const x = poses.reduce((prev, pos) => prev + pos[0], 0) / length;\n  const y = poses.reduce((prev, pos) => prev + pos[1], 0) / length;\n  return {\n    transform: `translateZ(0px) translate(${x}px, ${y}px) rotate(${rotation}rad) scale(${zoom})`,\n  };\n}\n\nexport function getProps<Props>(props: Props, ableName: keyof Props): Props {\n  const self = props[ableName];\n\n  if (isObject(self)) {\n    return {\n      ...props,\n      ...self,\n    };\n  }\n  return props;\n}\n\nexport function getSize(\n  target?: SVGElement | HTMLElement | null,\n): ElementSizes {\n  const hasOffset = target && !isUndefined((target as any).offsetWidth);\n\n  let offsetWidth = 0;\n  let offsetHeight = 0;\n  let clientWidth = 0;\n  let clientHeight = 0;\n  let cssWidth = 0;\n  let cssHeight = 0;\n  let contentWidth = 0;\n  let contentHeight = 0;\n\n  let minWidth = 0;\n  let minHeight = 0;\n  let minOffsetWidth = 0;\n  let minOffsetHeight = 0;\n\n  let maxWidth = Infinity;\n  let maxHeight = Infinity;\n  let maxOffsetWidth = Infinity;\n  let maxOffsetHeight = Infinity;\n  let inlineCSSWidth = 0;\n  let inlineCSSHeight = 0;\n  let svg = false;\n\n  if (target) {\n    if (!hasOffset && (target as SVGElement).ownerSVGElement) {\n      // check svg elements\n      const bbox = (target as SVGGraphicsElement).getBBox();\n\n      svg = true;\n      offsetWidth = bbox.width;\n      offsetHeight = bbox.height;\n      cssWidth = offsetWidth;\n      cssHeight = offsetHeight;\n      contentWidth = offsetWidth;\n      contentHeight = offsetHeight;\n      clientWidth = offsetWidth;\n      clientHeight = offsetHeight;\n    } else {\n      // check html elements\n      const getStyle = getCachedStyle(target);\n      const targetStyle = target.style;\n      const boxSizing = getStyle('boxSizing') === 'border-box';\n      const borderLeft = parseFloat(getStyle('borderLeftWidth')) || 0;\n      const borderRight = parseFloat(getStyle('borderRightWidth')) || 0;\n      const borderTop = parseFloat(getStyle('borderTopWidth')) || 0;\n      const borderBottom = parseFloat(getStyle('borderBottomWidth')) || 0;\n      const paddingLeft = parseFloat(getStyle('paddingLeft')) || 0;\n      const paddingRight = parseFloat(getStyle('paddingRight')) || 0;\n      const paddingTop = parseFloat(getStyle('paddingTop')) || 0;\n      const paddingBottom = parseFloat(getStyle('paddingBottom')) || 0;\n\n      const horizontalPadding = paddingLeft + paddingRight;\n      const verticalPadding = paddingTop + paddingBottom;\n      const horizontalBorder = borderLeft + borderRight;\n      const verticalBorder = borderTop + borderBottom;\n      const horizontalOffset = horizontalPadding + horizontalBorder;\n      const verticalOffset = verticalPadding + verticalBorder;\n      const position = getStyle('position');\n\n      let containerWidth = 0;\n      let containerHeight = 0;\n\n      // SVGSVGElement, HTMLElement\n      if ('clientLeft' in target) {\n        let parentElement: HTMLElement | null = null;\n\n        if (position === 'absolute') {\n          const offsetInfo = getOffsetInfo(target, getDocumentBody(target));\n          parentElement = offsetInfo.offsetParent;\n        } else {\n          parentElement = target.parentElement;\n        }\n        if (parentElement) {\n          const getParentStyle = getCachedStyle(parentElement);\n\n          containerWidth = parseFloat(getParentStyle('width'));\n          containerHeight = parseFloat(getParentStyle('height'));\n        }\n      }\n      minWidth = Math.max(\n        horizontalPadding,\n        convertUnitSize(getStyle('minWidth'), containerWidth) || 0,\n      );\n      minHeight = Math.max(\n        verticalPadding,\n        convertUnitSize(getStyle('minHeight'), containerHeight) || 0,\n      );\n      maxWidth = convertUnitSize(getStyle('maxWidth'), containerWidth);\n      maxHeight = convertUnitSize(getStyle('maxHeight'), containerHeight);\n\n      if (isNaN(maxWidth)) {\n        maxWidth = Infinity;\n      }\n      if (isNaN(maxHeight)) {\n        maxHeight = Infinity;\n      }\n      inlineCSSWidth = convertUnitSize(targetStyle.width, 0) || 0;\n      inlineCSSHeight = convertUnitSize(targetStyle.height, 0) || 0;\n      cssWidth = parseFloat(getStyle('width')) || 0;\n      cssHeight = parseFloat(getStyle('height')) || 0;\n\n      contentWidth =\n        abs(cssWidth - inlineCSSWidth) < 1\n          ? between(minWidth, inlineCSSWidth || cssWidth, maxWidth)\n          : cssWidth;\n      contentHeight =\n        abs(cssHeight - inlineCSSHeight) < 1\n          ? between(minHeight, inlineCSSHeight || cssHeight, maxHeight)\n          : cssHeight;\n\n      offsetWidth = contentWidth;\n      offsetHeight = contentHeight;\n      clientWidth = contentWidth;\n      clientHeight = contentHeight;\n\n      if (boxSizing) {\n        maxOffsetWidth = maxWidth;\n        maxOffsetHeight = maxHeight;\n        minOffsetWidth = minWidth;\n        minOffsetHeight = minHeight;\n        contentWidth = offsetWidth - horizontalOffset;\n        contentHeight = offsetHeight - verticalOffset;\n      } else {\n        maxOffsetWidth = maxWidth + horizontalOffset;\n        maxOffsetHeight = maxHeight + verticalOffset;\n        minOffsetWidth = minWidth + horizontalOffset;\n        minOffsetHeight = minHeight + verticalOffset;\n        offsetWidth = contentWidth + horizontalOffset;\n        offsetHeight = contentHeight + verticalOffset;\n      }\n      clientWidth = contentWidth + horizontalPadding;\n      clientHeight = contentHeight + verticalPadding;\n    }\n  }\n\n  return {\n    svg,\n    offsetWidth,\n    offsetHeight,\n    clientWidth,\n    clientHeight,\n    contentWidth,\n    contentHeight,\n    inlineCSSWidth,\n    inlineCSSHeight,\n    cssWidth,\n    cssHeight,\n    minWidth,\n    minHeight,\n    maxWidth,\n    maxHeight,\n    minOffsetWidth,\n    minOffsetHeight,\n    maxOffsetWidth,\n    maxOffsetHeight,\n  };\n}\nexport function getRotationRad(poses: number[][], direction: number) {\n  return getRad(\n    direction > 0 ? poses[0] : poses[1],\n    direction > 0 ? poses[1] : poses[0],\n  );\n}\n\nexport function resetClientRect(): MoveableClientRect {\n  return {\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0,\n    right: 0,\n    bottom: 0,\n    clientLeft: 0,\n    clientTop: 0,\n    clientWidth: 0,\n    clientHeight: 0,\n    scrollWidth: 0,\n    scrollHeight: 0,\n  };\n}\n\nexport function getExtendsRect(\n  el: HTMLElement | SVGElement,\n  rect: MoveableClientRect,\n): MoveableClientRect {\n  const isRoot = el === getDocumentBody(el) || el === getDocumentElement(el);\n\n  const extendsRect = {\n    clientLeft: el.clientLeft,\n    clientTop: el.clientTop,\n    clientWidth: el.clientWidth,\n    clientHeight: el.clientHeight,\n    scrollWidth: el.scrollWidth,\n    scrollHeight: el.scrollHeight,\n    overflow: false,\n  };\n\n  if (isRoot) {\n    extendsRect.clientHeight = Math.max(rect.height, extendsRect.clientHeight);\n    extendsRect.scrollHeight = Math.max(rect.height, extendsRect.scrollHeight);\n  }\n\n  extendsRect.overflow = getCachedStyle(el)('overflow') !== 'visible';\n\n  return {\n    ...rect,\n    ...extendsRect,\n  };\n}\n\nexport function getClientRectByPosition(\n  position: { left: number; right: number; top: number; bottom: number },\n  base: MoveableClientRect,\n  el?: HTMLElement | SVGElement,\n  isExtends?: boolean,\n) {\n  const { left, right, top, bottom } = position;\n  const baseTop = base.top;\n  const baseLeft = base.left;\n\n  const rect: MoveableClientRect = {\n    left: baseLeft + left,\n    top: baseTop + top,\n    right: baseLeft + right,\n    bottom: baseTop + bottom,\n    width: right - left,\n    height: bottom - top,\n  };\n\n  if (el && isExtends) {\n    return getExtendsRect(el, rect);\n  }\n  return rect;\n}\nexport function getClientRect(\n  el: HTMLElement | SVGElement,\n  isExtends?: boolean,\n): MoveableClientRect {\n  let left = 0;\n  let top = 0;\n  let width = 0;\n  let height = 0;\n  // let isRoot = false;\n\n  if (el) {\n    const clientRect = el.getBoundingClientRect();\n\n    left = clientRect.left;\n    top = clientRect.top;\n    width = clientRect.width;\n    height = clientRect.height;\n  }\n\n  const rect: MoveableClientRect = {\n    left,\n    top,\n    width,\n    height,\n    right: left + width,\n    bottom: top + height,\n  };\n\n  if (el && isExtends) {\n    return getExtendsRect(el, rect);\n  }\n  return rect;\n}\n\nexport function getTotalOrigin(moveable: MoveableManagerInterface<any>) {\n  const { groupable, svgOrigin } = moveable.props;\n  const { offsetWidth, offsetHeight, svg, transformOrigin } =\n    moveable.getState();\n\n  if (!groupable && svg && svgOrigin) {\n    return convertTransformOriginArray(svgOrigin, offsetWidth, offsetHeight);\n  }\n\n  return transformOrigin;\n}\n\nexport function getTotalDirection(\n  parentDirection: number[],\n  isPinch: boolean,\n  inputEvent: any,\n  datas: any,\n) {\n  let direction: number[] | undefined;\n\n  if (parentDirection) {\n    direction = parentDirection;\n  } else if (isPinch) {\n    direction = [0, 0];\n  } else {\n    const target = inputEvent.target;\n\n    direction = getDirection(target, datas);\n  }\n  return direction;\n}\nexport function getDirection(target: SVGElement | HTMLElement, datas: any) {\n  if (!target) {\n    return;\n  }\n  const deg = target.getAttribute('data-rotation') || '';\n  const direciton = target.getAttribute('data-direction')!;\n\n  datas.deg = deg;\n\n  if (!direciton) {\n    return;\n  }\n  const dir = [0, 0];\n\n  direciton.indexOf('w') > -1 && (dir[0] = -1);\n  direciton.indexOf('e') > -1 && (dir[0] = 1);\n  direciton.indexOf('n') > -1 && (dir[1] = -1);\n  direciton.indexOf('s') > -1 && (dir[1] = 1);\n\n  return dir;\n}\nexport function getAbsolutePoses(poses: number[][], dist: number[]) {\n  return [\n    plus(dist, poses[0]),\n    plus(dist, poses[1]),\n    plus(dist, poses[2]),\n    plus(dist, poses[3]),\n  ];\n}\nexport function getAbsolutePosesByState({\n  left,\n  top,\n  pos1,\n  pos2,\n  pos3,\n  pos4,\n}: {\n  left: number;\n  top: number;\n  pos1: number[];\n  pos2: number[];\n  pos3: number[];\n  pos4: number[];\n}) {\n  return getAbsolutePoses([pos1, pos2, pos3, pos4], [left, top]);\n}\n\nexport function roundSign(num: number) {\n  return Math.round(num % 1 === -0.5 ? num - 1 : num);\n}\n\nexport function unsetAbles(self: MoveableManagerInterface, isControl: boolean) {\n  self[isControl ? 'controlAbles' : 'targetAbles'].forEach((able) => {\n    able.unset && able.unset(self);\n  });\n}\nexport function unsetGesto(self: MoveableManagerInterface, isControl: boolean) {\n  const gestoName = isControl ? 'controlGesto' : 'targetGesto';\n  const gesto = self[gestoName];\n\n  if (gesto?.isIdle() === false) {\n    unsetAbles(self, isControl);\n  }\n  gesto?.unset();\n  self[gestoName] = null as any;\n}\n\nexport function fillCSSObject(\n  style: Record<string, any>,\n  resolvedEvent?: any,\n): CSSObject {\n  if (resolvedEvent) {\n    const originalDatas = getBeforeRenderableDatas(resolvedEvent);\n\n    originalDatas.nextStyle = {\n      ...originalDatas.nextStyle,\n      ...style,\n    };\n  }\n  return {\n    style,\n    cssText: getKeys(style)\n      .map((name) => `${decamelize(name, '-')}: ${style[name]};`)\n      .join(''),\n  };\n}\n\nexport function fillAfterTransform(\n  prevEvent: { style: Record<string, string>; transform: string },\n  nextEvent: {\n    style: Record<string, string>;\n    transform: string;\n    afterTransform?: string;\n  },\n  resolvedEvent?: any,\n): TransformObject {\n  const afterTransform = nextEvent.afterTransform || nextEvent.transform;\n\n  return {\n    ...fillCSSObject(\n      {\n        ...prevEvent.style,\n        ...nextEvent.style,\n        transform: afterTransform,\n      },\n      resolvedEvent,\n    ),\n    afterTransform,\n    transform: prevEvent.transform,\n  };\n}\n\nexport function fillParams<T extends IObject<any>>(\n  moveable: any,\n  e: any,\n  params: ExcludeParams<T>,\n  isBeforeEvent?: boolean,\n): T {\n  const datas = e.datas;\n\n  if (!datas.datas) {\n    datas.datas = {};\n  }\n  const nextParams = {\n    ...params,\n    target: moveable.state.target,\n    clientX: e.clientX,\n    clientY: e.clientY,\n    inputEvent: e.inputEvent,\n    currentTarget: moveable,\n    moveable,\n    datas: datas.datas,\n    isRequest: e.isRequest,\n    isRequestChild: e.isRequestChild,\n    isFirstDrag: !!e.isFirstDrag,\n    isTrusted: e.isTrusted !== false,\n    stopAble() {\n      datas.isEventStart = false;\n    },\n    stopDrag() {\n      e.stop?.();\n    },\n  } as any;\n\n  if (!datas.isStartEvent) {\n    datas.isStartEvent = true;\n  } else if (!isBeforeEvent) {\n    datas.lastEvent = nextParams;\n  }\n  return nextParams;\n}\nexport function fillEndParams<T extends IObject<any>>(\n  moveable: any,\n  e: any,\n  params: ExcludeEndParams<T> & { isDrag?: boolean },\n): T {\n  const datas = e.datas;\n  const isDrag = 'isDrag' in params ? params.isDrag : e.isDrag;\n\n  if (!datas.datas) {\n    datas.datas = {};\n  }\n\n  return {\n    isDrag,\n    ...params,\n    moveable,\n    target: moveable.state.target,\n    clientX: e.clientX,\n    clientY: e.clientY,\n    inputEvent: e.inputEvent,\n    currentTarget: moveable,\n    lastEvent: datas.lastEvent,\n    isDouble: e.isDouble,\n    datas: datas.datas,\n    isFirstDrag: !!e.isFirstDrag,\n  } as any;\n}\nexport function catchEvent<\n  EventName extends keyof Props,\n  Props extends IObject<any> = MoveableProps,\n>(\n  moveable: any,\n  name: EventName,\n  callback: (\n    e: Props[EventName] extends ((e: infer P) => any) | undefined\n      ? P\n      : IObject<any>,\n  ) => void,\n): any {\n  moveable._emitter.on(name, callback);\n}\n\nexport function triggerEvent<\n  EventName extends keyof Props,\n  Props extends IObject<any> = MoveableProps,\n>(\n  moveable: any,\n  name: EventName,\n  params: Props[EventName] extends ((e: infer P) => any) | undefined\n    ? P\n    : IObject<any>,\n  isManager?: boolean,\n  isRequest?: boolean,\n): any {\n  return moveable.triggerEvent(name, params, isManager, isRequest);\n}\n\nexport function getComputedStyle(el: Element, pseudoElt?: string | null) {\n  return getWindow(el).getComputedStyle(el, pseudoElt);\n}\n\nexport function filterAbles(\n  ables: Able[],\n  methods: Array<keyof Able>,\n  triggerAblesSimultaneously?: boolean,\n) {\n  const enabledAbles: IObject<boolean> = {};\n  const ableGroups: IObject<boolean> = {};\n\n  return ables.filter((able) => {\n    const name = able.name;\n\n    if (enabledAbles[name] || !methods.some((method) => able[method])) {\n      return false;\n    }\n    if (!triggerAblesSimultaneously && able.ableGroup) {\n      if (ableGroups[able.ableGroup]) {\n        return false;\n      }\n      ableGroups[able.ableGroup] = true;\n    }\n    enabledAbles[name] = true;\n    return true;\n  });\n}\n\nexport function equals(a1: any, a2: any) {\n  return a1 === a2 || (a1 == null && a2 == null);\n}\n\nexport function selectValue<T = any>(...values: any[]): T {\n  const length = values.length - 1;\n  for (let i = 0; i < length; ++i) {\n    const value = values[i];\n\n    if (!isUndefined(value)) {\n      return value;\n    }\n  }\n\n  return values[length];\n}\n\nexport function groupBy<T>(\n  arr: T[],\n  func: (el: T, index: number, arr: T[]) => any,\n) {\n  const groups: T[][] = [];\n  const groupKeys: any[] = [];\n\n  arr.forEach((el, index) => {\n    const groupKey = func(el, index, arr);\n    const keyIndex = groupKeys.indexOf(groupKey);\n    const group = groups[keyIndex] || [];\n\n    if (keyIndex === -1) {\n      groupKeys.push(groupKey);\n      groups.push(group);\n    }\n    group.push(el);\n  });\n  return groups;\n}\nexport function groupByMap<T>(\n  arr: T[],\n  func: (el: T, index: number, arr: T[]) => string | number,\n) {\n  const groups: T[][] = [];\n  const groupKeys: IObject<T[]> = {};\n\n  arr.forEach((el, index) => {\n    const groupKey = func(el, index, arr);\n    let group = groupKeys[groupKey];\n\n    if (!group) {\n      group = [];\n      groupKeys[groupKey] = group;\n      groups.push(group);\n    }\n    group.push(el);\n  });\n  return groups;\n}\nexport function flat<T>(arr: T[][]): T[] {\n  return arr.reduce((prev, cur) => {\n    return prev.concat(cur);\n  }, []);\n}\n\nexport function equalSign(a: number, b: number) {\n  return (a >= 0 && b >= 0) || (a < 0 && b < 0);\n}\n\nexport function maxOffset(...args: number[]) {\n  args.sort((a, b) => abs(b) - abs(a));\n\n  return args[0];\n}\nexport function minOffset(...args: number[]) {\n  args.sort((a, b) => abs(a) - abs(b));\n\n  return args[0];\n}\n\nexport function calculateInversePosition(\n  matrix: number[],\n  pos: number[],\n  n: number,\n) {\n  return calculate(invert(matrix, n), convertPositionMatrix(pos, n), n);\n}\nexport function convertDragDist(state: MoveableManagerState, e: any) {\n  const { is3d, rootMatrix } = state;\n  const n = is3d ? 4 : 3;\n  [e.distX, e.distY] = calculateInversePosition(\n    rootMatrix,\n    [e.distX, e.distY],\n    n,\n  );\n\n  return e;\n}\n\nexport function calculatePadding(\n  matrix: number[],\n  pos: number[],\n  added: number[],\n  n: number,\n) {\n  if (!added[0] && !added[1]) {\n    return pos;\n  }\n\n  const xAdded = calculatePosition(matrix, [normalized(added[0] || 1), 0], n);\n  const yAdded = calculatePosition(matrix, [0, normalized(added[1] || 1)], n);\n  const nextAdded = calculatePosition(\n    matrix,\n    [added[0] / getDistSize(xAdded), added[1] / getDistSize(yAdded)],\n    n,\n  );\n\n  return plus(pos, nextAdded);\n}\n\nexport function convertCSSSize(\n  value: number,\n  size: number,\n  isRelative?: boolean,\n) {\n  return isRelative ? `${(value / size) * 100}%` : `${value}px`;\n}\n\nexport function getTinyDist(v: number) {\n  return abs(v) <= TINY_NUM ? 0 : v;\n}\n\nexport function viewDraggingPrefix(ableName: string) {\n  return prefix(`${ableName}-view-dragging`);\n}\nexport function getDirectionViewClassName(ableName: string) {\n  return (moveable: MoveableManagerInterface) => {\n    if (!moveable.isDragging(ableName)) {\n      return '';\n    }\n    const data = getGestoData(moveable, ableName);\n    const deg = data.deg;\n    if (!deg) {\n      return '';\n    }\n    return prefix(`view-control-rotation${deg}`);\n  };\n}\nexport function getDirectionCondition(\n  ableName: string,\n  checkAbles: string[] = [ableName],\n) {\n  return (moveable: any, e: any) => {\n    if (e.isRequest) {\n      if (checkAbles.some((name) => e.requestAble === name)) {\n        return e.parentDirection!;\n      } else {\n        return false;\n      }\n    }\n    const target = e.inputEvent.target;\n\n    return (\n      hasClass(target, prefix('direction')) &&\n      (!ableName || hasClass(target, prefix(ableName)))\n    );\n  };\n}\n\nexport function convertTransformInfo(\n  transforms: string[],\n  state: MoveableManagerState,\n  index: number,\n) {\n  const matrixInfos = parse(transforms, {\n    'x%': (v) => (v / 100) * state.offsetWidth,\n    'y%': (v) => (v / 100) * state.offsetHeight,\n  });\n\n  const beforeFunctionTexts = transforms.slice(\n    0,\n    index < 0 ? undefined : index,\n  );\n  const beforeFunctionTexts2 = transforms.slice(\n    0,\n    index < 0 ? undefined : index + 1,\n  );\n  const targetFunctionText = transforms[index] || '';\n  const afterFunctionTexts = index < 0 ? [] : transforms.slice(index);\n  const afterFunctionTexts2 = index < 0 ? [] : transforms.slice(index + 1);\n\n  const beforeFunctions = matrixInfos.slice(0, index < 0 ? undefined : index);\n  const beforeFunctions2 = matrixInfos.slice(\n    0,\n    index < 0 ? undefined : index + 1,\n  );\n  const targetFunction = matrixInfos[index] ?? parse([''])[0];\n  const afterFunctions = index < 0 ? [] : matrixInfos.slice(index);\n  const afterFunctions2 = index < 0 ? [] : matrixInfos.slice(index + 1);\n  const targetFunctions = targetFunction ? [targetFunction] : [];\n\n  const beforeFunctionMatrix = toMat(beforeFunctions);\n  const beforeFunctionMatrix2 = toMat(beforeFunctions2);\n  const afterFunctionMatrix = toMat(afterFunctions);\n  const afterFunctionMatrix2 = toMat(afterFunctions2);\n  const allFunctionMatrix = multiply(\n    beforeFunctionMatrix,\n    afterFunctionMatrix,\n    4,\n  );\n  return {\n    transforms,\n    beforeFunctionMatrix,\n    beforeFunctionMatrix2,\n    targetFunctionMatrix: toMat(targetFunctions),\n    afterFunctionMatrix,\n    afterFunctionMatrix2,\n    allFunctionMatrix,\n    beforeFunctions,\n    beforeFunctions2,\n    targetFunction: targetFunctions[0],\n    afterFunctions,\n    afterFunctions2,\n    beforeFunctionTexts,\n    beforeFunctionTexts2,\n    targetFunctionText,\n    afterFunctionTexts,\n    afterFunctionTexts2,\n  };\n}\n\nexport function isArrayFormat<T = any>(arr: any): arr is ArrayFormat<T> {\n  if (!arr || !isObject(arr)) {\n    return false;\n  }\n  if (isNode(arr)) {\n    return false;\n  }\n  return isArray(arr) || 'length' in arr;\n}\n\nexport function getRefTarget<T extends Element = HTMLElement | SVGElement>(\n  target: MoveableRefType<T> | Window,\n  isSelector: true,\n): T | null;\nexport function getRefTarget<T extends Element = HTMLElement | SVGElement>(\n  target: MoveableRefType<T> | Window,\n  isSelector?: boolean,\n): T | string | null;\nexport function getRefTarget<T extends Element = HTMLElement | SVGElement>(\n  target: MoveableRefType<T> | Window,\n  isSelector?: boolean,\n): any {\n  if (!target) {\n    return null;\n  }\n  if (isNode(target)) {\n    return target;\n  }\n  if (isString(target)) {\n    if (isSelector) {\n      return document.querySelector(target);\n    }\n    return target;\n  }\n  if (isFunction(target)) {\n    return target();\n  }\n  if (isWindow(target)) {\n    return target;\n  }\n  if ('current' in target) {\n    return target.current;\n  }\n  return target;\n}\n\nexport function getRefTargets(\n  targets: MoveableRefTargetType,\n  isSelector: true,\n): Array<HTMLElement | SVGElement | null>;\nexport function getRefTargets(\n  targets: MoveableRefTargetType,\n  isSelector?: boolean,\n): MoveableRefTargetsResultType;\nexport function getRefTargets(\n  targets: MoveableRefTargetType,\n  isSelector?: boolean,\n): any[] {\n  if (!targets) {\n    return [];\n  }\n  const userTargets = isArrayFormat(targets)\n    ? [].slice.call(targets)\n    : [targets];\n\n  return userTargets.reduce((prev, target) => {\n    if (isString(target) && isSelector) {\n      return [\n        ...prev,\n        ...[].slice.call(document.querySelectorAll<HTMLElement>(target)),\n      ];\n    }\n    if (isArray(target)) {\n      prev.push(getRefTargets(target, isSelector));\n    } else {\n      prev.push(getRefTarget(target, isSelector));\n    }\n    return prev;\n  }, [] as MoveableRefTargetsResultType);\n}\n\nexport function minmax(...values: number[]) {\n  return [Math.min(...values), Math.max(...values)];\n}\n\nexport function getAbsoluteRotation(\n  pos1: number[],\n  pos2: number[],\n  direction: number,\n) {\n  let deg = (getRad(pos1, pos2) / Math.PI) * 180;\n\n  deg = direction >= 0 ? deg : 180 - deg;\n  deg = deg >= 0 ? deg : 360 + deg;\n\n  return deg;\n}\n\nexport function getDragDistByState(\n  state: MoveableManagerState,\n  dist: number[],\n) {\n  const { rootMatrix, is3d } = state;\n  const n = is3d ? 4 : 3;\n\n  let inverseMatrix = invert(rootMatrix, n);\n\n  if (!is3d) {\n    inverseMatrix = convertDimension(inverseMatrix, 3, 4);\n  }\n  inverseMatrix[12] = 0;\n  inverseMatrix[13] = 0;\n  inverseMatrix[14] = 0;\n\n  return calculateMatrixDist(inverseMatrix, dist);\n}\n\nexport function getSizeDistByDist(\n  startSize: number[],\n  dist: number[],\n  ratio: number,\n  direction: number[],\n  keepRatio?: boolean,\n) {\n  const [startOffsetWidth, startOffsetHeight] = startSize;\n  let distWidth = 0;\n  let distHeight = 0;\n\n  if (keepRatio && startOffsetWidth && startOffsetHeight) {\n    const rad = getRad([0, 0], dist);\n    const standardRad = getRad([0, 0], direction);\n    const size = getDistSize(dist);\n    const signSize = Math.cos(rad - standardRad) * size;\n\n    if (!direction[0]) {\n      // top, bottom\n      distHeight = signSize;\n      distWidth = distHeight * ratio;\n    } else if (!direction[1]) {\n      // left, right\n      distWidth = signSize;\n      distHeight = distWidth / ratio;\n    } else {\n      // two-way\n      const startWidthSize = direction[0] * startOffsetWidth;\n      const startHeightSize = direction[1] * startOffsetHeight;\n\n      let secondRad = Math.atan2(\n        startWidthSize + dist[0],\n        startHeightSize + dist[1],\n      );\n      let firstRad = Math.atan2(startWidthSize, startHeightSize);\n\n      if (secondRad < 0) {\n        secondRad += Math.PI * 2;\n      }\n      if (firstRad < 0) {\n        firstRad += Math.PI * 2;\n      }\n      let rad = 0;\n\n      if (\n        abs(secondRad - firstRad) < Math.PI / 2 ||\n        abs(secondRad - firstRad) > (Math.PI / 2) * 3\n      ) {\n        rad = secondRad - firstRad;\n      } else {\n        firstRad += Math.PI;\n        rad = secondRad - firstRad;\n      }\n      if (rad > Math.PI * 2) {\n        rad -= Math.PI * 2;\n      } else if (rad > Math.PI) {\n        rad = 2 * Math.PI - rad;\n      } else if (rad < -Math.PI) {\n        rad = -2 * Math.PI - rad;\n      }\n      //       180\n      // -1, -1,  // 1, -1\n      // 270            90\n      // -1, 1    // 1, 1\n      //       0\n      const distSize =\n        getDistSize([startWidthSize + dist[0], startHeightSize + dist[1]]) *\n        Math.cos(rad);\n\n      distWidth = distSize * Math.sin(firstRad) - startWidthSize;\n      distHeight = distSize * Math.cos(firstRad) - startHeightSize;\n\n      if (direction[0] < 0) {\n        distWidth *= -1;\n      }\n      if (direction[1] < 0) {\n        distHeight *= -1;\n      }\n    }\n  } else {\n    distWidth = direction[0] * dist[0];\n    distHeight = direction[1] * dist[1];\n  }\n\n  return [distWidth, distHeight];\n}\nexport function getOffsetSizeDist(\n  sizeDirection: number[],\n  keepRatio: boolean,\n  datas: any,\n  e: any,\n) {\n  const { ratio, startOffsetWidth, startOffsetHeight } = datas;\n  let distWidth = 0;\n  let distHeight = 0;\n  const { distX, distY, pinchScale, parentDistance, parentDist, parentScale } =\n    e;\n  const startFixedDirection = datas.fixedDirection;\n  const directionsDists = [0, 1].map((index) => {\n    return abs(sizeDirection[index] - startFixedDirection[index]);\n  });\n  const directionRatios = [0, 1].map((index) => {\n    let dist = directionsDists[index];\n\n    if (dist !== 0) {\n      dist = 2 / dist;\n    }\n    return dist;\n  });\n  if (parentDist) {\n    distWidth = parentDist[0];\n    distHeight = parentDist[1];\n\n    if (keepRatio) {\n      if (!distWidth) {\n        distWidth = distHeight * ratio;\n      } else if (!distHeight) {\n        distHeight = distWidth / ratio;\n      }\n    }\n  } else if (isNumber(pinchScale)) {\n    distWidth = (pinchScale - 1) * startOffsetWidth;\n    distHeight = (pinchScale - 1) * startOffsetHeight;\n  } else if (parentScale) {\n    distWidth = (parentScale[0] - 1) * startOffsetWidth;\n    distHeight = (parentScale[1] - 1) * startOffsetHeight;\n  } else if (parentDistance) {\n    const scaleX = startOffsetWidth * directionsDists[0];\n    const scaleY = startOffsetHeight * directionsDists[1];\n    const ratioDistance = getDistSize([scaleX, scaleY]);\n\n    distWidth = (parentDistance / ratioDistance) * scaleX * directionRatios[0];\n    distHeight = (parentDistance / ratioDistance) * scaleY * directionRatios[1];\n  } else {\n    let dist = getDragDist({ datas, distX, distY });\n\n    dist = directionRatios.map((ratio, i) => {\n      return dist[i] * ratio;\n    });\n\n    [distWidth, distHeight] = getSizeDistByDist(\n      [startOffsetWidth, startOffsetHeight],\n      dist,\n      ratio,\n      sizeDirection,\n      keepRatio,\n    );\n  }\n  return {\n    // direction,\n    // sizeDirection,\n    distWidth,\n    distHeight,\n  };\n}\n\nexport function convertTransformUnit(\n  origin: string,\n  xy?: boolean,\n): { x?: string; y?: string; value?: string } {\n  if (xy) {\n    if (origin === 'left') {\n      return { x: '0%', y: '50%' };\n    } else if (origin === 'top') {\n      return { x: '50%', y: '50%' };\n    } else if (origin === 'center') {\n      return { x: '50%', y: '50%' };\n    } else if (origin === 'right') {\n      return { x: '100%', y: '50%' };\n    } else if (origin === 'bottom') {\n      return { x: '50%', y: '100%' };\n    }\n    const [left, right] = origin.split(' ');\n    const leftOrigin = convertTransformUnit(left || '');\n    const rightOrigin = convertTransformUnit(right || '');\n    const originObject = {\n      ...leftOrigin,\n      ...rightOrigin,\n    };\n\n    const nextOriginObject = {\n      x: '50%',\n      y: '50%',\n    };\n    if (originObject.x) {\n      nextOriginObject.x = originObject.x;\n    }\n    if (originObject.y) {\n      nextOriginObject.y = originObject.y;\n    }\n    if (originObject.value) {\n      if (originObject.x && !originObject.y) {\n        nextOriginObject.y = originObject.value;\n      }\n      if (!originObject.x && originObject.y) {\n        nextOriginObject.x = originObject.value;\n      }\n    }\n    return nextOriginObject;\n  }\n  if (origin === 'left') {\n    return { x: '0%' };\n  }\n  if (origin === 'right') {\n    return { x: '100%' };\n  }\n  if (origin === 'top') {\n    return { y: '0%' };\n  }\n  if (origin === 'bottom') {\n    return { y: '100%' };\n  }\n  if (!origin) {\n    return {};\n  }\n  if (origin === 'center') {\n    return { value: '50%' };\n  }\n  return { value: origin };\n}\nexport function convertTransformOriginArray(\n  transformOrigin: string,\n  width: number,\n  height: number,\n) {\n  const { x, y } = convertTransformUnit(transformOrigin, true);\n\n  return [convertUnitSize(x!, width) || 0, convertUnitSize(y!, height) || 0];\n}\n\nexport function rotatePosesInfo(\n  poses: number[][],\n  origin: number[],\n  rad: number,\n) {\n  const prevPoses = poses.map((pos) => minus(pos, origin));\n  const nextPoses = prevPoses.map((pos) => rotate(pos, rad));\n\n  return {\n    prev: prevPoses,\n    next: nextPoses,\n    result: nextPoses.map((pos) => plus(pos, origin)),\n  };\n}\n\nexport function isDeepArrayEquals(arr1: any[], arr2: any[]): boolean {\n  return (\n    arr1.length === arr2.length &&\n    arr1.every((value1, i) => {\n      const value2 = arr2[i];\n      const isArray1 = isArray(value1);\n      const isArray2 = isArray(value2);\n      if (isArray1 && isArray2) {\n        return isDeepArrayEquals(value1, value2);\n      } else if (!isArray1 && !isArray2) {\n        return value1 === value2;\n      }\n      return false;\n    })\n  );\n}\n\nexport function watchValue<T>(\n  moveable: any,\n  property: string,\n  nextValue: T,\n  valueKey: (value: T) => string | number,\n  defaultValue?: T,\n): T {\n  const store = (moveable as any)._store;\n  let prevValue = store[property];\n\n  if (!(property in store)) {\n    if (defaultValue != null) {\n      store[property] = defaultValue;\n      prevValue = defaultValue;\n    } else {\n      store[property] = nextValue;\n      return nextValue;\n    }\n  }\n  if (prevValue === nextValue || valueKey(prevValue) === valueKey(nextValue)) {\n    return prevValue;\n  }\n\n  store[property] = nextValue;\n  return nextValue;\n}\n\nexport function sign(value: number) {\n  return value >= 0 ? 1 : -1;\n}\n\nexport function abs(value: number) {\n  return Math.abs(value);\n}\n\nexport function countEach<T>(\n  count: number,\n  callback: (index: number) => T,\n): T[] {\n  return counter(count).map((index) => callback(index));\n}\n\nexport function getPaddingBox(padding: PaddingBox | number) {\n  if (isNumber(padding)) {\n    return {\n      top: padding,\n      left: padding,\n      right: padding,\n      bottom: padding,\n    };\n  }\n\n  return {\n    left: padding.left || 0,\n    top: padding.top || 0,\n    right: padding.right || 0,\n    bottom: padding.bottom || 0,\n  };\n}\n", "import { makeAble } from \"./AbleManager\";\nimport { triggerEvent, fillParams, fillEndParams } from \"../utils\";\nimport {\n    PinchableProps, Able, SnappableState,\n    OnPinchStart, OnPinch, OnPinchEnd, MoveableManagerInterface, MoveableGroupInterface,\n} from \"../types\";\n\n/**\n * @namespace Moveable.Pinchable\n * @description Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)\n */\nexport default makeAble(\"pinchable\", {\n    props: [\n        \"pinchable\",\n    ] as const,\n    events: [\n        \"pinchStart\",\n        \"pinch\",\n        \"pinchEnd\",\n        \"pinchGroupStart\",\n        \"pinchGroup\",\n        \"pinchGroupEnd\",\n    ] as const,\n    dragStart() {\n        return true;\n    },\n    pinchStart(\n        moveable: MoveableManagerInterface<PinchableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas, targets, angle, originalDatas } = e;\n        const { pinchable, ables } = moveable.props;\n\n        if (!pinchable) {\n            return false;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}Start` as \"onPinchStart\";\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}ControlStart` as \"dragControlStart\";\n\n        const pinchAbles = (pinchable === true ? moveable.controlAbles : ables!.filter(able => {\n            return pinchable.indexOf(able.name as any) > -1;\n        })).filter(able => able.canPinch && able[controlEventName]);\n\n        const params = fillParams<OnPinchStart>(moveable, e, {}) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        const result = triggerEvent(moveable, eventName, params);\n\n        datas.isPinch = result !== false;\n        datas.ables = pinchAbles;\n\n        const isPinch = datas.isPinch;\n\n        if (!isPinch) {\n            return false;\n        }\n        pinchAbles.forEach(able => {\n            originalDatas[able.name] = originalDatas[able.name] || {};\n\n            if (!able[controlEventName]) {\n                return;\n            }\n            const ableEvent: any = {\n                ...e,\n                datas: originalDatas[able.name],\n                parentRotate: angle,\n                isPinch: true,\n            };\n            able[controlEventName]!(moveable, ableEvent);\n        });\n\n        moveable.state.snapRenderInfo = {\n            request: e.isRequest,\n            direction: [0, 0],\n        };\n        return isPinch;\n    },\n    pinch(\n        moveable: MoveableManagerInterface<PinchableProps>,\n        e: any,\n    ) {\n        const {\n            datas, scale: pinchScale, distance,\n            originalDatas,\n            inputEvent, targets,\n            angle,\n        } = e;\n        if (!datas.isPinch) {\n            return;\n        }\n        const parentDistance = distance * (1 - 1 / pinchScale);\n        const params = fillParams<OnPinch>(moveable, e, {}) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}` as \"onPinch\";\n        triggerEvent(moveable, eventName, params);\n\n        const ables: Able[] = datas.ables;\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}Control` as \"dragControl\";\n\n        ables.forEach(able => {\n            if (!able[controlEventName]) {\n                return;\n            }\n            able[controlEventName]!(moveable, {\n                ...e,\n                datas: originalDatas[able.name],\n                inputEvent,\n                resolveMatrix: true,\n                pinchScale: pinchScale,\n                parentDistance,\n                parentRotate: angle,\n                isPinch: true,\n            } as any);\n        });\n        return params;\n    },\n    pinchEnd(\n        moveable: MoveableManagerInterface<PinchableProps>,\n        e: any,\n    ) {\n        const { datas, isPinch, inputEvent, targets, originalDatas } = e;\n        if (!datas.isPinch) {\n            return;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}End` as \"onPinchEnd\";\n\n        const params = fillEndParams<OnPinchEnd>(moveable, e, { isDrag: isPinch }) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        triggerEvent(moveable, eventName, params);\n        const ables: Able[] = datas.ables;\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}ControlEnd` as \"dragControlEnd\";\n\n        ables.forEach(able => {\n            if (!able[controlEventName]) {\n                return;\n            }\n            able[controlEventName]!(moveable, {\n                ...e,\n                isDrag: isPinch,\n                datas: originalDatas[able.name],\n                inputEvent,\n                isPinch: true,\n            } as any);\n        });\n        return isPinch;\n    },\n    pinchGroupStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        return this.pinchStart!(moveable, { ...e, targets: moveable.props.targets });\n    },\n    pinchGroup(moveable: MoveableGroupInterface, e: any) {\n        return this.pinch!(moveable, { ...e, targets: moveable.props.targets });\n    },\n    pinchGroupEnd(moveable: MoveableGroupInterface, e: any) {\n        return this.pinchEnd!(moveable, { ...e, targets: moveable.props.targets });\n    },\n});\n\n/**\n * Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)\n * @name Moveable.Pinchable#pinchable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.pinchable = true;\n */\n\n/**\n * When the pinch starts, the pinchStart event is called with part of scaleStart, rotateStart, resizeStart\n * @memberof Moveable.Pinchable\n * @event pinchStart\n * @param {Moveable.Pinchable.OnPinchStart} - Parameters for the pinchStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinchStart\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotateStart\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scaleStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When pinching, the pinch event is called with part of scale, rotate, resize\n * @memberof Moveable.Pinchable\n * @event pinch\n * @param {Moveable.Pinchable.OnPinch} - Parameters for the pinch event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinch\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotate\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scale\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When the pinch finishes, the pinchEnd event is called.\n * @memberof Moveable.Pinchable\n * @event pinchEnd\n * @param {Moveable.Pinchable.OnPinchEnd} - Parameters for the pinchEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinchEnd\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotateEnd\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scaleEnd\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n * When the group pinch starts, the `pinchGroupStart` event is called.\n * @memberof Moveable.Pinchable\n * @event pinchGroupStart\n * @param {Moveable.Pinchable.OnPinchGroupStart} - Parameters for the `pinchGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroupStart\", ({ targets }) => {\n *     console.log(\"onPinchGroupStart\", targets);\n * });\n */\n\n/**\n * When the group pinch, the `pinchGroup` event is called.\n * @memberof Moveable.Pinchable\n * @event pinchGroup\n * @param {Moveable.Pinchable.OnPinchGroup} - Parameters for the `pinchGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroup\", ({ targets, events }) => {\n *     console.log(\"onPinchGroup\", targets);\n * });\n */\n\n/**\n * When the group pinch finishes, the `pinchGroupEnd` event is called.\n * @memberof Moveable.Pinchable\n * @event pinchGroupEnd\n * @param {Moveable.Pinchable.OnPinchGroupEnd} - Parameters for the `pinchGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onPinchGroupEnd\", targets, isDrag);\n * });\n */\n", "import {\n  triggerEvent,\n  multiply2,\n  fillParams,\n  fillEndParams,\n  getAbsolutePosesByState,\n  catchEvent,\n  getOffsetSizeDist,\n  getDirectionCondition,\n  getDirectionViewClassName,\n  getTotalDirection,\n  sign,\n  countEach,\n  abs,\n} from '../utils';\nimport { MIN_SCALE } from '../consts';\nimport {\n  setDragStart,\n  resolveTransformEvent,\n  convertTransformFormat,\n  getScaleDist,\n  fillTransformStartEvent,\n  fillTransformEvent,\n  setDefaultTransformIndex,\n  getTranslateFixedPosition,\n} from '../gesto/GestoUtils';\nimport { getRenderDirections } from '../render-directions';\nimport {\n  ScalableProps,\n  OnScaleGroup,\n  OnScaleGroupEnd,\n  OnScaleGroupStart,\n  DraggableProps,\n  OnDragStart,\n  SnappableState,\n  GroupableProps,\n  OnScaleStart,\n  OnScale,\n  OnScaleEnd,\n  MoveableManagerInterface,\n  MoveableGroupInterface,\n  OnBeforeScaleGroup,\n  OnBeforeScale,\n} from '../types';\nimport {\n  fillChildEvents,\n  startChildDist,\n  triggerChildAbles,\n} from '../groupUtils';\nimport Draggable from './Draggable';\nimport { calculate, createRotateMatrix, plus, minus } from '@scena/matrix';\nimport CustomGesto from '../gesto/CustomGesto';\nimport { checkSnapScale } from './Snappable';\nimport {\n  isArray,\n  IObject,\n  getDist,\n  throttle,\n  calculateBoundSize,\n} from '@daybrush/utils';\nimport { getFixedDirectionInfo } from '../utils/getFixedDirection';\n\nconst directionCondition = getDirectionCondition('scalable');\n\n/**\n * @namespace Scalable\n * @memberof Moveable\n * @description Scalable indicates whether the target's x and y can be scale of transform.\n */\nexport default {\n  name: 'scalable',\n  ableGroup: 'size',\n  canPinch: true,\n  props: [\n    'scalable',\n    'throttleScale',\n    'renderDirections',\n    'keepRatio',\n    'edge',\n    'displayAroundControls',\n  ] as const,\n  events: [\n    'scaleStart',\n    'beforeScale',\n    'scale',\n    'scaleEnd',\n    'scaleGroupStart',\n    'beforeScaleGroup',\n    'scaleGroup',\n    'scaleGroupEnd',\n  ] as const,\n  render: getRenderDirections('scalable'),\n  dragControlCondition: directionCondition,\n  viewClassName: getDirectionViewClassName('scalable'),\n  dragControlStart(\n    moveable: MoveableManagerInterface<\n      ScalableProps & DraggableProps,\n      SnappableState\n    >,\n    e: any,\n  ) {\n    const { datas, isPinch, inputEvent, parentDirection } = e;\n\n    const direction = getTotalDirection(\n      parentDirection,\n      isPinch,\n      inputEvent,\n      datas,\n    );\n    const { width, height, targetTransform, target, pos1, pos2, pos4 } =\n      moveable.state;\n\n    if (!direction || !target) {\n      return false;\n    }\n    if (!isPinch) {\n      setDragStart(moveable, e);\n    }\n    datas.datas = {};\n    datas.transform = targetTransform;\n    datas.prevDist = [1, 1];\n    datas.direction = direction;\n    datas.startOffsetWidth = width;\n    datas.startOffsetHeight = height;\n    datas.startValue = [1, 1];\n\n    // const scaleWidth = getDist(pos1, pos2);\n    // const scaleHeight = getDist(pos2, pos4);\n    const isWidth =\n      (!direction[0] && !direction[1]) || direction[0] || !direction[1];\n\n    // datas.scaleWidth = scaleWidth;\n    // datas.scaleHeight = scaleHeight;\n    // datas.scaleXRatio = scaleWidth / width;\n    // datas.scaleYRatio = scaleHeight / height;\n\n    setDefaultTransformIndex(moveable, e, 'scale');\n\n    datas.isWidth = isWidth;\n\n    function setRatio(ratio: number) {\n      datas.ratio = ratio && isFinite(ratio) ? ratio : 0;\n    }\n\n    datas.startPositions = getAbsolutePosesByState(moveable.state);\n    function setFixedDirection(fixedDirection: number[]) {\n      const result = getFixedDirectionInfo(\n        datas.startPositions,\n        fixedDirection,\n      );\n\n      datas.fixedDirection = result.fixedDirection;\n      datas.fixedPosition = result.fixedPosition;\n      datas.fixedOffset = result.fixedOffset;\n    }\n\n    datas.setFixedDirection = setFixedDirection;\n    setRatio(getDist(pos1, pos2) / getDist(pos2, pos4));\n    setFixedDirection([-direction[0], -direction[1]]);\n\n    const setMinScaleSize = (min: number[]) => {\n      datas.minScaleSize = min;\n    };\n    const setMaxScaleSize = (max: number[]) => {\n      datas.maxScaleSize = max;\n    };\n    // const setMinScale = (min: number[]) => {\n    // };\n    // const setMaxScale = (max: number[]) => {\n    // };\n\n    setMinScaleSize([-Infinity, -Infinity]);\n    setMaxScaleSize([Infinity, Infinity]);\n    const params = fillParams<OnScaleStart>(moveable, e, {\n      direction,\n      set: (scale: number[]) => {\n        datas.startValue = scale;\n      },\n      setRatio,\n      setFixedDirection,\n      setMinScaleSize,\n      setMaxScaleSize,\n      ...fillTransformStartEvent(moveable, e),\n      dragStart: Draggable.dragStart(\n        moveable,\n        new CustomGesto().dragStart([0, 0], e),\n      ) as OnDragStart,\n    });\n    const result = triggerEvent(moveable, 'onScaleStart', params);\n\n    datas.startFixedDirection = datas.fixedDirection;\n\n    if (result !== false) {\n      datas.isScale = true;\n      moveable.state.snapRenderInfo = {\n        request: e.isRequest,\n        direction,\n      };\n    }\n    return datas.isScale ? params : false;\n  },\n  dragControl(\n    moveable: MoveableManagerInterface<\n      ScalableProps & DraggableProps & GroupableProps,\n      SnappableState\n    >,\n    e: any,\n  ) {\n    resolveTransformEvent(moveable, e, 'scale');\n    const {\n      datas,\n      parentKeepRatio,\n      parentFlag,\n      isPinch,\n      dragClient,\n      isRequest,\n      useSnap,\n      resolveMatrix,\n    } = e;\n    const {\n      prevDist,\n      direction,\n      startOffsetWidth,\n      startOffsetHeight,\n      isScale,\n      startValue,\n      isWidth,\n      ratio,\n    } = datas;\n\n    if (!isScale) {\n      return false;\n    }\n\n    const props = moveable.props;\n    const { throttleScale, parentMoveable } = props;\n    let sizeDirection = direction;\n\n    if (!direction[0] && !direction[1]) {\n      sizeDirection = [1, 1];\n    }\n    const keepRatio =\n      (ratio &&\n        (parentKeepRatio != null ? parentKeepRatio : props.keepRatio)) ||\n      false;\n    const state = moveable.state;\n\n    const tempScaleValue = [startValue[0], startValue[1]];\n\n    function getNextScale() {\n      const { distWidth, distHeight } = getOffsetSizeDist(\n        sizeDirection,\n        keepRatio,\n        datas,\n        e,\n      );\n\n      const distX = startOffsetWidth\n        ? (startOffsetWidth + distWidth) / startOffsetWidth\n        : 1;\n      const distY = startOffsetHeight\n        ? (startOffsetHeight + distHeight) / startOffsetHeight\n        : 1;\n\n      if (!startValue[0]) {\n        tempScaleValue[0] = distWidth / startOffsetWidth;\n      }\n      if (!startValue[1]) {\n        tempScaleValue[1] = distHeight / startOffsetHeight;\n      }\n      let scaleX =\n        (sizeDirection[0] || keepRatio ? distX : 1) * tempScaleValue[0];\n      let scaleY =\n        (sizeDirection[1] || keepRatio ? distY : 1) * tempScaleValue[1];\n\n      if (scaleX === 0) {\n        scaleX = sign(prevDist[0]) * MIN_SCALE;\n      }\n      if (scaleY === 0) {\n        scaleY = sign(prevDist[1]) * MIN_SCALE;\n      }\n      return [scaleX, scaleY];\n    }\n\n    let scale = getNextScale();\n\n    if (!isPinch && moveable.props.groupable) {\n      const snapRenderInfo = state.snapRenderInfo || {};\n      const stateDirection = snapRenderInfo.direction;\n\n      if (isArray(stateDirection) && (stateDirection[0] || stateDirection[1])) {\n        state.snapRenderInfo = { direction, request: e.isRequest };\n      }\n    }\n\n    triggerEvent(\n      moveable,\n      'onBeforeScale',\n      fillParams<OnBeforeScale>(\n        moveable,\n        e,\n        {\n          scale,\n          setFixedDirection(nextFixedDirection: number[]) {\n            datas.setFixedDirection(nextFixedDirection);\n\n            scale = getNextScale();\n            return scale;\n          },\n          startFixedDirection: datas.startFixedDirection,\n          setScale(nextScale: number[]) {\n            scale = nextScale;\n          },\n        },\n        true,\n      ),\n    );\n\n    let dist = [scale[0] / tempScaleValue[0], scale[1] / tempScaleValue[1]];\n    let fixedPosition = dragClient;\n    let snapDist = [0, 0];\n\n    const distSign = sign(dist[0] * dist[1]);\n    const isSelfPinch = !dragClient && !parentFlag && isPinch;\n\n    if (isSelfPinch || resolveMatrix) {\n      fixedPosition = getTranslateFixedPosition(\n        moveable,\n        datas.targetAllTransform,\n        [0, 0],\n        [0, 0],\n        datas,\n      );\n    } else if (!dragClient) {\n      fixedPosition = datas.fixedPosition;\n    }\n    if (!isPinch) {\n      snapDist = checkSnapScale(\n        moveable,\n        dist,\n        direction,\n        !useSnap && isRequest,\n        datas,\n      );\n    }\n\n    if (keepRatio) {\n      if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {\n        if (\n          Math.abs(snapDist[0] * startOffsetWidth) >\n          Math.abs(snapDist[1] * startOffsetHeight)\n        ) {\n          snapDist[1] = 0;\n        } else {\n          snapDist[0] = 0;\n        }\n      }\n\n      const isNoSnap = !snapDist[0] && !snapDist[1];\n\n      if (isNoSnap) {\n        // throttle scale value (not absolute scale size)\n        if (isWidth) {\n          dist[0] =\n            throttle(dist[0] * tempScaleValue[0], throttleScale!) /\n            tempScaleValue[0];\n        } else {\n          dist[1] =\n            throttle(dist[1] * tempScaleValue[1], throttleScale!) /\n            tempScaleValue[1];\n        }\n      }\n      if (\n        (sizeDirection[0] && !sizeDirection[1]) ||\n        (snapDist[0] && !snapDist[1]) ||\n        (isNoSnap && isWidth)\n      ) {\n        dist[0] += snapDist[0];\n        const snapHeight =\n          (startOffsetWidth * dist[0] * tempScaleValue[0]) / ratio;\n\n        dist[1] =\n          sign(distSign * dist[0]) *\n          abs(snapHeight / startOffsetHeight / tempScaleValue[1]);\n      } else if (\n        (!sizeDirection[0] && sizeDirection[1]) ||\n        (!snapDist[0] && snapDist[1]) ||\n        (isNoSnap && !isWidth)\n      ) {\n        dist[1] += snapDist[1];\n        const snapWidth =\n          startOffsetHeight * dist[1] * tempScaleValue[1] * ratio;\n\n        dist[0] =\n          sign(distSign * dist[1]) *\n          abs(snapWidth / startOffsetWidth / tempScaleValue[0]);\n      }\n    } else {\n      dist[0] += snapDist[0];\n      dist[1] += snapDist[1];\n\n      if (!snapDist[0]) {\n        dist[0] =\n          throttle(dist[0] * tempScaleValue[0], throttleScale!) /\n          tempScaleValue[0];\n      }\n      if (!snapDist[1]) {\n        dist[1] =\n          throttle(dist[1] * tempScaleValue[1], throttleScale!) /\n          tempScaleValue[1];\n      }\n    }\n\n    if (dist[0] === 0) {\n      dist[0] = sign(prevDist[0]) * MIN_SCALE;\n    }\n    if (dist[1] === 0) {\n      dist[1] = sign(prevDist[1]) * MIN_SCALE;\n    }\n    scale = multiply2(dist, [tempScaleValue[0], tempScaleValue[1]]);\n\n    const startOffsetSize = [startOffsetWidth, startOffsetHeight];\n    let scaleSize = [startOffsetWidth * scale[0], startOffsetHeight * scale[1]];\n\n    scaleSize = calculateBoundSize(\n      scaleSize,\n      datas.minScaleSize,\n      datas.maxScaleSize,\n      keepRatio ? ratio : false,\n    );\n\n    // if (keepRatio && (isGroup || keepRatioFinally)) {\n    //     if (isWidth) {\n    //         boundingHeight = boundingWidth / ratio;\n    //     } else {\n    //         boundingWidth = boundingHeight * ratio;\n    //     }\n    // }\n    scale = countEach(2, (i) => {\n      return startOffsetSize[i]\n        ? scaleSize[i] / startOffsetSize[i]\n        : scaleSize[i];\n    });\n    dist = countEach(2, (i) => {\n      return scale[i] / tempScaleValue[i];\n    });\n\n    const delta = countEach(2, (i) =>\n      prevDist[i] ? dist[i] / prevDist[i] : dist[i],\n    );\n\n    const distText = `scale(${dist.join(', ')})`;\n    const scaleText = `scale(${scale.join(', ')})`;\n    const nextTransform = convertTransformFormat(datas, scaleText, distText);\n    const isZeroScale = !startValue[0] || !startValue[1];\n\n    const inverseDist = getScaleDist(\n      moveable,\n      isZeroScale ? scaleText : distText,\n      datas.fixedDirection,\n      fixedPosition,\n      datas.fixedOffset,\n      datas,\n      isZeroScale,\n    );\n    const inverseDelta = isSelfPinch\n      ? inverseDist\n      : minus(inverseDist, datas.prevInverseDist || [0, 0]);\n\n    datas.prevDist = dist;\n    datas.prevInverseDist = inverseDist;\n    if (\n      scale[0] === prevDist[0] &&\n      scale[1] === prevDist[1] &&\n      inverseDelta.every((num) => !num) &&\n      !parentMoveable &&\n      !isSelfPinch\n    ) {\n      return false;\n    }\n\n    const params = fillParams<OnScale>(moveable, e, {\n      offsetWidth: startOffsetWidth,\n      offsetHeight: startOffsetHeight,\n      direction,\n\n      scale,\n      dist,\n      delta,\n\n      isPinch: !!isPinch,\n      ...fillTransformEvent(moveable, nextTransform, inverseDelta, isPinch, e),\n    });\n    triggerEvent(moveable, 'onScale', params);\n\n    return params;\n  },\n  dragControlEnd(moveable: MoveableManagerInterface<ScalableProps>, e: any) {\n    const { datas } = e;\n    if (!datas.isScale) {\n      return false;\n    }\n\n    datas.isScale = false;\n\n    const scaleEndParam = fillEndParams<OnScaleEnd>(moveable, e, {});\n    triggerEvent(moveable, 'onScaleEnd', scaleEndParam);\n    return scaleEndParam;\n  },\n  dragGroupControlCondition: directionCondition,\n  dragGroupControlStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n    const { datas } = e;\n\n    const params = this.dragControlStart(moveable, e);\n\n    if (!params) {\n      return false;\n    }\n    const originalEvents = fillChildEvents(moveable, 'resizable', e);\n\n    datas.moveableScale = moveable.scale;\n\n    const events = triggerChildAbles(\n      moveable,\n      this,\n      'dragControlStart',\n      e,\n      (child, ev) => {\n        return startChildDist(moveable, child, datas, ev);\n      },\n    );\n\n    const setFixedDirection = (fixedDirection: number[]) => {\n      params.setFixedDirection(fixedDirection);\n      events.forEach((ev, i) => {\n        ev.setFixedDirection(fixedDirection);\n        startChildDist(moveable, ev.moveable, datas, originalEvents[i]);\n      });\n    };\n\n    datas.setFixedDirection = setFixedDirection;\n    const nextParams: OnScaleGroupStart = {\n      ...params,\n      targets: moveable.props.targets!,\n      events,\n      setFixedDirection,\n    };\n    const result = triggerEvent(moveable, 'onScaleGroupStart', nextParams);\n\n    datas.isScale = result !== false;\n    return datas.isScale ? nextParams : false;\n  },\n  dragGroupControl(moveable: MoveableGroupInterface<any, any>, e: any) {\n    const { datas } = e;\n    if (!datas.isScale) {\n      return;\n    }\n\n    catchEvent(moveable, 'onBeforeScale', (parentEvent) => {\n      triggerEvent(\n        moveable,\n        'onBeforeScaleGroup',\n        fillParams<OnBeforeScaleGroup>(\n          moveable,\n          e,\n          {\n            ...parentEvent,\n            targets: moveable.props.targets!,\n          },\n          true,\n        ),\n      );\n    });\n\n    const params = this.dragControl(moveable, e);\n    if (!params) {\n      return;\n    }\n    const { dist } = params;\n    const moveableScale = datas.moveableScale;\n    moveable.scale = [dist[0] * moveableScale[0], dist[1] * moveableScale[1]];\n    const keepRatio = moveable.props.keepRatio;\n\n    const fixedPosition = datas.fixedPosition;\n    const events = triggerChildAbles(\n      moveable,\n      this,\n      'dragControl',\n      e,\n      (_, ev) => {\n        const [clientX, clientY] = calculate(\n          createRotateMatrix((moveable.rotation / 180) * Math.PI, 3),\n          [ev.datas.originalX * dist[0], ev.datas.originalY * dist[1], 1],\n          3,\n        );\n\n        return {\n          ...ev,\n          parentDist: null,\n          parentScale: dist,\n          parentKeepRatio: keepRatio,\n          // recalculate child fixed position for parent group's dragging.\n          dragClient: plus(fixedPosition, [clientX, clientY]),\n        };\n      },\n    );\n    const nextParams: OnScaleGroup = {\n      targets: moveable.props.targets!,\n      events,\n      ...params,\n    };\n\n    triggerEvent(moveable, 'onScaleGroup', nextParams);\n    return nextParams;\n  },\n  dragGroupControlEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n    const { isDrag, datas } = e;\n\n    if (!datas.isScale) {\n      return;\n    }\n    this.dragControlEnd(moveable, e);\n    const events = triggerChildAbles(moveable, this, 'dragControlEnd', e);\n\n    const nextParams = fillEndParams<OnScaleGroupEnd>(moveable, e, {\n      targets: moveable.props.targets!,\n      events,\n    });\n\n    triggerEvent(moveable, 'onScaleGroupEnd', nextParams);\n    return isDrag;\n  },\n  /**\n     * @method Moveable.Scalable#request\n     * @param {Moveable.Scalable.ScalableRequestParam} e - the Scalable's request parameter\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * moveable.request(\"scalable\", { deltaWidth: 10, deltaHeight: 10 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"scalable\");\n     *\n     * // request\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n  request() {\n    const datas = {};\n    let distWidth = 0;\n    let distHeight = 0;\n    let useSnap = false;\n\n    return {\n      isControl: true,\n      requestStart(e: IObject<any>) {\n        useSnap = e.useSnap;\n\n        return {\n          datas,\n          parentDirection: e.direction || [1, 1],\n          useSnap,\n        };\n      },\n      request(e: IObject<any>) {\n        distWidth += e.deltaWidth;\n        distHeight += e.deltaHeight;\n\n        return {\n          datas,\n          parentDist: [distWidth, distHeight],\n          parentKeepRatio: e.keepRatio,\n          useSnap,\n        };\n      },\n      requestEnd() {\n        return { datas, isDrag: true, useSnap };\n      },\n    };\n  },\n};\n\n/**\n * Whether or not target can scaled.\n *\n * @name Moveable.Scalable#scalable\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.scalable = true;\n */\n\n/**\n * throttle of scaleX, scaleY when scale.\n * @name Moveable.Scalable#throttleScale\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleScale = 0.1;\n */\n/**\n * Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\n * @name Moveable.Scalable#renderDirections\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     scalable: true,\n *   renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n * });\n *\n * moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n */\n/**\n * When resize or scale, keeps a ratio of the width, height. (default: false)\n * @name Moveable.Scalable#keepRatio\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     scalable: true,\n * });\n *\n * moveable.keepRatio = true;\n */\n/**\n * When the scale starts, the scaleStart event is called.\n * @memberof Moveable.Scalable\n * @event scaleStart\n * @param {Moveable.Scalable.OnScaleStart} - Parameters for the scaleStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scaleStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When scaling, `beforeScale` is called before `scale` occurs. In `beforeScale`, you can get and set the pre-value before scaling.\n * @memberof Moveable.Scalable\n * @event beforeScale\n * @param {Moveable.Scalable.OnBeforeScale} - Parameters for the `beforeScale` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"beforeScale\", ({ setFixedDirection }) => {\n *     if (shiftKey) {\n *        setFixedDirection([0, 0]);\n *     }\n * });\n * moveable.on(\"scale\", ({ target, transform, dist }) => {\n *     target.style.transform = transform;\n * });\n */\n\n/**\n * When scaling, the `scale` event is called.\n * @memberof Moveable.Scalable\n * @event scale\n * @param {Moveable.Scalable.OnScale} - Parameters for the `scale` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scale\", ({ target, transform, dist }) => {\n *     target.style.transform = transform;\n * });\n */\n/**\n * When the scale finishes, the `scaleEnd` event is called.\n * @memberof Moveable.Scalable\n * @event scaleEnd\n * @param {Moveable.Scalable.OnScaleEnd} - Parameters for the `scaleEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scaleEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n * When the group scale starts, the `scaleGroupStart` event is called.\n * @memberof Moveable.Scalable\n * @event scaleGroupStart\n * @param {Moveable.Scalable.OnScaleGroupStart} - Parameters for the `scaleGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     scalable: true\n * });\n * moveable.on(\"scaleGroupStart\", ({ targets }) => {\n *     console.log(\"onScaleGroupStart\", targets);\n * });\n */\n\n/**\n * When the group scale, the `scaleGroup` event is called.\n * @memberof Moveable.Scalable\n * @event scaleGroup\n * @param {Moveable.Scalable.OnScaleGroup} - Parameters for the `scaleGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     scalable: true\n * });\n * moveable.on(\"scaleGroup\", ({ targets, events }) => {\n *     console.log(\"onScaleGroup\", targets);\n *     events.forEach(ev => {\n *         const target = ev.target;\n *         // ev.drag is a drag event that occurs when the group scale.\n *         const left = ev.drag.beforeDist[0];\n *         const top = ev.drag.beforeDist[1];\n *         const scaleX = ev.scale[0];\n *         const scaleY = ev.scale[1];\n *     });\n * });\n */\n\n/**\n * When the group scale finishes, the `scaleGroupEnd` event is called.\n * @memberof Moveable.Scalable\n * @event scaleGroupEnd\n * @param {Moveable.Scalable.OnScaleGroupEnd} - Parameters for the `scaleGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     scalable: true\n * });\n * moveable.on(\"scaleGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onScaleGroupEnd\", targets, isDrag);\n * });\n */\n", "import {\n  prefix,\n  getLineStyle,\n  getDirection,\n  getAbsolutePosesByState,\n  triggerEvent,\n  fillParams,\n  fillEndParams,\n  getDirectionViewClassName,\n  fillCSSObject,\n} from '../utils';\nimport {\n  convertDimension,\n  invert,\n  multiply,\n  calculate,\n  createIdentityMatrix,\n  ignoreDimension,\n  minus,\n  createWarpMatrix,\n  plus,\n} from '@scena/matrix';\nimport { NEARBY_POS } from '../consts';\nimport {\n  setDragStart,\n  getDragDist,\n  getPosIndexesByDirection,\n  setDefaultTransformIndex,\n  fillTransformStartEvent,\n  resolveTransformEvent,\n  convertTransformFormat,\n  fillOriginalTransform,\n  getTransfromMatrix,\n} from '../gesto/GestoUtils';\nimport {\n  WarpableProps,\n  ScalableProps,\n  ResizableProps,\n  Renderer,\n  SnappableProps,\n  SnappableState,\n  OnWarpStart,\n  OnWarp,\n  OnWarpEnd,\n  MoveableManagerInterface,\n} from '../types';\nimport { hasClass, dot, getRad } from '@daybrush/utils';\nimport { renderAllDirections } from '../render-directions';\nimport { hasGuidelines } from './snappable/utils';\nimport { checkMoveableSnapBounds } from './snappable/snapBounds';\n\nfunction getMiddleLinePos(pos1: number[], pos2: number[]) {\n  return pos1.map((pos, i) => dot(pos, pos2[i], 1, 2));\n}\n\nfunction getTriangleRad(pos1: number[], pos2: number[], pos3: number[]) {\n  // pos1 Rad\n  const rad1 = getRad(pos1, pos2);\n  const rad2 = getRad(pos1, pos3);\n\n  const rad = rad2 - rad1;\n\n  return rad >= 0 ? rad : rad + 2 * Math.PI;\n}\n\nfunction isValidPos(poses1: number[][], poses2: number[][]) {\n  const rad1 = getTriangleRad(poses1[0], poses1[1], poses1[2]);\n  const rad2 = getTriangleRad(poses2[0], poses2[1], poses2[2]);\n  const pi = Math.PI;\n\n  if ((rad1 >= pi && rad2 <= pi) || (rad1 <= pi && rad2 >= pi)) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * @namespace Moveable.Warpable\n * @description Warpable indicates whether the target can be warped(distorted, bented).\n */\nexport default {\n  name: 'warpable',\n  ableGroup: 'size',\n  props: [\n    'warpable',\n    'renderDirections',\n    'edge',\n    'displayAroundControls',\n  ] as const,\n  events: ['warpStart', 'warp', 'warpEnd'] as const,\n  viewClassName: getDirectionViewClassName('warpable'),\n  render(\n    moveable: MoveableManagerInterface<\n      ResizableProps & ScalableProps & WarpableProps\n    >,\n    React: Renderer,\n  ): any[] {\n    const { resizable, scalable, warpable, zoom } = moveable.props;\n\n    if (resizable || scalable || !warpable) {\n      return [];\n    }\n    const { pos1, pos2, pos3, pos4 } = moveable.state;\n\n    const linePosFrom1 = getMiddleLinePos(pos1, pos2);\n    const linePosFrom2 = getMiddleLinePos(pos2, pos1);\n    const linePosFrom3 = getMiddleLinePos(pos1, pos3);\n    const linePosFrom4 = getMiddleLinePos(pos3, pos1);\n    const linePosTo1 = getMiddleLinePos(pos3, pos4);\n    const linePosTo2 = getMiddleLinePos(pos4, pos3);\n    const linePosTo3 = getMiddleLinePos(pos2, pos4);\n    const linePosTo4 = getMiddleLinePos(pos4, pos2);\n\n    return [\n      <div\n        className={prefix('line')}\n        key=\"middeLine1\"\n        style={getLineStyle(linePosFrom1, linePosTo1, zoom)}\n      ></div>,\n      <div\n        className={prefix('line')}\n        key=\"middeLine2\"\n        style={getLineStyle(linePosFrom2, linePosTo2, zoom)}\n      ></div>,\n      <div\n        className={prefix('line')}\n        key=\"middeLine3\"\n        style={getLineStyle(linePosFrom3, linePosTo3, zoom)}\n      ></div>,\n      <div\n        className={prefix('line')}\n        key=\"middeLine4\"\n        style={getLineStyle(linePosFrom4, linePosTo4, zoom)}\n      ></div>,\n      ...renderAllDirections(moveable, 'warpable', React),\n    ];\n  },\n  dragControlCondition(moveable: any, e: any) {\n    if (e.isRequest) {\n      return false;\n    }\n    const target = e.inputEvent.target;\n\n    return (\n      hasClass(target, prefix('direction')) &&\n      hasClass(target, prefix('warpable'))\n    );\n  },\n  dragControlStart(\n    moveable: MoveableManagerInterface<WarpableProps, SnappableState>,\n    e: any,\n  ) {\n    const { datas, inputEvent } = e;\n    const { target } = moveable.props;\n    const { target: inputTarget } = inputEvent;\n    const direction = getDirection(inputTarget, datas);\n\n    if (!direction || !target) {\n      return false;\n    }\n    const state = moveable.state;\n    const {\n      transformOrigin,\n      is3d,\n      targetTransform,\n      targetMatrix,\n      width,\n      height,\n      left,\n      top,\n    } = state;\n\n    datas.datas = {};\n    datas.targetTransform = targetTransform;\n    datas.warpTargetMatrix = is3d\n      ? targetMatrix\n      : convertDimension(targetMatrix, 3, 4);\n    datas.targetInverseMatrix = ignoreDimension(\n      invert(datas.warpTargetMatrix, 4),\n      3,\n      4,\n    );\n    datas.direction = direction;\n    datas.left = left;\n    datas.top = top;\n    datas.poses = [\n      [0, 0],\n      [width, 0],\n      [0, height],\n      [width, height],\n    ].map((p) => minus(p, transformOrigin));\n\n    datas.nextPoses = datas.poses.map(([x, y]: number[]) =>\n      calculate(datas.warpTargetMatrix, [x, y, 0, 1], 4),\n    );\n    datas.startValue = createIdentityMatrix(4);\n    datas.prevMatrix = createIdentityMatrix(4);\n    datas.absolutePoses = getAbsolutePosesByState(state);\n    datas.posIndexes = getPosIndexesByDirection(direction);\n\n    setDragStart(moveable, e);\n    setDefaultTransformIndex(moveable, e, 'matrix3d');\n\n    state.snapRenderInfo = {\n      request: e.isRequest,\n      direction,\n    };\n\n    const params = fillParams<OnWarpStart>(moveable, e, {\n      set: (matrix: number[]) => {\n        datas.startValue = matrix;\n      },\n      ...fillTransformStartEvent(moveable, e),\n    });\n    const result = triggerEvent(moveable, 'onWarpStart', params);\n    if (result !== false) {\n      datas.isWarp = true;\n    }\n    return datas.isWarp;\n  },\n  dragControl(\n    moveable: MoveableManagerInterface<\n      WarpableProps & SnappableProps,\n      SnappableState\n    >,\n    e: any,\n  ) {\n    const { datas, isRequest } = e;\n    let { distX, distY } = e;\n    const {\n      targetInverseMatrix,\n      prevMatrix,\n      isWarp,\n      startValue,\n      poses,\n      posIndexes,\n      absolutePoses,\n    } = datas;\n\n    if (!isWarp) {\n      return false;\n    }\n    resolveTransformEvent(moveable, e, 'matrix3d');\n    if (hasGuidelines(moveable, 'warpable')) {\n      const selectedPoses: number[][] = posIndexes.map(\n        (index: number) => absolutePoses[index],\n      );\n\n      if (selectedPoses.length > 1) {\n        selectedPoses.push([\n          (selectedPoses[0][0] + selectedPoses[1][0]) / 2,\n          (selectedPoses[0][1] + selectedPoses[1][1]) / 2,\n        ]);\n      }\n\n      const { horizontal: horizontalSnapInfo, vertical: verticalSnapInfo } =\n        checkMoveableSnapBounds(moveable, isRequest, {\n          horizontal: selectedPoses.map((pos) => pos[1] + distY),\n          vertical: selectedPoses.map((pos) => pos[0] + distX),\n        });\n\n      distY -= horizontalSnapInfo.offset;\n      distX -= verticalSnapInfo.offset;\n    }\n\n    const dist = getDragDist({ datas, distX, distY }, true);\n    const nextPoses = datas.nextPoses.slice();\n\n    posIndexes.forEach((index: number) => {\n      nextPoses[index] = plus(nextPoses[index], dist);\n    });\n\n    if (\n      !NEARBY_POS.every((nearByPoses) =>\n        isValidPos(\n          nearByPoses.map((i) => poses[i]),\n          nearByPoses.map((i) => nextPoses[i]),\n        ),\n      )\n    ) {\n      return false;\n    }\n    const h = createWarpMatrix(\n      poses[0],\n      poses[2],\n      poses[1],\n      poses[3],\n      nextPoses[0],\n      nextPoses[2],\n      nextPoses[1],\n      nextPoses[3],\n    );\n\n    if (!h.length) {\n      return false;\n    }\n    // B * A * M\n    const afterMatrix = multiply(targetInverseMatrix, h, 4);\n\n    // B * M * A\n    const matrix = getTransfromMatrix(datas, afterMatrix, true);\n\n    const delta = multiply(invert(prevMatrix, 4), matrix, 4);\n\n    datas.prevMatrix = matrix;\n    const totalMatrix = multiply(startValue, matrix, 4);\n    const nextTransform = convertTransformFormat(\n      datas,\n      `matrix3d(${totalMatrix.join(', ')})`,\n      `matrix3d(${matrix.join(', ')})`,\n    );\n\n    fillOriginalTransform(e, nextTransform);\n    triggerEvent(\n      moveable,\n      'onWarp',\n      fillParams<OnWarp>(moveable, e, {\n        delta,\n        matrix: totalMatrix,\n        dist: matrix,\n        multiply,\n        transform: nextTransform,\n        ...fillCSSObject(\n          {\n            transform: nextTransform,\n          },\n          e,\n        ),\n      }),\n    );\n    return true;\n  },\n  dragControlEnd(moveable: MoveableManagerInterface<WarpableProps>, e: any) {\n    const { datas, isDrag } = e;\n    if (!datas.isWarp) {\n      return false;\n    }\n    datas.isWarp = false;\n\n    triggerEvent(\n      moveable,\n      'onWarpEnd',\n      fillEndParams<OnWarpEnd>(moveable, e, {}),\n    );\n    return isDrag;\n  },\n};\n\n/**\n * Whether or not target can be warped. (default: false)\n * @name Moveable.Warpable#warpable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.warpable = true;\n */\n\n/**\n * Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\n * @name Moveable.Warpable#renderDirections\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     warpable: true,\n *     renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n * });\n *\n * moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n */\n/**\n * When the warp starts, the warpStart event is called.\n * @memberof Moveable.Warpable\n * @event warpStart\n * @param {Moveable.Warpable.OnWarpStart} - Parameters for the warpStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { warpable: true });\n * moveable.on(\"warpStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When warping, the warp event is called.\n * @memberof Moveable.Warpable\n * @event warp\n * @param {Moveable.Warpable.OnWarp} - Parameters for the warp event\n * @example\n * import Moveable from \"moveable\";\n * let matrix = [\n *  1, 0, 0, 0,\n *  0, 1, 0, 0,\n *  0, 0, 1, 0,\n *  0, 0, 0, 1,\n * ];\n * const moveable = new Moveable(document.body, { warpable: true });\n * moveable.on(\"warp\", ({ target, transform, delta, multiply }) => {\n *    // target.style.transform = transform;\n *    matrix = multiply(matrix, delta);\n *    target.style.transform = `matrix3d(${matrix.join(\",\")})`;\n * });\n */\n/**\n * When the warp finishes, the warpEnd event is called.\n * @memberof Moveable.Warpable\n * @event warpEnd\n * @param {Moveable.Warpable.OnWarpEnd} - Parameters for the warpEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { warpable: true });\n * moveable.on(\"warpEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n", "import { prefix } from \"./utils\";\n\nexport const AREA_PIECES = /*#__PURE__*/prefix(\"area-pieces\");\nexport const AREA_PIECE = /*#__PURE__*/prefix(\"area-piece\");\nexport const AVOID = /*#__PURE__*/prefix(\"avoid\");\nexport const VIEW_DRAGGING = prefix(\"view-dragging\");\n", "import { createWarpMatrix } from '@scena/matrix';\nimport { ref } from '../utils/framework-utils';\nimport {\n  getRect,\n  calculateInversePosition,\n  makeMatrixCSS,\n  prefix,\n} from '../utils';\nimport {\n  Renderer,\n  GroupableProps,\n  DragAreaProps,\n  MoveableManagerInterface,\n  MoveableGroupInterface,\n} from '../types';\nimport { AREA_PIECE, AVOID, AREA_PIECES } from '../classNames';\nimport { addClass, removeClass, requestAnimationFrame } from '@daybrush/utils';\n\nfunction restoreStyle(moveable: MoveableManagerInterface) {\n  const el = moveable.areaElement;\n\n  if (!el) {\n    return;\n  }\n  const { width, height } = moveable.state;\n\n  removeClass(el, AVOID);\n\n  el.style.cssText += `left: 0px; top: 0px; width: ${width}px; height: ${height}px`;\n}\n\nfunction renderPieces(React: Renderer): any {\n  return (\n    <div key=\"area_pieces\" className={AREA_PIECES}>\n      <div className={AREA_PIECE}></div>\n      <div className={AREA_PIECE}></div>\n      <div className={AREA_PIECE}></div>\n      <div className={AREA_PIECE}></div>\n    </div>\n  );\n}\nexport default {\n  name: 'dragArea',\n  props: ['dragArea', 'passDragArea'] as const,\n  events: ['click', 'clickGroup'] as const,\n  render(\n    moveable: MoveableManagerInterface<GroupableProps>,\n    React: Renderer,\n  ): any[] {\n    const { target, dragArea, groupable, passDragArea } = moveable.props;\n    const { width, height, renderPoses } = moveable.getState();\n\n    const className = passDragArea ? prefix('area', 'pass') : prefix('area');\n    if (groupable) {\n      return [\n        <div\n          key=\"area\"\n          ref={ref(moveable, 'areaElement')}\n          className={className}\n        ></div>,\n        renderPieces(React),\n      ];\n    }\n    if (!target || !dragArea) {\n      return [];\n    }\n    const h = createWarpMatrix(\n      [0, 0],\n      [width, 0],\n      [0, height],\n      [width, height],\n      renderPoses[0],\n      renderPoses[1],\n      renderPoses[2],\n      renderPoses[3],\n    );\n    const transform = h.length ? makeMatrixCSS(h, true) : 'none';\n\n    return [\n      <div\n        key=\"area\"\n        ref={ref(moveable, 'areaElement')}\n        className={className}\n        style={{\n          top: '0px',\n          left: '0px',\n          width: `${width}px`,\n          height: `${height}px`,\n          transformOrigin: '0 0',\n          transform,\n        }}\n      ></div>,\n      renderPieces(React),\n    ];\n  },\n  dragStart(\n    moveable: MoveableManagerInterface,\n    { datas, clientX, clientY, inputEvent }: any,\n  ) {\n    if (!inputEvent) {\n      return false;\n    }\n    datas.isDragArea = false;\n    const areaElement = moveable.areaElement;\n    const state = moveable.state;\n    const { moveableClientRect, renderPoses, rootMatrix, is3d } = state;\n    const { left, top } = moveableClientRect;\n    const {\n      left: relativeLeft,\n      top: relativeTop,\n      width,\n      height,\n    } = getRect(renderPoses);\n    const n = is3d ? 4 : 3;\n    let [posX, posY] = calculateInversePosition(\n      rootMatrix,\n      [clientX - left, clientY - top],\n      n,\n    );\n\n    posX -= relativeLeft;\n    posY -= relativeTop;\n    const rects = [\n      { left: relativeLeft, top: relativeTop, width, height: posY - 10 },\n      { left: relativeLeft, top: relativeTop, width: posX - 10, height },\n      {\n        left: relativeLeft,\n        top: relativeTop + posY + 10,\n        width,\n        height: height - posY - 10,\n      },\n      {\n        left: relativeLeft + posX + 10,\n        top: relativeTop,\n        width: width - posX - 10,\n        height,\n      },\n    ];\n\n    const children = [].slice.call(\n      areaElement.nextElementSibling!.children,\n    ) as HTMLElement[];\n    rects.forEach((rect, i) => {\n      children[i].style.cssText =\n        `left: ${rect.left}px;top: ${rect.top}px; width: ${rect.width}px; height: ${rect.height}px;`;\n    });\n    addClass(areaElement, AVOID);\n    state.disableNativeEvent = true;\n    return;\n  },\n  drag(moveable: MoveableManagerInterface, { datas, inputEvent }: any) {\n    this.enableNativeEvent(moveable);\n    if (!inputEvent) {\n      return false;\n    }\n    if (!datas.isDragArea) {\n      datas.isDragArea = true;\n      restoreStyle(moveable);\n    }\n  },\n  dragEnd(moveable: MoveableManagerInterface<DragAreaProps>, e: any) {\n    this.enableNativeEvent(moveable);\n    const { inputEvent, datas } = e;\n    if (!inputEvent) {\n      return false;\n    }\n    if (!datas.isDragArea) {\n      restoreStyle(moveable);\n    }\n  },\n  dragGroupStart(moveable: MoveableGroupInterface, e: any) {\n    return this.dragStart(moveable, e);\n  },\n  dragGroup(moveable: MoveableGroupInterface, e: any) {\n    return this.drag(moveable, e);\n  },\n  dragGroupEnd(moveable: MoveableGroupInterface<DragAreaProps>, e: any) {\n    return this.dragEnd(moveable, e);\n  },\n  unset(moveable: MoveableManagerInterface<DragAreaProps>) {\n    restoreStyle(moveable);\n    moveable.state.disableNativeEvent = false;\n  },\n  enableNativeEvent(moveable: MoveableManagerInterface<DragAreaProps>) {\n    const state = moveable.state;\n    if (state.disableNativeEvent) {\n      requestAnimationFrame(() => {\n        state.disableNativeEvent = false;\n      });\n    }\n  },\n};\n\n/**\n * Add an event to the moveable area instead of the target for stopPropagation. (default: false, true in group)\n * @name Moveable#dragArea\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  dragArea: false,\n * });\n */\n/**\n * Set `pointerEvents: none;` css to pass events in dragArea. (default: false)\n * @name Moveable#passDragArea\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  dragArea: false,\n * });\n */\n", "import { prefix, getControlTransform, calculatePosition, convertTransformOriginArray } from \"../utils\";\nimport { Renderer, OriginOptions, MoveableManagerInterface } from \"../types\";\nimport { makeAble } from \"./AbleManager\";\nimport { minus } from \"@scena/matrix\";\n\nexport default makeAble(\"origin\", {\n    props: [\"origin\", \"svgOrigin\"] as const,\n    render(moveable: MoveableManagerInterface<OriginOptions>, React: Renderer): any[] {\n        const { zoom, svgOrigin, groupable } = moveable.props;\n        const {\n            beforeOrigin, rotation, svg, allMatrix, is3d,\n            left, top, offsetWidth, offsetHeight,\n        } = moveable.getState();\n\n        let originStyle!: Record<string, any>;\n\n        if (!groupable && svg && svgOrigin) {\n            const [originX, originY] = convertTransformOriginArray(svgOrigin, offsetWidth, offsetHeight);\n            const n = is3d ? 4 : 3;\n            const result = calculatePosition(\n                allMatrix,\n                [originX, originY],\n                n,\n            );\n            originStyle = getControlTransform(rotation, zoom!, minus(result, [left, top]));\n        } else {\n            originStyle = getControlTransform(rotation, zoom!, beforeOrigin);\n        }\n        return [\n            <div className={prefix(\"control\", \"origin\")} style={originStyle} key=\"beforeOrigin\"></div>,\n        ];\n    },\n});\n\n/**\n * Whether or not the origin controlbox will be visible or not (default: true)\n * @name Moveable#origin\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.origin = true;\n */\n", "/*\nCopyright (c) 2019 Daybrush\nname: @scena/event-emitter\nlicense: MIT\nauthor: Daybrush\nrepository: git+https://github.com/daybrush/gesture.git\nversion: 1.0.5\n*/\nimport { isObject, findIndex } from '@daybrush/utils';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n}\n\n/**\n * Implement EventEmitter on object or component.\n */\n\nvar EventEmitter =\n/*#__PURE__*/\nfunction () {\n  function EventEmitter() {\n    this._events = {};\n  }\n  /**\n   * Add a listener to the registered event.\n   * @param - Name of the event to be added\n   * @param - listener function of the event to be added\n   * @example\n   * import EventEmitter from \"@scena/event-emitter\";\n   * cosnt emitter = new EventEmitter();\n   *\n   * // Add listener in \"a\" event\n   * emitter.on(\"a\", () => {\n   * });\n   * // Add listeners\n   * emitter.on({\n   *  a: () => {},\n   *  b: () => {},\n   * });\n   */\n\n\n  var __proto = EventEmitter.prototype;\n\n  __proto.on = function (eventName, listener) {\n    if (isObject(eventName)) {\n      for (var name in eventName) {\n        this.on(name, eventName[name]);\n      }\n    } else {\n      this._addEvent(eventName, listener, {});\n    }\n\n    return this;\n  };\n  /**\n   * Remove listeners registered in the event target.\n   * @param - Name of the event to be removed\n   * @param - listener function of the event to be removed\n   * @example\n   * import EventEmitter from \"@scena/event-emitter\";\n   * cosnt emitter = new EventEmitter();\n   *\n   * // Remove all listeners.\n   * emitter.off();\n   *\n   * // Remove all listeners in \"A\" event.\n   * emitter.off(\"a\");\n   *\n   *\n   * // Remove \"listener\" listener in \"a\" event.\n   * emitter.off(\"a\", listener);\n   */\n\n\n  __proto.off = function (eventName, listener) {\n    if (!eventName) {\n      this._events = {};\n    } else if (isObject(eventName)) {\n      for (var name in eventName) {\n        this.off(name);\n      }\n    } else if (!listener) {\n      this._events[eventName] = [];\n    } else {\n      var events = this._events[eventName];\n\n      if (events) {\n        var index = findIndex(events, function (e) {\n          return e.listener === listener;\n        });\n\n        if (index > -1) {\n          events.splice(index, 1);\n        }\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Add a disposable listener and Use promise to the registered event.\n   * @param - Name of the event to be added\n   * @param - disposable listener function of the event to be added\n   * @example\n   * import EventEmitter from \"@scena/event-emitter\";\n   * cosnt emitter = new EventEmitter();\n   *\n   * // Add a disposable listener in \"a\" event\n   * emitter.once(\"a\", () => {\n   * });\n   *\n   * // Use Promise\n   * emitter.once(\"a\").then(e => {\n   * });\n   */\n\n\n  __proto.once = function (eventName, listener) {\n    var _this = this;\n\n    if (listener) {\n      this._addEvent(eventName, listener, {\n        once: true\n      });\n    }\n\n    return new Promise(function (resolve) {\n      _this._addEvent(eventName, resolve, {\n        once: true\n      });\n    });\n  };\n  /**\n   * Fires an event to call listeners.\n   * @param - Event name\n   * @param - Event parameter\n   * @return If false, stop the event.\n   * @example\n   *\n   * import EventEmitter from \"@scena/event-emitter\";\n   *\n   *\n   * const emitter = new EventEmitter();\n   *\n   * emitter.on(\"a\", e => {\n   * });\n   *\n   *\n   * emitter.emit(\"a\", {\n   *   a: 1,\n   * });\n   */\n\n\n  __proto.emit = function (eventName, param) {\n    var _this = this;\n\n    if (param === void 0) {\n      param = {};\n    }\n\n    var events = this._events[eventName];\n\n    if (!eventName || !events) {\n      return true;\n    }\n\n    var isStop = false;\n    param.eventType = eventName;\n\n    param.stop = function () {\n      isStop = true;\n    };\n\n    param.currentTarget = this;\n\n    __spreadArrays(events).forEach(function (info) {\n      info.listener(param);\n\n      if (info.once) {\n        _this.off(eventName, info.listener);\n      }\n    });\n\n    return !isStop;\n  };\n  /**\n   * Fires an event to call listeners.\n   * @param - Event name\n   * @param - Event parameter\n   * @return If false, stop the event.\n   * @example\n   *\n   * import EventEmitter from \"@scena/event-emitter\";\n   *\n   *\n   * const emitter = new EventEmitter();\n   *\n   * emitter.on(\"a\", e => {\n   * });\n   *\n   *\n   * emitter.emit(\"a\", {\n   *   a: 1,\n   * });\n   */\n\n  /**\n  * Fires an event to call listeners.\n  * @param - Event name\n  * @param - Event parameter\n  * @return If false, stop the event.\n  * @example\n  *\n  * import EventEmitter from \"@scena/event-emitter\";\n  *\n  *\n  * const emitter = new EventEmitter();\n  *\n  * emitter.on(\"a\", e => {\n  * });\n  *\n  * // emit\n  * emitter.trigger(\"a\", {\n  *   a: 1,\n  * });\n  */\n\n\n  __proto.trigger = function (eventName, param) {\n    if (param === void 0) {\n      param = {};\n    }\n\n    return this.emit(eventName, param);\n  };\n\n  __proto._addEvent = function (eventName, listener, options) {\n    var events = this._events;\n    events[eventName] = events[eventName] || [];\n    var listeners = events[eventName];\n    listeners.push(__assign({\n      listener: listener\n    }, options));\n  };\n\n  return EventEmitter;\n}();\n\nexport default EventEmitter;\n//# sourceMappingURL=event-emitter.esm.js.map\n", "/*\nCopyright (c) 2019 Daybrush\nname: @scena/dragscroll\nlicense: MIT\nauthor: Daybrush\nrepository: git+https://github.com/daybrush/dragscroll.git\nversion: 1.4.0\n*/\nimport EventEmitter from '@scena/event-emitter';\nimport { now, isString, isFunction } from '@daybrush/utils';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n  return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n  extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\n\nfunction getDefaultScrollPosition(e) {\n  var container = e.container;\n  if (container === document.body) {\n    return [container.scrollLeft || document.documentElement.scrollLeft, container.scrollTop || document.documentElement.scrollTop];\n  }\n  return [container.scrollLeft, container.scrollTop];\n}\nfunction checkDefaultScrollEvent(container, callback) {\n  container.addEventListener(\"scroll\", callback);\n  return function () {\n    container.removeEventListener(\"scroll\", callback);\n  };\n}\nfunction getContainerElement(container) {\n  if (!container) {\n    return null;\n  } else if (isString(container)) {\n    return document.querySelector(container);\n  }\n  if (isFunction(container)) {\n    return container();\n  } else if (container instanceof Element) {\n    return container;\n  } else if (\"current\" in container) {\n    return container.current;\n  } else if (\"value\" in container) {\n    return container.value;\n  }\n}\n/**\n * @sort 1\n */\nvar DragScroll = /*#__PURE__*/function (_super) {\n  __extends(DragScroll, _super);\n  function DragScroll() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this._startRect = null;\n    _this._startPos = [];\n    _this._prevTime = 0;\n    _this._timer = 0;\n    _this._prevScrollPos = [0, 0];\n    _this._isWait = false;\n    _this._flag = false;\n    _this._currentOptions = null;\n    _this._lock = false;\n    _this._unregister = null;\n    _this._onScroll = function () {\n      var options = _this._currentOptions;\n      if (_this._lock || !options) {\n        return;\n      }\n      _this.emit(\"scrollDrag\", {\n        next: function (inputEvent) {\n          _this.checkScroll({\n            container: options.container,\n            inputEvent: inputEvent\n          });\n        }\n      });\n    };\n    return _this;\n  }\n  /**\n   */\n  var __proto = DragScroll.prototype;\n  __proto.dragStart = function (e, options) {\n    var container = getContainerElement(options.container);\n    if (!container) {\n      this._flag = false;\n      return;\n    }\n    var top = 0;\n    var left = 0;\n    var width = 0;\n    var height = 0;\n    if (container === document.body) {\n      width = window.innerWidth;\n      height = window.innerHeight;\n    } else {\n      var rect = container.getBoundingClientRect();\n      top = rect.top;\n      left = rect.left;\n      width = rect.width;\n      height = rect.height;\n    }\n    this._flag = true;\n    this._startPos = [e.clientX, e.clientY];\n    this._startRect = {\n      top: top,\n      left: left,\n      width: width,\n      height: height\n    };\n    this._prevScrollPos = this._getScrollPosition([0, 0], options);\n    this._currentOptions = options;\n    this._registerScrollEvent(options);\n  };\n  __proto.drag = function (e, options) {\n    clearTimeout(this._timer);\n    if (!this._flag) {\n      return;\n    }\n    var clientX = e.clientX,\n      clientY = e.clientY;\n    var _a = options.threshold,\n      threshold = _a === void 0 ? 0 : _a;\n    var _b = this,\n      _startRect = _b._startRect,\n      _startPos = _b._startPos;\n    this._currentOptions = options;\n    var direction = [0, 0];\n    if (_startRect.top > clientY - threshold) {\n      if (_startPos[1] > _startRect.top || clientY < _startPos[1]) {\n        direction[1] = -1;\n      }\n    } else if (_startRect.top + _startRect.height < clientY + threshold) {\n      if (_startPos[1] < _startRect.top + _startRect.height || clientY > _startPos[1]) {\n        direction[1] = 1;\n      }\n    }\n    if (_startRect.left > clientX - threshold) {\n      if (_startPos[0] > _startRect.left || clientX < _startPos[0]) {\n        direction[0] = -1;\n      }\n    } else if (_startRect.left + _startRect.width < clientX + threshold) {\n      if (_startPos[0] < _startRect.left + _startRect.width || clientX > _startPos[0]) {\n        direction[0] = 1;\n      }\n    }\n    if (!direction[0] && !direction[1]) {\n      return false;\n    }\n    return this._continueDrag(__assign(__assign({}, options), {\n      direction: direction,\n      inputEvent: e,\n      isDrag: true\n    }));\n  };\n  /**\n   */\n  __proto.checkScroll = function (options) {\n    var _this = this;\n    if (this._isWait) {\n      return false;\n    }\n    var _a = options.prevScrollPos,\n      prevScrollPos = _a === void 0 ? this._prevScrollPos : _a,\n      direction = options.direction,\n      _b = options.throttleTime,\n      throttleTime = _b === void 0 ? 0 : _b,\n      inputEvent = options.inputEvent,\n      isDrag = options.isDrag;\n    var nextScrollPos = this._getScrollPosition(direction || [0, 0], options);\n    var offsetX = nextScrollPos[0] - prevScrollPos[0];\n    var offsetY = nextScrollPos[1] - prevScrollPos[1];\n    var nextDirection = direction || [offsetX ? Math.abs(offsetX) / offsetX : 0, offsetY ? Math.abs(offsetY) / offsetY : 0];\n    this._prevScrollPos = nextScrollPos;\n    this._lock = false;\n    if (!offsetX && !offsetY) {\n      return false;\n    }\n    /**\n     * @event DragScroll#move\n     */\n    this.emit(\"move\", {\n      offsetX: nextDirection[0] ? offsetX : 0,\n      offsetY: nextDirection[1] ? offsetY : 0,\n      inputEvent: inputEvent\n    });\n    if (throttleTime && isDrag) {\n      clearTimeout(this._timer);\n      this._timer = window.setTimeout(function () {\n        _this._continueDrag(options);\n      }, throttleTime);\n    }\n    return true;\n  };\n  /**\n   *\n   */\n  __proto.dragEnd = function () {\n    this._flag = false;\n    this._lock = false;\n    clearTimeout(this._timer);\n    this._unregisterScrollEvent();\n  };\n  __proto._getScrollPosition = function (direction, options) {\n    var container = options.container,\n      _a = options.getScrollPosition,\n      getScrollPosition = _a === void 0 ? getDefaultScrollPosition : _a;\n    return getScrollPosition({\n      container: getContainerElement(container),\n      direction: direction\n    });\n  };\n  __proto._continueDrag = function (options) {\n    var _this = this;\n    var _a;\n    var container = options.container,\n      direction = options.direction,\n      throttleTime = options.throttleTime,\n      useScroll = options.useScroll,\n      isDrag = options.isDrag,\n      inputEvent = options.inputEvent;\n    if (!this._flag || isDrag && this._isWait) {\n      return;\n    }\n    var nowTime = now();\n    var distTime = Math.max(throttleTime + this._prevTime - nowTime, 0);\n    if (distTime > 0) {\n      clearTimeout(this._timer);\n      this._timer = window.setTimeout(function () {\n        _this._continueDrag(options);\n      }, distTime);\n      return false;\n    }\n    this._prevTime = nowTime;\n    var prevScrollPos = this._getScrollPosition(direction, options);\n    this._prevScrollPos = prevScrollPos;\n    if (isDrag) {\n      this._isWait = true;\n    }\n    // unregister native scroll event\n    if (!useScroll) {\n      this._lock = true;\n    }\n    var param = {\n      container: getContainerElement(container),\n      direction: direction,\n      inputEvent: inputEvent\n    };\n    (_a = options.requestScroll) === null || _a === void 0 ? void 0 : _a.call(options, param);\n    /**\n     * @event DragScroll#scroll\n     */\n    this.emit(\"scroll\", param);\n    this._isWait = false;\n    return useScroll || this.checkScroll(__assign(__assign({}, options), {\n      prevScrollPos: prevScrollPos,\n      direction: direction,\n      inputEvent: inputEvent\n    }));\n  };\n  __proto._registerScrollEvent = function (options) {\n    this._unregisterScrollEvent();\n    var checkScrollEvent = options.checkScrollEvent;\n    if (!checkScrollEvent) {\n      return;\n    }\n    var callback = checkScrollEvent === true ? checkDefaultScrollEvent : checkScrollEvent;\n    var container = getContainerElement(options.container);\n    if (checkScrollEvent === true && (container === document.body || container === document.documentElement)) {\n      this._unregister = checkDefaultScrollEvent(window, this._onScroll);\n    } else {\n      this._unregister = callback(container, this._onScroll);\n    }\n  };\n  __proto._unregisterScrollEvent = function () {\n    var _a;\n    (_a = this._unregister) === null || _a === void 0 ? void 0 : _a.call(this);\n    this._unregister = null;\n  };\n  return DragScroll;\n}(EventEmitter);\n\nexport default DragScroll;\n//# sourceMappingURL=dragscroll.esm.js.map\n", "\nimport {\n    ScrollableProps, OnScroll, MoveableManagerInterface,\n    MoveableGroupInterface, MoveableRefType,\n} from \"../types\";\nimport { triggerEvent, fillParams, getRefTarget } from \"../utils\";\nimport DragScroll from \"@scena/dragscroll\";\n\nfunction getDefaultScrollPosition(e: { scrollContainer: HTMLElement, direction: number[] }) {\n    const scrollContainer = e.scrollContainer;\n\n    return [\n        scrollContainer.scrollLeft,\n        scrollContainer.scrollTop,\n    ];\n}\n/**\n * @namespace Moveable.Scrollable\n * @description Whether or not target can be scrolled to the scroll container (default: false)\n */\nexport default {\n    name: \"scrollable\",\n    canPinch: true,\n    props: [\n        \"scrollable\",\n        \"scrollContainer\",\n        \"scrollThreshold\",\n        \"scrollThrottleTime\",\n        \"getScrollPosition\",\n        \"scrollOptions\",\n    ] as const,\n    events: [\n        \"scroll\",\n        \"scrollGroup\",\n    ] as const,\n    dragRelation: \"strong\",\n    dragStart(moveable: MoveableManagerInterface<ScrollableProps, Record<string, any>>, e: any) {\n        const props = moveable.props;\n        const {\n            scrollContainer = moveable.getContainer() as HTMLElement,\n            scrollOptions,\n        } = props;\n\n        const dragScroll = new DragScroll();\n        const scrollContainerElement = getRefTarget<HTMLElement>(scrollContainer, true);\n\n        e.datas.dragScroll = dragScroll;\n        moveable.state.dragScroll = dragScroll;\n\n        const gestoName = e.isControl ? \"controlGesto\" : \"targetGesto\";\n        const targets = e.targets;\n\n        dragScroll.on(\"scroll\", ({ container, direction }) => {\n            const params = fillParams<OnScroll>(moveable, e, {\n                scrollContainer: container,\n                direction,\n            }) as any;\n\n            const eventName = targets ? \"onScrollGroup\" : \"onScroll\" as any;\n            if (targets) {\n                params.targets = targets;\n            }\n            triggerEvent(moveable, eventName, params);\n        }).on(\"move\", ({ offsetX, offsetY, inputEvent }) => {\n            moveable[gestoName].scrollBy(offsetX, offsetY, inputEvent.inputEvent, false);\n        }).on(\"scrollDrag\", ({ next }) => {\n            next(moveable[gestoName].getCurrentEvent());\n        });\n        dragScroll.dragStart(e, {\n            container: scrollContainerElement!,\n            ...scrollOptions,\n        });\n    },\n    checkScroll(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        const dragScroll = e.datas.dragScroll as DragScroll;\n\n        if (!dragScroll) {\n            return;\n        }\n        const {\n            scrollContainer = moveable.getContainer() as MoveableRefType<HTMLElement>,\n            scrollThreshold = 0,\n            scrollThrottleTime = 0,\n            getScrollPosition = getDefaultScrollPosition,\n            scrollOptions,\n        } = moveable.props;\n\n        dragScroll.drag(e, {\n            container: scrollContainer!,\n            threshold: scrollThreshold,\n            throttleTime: scrollThrottleTime,\n            getScrollPosition: (ev: any) => {\n                return getScrollPosition({ scrollContainer: ev.container, direction: ev.direction });\n            },\n            ...scrollOptions,\n        });\n\n        return true;\n    },\n    drag(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        return this.checkScroll(moveable, e);\n    },\n    dragEnd(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        e.datas.dragScroll.dragEnd();\n        e.datas.dragScroll = null;\n    },\n    dragControlStart(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        return this.dragStart(moveable, { ...e, isControl: true });\n    },\n    dragControl(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        return this.drag(moveable, e);\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        return this.dragEnd(moveable, e);\n    },\n    dragGroupStart(moveable: MoveableGroupInterface, e: any) {\n        return this.dragStart(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroup(moveable: MoveableGroupInterface, e: any) {\n        return this.drag(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroupEnd(moveable: MoveableGroupInterface, e: any) {\n        return this.dragEnd(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroupControlStart(moveable: MoveableGroupInterface, e: any) {\n        return this.dragStart(moveable, { ...e, targets: moveable.props.targets, isControl: true });\n    },\n    dragGroupControl(moveable: MoveableGroupInterface, e: any) {\n        return this.drag(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroupControEnd(moveable: MoveableGroupInterface, e: any) {\n        return this.dragEnd(moveable, { ...e, targets: moveable.props.targets });\n    },\n    unset(moveable: MoveableManagerInterface<ScrollableProps, Record<string, any>>) {\n        const state = moveable.state;\n\n        state.dragScroll?.dragEnd();\n        state.dragScroll = null;\n    },\n};\n\n/**\n * When the drag cursor leaves the scrollContainer, the `scroll` event occur to scroll.\n * @memberof Moveable.Scrollable\n * @event scroll\n * @param {Moveable.Scrollable.OnScroll} - Parameters for the `scroll` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"scroll\", ({ scrollContainer, direction }) => {\n *   scrollContainer.scrollLeft += direction[0] * 10;\n *   scrollContainer.scrollTop += direction[1] * 10;\n * });\n */\n\n/**\n * When the drag cursor leaves the scrollContainer, the `scrollGroup` event occur to scroll in group.\n * @memberof Moveable.Scrollable\n * @event scrollGroup\n * @param {Moveable.Scrollable.OnScrollGroup} - Parameters for the `scrollGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"scroll\", ({ scrollContainer, direction }) => {\n *   scrollContainer.scrollLeft += direction[0] * 10;\n *   scrollContainer.scrollTop += direction[1] * 10;\n * });\n */\n", "export default {\n    name: \"\",\n    props: [\n        \"target\",\n        \"dragTargetSelf\",\n        \"dragTarget\",\n        \"dragContainer\",\n        \"container\",\n        \"warpSelf\",\n        \"rootContainer\",\n        \"useResizeObserver\",\n        \"useMutationObserver\",\n        \"zoom\",\n        \"dragFocusedInput\",\n        \"transformOrigin\",\n        \"ables\",\n        \"className\",\n        \"pinchThreshold\",\n        \"pinchOutside\",\n        \"triggerAblesSimultaneously\",\n        \"checkInput\",\n        \"cspNonce\",\n        \"translateZ\",\n        \"hideDefaultLines\",\n        \"props\",\n        \"flushSync\",\n        \"stopPropagation\",\n        \"preventClickEventOnDrag\",\n        \"preventClickDefault\",\n        \"viewContainer\",\n        \"persistData\",\n        \"useAccuratePosition\",\n        \"firstRenderState\",\n        \"linePadding\",\n        \"controlPadding\",\n        \"preventDefault\",\n        \"preventRightClick\",\n        \"preventWheelClick\",\n        \"requestStyles\",\n    ] as const,\n    events: [\n        \"changeTargets\",\n    ] as const,\n};\n", "import { prefix, makeMatrixCSS, getPaddingBox } from \"../utils\";\nimport { Renderer, MoveableManagerInterface } from \"../types\";\nimport { createWarpMatrix } from \"@scena/matrix\";\nimport { makeAble } from \"./AbleManager\";\n\nexport default makeAble(\"padding\", {\n    props: [\"padding\"] as const,\n    render(moveable: MoveableManagerInterface, React: Renderer): any[] {\n        const props = moveable.props;\n        if (props.dragArea) {\n            return [];\n        }\n        const {\n            left,\n            top,\n            right,\n            bottom,\n        } = getPaddingBox(props.padding || {});\n        const {\n            renderPoses,\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n        } = moveable.getState();\n\n        const poses = [pos1, pos2, pos3, pos4];\n        const paddingDirections: number[][] = [];\n\n        if (left > 0) {\n            paddingDirections.push([0, 2]);\n        }\n        if (top > 0) {\n            paddingDirections.push([0, 1]);\n        }\n        if (right > 0) {\n            paddingDirections.push([1, 3]);\n        }\n        if (bottom > 0) {\n            paddingDirections.push([2, 3]);\n        }\n        return paddingDirections.map(([dir1, dir2], i) => {\n            const paddingPos1 = poses[dir1];\n            const paddingPos2 = poses[dir2];\n            const paddingPos3 = renderPoses[dir1];\n            const paddingPos4 = renderPoses[dir2];\n\n            const h = createWarpMatrix(\n                [0, 0],\n                [100, 0],\n                [0, 100],\n                [100, 100],\n                paddingPos1,\n                paddingPos2,\n                paddingPos3,\n                paddingPos4,\n            );\n            if (!h.length) {\n                return undefined;\n            }\n            return (<div key={`padding${i}`} className={prefix(\"padding\")} style={{\n                transform: makeMatrixCSS(h, true),\n            }}></div>);\n        });\n    },\n});\n\n/**\n * Add padding around the target to increase the drag area.\n * @name Moveable#padding\n * @default null\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  target: document.querySelector(\".target\"),\n *  padding: { left: 0, top: 0, right: 0, bottom: 0 },\n * });\n * moveable.padding = { left: 10, top: 10, right: 10, bottom: 10 },\n * moveable.updateRect();\n */\n", "import { convertCSSSize } from \"../../utils\";\nimport { ControlPose } from \"../../types\";\nimport { convertUnitSize } from \"@daybrush/utils\";\n\nconst RADIUS_DIRECTIONS = [\"nw\", \"ne\", \"se\", \"sw\"] as const;\n\nfunction calculateRatio(values: number[], size: number) {\n    const sumSize = values[0] + values[1];\n    const sumRatio = sumSize > size ? size / sumSize : 1;\n\n    values[0] *= sumRatio;\n    values[1] = size - values[1] * sumRatio;\n\n    return values;\n}\nexport const HORIZONTAL_RADIUS_ORDER = [1, 2, 5, 6];\nexport const VERTICAL_RADIUS_ORDER = [0, 3, 4, 7];\nexport const HORIZONTAL_RADIUS_DIRECTIONS = [1, -1, -1, 1] as const;\nexport const VERTICAL_RADIUS_DIRECTIONS = [1, 1, -1, -1] as const;\n\nexport function getRadiusStyles(\n    nextPoses: ControlPose[],\n    isRelative: boolean,\n    width: number,\n    height: number,\n    left = 0,\n    top = 0,\n    right: number = width,\n    bottom: number = height,\n) {\n    const clipStyles: string[] = [];\n    let isVertical = false;\n\n    const radiusPoses = nextPoses.filter(pos => !pos.virtual);\n    const raws = radiusPoses.map(posInfo => {\n        const { horizontal, vertical, pos } = posInfo;\n\n        if (vertical && !isVertical) {\n            isVertical = true;\n            clipStyles.push(\"/\");\n        }\n\n        if (isVertical) {\n            const rawPos = Math.max(0, vertical === 1 ? pos[1] - top : bottom - pos[1]);\n            clipStyles.push(convertCSSSize(rawPos, height, isRelative));\n\n            return rawPos;\n        } else {\n            const rawPos = Math.max(0, horizontal === 1 ? pos[0] - left : right - pos[0]);\n            clipStyles.push(convertCSSSize(rawPos, width, isRelative));\n\n            return rawPos;\n        }\n    });\n\n    return {\n        radiusPoses,\n        styles: clipStyles,\n        raws,\n    };\n}\nexport function getRadiusRange(controlPoses: ControlPose[]) {\n    // [start, length]\n    const horizontalRange = [0, 0];\n    const verticalRange = [0, 0];\n    const length = controlPoses.length;\n\n    for (let i = 0; i < length; ++i) {\n        const clipPose = controlPoses[i];\n\n        if (!clipPose.sub) {\n            continue;\n        }\n        if (clipPose.horizontal) {\n            if (horizontalRange[1] === 0) {\n                horizontalRange[0] = i;\n            }\n            horizontalRange[1] = i - horizontalRange[0] + 1;\n            verticalRange[0] = i + 1;\n        }\n        if (clipPose.vertical) {\n            if (verticalRange[1] === 0) {\n                verticalRange[0] = i;\n            }\n            verticalRange[1] = i - verticalRange[0] + 1;\n        }\n    }\n\n    return {\n        horizontalRange,\n        verticalRange,\n    };\n}\nexport function getRadiusValues(\n    values: string[],\n    width: number,\n    height: number,\n    left: number,\n    top: number,\n    minCounts: number[] = [0, 0],\n    full = false,\n): ControlPose[] {\n    const splitIndex = values.indexOf(\"/\");\n    const splitLength = (splitIndex > -1 ? values.slice(0, splitIndex) : values).length;\n    const horizontalValues = values.slice(0, splitLength);\n    const verticalValues = values.slice(splitLength + 1);\n    const horizontalValuesLength = horizontalValues.length;\n    const verticalValuesLength = verticalValues.length;\n    const hasVerticalValues = verticalValuesLength > 0;\n    const [\n        nwValue = \"0px\",\n        neValue = nwValue,\n        seValue = nwValue,\n        swValue = neValue,\n    ] = horizontalValues;\n    const [\n        wnValue = nwValue,\n        enValue = hasVerticalValues ? wnValue : neValue,\n        esValue = hasVerticalValues ? wnValue : seValue,\n        wsValue = hasVerticalValues ? enValue : swValue,\n    ] = verticalValues;\n\n    const horizontalRawPoses = [nwValue, neValue, seValue, swValue].map(pos => convertUnitSize(pos, width));\n    const verticalRawPoses = [wnValue, enValue, esValue, wsValue].map(pos => convertUnitSize(pos, height));\n    const horizontalPoses = horizontalRawPoses.slice();\n    const verticalPoses = verticalRawPoses.slice();\n\n    [horizontalPoses[0], horizontalPoses[1]] = calculateRatio(\n        [horizontalPoses[0], horizontalPoses[1]],\n        width,\n    );\n    [horizontalPoses[3], horizontalPoses[2]] = calculateRatio(\n        [horizontalPoses[3], horizontalPoses[2]],\n        width,\n    );\n    [verticalPoses[0], verticalPoses[3]] = calculateRatio(\n        [verticalPoses[0], verticalPoses[3]], height,\n    );\n    [verticalPoses[1], verticalPoses[2]] = calculateRatio(\n        [verticalPoses[1], verticalPoses[2]], height,\n    );\n\n    const nextHorizontalPoses = full\n        ? horizontalPoses\n        : horizontalPoses.slice(0, Math.max(minCounts[0], horizontalValuesLength));\n    const nextVerticalPoses = full\n        ? verticalPoses\n        : verticalPoses.slice(0, Math.max(minCounts[1], verticalValuesLength));\n\n    return [\n        ...nextHorizontalPoses.map((pos, i) => {\n            const direction = RADIUS_DIRECTIONS[i];\n\n            return {\n                virtual: i >= horizontalValuesLength,\n                horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],\n                vertical: 0,\n                pos: [left + pos, top + (VERTICAL_RADIUS_DIRECTIONS[i] === -1 ? height : 0)],\n                sub: true,\n                raw: horizontalRawPoses[i],\n                direction,\n            };\n        }),\n        ...nextVerticalPoses.map((pos, i) => {\n            const direction = RADIUS_DIRECTIONS[i];\n\n            return {\n                virtual: i >= verticalValuesLength,\n                horizontal: 0,\n                vertical: VERTICAL_RADIUS_DIRECTIONS[i],\n                pos: [left + (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1 ? width : 0), top + pos],\n                sub: true,\n                raw: verticalRawPoses[i],\n                direction,\n            };\n        }),\n    ];\n}\nexport function removeRadiusPos(\n    controlPoses: ControlPose[],\n    poses: number[][],\n    index: number,\n    startIndex: number,\n    length: number = poses.length,\n) {\n    const {\n        horizontalRange,\n        verticalRange,\n    } = getRadiusRange(controlPoses.slice(startIndex));\n    const radiuslIndex = index - startIndex;\n    let deleteCount = 0;\n\n    if (radiuslIndex === 0) {\n        deleteCount = length;\n    } else if (radiuslIndex > 0 && radiuslIndex < horizontalRange[1]) {\n        deleteCount = horizontalRange[1] - radiuslIndex;\n    } else if (radiuslIndex >= verticalRange[0]) {\n        deleteCount = verticalRange[0] + verticalRange[1] - radiuslIndex;\n    } else {\n        return;\n    }\n    controlPoses.splice(index, deleteCount);\n    poses.splice(index, deleteCount);\n}\nexport function addRadiusPos(\n    controlPoses: ControlPose[],\n    poses: number[][],\n    startIndex: number,\n    horizontalIndex: number,\n    verticalIndex: number,\n    distX: number,\n    distY: number,\n    right: number,\n    bottom: number,\n    left = 0,\n    top = 0,\n) {\n    const {\n        horizontalRange,\n        verticalRange,\n    } = getRadiusRange(controlPoses.slice(startIndex));\n    if (horizontalIndex > -1) {\n        const radiusX = HORIZONTAL_RADIUS_DIRECTIONS[horizontalIndex] === 1\n            ? distX - left\n            : right - distX;\n        for (let i = horizontalRange[1]; i <= horizontalIndex; ++i) {\n            const y = VERTICAL_RADIUS_DIRECTIONS[i] === 1 ? top : bottom;\n            let x = 0;\n            if (horizontalIndex === i) {\n                x = distX;\n            } else if (i === 0) {\n                x = left + radiusX;\n            } else if (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1) {\n                x = right - (poses[startIndex][0] - left);\n            }\n            controlPoses.splice(startIndex + i, 0, {\n                horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],\n                vertical: 0,\n                pos: [x, y],\n            });\n            poses.splice(startIndex + i, 0, [x, y]);\n\n            if (i === 0) {\n                break;\n            }\n        }\n    } else if (verticalIndex > - 1) {\n        const radiusY = VERTICAL_RADIUS_DIRECTIONS[verticalIndex] === 1\n            ? distY - top\n            : bottom - distY;\n        if (horizontalRange[1] === 0 && verticalRange[1] === 0) {\n            const pos = [\n                left + radiusY,\n                top,\n            ];\n            controlPoses.push({\n                horizontal: HORIZONTAL_RADIUS_DIRECTIONS[0],\n                vertical: 0,\n                pos,\n            });\n            poses.push(pos);\n        }\n\n        const startVerticalIndex = verticalRange[0];\n        for (let i = verticalRange[1]; i <= verticalIndex; ++i) {\n            const x = HORIZONTAL_RADIUS_DIRECTIONS[i] === 1 ? left : right;\n            let y = 0;\n            if (verticalIndex === i) {\n                y = distY;\n            } else if (i === 0) {\n                y = top + radiusY;\n            } else if (VERTICAL_RADIUS_DIRECTIONS[i] === 1) {\n                y = poses[startIndex + startVerticalIndex][1];\n            } else if (VERTICAL_RADIUS_DIRECTIONS[i] === -1) {\n                y = bottom - (poses[startIndex + startVerticalIndex][1] - top);\n            }\n            controlPoses.push({\n                horizontal: 0,\n                vertical: VERTICAL_RADIUS_DIRECTIONS[i],\n                pos: [x, y],\n            });\n            poses.push([x, y]);\n            if (i === 0) {\n                break;\n            }\n        }\n    }\n}\nexport function splitRadiusPoses(\n    controlPoses: ControlPose[],\n    raws: number[] = controlPoses.map(pos => pos.raw!),\n) {\n    const horizontals = controlPoses\n        .map((pos, i) => pos.horizontal ? raws[i] : null).filter(pos => pos != null) as number[];\n    const verticals = controlPoses\n        .map((pos, i) => pos.vertical ? raws[i] : null).filter(pos => pos != null) as number[];\n\n    return {\n        horizontals,\n        verticals,\n    };\n}\n", "/*\nCopyright (c) 2020 Daybrush\nname: overlap-area\nlicense: MIT\nauthor: Daybrush\nrepository: git+https://github.com/daybrush/overlap-area.git\nversion: 1.1.0\n*/\nimport { throttle, TINY_NUM, sum, find, getDist, getShapeDirection, findIndex } from '@daybrush/utils';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n}\n\nfunction tinyThrottle(num) {\n  return throttle(num, TINY_NUM);\n}\nfunction isSameConstants(linearConstants1, linearConstants2) {\n  return linearConstants1.every(function (v, i) {\n    return tinyThrottle(v - linearConstants2[i]) === 0;\n  });\n}\nfunction isSamePoint(point1, point2) {\n  return !tinyThrottle(point1[0] - point2[0]) && !tinyThrottle(point1[1] - point2[1]);\n}\nfunction flat(arr) {\n  return arr.reduce(function (prev, current) {\n    prev.push.apply(prev, current);\n    return prev;\n  }, []);\n}\n\n/**\n * @namespace OverlapArea\n */\n\n/**\n * Gets the size of a shape (polygon) made of points.\n * @memberof OverlapArea\n */\n\nfunction getAreaSize(points) {\n  if (points.length < 3) {\n    return 0;\n  }\n\n  return Math.abs(sum(points.map(function (point, i) {\n    var nextPoint = points[i + 1] || points[0];\n    return point[0] * nextPoint[1] - nextPoint[0] * point[1];\n  }))) / 2;\n}\n/**\n * Get points that fit the rect,\n * @memberof OverlapArea\n */\n\nfunction fitPoints(points, rect) {\n  var width = rect.width,\n      height = rect.height,\n      left = rect.left,\n      top = rect.top;\n\n  var _a = getMinMaxs(points),\n      minX = _a.minX,\n      minY = _a.minY,\n      maxX = _a.maxX,\n      maxY = _a.maxY;\n\n  var ratioX = width / (maxX - minX);\n  var ratioY = height / (maxY - minY);\n  return points.map(function (point) {\n    return [left + (point[0] - minX) * ratioX, top + (point[1] - minY) * ratioY];\n  });\n}\n/**\n * Get the minimum and maximum points of the points.\n * @memberof OverlapArea\n */\n\nfunction getMinMaxs(points) {\n  var xs = points.map(function (point) {\n    return point[0];\n  });\n  var ys = points.map(function (point) {\n    return point[1];\n  });\n  return {\n    minX: Math.min.apply(Math, xs),\n    minY: Math.min.apply(Math, ys),\n    maxX: Math.max.apply(Math, xs),\n    maxY: Math.max.apply(Math, ys)\n  };\n}\n/**\n * Whether the point is in shape\n * @param - point pos\n * @param - shape points\n * @param - whether to check except line\n * @memberof OverlapArea\n */\n\nfunction isInside(pos, points, excludeLine) {\n  var x = pos[0],\n      y = pos[1];\n\n  var _a = getMinMaxs(points),\n      minX = _a.minX,\n      maxX = _a.maxX;\n\n  var xLine = [[minX, y], [maxX, y]];\n  var xLinearConstants = getLinearConstants(xLine[0], xLine[1]);\n  var lines = convertLines(points);\n  var intersectionPosInfos = [];\n  lines.forEach(function (line) {\n    var linearConstants = getLinearConstants(line[0], line[1]);\n    var standardPoint = line[0];\n\n    if (isSameConstants(xLinearConstants, linearConstants)) {\n      intersectionPosInfos.push({\n        pos: pos,\n        line: line,\n        type: \"line\"\n      });\n    } else {\n      var xPoints = getPointsOnLines(getIntersectionPointsByConstants(xLinearConstants, linearConstants), [xLine, line]);\n      xPoints.forEach(function (point) {\n        if (line.some(function (linePoint) {\n          return isSamePoint(linePoint, point);\n        })) {\n          intersectionPosInfos.push({\n            pos: point,\n            line: line,\n            type: \"point\"\n          });\n        } else if (tinyThrottle(standardPoint[1] - y) !== 0) {\n          intersectionPosInfos.push({\n            pos: point,\n            line: line,\n            type: \"intersection\"\n          });\n        }\n      });\n    }\n  });\n\n  if (!excludeLine) {\n    // on line\n    if (find(intersectionPosInfos, function (p) {\n      return p[0] === x;\n    })) {\n      return true;\n    }\n  }\n\n  var intersectionCount = 0;\n  var xMap = {};\n  intersectionPosInfos.forEach(function (_a) {\n    var pos = _a.pos,\n        type = _a.type,\n        line = _a.line;\n\n    if (pos[0] > x) {\n      return;\n    }\n\n    if (type === \"intersection\") {\n      ++intersectionCount;\n    } else if (type === \"line\") {\n      return;\n    } else if (type === \"point\") {\n      var point = find(line, function (linePoint) {\n        return linePoint[1] !== y;\n      });\n      var prevValue = xMap[pos[0]];\n      var nextValue = point[1] > y ? 1 : -1;\n\n      if (!prevValue) {\n        xMap[pos[0]] = nextValue;\n      } else if (prevValue !== nextValue) {\n        ++intersectionCount;\n      }\n    }\n  });\n  return intersectionCount % 2 === 1;\n}\n/**\n * Get distance from point to constants. [a, b, c] (ax + by + c = 0)\n * @return [a, b, c]\n * @memberof OverlapArea\n */\n\nfunction getDistanceFromPointToConstants(_a, pos) {\n  var a = _a[0],\n      b = _a[1],\n      c = _a[2];\n  return (a * pos[0] + b * pos[1] + c) / (a * a + b * b);\n}\n/**\n * Get the coefficient of the linear function. [a, b, c] (ax + by + c = 0)\n * @return [a, b, c]\n * @memberof OverlapArea\n */\n\nfunction getLinearConstants(point1, point2) {\n  var x1 = point1[0],\n      y1 = point1[1];\n  var x2 = point2[0],\n      y2 = point2[1]; // ax + by + c = 0\n  // [a, b, c]\n\n  var dx = x2 - x1;\n  var dy = y2 - y1;\n\n  if (Math.abs(dx) < TINY_NUM) {\n    dx = 0;\n  }\n\n  if (Math.abs(dy) < TINY_NUM) {\n    dy = 0;\n  } // b > 0\n  // ax + by + c = 0\n\n\n  var a = 0;\n  var b = 0;\n  var c = 0;\n\n  if (!dx) {\n    if (dy) {\n      // -x + 1 = 0\n      a = -1;\n      c = x1;\n    }\n  } else if (!dy) {\n    // y - 1 = 0\n    b = 1;\n    c = -y1;\n  } else {\n    // y = -a(x - x1) + y1\n    // ax + y + a * x1 - y1 = 0\n    a = -dy / dx;\n    b = 1;\n    c = -a * x1 - y1;\n  }\n\n  return [a, b, c];\n}\n/**\n * Get intersection points with linear functions.\n * @memberof OverlapArea\n */\n\nfunction getIntersectionPointsByConstants(linearConstants1, linearConstants2) {\n  var a1 = linearConstants1[0],\n      b1 = linearConstants1[1],\n      c1 = linearConstants1[2];\n  var a2 = linearConstants2[0],\n      b2 = linearConstants2[1],\n      c2 = linearConstants2[2];\n  var isZeroA = a1 === 0 && a2 === 0;\n  var isZeroB = b1 === 0 && b2 === 0;\n  var results = [];\n\n  if (isZeroA && isZeroB) {\n    return [];\n  } else if (isZeroA) {\n    // b1 * y + c1 = 0\n    // b2 * y + c2 = 0\n    var y1 = -c1 / b1;\n    var y2 = -c2 / b2;\n\n    if (y1 !== y2) {\n      return [];\n    } else {\n      return [[-Infinity, y1], [Infinity, y1]];\n    }\n  } else if (isZeroB) {\n    // a1 * x + c1 = 0\n    // a2 * x + c2 = 0\n    var x1 = -c1 / a1;\n    var x2 = -c2 / a2;\n\n    if (x1 !== x2) {\n      return [];\n    } else {\n      return [[x1, -Infinity], [x1, Infinity]];\n    }\n  } else if (a1 === 0) {\n    // b1 * y + c1 = 0\n    // y = - c1 / b1;\n    // a2 * x + b2 * y + c2 = 0\n    var y = -c1 / b1;\n    var x = -(b2 * y + c2) / a2;\n    results = [[x, y]];\n  } else if (a2 === 0) {\n    // b2 * y + c2 = 0\n    // y = - c2 / b2;\n    // a1 * x + b1 * y + c1 = 0\n    var y = -c2 / b2;\n    var x = -(b1 * y + c1) / a1;\n    results = [[x, y]];\n  } else if (b1 === 0) {\n    // a1 * x + c1 = 0\n    // x = - c1 / a1;\n    // a2 * x + b2 * y + c2 = 0\n    var x = -c1 / a1;\n    var y = -(a2 * x + c2) / b2;\n    results = [[x, y]];\n  } else if (b2 === 0) {\n    // a2 * x + c2 = 0\n    // x = - c2 / a2;\n    // a1 * x + b1 * y + c1 = 0\n    var x = -c2 / a2;\n    var y = -(a1 * x + c1) / b1;\n    results = [[x, y]];\n  } else {\n    // a1 * x + b1 * y + c1 = 0\n    // a2 * x + b2 * y + c2 = 0\n    // b2 * a1 * x + b2 * b1 * y + b2 * c1 = 0\n    // b1 * a2 * x + b1 * b2 * y + b1 * c2 = 0\n    // (b2 * a1 - b1 * a2)  * x = (b1 * c2 - b2 * c1)\n    var x = (b1 * c2 - b2 * c1) / (b2 * a1 - b1 * a2);\n    var y = -(a1 * x + c1) / b1;\n    results = [[x, y]];\n  }\n\n  return results.map(function (result) {\n    return [result[0], result[1]];\n  });\n}\n/**\n * Get intersection points to the two lines.\n * @memberof OverlapArea\n */\n\nfunction getIntersectionPoints(line1, line2, isLimit) {\n  var points = getIntersectionPointsByConstants(getLinearConstants(line1[0], line1[1]), getLinearConstants(line2[0], line2[1]));\n\n  if (isLimit) {\n    return getPointsOnLines(points, [line1, line2]);\n  }\n\n  return points;\n}\nfunction isPointOnLine(pos, line) {\n  var linearConstants = getLinearConstants(line[0], line[1]);\n  return tinyThrottle(getDistanceFromPointToConstants(linearConstants, pos)) === 0;\n}\n/**\n * Get the points on the lines (between two points).\n * @memberof OverlapArea\n */\n\nfunction getPointsOnLines(points, lines) {\n  var minMaxs = lines.map(function (line) {\n    return [0, 1].map(function (order) {\n      return [Math.min(line[0][order], line[1][order]), Math.max(line[0][order], line[1][order])];\n    });\n  });\n  var results = [];\n\n  if (points.length === 2) {\n    var _a = points[0],\n        x = _a[0],\n        y = _a[1];\n\n    if (!tinyThrottle(x - points[1][0])) {\n      /// Math.max(minY1, minY2)\n      var top = Math.max.apply(Math, minMaxs.map(function (minMax) {\n        return minMax[1][0];\n      })); /// Math.min(maxY1, miax2)\n\n      var bottom = Math.min.apply(Math, minMaxs.map(function (minMax) {\n        return minMax[1][1];\n      }));\n\n      if (tinyThrottle(top - bottom) > 0) {\n        return [];\n      }\n\n      results = [[x, top], [x, bottom]];\n    } else if (!tinyThrottle(y - points[1][1])) {\n      /// Math.max(minY1, minY2)\n      var left = Math.max.apply(Math, minMaxs.map(function (minMax) {\n        return minMax[0][0];\n      })); /// Math.min(maxY1, miax2)\n\n      var right = Math.min.apply(Math, minMaxs.map(function (minMax) {\n        return minMax[0][1];\n      }));\n\n      if (tinyThrottle(left - right) > 0) {\n        return [];\n      }\n\n      results = [[left, y], [right, y]];\n    }\n  }\n\n  if (!results.length) {\n    results = points.filter(function (point) {\n      var pointX = point[0],\n          pointY = point[1];\n      return minMaxs.every(function (minMax) {\n        return 0 <= tinyThrottle(pointX - minMax[0][0]) && 0 <= tinyThrottle(minMax[0][1] - pointX) && 0 <= tinyThrottle(pointY - minMax[1][0]) && 0 <= tinyThrottle(minMax[1][1] - pointY);\n      });\n    });\n  }\n\n  return results.map(function (result) {\n    return [tinyThrottle(result[0]), tinyThrottle(result[1])];\n  });\n}\n/**\n* Convert two points into lines.\n* @function\n* @memberof OverlapArea\n*/\n\nfunction convertLines(points) {\n  return __spreadArrays(points.slice(1), [points[0]]).map(function (point, i) {\n    return [points[i], point];\n  });\n}\n\nfunction getOverlapPointInfos(points1, points2) {\n  var targetPoints1 = points1.slice();\n  var targetPoints2 = points2.slice();\n\n  if (getShapeDirection(targetPoints1) === -1) {\n    targetPoints1.reverse();\n  }\n\n  if (getShapeDirection(targetPoints2) === -1) {\n    targetPoints2.reverse();\n  }\n\n  var lines1 = convertLines(targetPoints1);\n  var lines2 = convertLines(targetPoints2);\n  var linearConstantsList1 = lines1.map(function (line1) {\n    return getLinearConstants(line1[0], line1[1]);\n  });\n  var linearConstantsList2 = lines2.map(function (line2) {\n    return getLinearConstants(line2[0], line2[1]);\n  });\n  var overlapInfos = [];\n  linearConstantsList1.forEach(function (linearConstants1, i) {\n    var line1 = lines1[i];\n    var linePointInfos = [];\n    linearConstantsList2.forEach(function (linearConstants2, j) {\n      var intersectionPoints = getIntersectionPointsByConstants(linearConstants1, linearConstants2);\n      var points = getPointsOnLines(intersectionPoints, [line1, lines2[j]]);\n      linePointInfos.push.apply(linePointInfos, points.map(function (pos) {\n        return {\n          index1: i,\n          index2: j,\n          pos: pos,\n          type: \"intersection\"\n        };\n      }));\n    });\n    linePointInfos.sort(function (a, b) {\n      return getDist(line1[0], a.pos) - getDist(line1[0], b.pos);\n    });\n    overlapInfos.push.apply(overlapInfos, linePointInfos);\n\n    if (isInside(line1[1], targetPoints2)) {\n      overlapInfos.push({\n        index1: i,\n        index2: -1,\n        pos: line1[1],\n        type: \"inside\"\n      });\n    }\n  });\n  lines2.forEach(function (line2, i) {\n    if (!isInside(line2[1], targetPoints1)) {\n      return;\n    }\n\n    var isNext = false;\n    var index = findIndex(overlapInfos, function (_a) {\n      var index2 = _a.index2;\n\n      if (index2 === i) {\n        isNext = true;\n        return false;\n      }\n\n      if (isNext) {\n        return true;\n      }\n\n      return false;\n    });\n\n    if (index === -1) {\n      isNext = false;\n      index = findIndex(overlapInfos, function (_a) {\n        var index1 = _a.index1,\n            index2 = _a.index2;\n\n        if (index1 === -1 && index2 + 1 === i) {\n          isNext = true;\n          return false;\n        }\n\n        if (isNext) {\n          return true;\n        }\n\n        return false;\n      });\n    }\n\n    if (index === -1) {\n      overlapInfos.push({\n        index1: -1,\n        index2: i,\n        pos: line2[1],\n        type: \"inside\"\n      });\n    } else {\n      overlapInfos.splice(index, 0, {\n        index1: -1,\n        index2: i,\n        pos: line2[1],\n        type: \"inside\"\n      });\n    }\n  });\n  var pointMap = {};\n  return overlapInfos.filter(function (_a) {\n    var pos = _a.pos;\n    var key = pos[0] + \"x\" + pos[1];\n\n    if (pointMap[key]) {\n      return false;\n    }\n\n    pointMap[key] = true;\n    return true;\n  });\n}\n/**\n* Get the points of the overlapped part of two shapes.\n* @function\n* @memberof OverlapArea\n*/\n\n\nfunction getOverlapPoints(points1, points2) {\n  var infos = getOverlapPointInfos(points1, points2);\n  return infos.map(function (_a) {\n    var pos = _a.pos;\n    return pos;\n  });\n}\n\nfunction isConnectedLine(line) {\n  var _a = line[0],\n      prevIndex1 = _a.index1,\n      prevIndex2 = _a.index2,\n      _b = line[1],\n      nextIndex1 = _b.index1,\n      nextIndex2 = _b.index2;\n\n  if (prevIndex1 !== -1) {\n    // same line\n    if (prevIndex1 === nextIndex1) {\n      return true;\n    }\n\n    if (prevIndex1 + 1 === nextIndex1) {\n      return true;\n    }\n  }\n\n  if (prevIndex2 !== -1) {\n    // same line\n    if (prevIndex2 === nextIndex2) {\n      return true;\n    }\n\n    if (prevIndex2 + 1 === nextIndex2) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n* Get the areas of the overlapped part of two shapes.\n* @function\n* @memberof OverlapArea\n*/\n\n\nfunction getOverlapAreas(points1, points2) {\n  var infos = getOverlapPointInfos(points1, points2);\n  var areas = [];\n  var area;\n  getOverlapPointInfos(points1, points2).forEach(function (info, i, arr) {\n    if (i === 0 || !isConnectedLine([arr[i - 1], info])) {\n      area = [info];\n      areas.push(area);\n    } else {\n      area.push(info);\n    }\n  });\n  return areas.map(function (area) {\n    return area.map(function (_a) {\n      var pos = _a.pos;\n      return pos;\n    });\n  });\n}\n\nfunction findReversedAreas(points1, points2, index, areas) {\n  if (index === void 0) {\n    index = 0;\n  }\n\n  if (areas === void 0) {\n    areas = [];\n  }\n\n  var isFirst = areas.length === 0;\n  var length = points1.length;\n  var nextIndex = points1[index] ? index : 0;\n\n  var nextPoints1 = __spreadArrays(points1.slice(nextIndex), points1.slice(0, nextIndex));\n\n  var _loop_1 = function (i) {\n    var point1 = nextPoints1[i];\n\n    if (find(points2, function (point2) {\n      return point2[0] === point1[0] && point2[1] === point1[1];\n    })) {\n      return \"continue\";\n    }\n\n    if (areas.some(function (nextArea) {\n      return find(nextArea, function (areaPoint) {\n        return areaPoint[0] === point1[0] && areaPoint[1] === point1[1];\n      });\n    })) {\n      if (isFirst) {\n        return \"continue\";\n      } else {\n        return \"break\";\n      }\n    }\n\n    var nextArea = void 0;\n\n    if (isFirst) {\n      nextArea = [];\n      areas.push(nextArea);\n    } else {\n      nextArea = areas[areas.length - 1];\n    }\n\n    nextArea.push(point1);\n    var line = [point1, points1[index + 1] || points1[0]];\n    var nextPoint2 = points2.filter(function (point2) {\n      return isPointOnLine(point2, line);\n    }).sort(function (a, b) {\n      return getDist(point1, a) - getDist(point1, b);\n    })[0];\n\n    if (!nextPoint2) {\n      findReversedAreas(nextPoints1, points2, i + 1, areas);\n      return \"break\";\n    } else {\n      var point2Index = points2.indexOf(nextPoint2);\n      findReversedAreas(points2, points1, point2Index, areas);\n\n      if (!isFirst) {\n        return \"break\";\n      }\n    }\n  };\n\n  for (var i = 0; i < length; ++i) {\n    var state_1 = _loop_1(i);\n\n    if (state_1 === \"break\") break;\n  }\n\n  return areas;\n}\n\nfunction findConnectedAreas(points1, points2) {\n  return findReversedAreas(points1, __spreadArrays(points2).reverse());\n}\n/**\n* Get non-overlapping areas of two shapes based on points1.\n* @memberof OverlapArea\n*/\n\nfunction getUnoverlapAreas(points1, points2) {\n  if (!points2.length) {\n    return [__spreadArrays(points1)];\n  }\n\n  var overlapAreas = getOverlapAreas(points1, points2);\n  var unoverlapAreas = [points1];\n  overlapAreas.forEach(function (overlapArea) {\n    var nextOverlapArea = __spreadArrays(overlapArea).reverse();\n\n    unoverlapAreas = flat(unoverlapAreas.map(function (area) {\n      var connectedAreas = findReversedAreas(area, nextOverlapArea);\n      var firstConnectedArea = connectedAreas[0];\n\n      if (connectedAreas.length === 1 && nextOverlapArea.every(function (point) {\n        return firstConnectedArea.indexOf(point) === -1;\n      })) {\n        var lastPoint_1 = firstConnectedArea[firstConnectedArea.length - 1];\n\n        var firstPoint = __spreadArrays(nextOverlapArea).sort(function (a, b) {\n          return getDist(lastPoint_1, a) - getDist(lastPoint_1, b);\n        })[0];\n\n        var firstIndex = nextOverlapArea.indexOf(firstPoint);\n        firstConnectedArea.push.apply(firstConnectedArea, __spreadArrays(nextOverlapArea.slice(firstIndex), nextOverlapArea.slice(0, firstIndex), [nextOverlapArea[firstIndex], lastPoint_1]));\n      }\n\n      return connectedAreas;\n    }));\n  });\n  return unoverlapAreas;\n}\n/**\n* Gets the size of the overlapped part of two shapes.\n* @function\n* @memberof OverlapArea\n*/\n\nfunction getOverlapSize(points1, points2) {\n  var points = getOverlapPoints(points1, points2);\n  return getAreaSize(points);\n}\n\nexport { convertLines, findConnectedAreas, fitPoints, getAreaSize, getDistanceFromPointToConstants, getIntersectionPoints, getIntersectionPointsByConstants, getLinearConstants, getMinMaxs, getOverlapAreas, getOverlapPoints, getOverlapSize, getPointsOnLines, getUnoverlapAreas, isInside, isPointOnLine };\n//# sourceMappingURL=overlap-area.esm.js.map\n", "import {\n  splitBracket,\n  splitComma,\n  convertUnitSize,\n  splitSpace,\n  splitUnit,\n} from '@daybrush/utils';\nimport { minus } from '@scena/matrix';\nimport { abs, convertCSSSize } from '../../utils';\nimport { getRadiusStyles, getRadiusValues } from '../roundable/borderRadius';\nimport {\n  MoveableManagerInterface,\n  ClippableProps,\n  ControlPose,\n} from '../../types';\nimport { getMinMaxs } from 'overlap-area';\nimport { getCachedStyle } from '../../store/Store';\n\nexport const CLIP_DIRECTIONS = [\n  [0, -1, 'n'],\n  [1, 0, 'e'],\n] as const;\n\nexport const CLIP_RECT_DIRECTIONS = [\n  [-1, -1, 'nw'],\n  [0, -1, 'n'],\n  [1, -1, 'ne'],\n  [1, 0, 'e'],\n  [1, 1, 'se'],\n  [0, 1, 's'],\n  [-1, 1, 'sw'],\n  [-1, 0, 'w'],\n] as const;\n\n// 1 2 5 6 0 3 4 7\n// 0 1 2 3 4 5 6 7\n\nexport function getClipStyles(\n  moveable: MoveableManagerInterface<ClippableProps>,\n  clipPath: ReturnType<typeof getClipPath>,\n  poses: number[][],\n) {\n  const { clipRelative } = moveable.props;\n  const { width, height } = moveable.state;\n  const { type: clipType, poses: clipPoses } = clipPath!;\n\n  const isRect = clipType === 'rect';\n  const isCircle = clipType === 'circle';\n  if (clipType === 'polygon') {\n    return poses.map(\n      (pos) =>\n        `${convertCSSSize(pos[0], width, clipRelative)} ${convertCSSSize(pos[1], height, clipRelative)}`,\n    );\n  } else if (isRect || clipType === 'inset') {\n    const top = poses[1][1];\n    const right = poses[3][0];\n    const left = poses[7][0];\n    const bottom = poses[5][1];\n\n    if (isRect) {\n      return [top, right, bottom, left].map((pos) => `${pos}px`);\n    }\n    const clipStyles = [top, width - right, height - bottom, left].map(\n      (pos, i) => convertCSSSize(pos, i % 2 ? width : height, clipRelative),\n    );\n\n    if (poses.length > 8) {\n      const [subWidth, subHeight] = minus(poses[4], poses[0]);\n\n      clipStyles.push(\n        'round',\n        ...getRadiusStyles(\n          clipPoses.slice(8).map((info, i) => {\n            return {\n              ...info,\n              pos: poses[i],\n            };\n          }),\n          clipRelative!,\n          subWidth,\n          subHeight,\n          left,\n          top,\n          right,\n          bottom,\n        ).styles,\n      );\n    }\n    return clipStyles;\n  } else if (isCircle || clipType === 'ellipse') {\n    const center = poses[0];\n    const ry = convertCSSSize(\n      abs(poses[1][1] - center[1]),\n      isCircle ? Math.sqrt((width * width + height * height) / 2) : height,\n      clipRelative,\n    );\n\n    const clipStyles = isCircle\n      ? [ry]\n      : [convertCSSSize(abs(poses[2][0] - center[0]), width, clipRelative), ry];\n\n    clipStyles.push(\n      'at',\n      convertCSSSize(center[0], width, clipRelative),\n      convertCSSSize(center[1], height, clipRelative),\n    );\n\n    return clipStyles;\n  }\n}\n\nexport function getRectPoses(\n  top: number,\n  right: number,\n  bottom: number,\n  left: number,\n): ControlPose[] {\n  const xs = [left, (left + right) / 2, right];\n  const ys = [top, (top + bottom) / 2, bottom];\n\n  return CLIP_RECT_DIRECTIONS.map(([dirx, diry, dir]) => {\n    const x = xs[dirx + 1];\n    const y = ys[diry + 1];\n    return {\n      vertical: abs(diry),\n      horizontal: abs(dirx),\n      direction: dir,\n      pos: [x, y],\n    };\n  });\n}\n\nexport function getControlSize(controlPoses: ControlPose[]) {\n  const xRange = [Infinity, -Infinity];\n  const yRange = [Infinity, -Infinity];\n\n  controlPoses.forEach(({ pos }) => {\n    xRange[0] = Math.min(xRange[0], pos[0]);\n    xRange[1] = Math.max(xRange[1], pos[0]);\n    yRange[0] = Math.min(yRange[0], pos[1]);\n    yRange[1] = Math.max(yRange[1], pos[1]);\n  });\n\n  return [abs(xRange[1] - xRange[0]), abs(yRange[1] - yRange[0])];\n}\n\nexport function getClipPath(\n  target: HTMLElement | SVGElement | undefined | null,\n  width: number,\n  height: number,\n  defaultClip?: string,\n  customClip?: string,\n) {\n  if (!target) {\n    return;\n  }\n  let clipText: string | undefined = customClip;\n\n  if (!clipText) {\n    const getStyle = getCachedStyle(target!);\n    const clipPath = getStyle('clipPath');\n\n    clipText = clipPath !== 'none' ? clipPath : getStyle('clip');\n  }\n  if (!clipText || clipText === 'none' || clipText === 'auto') {\n    clipText = defaultClip;\n\n    if (!clipText) {\n      return;\n    }\n  }\n  const { prefix: clipPrefix = clipText, value = '' } = splitBracket(clipText);\n  const isCircle = clipPrefix === 'circle';\n  let splitter = ' ';\n\n  if (clipPrefix === 'polygon') {\n    const values = splitComma(value! || `0% 0%, 100% 0%, 100% 100%, 0% 100%`);\n    splitter = ',';\n\n    const poses: ControlPose[] = values.map((pos) => {\n      const [xPos, yPos] = pos.split(' ');\n\n      return {\n        vertical: 1,\n        horizontal: 1,\n        pos: [convertUnitSize(xPos, width), convertUnitSize(yPos, height)],\n      };\n    });\n    const minMaxs = getMinMaxs(poses.map((pos) => pos.pos));\n\n    return {\n      type: clipPrefix,\n      clipText,\n      poses,\n      splitter,\n      left: minMaxs.minX,\n      right: minMaxs.maxX,\n      top: minMaxs.minY,\n      bottom: minMaxs.maxY,\n    } as const;\n  } else if (isCircle || clipPrefix === 'ellipse') {\n    let xPos = '';\n    let yPos = '';\n    let radiusX = 0;\n    let radiusY = 0;\n    const values = splitSpace(value!);\n\n    if (isCircle) {\n      let radius = '';\n      [radius = '50%', , xPos = '50%', yPos = '50%'] = values;\n\n      radiusX = convertUnitSize(\n        radius,\n        Math.sqrt((width * width + height * height) / 2),\n      );\n      radiusY = radiusX;\n    } else {\n      let xRadius = '';\n      let yRadius = '';\n      [xRadius = '50%', yRadius = '50%', , xPos = '50%', yPos = '50%'] = values;\n\n      radiusX = convertUnitSize(xRadius, width);\n      radiusY = convertUnitSize(yRadius, height);\n    }\n    const centerPos = [\n      convertUnitSize(xPos, width),\n      convertUnitSize(yPos, height),\n    ];\n    const poses: ControlPose[] = [\n      {\n        vertical: 1,\n        horizontal: 1,\n        pos: centerPos,\n        direction: 'nesw',\n      },\n      ...CLIP_DIRECTIONS.slice(0, isCircle ? 1 : 2).map((dir) => ({\n        vertical: abs(dir[1]),\n        horizontal: dir[0],\n        direction: dir[2],\n        sub: true,\n        pos: [centerPos[0] + dir[0] * radiusX, centerPos[1] + dir[1] * radiusY],\n      })),\n    ];\n    return {\n      type: clipPrefix as 'circle' | 'ellipse',\n      clipText,\n      radiusX,\n      radiusY,\n      left: centerPos[0] - radiusX,\n      top: centerPos[1] - radiusY,\n      right: centerPos[0] + radiusX,\n      bottom: centerPos[1] + radiusY,\n      poses,\n      splitter,\n    } as const;\n  } else if (clipPrefix === 'inset') {\n    const values = splitSpace(value! || '0 0 0 0 round 0px');\n\n    const roundIndex = values.indexOf('round');\n\n    const rectLength = (roundIndex > -1 ? values.slice(0, roundIndex) : values)\n      .length;\n    const radiusValues = values.slice(rectLength + 1);\n\n    const [\n      topValue,\n      rightValue = topValue,\n      bottomValue = topValue,\n      leftValue = rightValue,\n    ] = values.slice(0, rectLength);\n    const [top, bottom] = [topValue, bottomValue].map((pos) =>\n      convertUnitSize(pos, height),\n    );\n    const [left, right] = [leftValue, rightValue].map((pos) =>\n      convertUnitSize(pos, width),\n    );\n    const nextRight = width - right;\n    const nextBottom = height - bottom;\n\n    const poses: ControlPose[] = [\n      ...getRectPoses(top, nextRight, nextBottom, left),\n    ];\n\n    return {\n      type: 'inset',\n      clipText,\n      poses,\n      top,\n      left,\n      right: nextRight,\n      bottom: nextBottom,\n      radius: radiusValues,\n      splitter,\n    } as const;\n  } else if (clipPrefix === 'rect') {\n    // top right bottom left\n    const values = splitComma(value! || `0px, ${width}px, ${height}px, 0px`);\n\n    splitter = ',';\n    const [top, right, bottom, left] = values.map((pos) => {\n      const { value: posValue } = splitUnit(pos);\n\n      return posValue;\n    });\n    const poses = getRectPoses(top, right, bottom, left);\n\n    return {\n      type: 'rect',\n      clipText,\n      poses,\n      top,\n      right,\n      bottom,\n      left,\n      values,\n      splitter,\n    } as const;\n  }\n  return;\n}\n", "import {\n  Renderer,\n  ClippableProps,\n  OnClip,\n  ClippableState,\n  OnClipEnd,\n  OnClipStart,\n  ControlPose,\n  MoveableManagerInterface,\n  DraggableProps,\n} from '../types';\nimport { convertUnitSize, getRad } from '@daybrush/utils';\nimport {\n  prefix,\n  calculatePosition,\n  getDiagonalSize,\n  fillParams,\n  triggerEvent,\n  makeMatrixCSS,\n  getRect,\n  fillEndParams,\n  getSizeDistByDist,\n  getProps,\n  fillCSSObject,\n  abs,\n  sign,\n} from '../utils';\nimport { plus, minus, multiply } from '@scena/matrix';\nimport {\n  getDragDist,\n  calculatePointerDist,\n  setDragStart,\n} from '../gesto/GestoUtils';\nimport {\n  HORIZONTAL_RADIUS_ORDER,\n  VERTICAL_RADIUS_ORDER,\n  addRadiusPos,\n  removeRadiusPos,\n} from './roundable/borderRadius';\nimport { renderLine } from '../render-directions';\nimport { checkSnapBoundPriority } from './snappable/snap';\nimport { checkSnapBounds } from './snappable/snapBounds';\nimport { getDefaultGuidelines } from './snappable/getTotalGuidelines';\nimport {\n  getControlSize,\n  getClipPath,\n  getClipStyles,\n  getRectPoses,\n} from './clippable/utils';\n\ntype Point = [number, number];\ntype Direction = 'n' | 's' | 'e' | 'w' | 'ne' | 'nw' | 'se' | 'sw';\n\nfunction mapPointsToDirections(points: Point[]): Direction[] {\n  const directions: Direction[] = [];\n\n  const minX = Math.min(...points.map((point) => point[0]));\n  const maxX = Math.max(...points.map((point) => point[0]));\n  const minY = Math.min(...points.map((point) => point[1]));\n  const maxY = Math.max(...points.map((point) => point[1]));\n\n  for (const [x, y] of points) {\n    if (x === minX && y === minY) {\n      directions.push('nw');\n    } else if (x === maxX && y === minY) {\n      directions.push('ne');\n    } else if (x === maxX && y === maxY) {\n      directions.push('se');\n    } else if (x === minX && y === maxY) {\n      directions.push('sw');\n    } else if (x === minX) {\n      directions.push('w');\n    } else if (x === maxX) {\n      directions.push('e');\n    } else if (y === minY) {\n      directions.push('n');\n    } else if (y === maxY) {\n      directions.push('s');\n    }\n  }\n\n  return directions;\n}\n\n// Example usage\nconst points: Point[] = [\n  [0, 0],\n  [213.5, 0],\n  [427, 0],\n  [427, 320],\n  [427, 640],\n  [213.5, 640],\n  [0, 640],\n  [0, 320],\n];\n\nexport function moveControlPos(\n  controlPoses: ControlPose[],\n  index: number,\n  dist: number[],\n  isRect?: boolean,\n  keepRatio?: boolean,\n) {\n  const { direction, sub } = controlPoses[index];\n  const dists = controlPoses.map(() => [0, 0]);\n  const directions = direction ? direction.split('') : [];\n\n  if (isRect && index < 8) {\n    const verticalDirections = directions.filter(\n      (dir) => dir === 'w' || dir === 'e',\n    );\n    const horizontalDirections = directions.filter(\n      (dir) => dir === 'n' || dir === 's',\n    );\n\n    const verticalDirection = verticalDirections[0];\n    const horizontalDirection = horizontalDirections[0];\n\n    dists[index] = dist;\n    const [width, height] = getControlSize(controlPoses);\n    const ratio = width && height ? width / height : 0;\n\n    if (ratio && keepRatio) {\n      // 0 1 2\n      // 7   3\n      // 6 5 4\n      const fixedIndex = (index + 4) % 8;\n      const fixedPosition = controlPoses[fixedIndex].pos;\n      const sizeDirection = [0, 0];\n\n      if (direction!.indexOf('w') > -1) {\n        sizeDirection[0] = -1;\n      } else if (direction!.indexOf('e') > -1) {\n        sizeDirection[0] = 1;\n      }\n      if (direction!.indexOf('n') > -1) {\n        sizeDirection[1] = -1;\n      } else if (direction!.indexOf('s') > -1) {\n        sizeDirection[1] = 1;\n      }\n\n      const nextDist = getSizeDistByDist(\n        [width, height],\n        dist,\n        ratio,\n        sizeDirection,\n        true,\n      );\n      const nextWidth = width + nextDist[0];\n      const nextHeight = height + nextDist[1];\n      let top = fixedPosition[1];\n      let bottom = fixedPosition[1];\n      let left = fixedPosition[0];\n      let right = fixedPosition[0];\n\n      if (sizeDirection[0] === -1) {\n        left = right - nextWidth;\n      } else if (sizeDirection[0] === 1) {\n        right = left + nextWidth;\n      } else {\n        left = left - nextWidth / 2;\n        right = right + nextWidth / 2;\n      }\n      if (sizeDirection[1] === -1) {\n        top = bottom - nextHeight;\n      } else if (sizeDirection[1] === 1) {\n        bottom = top + nextHeight;\n      } else {\n        top = bottom - nextHeight / 2;\n        bottom = top + nextHeight;\n      }\n\n      const nextControlPoses = getRectPoses(top, right, bottom, left);\n\n      controlPoses.forEach((controlPose, i) => {\n        dists[i][0] = nextControlPoses[i].pos[0] - controlPose.pos[0];\n        dists[i][1] = nextControlPoses[i].pos[1] - controlPose.pos[1];\n      });\n    } else {\n      controlPoses.forEach((controlPose, i) => {\n        const { direction: controlDir } = controlPose;\n\n        if (!controlDir) {\n          return;\n        }\n        if (controlDir.indexOf(verticalDirection) > -1) {\n          dists[i][0] = dist[0];\n        }\n        if (controlDir.indexOf(horizontalDirection) > -1) {\n          dists[i][1] = dist[1];\n        }\n      });\n      if (verticalDirection) {\n        dists[1][0] = dist[0] / 2;\n        dists[5][0] = dist[0] / 2;\n      }\n      if (horizontalDirection) {\n        dists[3][1] = dist[1] / 2;\n        dists[7][1] = dist[1] / 2;\n      }\n    }\n  } else if (direction && !sub) {\n    directions.forEach((dir) => {\n      const isVertical = dir === 'n' || dir === 's';\n\n      controlPoses.forEach((controlPose, i) => {\n        const {\n          direction: dirDir,\n          horizontal: dirHorizontal,\n          vertical: dirVertical,\n        } = controlPose;\n\n        if (!dirDir || dirDir.indexOf(dir) === -1) {\n          return;\n        }\n        dists[i] = [\n          isVertical || !dirHorizontal ? 0 : dist[0],\n          !isVertical || !dirVertical ? 0 : dist[1],\n        ];\n      });\n    });\n  } else {\n    dists[index] = dist;\n  }\n\n  return dists;\n}\n\nfunction addClipPath(\n  moveable: MoveableManagerInterface<ClippableProps>,\n  e: any,\n) {\n  const [distX, distY] = calculatePointerDist(moveable, e);\n  const { clipPath, clipIndex } = e.datas;\n  const {\n    type: clipType,\n    poses: clipPoses,\n    splitter,\n  } = (clipPath as ReturnType<typeof getClipPath>)!;\n  const poses = clipPoses.map((pos) => pos.pos);\n  if (clipType === 'polygon') {\n    poses.splice(clipIndex, 0, [distX, distY]);\n  } else if (clipType === 'inset') {\n    const horizontalIndex = HORIZONTAL_RADIUS_ORDER.indexOf(clipIndex);\n    const verticalIndex = VERTICAL_RADIUS_ORDER.indexOf(clipIndex);\n    const length = clipPoses.length;\n\n    addRadiusPos(\n      clipPoses,\n      poses,\n      8,\n      horizontalIndex,\n      verticalIndex,\n      distX,\n      distY,\n      poses[4][0],\n      poses[4][1],\n      poses[0][0],\n      poses[0][1],\n    );\n\n    if (length === clipPoses.length) {\n      return;\n    }\n  } else {\n    return;\n  }\n  const clipStyles = getClipStyles(moveable, clipPath, poses)!;\n  const clipStyle = `${clipType}(${clipStyles.join(splitter)})`;\n\n  triggerEvent(\n    moveable,\n    'onClip',\n    fillParams<OnClip>(moveable, e, {\n      clipEventType: 'added',\n      clipType,\n      poses,\n      clipStyles,\n      clipStyle,\n      distX: 0,\n      distY: 0,\n      ...fillCSSObject(\n        {\n          clipPath: clipStyle,\n        },\n        e,\n      ),\n    }),\n  );\n}\nfunction removeClipPath(\n  moveable: MoveableManagerInterface<ClippableProps>,\n  e: any,\n) {\n  const { clipPath, clipIndex } = e.datas;\n  const {\n    type: clipType,\n    poses: clipPoses,\n    splitter,\n  } = (clipPath as ReturnType<typeof getClipPath>)!;\n  const poses = clipPoses.map((pos) => pos.pos);\n  const length = poses.length;\n  if (clipType === 'polygon') {\n    clipPoses.splice(clipIndex, 1);\n    poses.splice(clipIndex, 1);\n  } else if (clipType === 'inset') {\n    if (clipIndex < 8) {\n      return;\n    }\n    removeRadiusPos(clipPoses, poses, clipIndex, 8, length);\n\n    if (length === clipPoses.length) {\n      return;\n    }\n  } else {\n    return;\n  }\n  const clipStyles = getClipStyles(moveable, clipPath, poses)!;\n  const clipStyle = `${clipType}(${clipStyles.join(splitter)})`;\n\n  triggerEvent(\n    moveable,\n    'onClip',\n    fillParams<OnClip>(moveable, e, {\n      clipEventType: 'removed',\n      clipType,\n      poses,\n      clipStyles,\n      clipStyle,\n      distX: 0,\n      distY: 0,\n      ...fillCSSObject(\n        {\n          clipPath: clipStyle,\n        },\n        e,\n      ),\n    }),\n  );\n}\n/**\n * @namespace Moveable.Clippable\n * @description Whether to clip the target.\n */\n\nexport default {\n  name: 'clippable',\n  props: [\n    'clippable',\n    'defaultClipPath',\n    'customClipPath',\n    'keepRatio',\n    'clipRelative',\n    'clipArea',\n    'dragWithClip',\n    'clipTargetBounds',\n    'clipVerticalGuidelines',\n    'clipHorizontalGuidelines',\n    'clipSnapThreshold',\n  ] as const,\n  events: ['clipStart', 'clip', 'clipEnd'] as const,\n  css: [\n    `.control.clip-control {\nbackground: red;\ncursor: pointer;\n}\n.control.clip-control.clip-radius {\nbackground: #d66;\n}\n.line.clip-line {\nbackground: #6e6;\ncursor: move;\nz-index: 1;\n}\n.clip-area {\nposition: absolute;\ntop: 0;\nleft: 0;\n}\n.clip-ellipse {\nposition: absolute;\ncursor: move;\nborder: 1px solid #6d6;\nborder: var(--zoompx) solid #6d6;\nborder-radius: 50%;\ntransform-origin: 0px 0px;\n}`,\n    `:host {\n--bounds-color: #d66;\n}`,\n    `.guideline {\npointer-events: none;\nz-index: 2;\n}`,\n    `.line.guideline.bounds {\nbackground: #d66;\nbackground: var(--bounds-color);\n}`,\n  ],\n  render(\n    moveable: MoveableManagerInterface<ClippableProps, ClippableState>,\n    React: Renderer,\n  ): any[] {\n    const { customClipPath, defaultClipPath, clipArea, zoom, groupable } =\n      moveable.props;\n    const {\n      target,\n      width,\n      height,\n      allMatrix,\n      is3d,\n      left,\n      top,\n      pos1,\n      pos2,\n      pos3,\n      pos4,\n      clipPathState,\n      snapBoundInfos,\n      rotation: rotationRad,\n    } = moveable.getState();\n\n    if (!target || groupable) {\n      return [];\n    }\n\n    const clipPath = getClipPath(\n      target,\n      width,\n      height,\n      defaultClipPath || 'inset',\n      clipPathState || customClipPath,\n    );\n\n    if (!clipPath) {\n      return [];\n    }\n    const n = is3d ? 4 : 3;\n    const type = clipPath.type;\n    const clipPoses = clipPath.poses;\n    const poses = clipPoses.map((pos) => {\n      // return [x, y];\n      const calculatedPos = calculatePosition(allMatrix, pos.pos, n);\n\n      return [calculatedPos[0] - left, calculatedPos[1] - top] as Point;\n    });\n\n    let controls: any[] = [];\n    let lines: any[] = [];\n\n    const isRect = type === 'rect';\n    const isInset = type === 'inset';\n    const isPolygon = type === 'polygon';\n\n    if (isRect || isInset || isPolygon) {\n      const linePoses = isInset ? poses.slice(0, 8) : poses;\n\n      lines = linePoses.map((to, i) => {\n        const from =\n          i === 0 ? linePoses[linePoses.length - 1] : linePoses[i - 1];\n\n        const rad = getRad(from, to);\n        const dist = getDiagonalSize(from, to);\n        return (\n          <div\n            key={`clipLine${i}`}\n            className={prefix('line', 'clip-line', 'snap-control')}\n            data-clip-index={i}\n            style={{\n              width: `${dist}px`,\n              transform: `translate(${from[0]}px, ${from[1]}px) rotate(${rad}rad) scaleY(${zoom})`,\n            }}\n          ></div>\n        );\n      });\n    }\n    const directions = ['nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'];\n    controls = poses.map((pos, i) => {\n      // console.log(poses);\n      const direction = directions[i];\n      // console.log(direction);\n      return (\n        <div\n          key={`clipControl${i}`}\n          className={prefix(\n            'control',\n            'clip-control',\n            'snap-control',\n            `clip-${direction}`,\n          )}\n          data-clip-index={i}\n          style={{\n            transform: `translate(${pos[0]}px, ${pos[1]}px) rotate(${rotationRad}rad) scale(${zoom})`,\n            backgroundColor: 'green',\n          }}\n        ></div>\n      );\n    });\n\n    if (isInset) {\n      controls.push(\n        ...poses.slice(8).map((pos, i) => {\n          return (\n            <div\n              key={`clipRadiusControl${i}`}\n              className={prefix(\n                'control',\n                'clip-control',\n                'clip-radius',\n                'snap-control',\n              )}\n              data-clip-index={8 + i}\n              style={{\n                transform: `translate(${pos[0]}px, ${pos[1]}px) rotate(${rotationRad}rad) scale(${zoom})`,\n              }}\n            ></div>\n          );\n        }),\n      );\n    }\n    if (type === 'circle' || type === 'ellipse') {\n      const { left: clipLeft, top: clipTop, radiusX, radiusY } = clipPath;\n\n      const [distLeft, distTop] = minus(\n        calculatePosition(allMatrix, [clipLeft!, clipTop!], n),\n        calculatePosition(allMatrix, [0, 0], n),\n      );\n      let ellipseClipPath = 'none';\n\n      if (!clipArea) {\n        const piece = Math.max(10, radiusX! / 5, radiusY! / 5);\n        const areaPoses: number[][] = [];\n\n        for (let i = 0; i <= piece; ++i) {\n          const rad = ((Math.PI * 2) / piece) * i;\n          areaPoses.push([\n            radiusX! + (radiusX! - zoom!) * Math.cos(rad),\n            radiusY! + (radiusY! - zoom!) * Math.sin(rad),\n          ]);\n        }\n        areaPoses.push([radiusX!, -2]);\n        areaPoses.push([-2, -2]);\n        areaPoses.push([-2, radiusY! * 2 + 2]);\n        areaPoses.push([radiusX! * 2 + 2, radiusY! * 2 + 2]);\n        areaPoses.push([radiusX! * 2 + 2, -2]);\n        areaPoses.push([radiusX!, -2]);\n\n        ellipseClipPath = `polygon(${areaPoses.map((pos) => `${pos[0]}px ${pos[1]}px`).join(', ')})`;\n      }\n      controls.push(\n        <div\n          key=\"clipEllipse\"\n          className={prefix('clip-ellipse', 'snap-control')}\n          style={{\n            width: `${radiusX! * 2}px`,\n            height: `${radiusY! * 2}px`,\n            clipPath: ellipseClipPath,\n            transform: `translate(${-left + distLeft}px, ${-top + distTop}px) ${makeMatrixCSS(allMatrix)}`,\n          }}\n        ></div>,\n      );\n    }\n    if (clipArea) {\n      const {\n        width: allWidth,\n        height: allHeight,\n        left: allLeft,\n        top: allTop,\n      } = getRect([pos1, pos2, pos3, pos4, ...poses]);\n      if (isPolygon || isRect || isInset) {\n        const areaPoses = isInset ? poses.slice(0, 8) : poses;\n        controls.push(\n          <div\n            key=\"clipArea\"\n            className={prefix('clip-area', 'snap-control')}\n            style={{\n              width: `${allWidth}px`,\n              height: `${allHeight}px`,\n              transform: `translate(${allLeft}px, ${allTop}px)`,\n              clipPath: `polygon(${areaPoses.map((pos) => `${pos[0] - allLeft}px ${pos[1] - allTop}px`).join(', ')})`,\n            }}\n          ></div>,\n        );\n      }\n    }\n    if (snapBoundInfos) {\n      (['vertical', 'horizontal'] as const).forEach((directionType) => {\n        const info = snapBoundInfos[directionType];\n        const isHorizontal = directionType === 'horizontal';\n\n        if (info.isSnap) {\n          lines.push(\n            ...info.snap.posInfos.map(({ pos }, i) => {\n              const snapPos1 = minus(\n                calculatePosition(\n                  allMatrix,\n                  isHorizontal ? [0, pos] : [pos, 0],\n                  n,\n                ),\n                [left, top],\n              );\n              const snapPos2 = minus(\n                calculatePosition(\n                  allMatrix,\n                  isHorizontal ? [width, pos] : [pos, height],\n                  n,\n                ),\n                [left, top],\n              );\n\n              return renderLine(\n                React,\n                '',\n                snapPos1,\n                snapPos2,\n                zoom!,\n                `clip${directionType}snap${i}`,\n                'guideline',\n              );\n            }),\n          );\n        }\n        if (info.isBound) {\n          lines.push(\n            ...info.bounds.map(({ pos }, i) => {\n              const snapPos1 = minus(\n                calculatePosition(\n                  allMatrix,\n                  isHorizontal ? [0, pos] : [pos, 0],\n                  n,\n                ),\n                [left, top],\n              );\n              const snapPos2 = minus(\n                calculatePosition(\n                  allMatrix,\n                  isHorizontal ? [width, pos] : [pos, height],\n                  n,\n                ),\n                [left, top],\n              );\n\n              return renderLine(\n                React,\n                '',\n                snapPos1,\n                snapPos2,\n                zoom!,\n                `clip${directionType}bounds${i}`,\n                'guideline',\n                'bounds',\n                'bold',\n              );\n            }),\n          );\n        }\n      });\n    }\n    return [...controls, ...lines];\n  },\n  dragControlCondition(moveable: any, e: any) {\n    return (\n      e.inputEvent &&\n      (e.inputEvent.target.getAttribute('class') || '').indexOf('clip') > -1\n    );\n  },\n  dragStart(\n    moveable: MoveableManagerInterface<ClippableProps, ClippableState>,\n    e: any,\n  ) {\n    const props = moveable.props;\n    const { dragWithClip = true } = props;\n\n    if (dragWithClip) {\n      return false;\n    }\n\n    return this.dragControlStart(moveable, e);\n  },\n  drag(\n    moveable: MoveableManagerInterface<ClippableProps, ClippableState>,\n    e: any,\n  ) {\n    return this.dragControl(moveable, { ...e, isDragTarget: true });\n  },\n  dragEnd(\n    moveable: MoveableManagerInterface<ClippableProps, ClippableState>,\n    e: any,\n  ) {\n    return this.dragControlEnd(moveable, e);\n  },\n  dragControlStart(\n    moveable: MoveableManagerInterface<ClippableProps, ClippableState>,\n    e: any,\n  ) {\n    const state = moveable.state;\n    const { defaultClipPath, customClipPath } = moveable.props;\n    const { target, width, height } = state;\n    const inputTarget = e.inputEvent ? e.inputEvent.target : null;\n    const className = (inputTarget && inputTarget.getAttribute('class')) || '';\n    const datas = e.datas;\n    const clipPath = getClipPath(\n      target!,\n      width,\n      height,\n      defaultClipPath || 'inset',\n      customClipPath,\n    );\n\n    if (!clipPath) {\n      return false;\n    }\n    const { clipText, type, poses } = clipPath;\n\n    const result = triggerEvent(\n      moveable,\n      'onClipStart',\n      fillParams<OnClipStart>(moveable, e, {\n        clipType: type,\n        clipStyle: clipText,\n        poses: poses.map((pos) => pos.pos),\n      }),\n    );\n\n    if (result === false) {\n      datas.isClipStart = false;\n      return false;\n    }\n    datas.isControl = className && className.indexOf('clip-control') > -1;\n    datas.isLine = className.indexOf('clip-line') > -1;\n    datas.isArea =\n      className.indexOf('clip-area') > -1 ||\n      className.indexOf('clip-ellipse') > -1;\n    datas.clipIndex = inputTarget\n      ? parseInt(inputTarget.getAttribute('data-clip-index'), 10)\n      : -1;\n    datas.clipPath = clipPath;\n    datas.isClipStart = true;\n    state.clipPathState = clipText;\n    setDragStart(moveable, e);\n\n    return true;\n  },\n  dragControl(\n    moveable: MoveableManagerInterface<\n      ClippableProps & DraggableProps,\n      ClippableState\n    >,\n    e: any,\n  ) {\n    const { datas, originalDatas, isDragTarget } = e;\n\n    if (!datas.isClipStart) {\n      return false;\n    }\n    const { isControl, isLine, isArea, clipIndex, clipPath } = datas as {\n      clipPath: ReturnType<typeof getClipPath>;\n      [key: string]: any;\n    };\n    if (!clipPath) {\n      return false;\n    }\n    const props = getProps(moveable.props, 'clippable');\n\n    const { keepRatio } = props;\n    let distX = 0;\n    let distY = 0;\n\n    const originalDraggable = originalDatas.draggable;\n    const originalDist = getDragDist(e);\n\n    if (isDragTarget && originalDraggable) {\n      [distX, distY] = originalDraggable.prevBeforeDist;\n    } else {\n      [distX, distY] = originalDist;\n    }\n\n    const firstDist = [distX, distY];\n\n    const state = moveable.state;\n    const { width, height } = state;\n    const isDragWithTarget = !isArea && !isControl && !isLine;\n    const { type: clipType, poses: clipPoses, splitter } = clipPath;\n    const poses = clipPoses.map((pos) => pos.pos);\n\n    if (isDragWithTarget) {\n      distX = -distX;\n      distY = -distY;\n    }\n    const isAll = !isControl || clipPoses[clipIndex].direction === 'nesw';\n    const isRect = clipType === 'inset' || clipType === 'rect';\n    let dists = clipPoses.map(() => [0, 0]);\n\n    let shouldKeepRatio = props.defaultClipPath === 'inset' ? false : keepRatio;\n\n    if (isControl && !isAll) {\n      const { horizontal, vertical } = clipPoses[clipIndex];\n      const dist = [distX * abs(horizontal), distY * abs(vertical)];\n      dists = moveControlPos(\n        clipPoses,\n        clipIndex,\n        dist,\n        isRect,\n        shouldKeepRatio,\n      );\n    } else if (isAll) {\n      dists = poses.map(() => [distX, distY]);\n    }\n    const nextPoses: number[][] = poses.map((pos, i) => plus(pos, dists[i]));\n    const guidePoses = [...nextPoses];\n\n    state.snapBoundInfos = null;\n    const isCircle = clipPath.type === 'circle';\n    const isEllipse = clipPath.type === 'ellipse';\n\n    if (isCircle || isEllipse) {\n      const guideRect = getRect(nextPoses);\n      const ry = abs(guideRect.bottom - guideRect.top);\n      const rx = abs(isEllipse ? guideRect.right - guideRect.left : ry);\n      const bottom = nextPoses[0][1] + ry;\n      const left = nextPoses[0][0] - rx;\n      const right = nextPoses[0][0] + rx;\n\n      // right\n      if (isCircle) {\n        guidePoses.push([right, guideRect.bottom]);\n        dists.push([1, 0]);\n      }\n      // bottom\n      guidePoses.push([guideRect.left, bottom]);\n      dists.push([0, 1]);\n      // left\n      guidePoses.push([left, guideRect.bottom]);\n      dists.push([1, 0]);\n    }\n\n    const guidelines = getDefaultGuidelines(\n      (props.clipHorizontalGuidelines || []).map((v) =>\n        convertUnitSize(`${v}`, height),\n      ),\n      (props.clipVerticalGuidelines || []).map((v) =>\n        convertUnitSize(`${v}`, width),\n      ),\n      width!,\n      height!,\n    );\n    let guideXPoses: number[] = [];\n    let guideYPoses: number[] = [];\n\n    if (isCircle || isEllipse) {\n      guideXPoses = [guidePoses[4][0], guidePoses[2][0]];\n      guideYPoses = [guidePoses[1][1], guidePoses[3][1]];\n    } else if (isRect) {\n      const rectPoses = [\n        guidePoses[0],\n        guidePoses[2],\n        guidePoses[4],\n        guidePoses[6],\n      ];\n      const rectDists = [dists[0], dists[2], dists[4], dists[6]];\n\n      guideXPoses = rectPoses\n        .filter((_, i) => rectDists[i][0])\n        .map((pos) => pos[0]);\n      guideYPoses = rectPoses\n        .filter((_, i) => rectDists[i][1])\n        .map((pos) => pos[1]);\n    } else {\n      guideXPoses = guidePoses\n        .filter((_, i) => dists[i][0])\n        .map((pos) => pos[0]);\n      guideYPoses = guidePoses\n        .filter((_, i) => dists[i][1])\n        .map((pos) => pos[1]);\n    }\n    const boundDelta = [0, 0];\n    const { horizontal: horizontalSnapInfo, vertical: verticalSnapInfo } =\n      checkSnapBounds(\n        guidelines,\n        props.clipTargetBounds && {\n          left: 0,\n          top: 0,\n          right: width,\n          bottom: height,\n        },\n        guideXPoses,\n        guideYPoses,\n        5,\n        5,\n      );\n    let snapOffsetY = horizontalSnapInfo.offset;\n    let snapOffsetX = verticalSnapInfo.offset;\n\n    if (horizontalSnapInfo.isBound) {\n      boundDelta[1] += snapOffsetY;\n    }\n    if (verticalSnapInfo.isBound) {\n      boundDelta[0] += snapOffsetX;\n    }\n    if ((isEllipse || isCircle) && dists[0][0] === 0 && dists[0][1] === 0) {\n      const guideRect = getRect(nextPoses);\n      let cy = guideRect.bottom - guideRect.top;\n      let cx = isEllipse ? guideRect.right - guideRect.left : cy;\n\n      const distSnapX = verticalSnapInfo.isBound\n        ? abs(snapOffsetX)\n        : verticalSnapInfo.snapIndex === 0\n          ? -snapOffsetX\n          : snapOffsetX;\n      const distSnapY = horizontalSnapInfo.isBound\n        ? abs(snapOffsetY)\n        : horizontalSnapInfo.snapIndex === 0\n          ? -snapOffsetY\n          : snapOffsetY;\n      cx -= distSnapX;\n      cy -= distSnapY;\n\n      if (isCircle) {\n        cy =\n          checkSnapBoundPriority(verticalSnapInfo, horizontalSnapInfo) > 0\n            ? cy\n            : cx;\n        cx = cy;\n      }\n      const center = guidePoses[0];\n\n      guidePoses[1][1] = center[1] - cy;\n      guidePoses[2][0] = center[0] + cx;\n      guidePoses[3][1] = center[1] + cy;\n      guidePoses[4][0] = center[0] - cx;\n    } else if (isRect && shouldKeepRatio && isControl) {\n      const [width, height] = getControlSize(clipPoses);\n      const ratio = width && height ? width / height : 0;\n      const clipPose = clipPoses[clipIndex];\n      const direction = clipPose.direction! || '';\n      let top = guidePoses[1][1];\n      let bottom = guidePoses[5][1];\n      let left = guidePoses[7][0];\n      let right = guidePoses[3][0];\n\n      if (abs(snapOffsetY) <= abs(snapOffsetX)) {\n        snapOffsetY = (sign(snapOffsetY) * abs(snapOffsetX)) / ratio;\n      } else {\n        snapOffsetX = sign(snapOffsetX) * abs(snapOffsetY) * ratio;\n      }\n      if (direction!.indexOf('w') > -1) {\n        left -= snapOffsetX;\n      } else if (direction!.indexOf('e') > -1) {\n        right -= snapOffsetX;\n      } else {\n        left += snapOffsetX / 2;\n        right -= snapOffsetX / 2;\n      }\n      if (direction!.indexOf('n') > -1) {\n        top -= snapOffsetY;\n      } else if (direction!.indexOf('s') > -1) {\n        bottom -= snapOffsetY;\n      } else {\n        top += snapOffsetY / 2;\n        bottom -= snapOffsetY / 2;\n      }\n      const nextControlPoses = getRectPoses(top, right, bottom, left);\n\n      guidePoses.forEach((pos, i) => {\n        [pos[0], pos[1]] = nextControlPoses[i].pos;\n      });\n    } else {\n      guidePoses.forEach((pos, j) => {\n        const dist = dists[j];\n\n        if (dist[0]) {\n          pos[0] -= snapOffsetX;\n        }\n        if (dist[1]) {\n          pos[1] -= snapOffsetY;\n        }\n      });\n    }\n\n    const nextClipStyles = getClipStyles(moveable, clipPath, nextPoses)!;\n    const clipStyle = `${clipType}(${nextClipStyles.join(splitter)} ${clipPath.radius.length ? 'round ' + clipPath.radius.join(' ') : ''})`;\n\n    // console.log({ clipStyle });\n    state.clipPathState = clipStyle;\n\n    if (isCircle || isEllipse) {\n      guideXPoses = [guidePoses[4][0], guidePoses[2][0]];\n      guideYPoses = [guidePoses[1][1], guidePoses[3][1]];\n    } else if (isRect) {\n      const rectPoses = [\n        guidePoses[0],\n        guidePoses[2],\n        guidePoses[4],\n        guidePoses[6],\n      ];\n\n      guideXPoses = rectPoses.map((pos) => pos[0]);\n      guideYPoses = rectPoses.map((pos) => pos[1]);\n    } else {\n      guideXPoses = guidePoses.map((pos) => pos[0]);\n      guideYPoses = guidePoses.map((pos) => pos[1]);\n    }\n    state.snapBoundInfos = checkSnapBounds(\n      guidelines,\n      props.clipTargetBounds && {\n        left: 0,\n        top: 0,\n        right: width,\n        bottom: height,\n      },\n      guideXPoses,\n      guideYPoses,\n      1,\n      1,\n    );\n\n    if (originalDraggable) {\n      const { is3d, allMatrix } = state;\n      const n = is3d ? 4 : 3;\n\n      let dragDist = boundDelta;\n\n      if (isDragTarget) {\n        dragDist = [\n          firstDist[0] + boundDelta[0] - originalDist[0],\n          firstDist[1] + boundDelta[1] - originalDist[1],\n        ];\n      }\n      originalDraggable.deltaOffset = multiply(\n        allMatrix,\n        [dragDist[0], dragDist[1], 0, 0],\n        n,\n      );\n    }\n    triggerEvent(\n      moveable,\n      'onClip',\n      fillParams<OnClip>(moveable, e, {\n        clipEventType: 'changed',\n        clipType,\n        poses: nextPoses,\n        clipStyle,\n        clipStyles: nextClipStyles,\n        distX,\n        distY,\n        ...fillCSSObject(\n          {\n            [clipType === 'rect' ? 'clip' : 'clipPath']: clipStyle,\n          },\n          e,\n        ),\n      }),\n    );\n\n    return true;\n  },\n  dragControlEnd(\n    moveable: MoveableManagerInterface<ClippableProps, ClippableState>,\n    e: any,\n  ) {\n    this.unset(moveable);\n    const { isDrag, datas, isDouble } = e;\n    const { isLine, isClipStart, isControl } = datas;\n\n    if (!isClipStart) {\n      return false;\n    }\n    triggerEvent(\n      moveable,\n      'onClipEnd',\n      fillEndParams<OnClipEnd>(moveable, e, {}),\n    );\n    if (isDouble) {\n      if (isControl) {\n        console.log('removeClipPath');\n        removeClipPath(moveable, e);\n      } else if (isLine) {\n        console.log('addClipPath');\n        // add\n        addClipPath(moveable, e);\n      }\n    }\n    return isDouble || isDrag;\n  },\n  unset(moveable: MoveableManagerInterface<ClippableProps, ClippableState>) {\n    moveable.state.clipPathState = '';\n    moveable.state.snapBoundInfos = null;\n  },\n};\n\n/**\n * Whether to clip the target. (default: false)\n * @name Moveable.Clippable#clippable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n *  If clippath is not set, the default value can be set. (defaultClipPath < style < customClipPath < dragging clipPath)\n * @name Moveable.Clippable#defaultClipPath\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * % Can be used instead of the absolute px (`rect` not possible) (default: false)\n * @name Moveable.Clippable#clipRelative\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * You can force the custom clipPath. (defaultClipPath < style < customClipPath < dragging clipPath)\n * @name Moveable.Clippable#customClipPath\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * When dragging the target, the clip also moves. (default: true)\n * @name Moveable.Clippable#dragWithClip\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * You can drag the clip by setting clipArea.\n * @name Moveable.Clippable#clipArea\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * Whether the clip is bound to the target.\n * @name Moveable.Clippable#clipTargetBounds\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n *     clipTargetBounds: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * Add clip guidelines in the vertical direction.\n * @name Moveable.Clippable#clipVerticalGuidelines\n * @default 0\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n *     clipVerticalGuidelines: [0, 100, 200],\n *     clipHorizontalGuidelines: [0, 100, 200],\n *     clipSnapThreshold: 5,\n * });\n */\n\n/**\n * Add clip guidelines in the horizontal direction.\n * @name Moveable.Clippable#clipHorizontalGuidelines\n * @default []\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n *     clipVerticalGuidelines: [0, 100, 200],\n *     clipHorizontalGuidelines: [0, 100, 200],\n *     clipSnapThreshold: 5,\n * });\n */\n/**\n * istance value that can snap to clip guidelines.\n * @name Moveable.Clippable#clipSnapThreshold\n * @default 5\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n *     clipVerticalGuidelines: [0, 100, 200],\n *     clipHorizontalGuidelines: [0, 100, 200],\n *     clipSnapThreshold: 5,\n * });\n */\n/**\n * When drag start the clip area or controls, the `clipStart` event is called.\n * @memberof Moveable.Clippable\n * @event clipStart\n * @param {Moveable.Clippable.OnClipStart} - Parameters for the `clipStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * When drag the clip area or controls, the `clip` event is called.\n * @memberof Moveable.Clippable\n * @event clip\n * @param {Moveable.Clippable.OnClip} - Parameters for the `clip` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * When drag end the clip area or controls, the `clipEnd` event is called.\n * @memberof Moveable.Clippable\n * @event clipEnd\n * @param {Moveable.Clippable.OnClipEnd} - Parameters for the `clipEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n", "import {\n    prefix, triggerEvent,\n    fillParams, calculatePoses, getRect, fillEndParams, convertCSSSize, fillCSSObject,\n} from \"../utils\";\nimport {\n    OnDragOriginStart, OnDragOrigin,\n    OnDragOriginEnd, MoveableManagerInterface, DraggableProps, OriginDraggableProps, MoveableGroupInterface,\n} from \"../types\";\nimport { hasClass, IObject } from \"@daybrush/utils\";\nimport { setDragStart, getDragDist, getNextMatrix } from \"../gesto/GestoUtils\";\nimport { minus, plus } from \"@scena/matrix\";\nimport Draggable from \"./Draggable\";\nimport CustomGesto, { setCustomDrag } from \"../gesto/CustomGesto\";\n\n/**\n * @namespace OriginDraggable\n * @memberof Moveable\n * @description Whether to drag origin (default: false)\n */\nexport default {\n    name: \"originDraggable\",\n    props: [\n        \"originDraggable\",\n        \"originRelative\",\n    ] as const,\n    events: [\n        \"dragOriginStart\",\n        \"dragOrigin\",\n        \"dragOriginEnd\",\n    ] as const,\n    css: [\n        `:host[data-able-origindraggable] .control.origin {\npointer-events: auto;\n}`,\n    ],\n    dragControlCondition(_: any, e: any) {\n        if (e.isRequest) {\n            return e.requestAble === \"originDraggable\";\n        }\n        return hasClass(e.inputEvent.target, prefix(\"origin\"));\n    },\n    dragControlStart(moveable: MoveableManagerInterface<OriginDraggableProps & DraggableProps>, e: any) {\n        const { datas } = e;\n\n        setDragStart(moveable, e);\n\n        const params = fillParams<OnDragOriginStart>(moveable, e, {\n            dragStart: Draggable.dragStart(\n                moveable,\n                new CustomGesto().dragStart([0, 0], e),\n            ),\n        });\n        const result = triggerEvent(moveable, \"onDragOriginStart\", params);\n\n        datas.startOrigin = moveable.state.transformOrigin;\n        datas.startTargetOrigin = moveable.state.targetOrigin;\n        datas.prevOrigin = [0, 0];\n        datas.isDragOrigin = true;\n\n        if (result === false) {\n            datas.isDragOrigin = false;\n            return false;\n        }\n\n        return params;\n    },\n    dragControl(moveable: MoveableManagerInterface<OriginDraggableProps & DraggableProps>, e: any) {\n        const { datas, isPinch, isRequest } = e;\n\n        if (!datas.isDragOrigin) {\n            return false;\n        }\n        const [distX, distY] = getDragDist(e);\n        const state = moveable.state;\n        const {\n            width,\n            height,\n            offsetMatrix,\n            targetMatrix,\n            is3d,\n        } = state;\n        const {\n            originRelative = true,\n        } = moveable.props;\n        const n = is3d ? 4 : 3;\n        let dist = [distX, distY];\n\n        if (isRequest) {\n            const distOrigin = e.distOrigin;\n            if (distOrigin[0] || distOrigin[1]) {\n                dist = distOrigin;\n            }\n        }\n        const origin = plus(datas.startOrigin, dist);\n        const targetOrigin = plus(datas.startTargetOrigin, dist);\n        const delta = minus(dist, datas.prevOrigin);\n\n        const nextMatrix = getNextMatrix(\n            offsetMatrix,\n            targetMatrix,\n            origin,\n            n,\n        );\n\n        const rect = moveable.getRect();\n        const nextRect = getRect(calculatePoses(nextMatrix, width, height, n));\n\n        const dragDelta = [\n            rect.left - nextRect.left,\n            rect.top - nextRect.top,\n        ];\n\n        datas.prevOrigin = dist;\n        const transformOrigin = [\n            convertCSSSize(targetOrigin[0], width, originRelative),\n            convertCSSSize(targetOrigin[1], height, originRelative),\n        ].join(\" \");\n        const result = Draggable.drag(\n            moveable,\n            setCustomDrag(e, moveable.state, dragDelta, !!isPinch, false),\n        )!;\n        const params = fillParams<OnDragOrigin>(moveable, e, {\n            width,\n            height,\n            origin,\n            dist,\n            delta,\n            transformOrigin,\n            drag: result,\n            ...fillCSSObject({\n                transformOrigin,\n                transform: result.transform,\n            }, e),\n            afterTransform: result.transform,\n        });\n        triggerEvent(moveable, \"onDragOrigin\", params);\n        return params;\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<OriginDraggableProps>, e: any) {\n        const { datas } = e;\n\n        if (!datas.isDragOrigin) {\n            return false;\n        }\n        triggerEvent(moveable, \"onDragOriginEnd\",\n            fillEndParams<OnDragOriginEnd>(moveable, e, {}));\n        return true;\n    },\n    dragGroupControlCondition(moveable: any, e: any) {\n        return this.dragControlCondition(moveable, e);\n    },\n    dragGroupControlStart(moveable: MoveableGroupInterface<OriginDraggableProps>, e: any) {\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n\n        return true;\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<OriginDraggableProps>, e: any) {\n        const params = this.dragControl(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        moveable.transformOrigin = params.transformOrigin;\n\n        return true;\n    },\n    /**\n    * @method Moveable.OriginDraggable#request\n    * @param {object} e - the OriginDraggable's request parameter\n    * @param {number} [e.x] - x position\n    * @param {number} [e.y] - y position\n    * @param {number} [e.deltaX] - x number to move\n    * @param {number} [e.deltaY] - y number to move\n    * @param {array} [e.deltaOrigin] - left, top number to move transform-origin\n    * @param {array} [e.origin] - transform-origin position\n    * @param {number} [e.isInstant] - Whether to execute the request instantly\n    * @return {Moveable.Requester} Moveable Requester\n    * @example\n\n    * // Instantly Request (requestStart - request - requestEnd)\n    * // Use Relative Value\n    * moveable.request(\"originDraggable\", { deltaX: 10, deltaY: 10 }, true);\n    * // Use Absolute Value\n    * moveable.request(\"originDraggable\", { x: 200, y: 100 }, true);\n    * // Use Transform Value\n    * moveable.request(\"originDraggable\", { deltaOrigin: [10, 0] }, true);\n    * moveable.request(\"originDraggable\", { origin: [100, 0] }, true);\n    * // requestStart\n    * const requester = moveable.request(\"originDraggable\");\n    *\n    * // request\n    * // Use Relative Value\n    * requester.request({ deltaX: 10, deltaY: 10 });\n    * requester.request({ deltaX: 10, deltaY: 10 });\n    * requester.request({ deltaX: 10, deltaY: 10 });\n    * // Use Absolute Value\n    * moveable.request(\"originDraggable\", { x: 200, y: 100 });\n    * moveable.request(\"originDraggable\", { x: 220, y: 100 });\n    * moveable.request(\"originDraggable\", { x: 240, y: 100 });\n    *\n    * // requestEnd\n    * requester.requestEnd();\n    */\n    request(moveable: MoveableManagerInterface<any, any>) {\n        const datas = {};\n        const rect = moveable.getRect();\n        let distX = 0;\n        let distY = 0;\n\n        const transformOrigin = rect.transformOrigin;\n        const distOrigin = [0, 0];\n\n        return {\n            isControl: true,\n            requestStart() {\n                return { datas };\n            },\n            request(e: IObject<any>) {\n                if (\"deltaOrigin\" in e) {\n                    distOrigin[0] += e.deltaOrigin[0];\n                    distOrigin[1] += e.deltaOrigin[1];\n                } else if (\"origin\" in e) {\n                    distOrigin[0] = e.origin[0] - transformOrigin[0];\n                    distOrigin[1] = e.origin[1] - transformOrigin[1];\n                } else {\n                    if (\"x\" in e) {\n                        distX = e.x - rect.left;\n                    } else if (\"deltaX\" in e) {\n                        distX += e.deltaX;\n                    }\n                    if (\"y\" in e) {\n                        distY = e.y - rect.top;\n                    } else if (\"deltaY\" in e) {\n                        distY += e.deltaY;\n                    }\n                }\n\n                return { datas, distX, distY, distOrigin };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n};\n/**\n * Whether to drag origin (default: false)\n * @name Moveable.OriginDraggable#originDraggable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     originDraggable: true,\n * });\n * let translate = [0, 0];\n * moveable.on(\"dragOriginStart\", e => {\n *     e.dragStart && e.dragStart.set(translate);\n * }).on(\"dragOrigin\", e => {\n *     translate = e.drag.beforeTranslate;\n *     e.target.style.cssText\n *         = `transform-origin: ${e.transformOrigin};`\n *         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n * }).on(\"dragOriginEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * % Can be used instead of the absolute px (default: true)\n * @name Moveable.OriginDraggable#originRelative\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     originDraggable: true,\n *     originRelative: false,\n * });\n * moveable.originRelative = true;\n */\n\n/**\n* When drag start the origin, the `dragOriginStart` event is called.\n* @memberof Moveable.OriginDraggable\n* @event dragOriginStart\n* @param {Moveable.OriginDraggable.OnDragOriginStart} - Parameters for the `dragOriginStart` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     originDraggable: true,\n* });\n* let translate = [0, 0];\n* moveable.on(\"dragOriginStart\", e => {\n*     e.dragStart && e.dragStart.set(translate);\n* }).on(\"dragOrigin\", e => {\n*     translate = e.drag.beforeTranslate;\n*     e.target.style.cssText\n*         = `transform-origin: ${e.transformOrigin};`\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n* }).on(\"dragOriginEnd\", e => {\n*     console.log(e);\n* });\n*/\n\n/**\n* When drag the origin, the `dragOrigin` event is called.\n* @memberof Moveable.OriginDraggable\n* @event dragOrigin\n* @param {Moveable.OriginDraggable.OnDragOrigin} - Parameters for the `dragOrigin` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     originDraggable: true,\n* });\n* let translate = [0, 0];\n* moveable.on(\"dragOriginStart\", e => {\n*     e.dragStart && e.dragStart.set(translate);\n* }).on(\"dragOrigin\", e => {\n*     translate = e.drag.beforeTranslate;\n*     e.target.style.cssText\n*         = `transform-origin: ${e.transformOrigin};`\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n* }).on(\"dragOriginEnd\", e => {\n*     console.log(e);\n* });\n*/\n\n/**\n* When drag end the origin, the `dragOriginEnd` event is called.\n* @memberof Moveable.OriginDraggable\n* @event dragOriginEnd\n* @param {Moveable.OriginDraggable.OnDragOriginEnd} - Parameters for the `dragOriginEnd` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     originDraggable: true,\n* });\n* let translate = [0, 0];\n* moveable.on(\"dragOriginStart\", e => {\n*     e.dragStart && e.dragStart.set(translate);\n* }).on(\"dragOrigin\", e => {\n*     translate = e.drag.beforeTranslate;\n*     e.target.style.cssText\n*         = `transform-origin: ${e.transformOrigin};`\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n* }).on(\"dragOriginEnd\", e => {\n*     console.log(e);\n* });\n*/\n", "import {\n    prefix, triggerEvent,\n    fillParams, fillEndParams, calculatePosition,\n    fillCSSObject,\n    catchEvent,\n    getComputedStyle,\n} from \"../utils\";\nimport {\n    Renderer, RoundableProps, OnRoundStart,\n    RoundableState, OnRound, ControlPose, OnRoundEnd,\n    MoveableManagerInterface,\n    OnRoundGroup,\n    MoveableGroupInterface,\n    OnRoundGroupStart,\n    OnRoundGroupEnd,\n} from \"../types\";\nimport { splitSpace } from \"@daybrush/utils\";\nimport { setDragStart, getDragDist, calculatePointerDist } from \"../gesto/GestoUtils\";\nimport { minus, plus } from \"@scena/matrix\";\nimport {\n    getRadiusValues,\n    getRadiusStyles,\n    splitRadiusPoses,\n} from \"./roundable/borderRadius\";\nimport { fillChildEvents } from \"../groupUtils\";\n\n\nfunction addBorderRadiusByLine(\n    controlPoses: ControlPose[],\n    lineIndex: number,\n    distX: number,\n    distY: number,\n) {\n    // lineIndex\n    // 0 top\n    // 1 right\n    // 2 bottom\n    // 3 left\n\n    const horizontalsLength = controlPoses.filter(({ virtual, horizontal }) => horizontal && !virtual).length;\n    const verticalsLength = controlPoses.filter(({ virtual, vertical }) => vertical && !virtual).length;\n    let controlIndex = -1;\n\n    //top\n    if (lineIndex === 0) {\n        if (horizontalsLength === 0) {\n            controlIndex = 0;\n        } else if (horizontalsLength === 1) {\n            controlIndex = 1;\n        }\n    }\n    // bottom\n    if (lineIndex === 2) {\n        if (horizontalsLength <= 2) {\n            controlIndex = 2;\n        } else if (horizontalsLength <= 3) {\n            controlIndex = 3;\n        }\n    }\n    // left\n    if (lineIndex === 3) {\n        if (verticalsLength === 0) {\n            controlIndex = 4;\n        } else if (verticalsLength < 4) {\n            controlIndex = 7;\n        }\n    }\n\n    // right\n    if (lineIndex === 1) {\n        if (verticalsLength <= 1) {\n            controlIndex = 5;\n        } else if (verticalsLength <= 2) {\n            controlIndex = 6;\n        }\n    }\n    if (controlIndex === -1 || !controlPoses[controlIndex].virtual) {\n        return;\n    }\n    const controlPoseInfo = controlPoses[controlIndex];\n\n    addBorderRadius(controlPoses, controlIndex);\n\n    if (controlIndex < 4) {\n        controlPoseInfo.pos[0] = distX;\n    } else {\n        controlPoseInfo.pos[1] = distY;\n    }\n}\nfunction addBorderRadius(\n    controlPoses: ControlPose[],\n    index: number,\n) {\n    if (index < 4) {\n        controlPoses.slice(0, index + 1).forEach(info => {\n            info.virtual = false;\n        });\n    } else {\n        if (controlPoses[0].virtual) {\n            controlPoses[0].virtual = false;\n        }\n        controlPoses.slice(4, index + 1).forEach(info => {\n            info.virtual = false;\n        });\n    }\n}\nfunction removeBorderRadius(\n    controlPoses: ControlPose[],\n    index: number,\n) {\n    if (index < 4) {\n        controlPoses.slice(index, 4).forEach(info => {\n            info.virtual = true;\n        });\n    } else {\n        controlPoses.slice(index).forEach(info => {\n            info.virtual = true;\n        });\n    }\n}\nfunction getBorderRadius(\n    borderRadius: string,\n    width: number,\n    height: number,\n    minCounts: number[] = [0, 0],\n    full?: boolean,\n) {\n    let values: string[] = [];\n\n    if (!borderRadius || borderRadius === \"0px\") {\n        values = [];\n    } else {\n        values = splitSpace(borderRadius);\n    }\n\n    return getRadiusValues(values, width, height, 0, 0, minCounts, full);\n}\n\nfunction triggerRoundEvent(\n    moveable: MoveableManagerInterface<RoundableProps, RoundableState>,\n    e: any,\n    dist: number[],\n    delta: number[],\n    nextPoses: ControlPose[],\n) {\n    const state = moveable.state;\n    const {\n        width,\n        height,\n    } = state;\n    const {\n        raws,\n        styles,\n        radiusPoses,\n    } = getRadiusStyles(\n        nextPoses,\n        moveable.props.roundRelative!,\n        width,\n        height,\n    );\n    const {\n        horizontals,\n        verticals,\n    } = splitRadiusPoses(radiusPoses, raws);\n    const borderRadius = styles.join(\" \");\n\n    state.borderRadiusState = borderRadius;\n    const params = fillParams<OnRound>(moveable, e, {\n        horizontals,\n        verticals,\n        borderRadius,\n        width,\n        height,\n        delta,\n        dist,\n        ...fillCSSObject({\n            borderRadius,\n        }, e),\n    });\n    triggerEvent(moveable, \"onRound\", params);\n\n    return params;\n}\n\n\nfunction getStyleBorderRadius(moveable: MoveableManagerInterface<RoundableProps, RoundableState>) {\n    const {\n        style,\n    } = moveable.getState();\n    let borderRadius = style.borderRadius || \"\";\n\n    if (!borderRadius && moveable.props.groupable) {\n        const firstMoveable = moveable.moveables![0];\n        const firstTarget = moveable.getTargets()[0];\n\n\n        if (firstTarget) {\n            if (firstMoveable?.props.target === firstTarget) {\n                borderRadius = moveable.moveables![0]?.state.style.borderRadius ?? \"\";\n                style.borderRadius = borderRadius;\n            } else {\n                borderRadius = getComputedStyle(firstTarget).borderRadius;\n                style.borderRadius = borderRadius;\n            }\n        }\n\n    }\n    return borderRadius;\n}\n\n/**\n * @namespace Moveable.Roundable\n * @description Whether to show and drag or double click border-radius\n */\n\nexport default {\n    name: \"roundable\",\n    props: [\n        \"roundable\",\n        \"roundRelative\",\n        \"minRoundControls\",\n        \"maxRoundControls\",\n        \"roundClickable\",\n        \"roundPadding\",\n        \"isDisplayShadowRoundControls\",\n    ] as const,\n    events: [\n        \"roundStart\",\n        \"round\",\n        \"roundEnd\",\n        \"roundGroupStart\",\n        \"roundGroup\",\n        \"roundGroupEnd\",\n    ] as const,\n    css: [\n        `.control.border-radius {\nbackground: #d66;\ncursor: pointer;\nz-index: 3;\n}`,\n        `.control.border-radius.vertical {\nbackground: #d6d;\nz-index: 2;\n}`,\n        `.control.border-radius.virtual {\nopacity: 0.5;\nz-index: 1;\n}`,\n        `:host.round-line-clickable .line.direction {\ncursor: pointer;\n}`,\n    ],\n    className(moveable: MoveableManagerInterface<RoundableProps, RoundableState>) {\n        const roundClickable = moveable.props.roundClickable;\n\n        return roundClickable === true || roundClickable === \"line\" ? prefix(\"round-line-clickable\") : \"\";\n    },\n    requestStyle(): Array<keyof CSSStyleDeclaration> {\n        return [\"borderRadius\"];\n    },\n    requestChildStyle(): Array<keyof CSSStyleDeclaration> {\n        return [\"borderRadius\"];\n    },\n    render(moveable: MoveableManagerInterface<RoundableProps, RoundableState>, React: Renderer): any {\n        const {\n            target,\n            width,\n            height,\n            allMatrix,\n            is3d,\n            left,\n            top,\n            borderRadiusState,\n        } = moveable.getState();\n\n        const {\n            minRoundControls = [0, 0],\n            maxRoundControls = [4, 4],\n            zoom,\n            roundPadding = 0,\n            isDisplayShadowRoundControls,\n            groupable,\n        } = moveable.props;\n\n        if (!target) {\n            return null;\n        }\n\n        const borderRadius = borderRadiusState || getStyleBorderRadius(moveable);\n        const n = is3d ? 4 : 3;\n        const radiusValues = getBorderRadius(\n            borderRadius,\n            width, height,\n            minRoundControls,\n            true,\n        );\n\n        if (!radiusValues) {\n            return null;\n        }\n        let verticalCount = 0;\n        let horizontalCount = 0;\n        const basePos = groupable ? [0, 0] : [left, top];\n\n        return radiusValues.map((v, i) => {\n            const horizontal = v.horizontal;\n            const vertical = v.vertical;\n            const direction = v.direction || \"\";\n            const originalPos = [...v.pos];\n\n            horizontalCount += Math.abs(horizontal);\n            verticalCount += Math.abs(vertical);\n\n\n            if (horizontal && direction.indexOf(\"n\") > -1) {\n                originalPos[1] -= roundPadding;\n            }\n            if (vertical && direction.indexOf(\"w\") > -1) {\n                originalPos[0] -= roundPadding;\n            }\n            if (horizontal && direction.indexOf(\"s\") > -1) {\n                originalPos[1] += roundPadding;\n            }\n            if (vertical && direction.indexOf(\"e\") > -1) {\n                originalPos[0] += roundPadding;\n            }\n            const pos = minus(calculatePosition(allMatrix, originalPos, n), basePos);\n            const isDisplayVerticalShadow\n                = isDisplayShadowRoundControls\n                && isDisplayShadowRoundControls !== \"horizontal\";\n            const isDisplay = v.vertical\n                ? verticalCount <= maxRoundControls[1] && (isDisplayVerticalShadow || !v.virtual)\n                : horizontalCount <= maxRoundControls[0] && (isDisplayShadowRoundControls || !v.virtual);\n\n            return <div key={`borderRadiusControl${i}`}\n                className={prefix(\n                    \"control\", \"border-radius\",\n                    v.vertical ? \"vertical\" : \"\",\n                    v.virtual ? \"virtual\" : \"\",\n                )}\n                data-radius-index={i}\n                style={{\n                    display: isDisplay ? \"block\" : \"none\",\n                    transform: `translate(${pos[0]}px, ${pos[1]}px) scale(${zoom})`,\n                }}></div>;\n        });\n    },\n    dragControlCondition(moveable: any, e: any) {\n        if (!e.inputEvent || e.isRequest) {\n            return false;\n        }\n        const className = (e.inputEvent.target.getAttribute(\"class\") || \"\");\n\n        return className.indexOf(\"border-radius\") > -1\n            || (className.indexOf(\"moveable-line\") > -1 && className.indexOf(\"moveable-direction\") > -1);\n    },\n    dragGroupControlCondition(moveable: any, e: any) {\n        return this.dragControlCondition(moveable, e);\n    },\n    dragControlStart(moveable: MoveableManagerInterface<RoundableProps, RoundableState>, e: any) {\n        const { inputEvent, datas } = e;\n        const inputTarget = inputEvent.target;\n        const className = (inputTarget.getAttribute(\"class\") || \"\");\n        const isControl = className.indexOf(\"border-radius\") > -1;\n        const isLine = className.indexOf(\"moveable-line\") > -1 && className.indexOf(\"moveable-direction\") > -1;\n        const controlIndex = isControl ? parseInt(inputTarget.getAttribute(\"data-radius-index\"), 10) : -1;\n        let lineIndex = -1;\n\n        if (isLine) {\n            const indexAttr = inputTarget.getAttribute(\"data-line-key\")! || \"\";\n\n            if (indexAttr) {\n                lineIndex = parseInt(indexAttr.replace(/render-line-/g, \"\"), 10);\n\n                if (isNaN(lineIndex)) {\n                    lineIndex = -1;\n                }\n            }\n        }\n\n        if (!isControl && !isLine) {\n            return false;\n        }\n\n        const params = fillParams<OnRoundStart>(moveable, e, {});\n\n        const result = triggerEvent(\n            moveable, \"onRoundStart\", params);\n\n        if (result === false) {\n            return false;\n        }\n\n        datas.lineIndex = lineIndex;\n        datas.controlIndex = controlIndex;\n        datas.isControl = isControl;\n        datas.isLine = isLine;\n\n        setDragStart(moveable, e);\n\n        const {\n            roundRelative,\n            minRoundControls = [0, 0],\n        } = moveable.props;\n        const state = moveable.state;\n        const {\n            width,\n            height,\n        } = state;\n\n        datas.isRound = true;\n        datas.prevDist = [0, 0];\n        const borderRadius = getStyleBorderRadius(moveable);\n        const controlPoses = getBorderRadius(\n            borderRadius || \"\",\n            width,\n            height,\n            minRoundControls,\n            true,\n        ) || [];\n\n        datas.controlPoses = controlPoses;\n\n        state.borderRadiusState = getRadiusStyles(\n            controlPoses,\n            roundRelative!,\n            width,\n            height,\n        ).styles.join(\" \");\n        return params;\n    },\n    dragControl(moveable: MoveableManagerInterface<RoundableProps, RoundableState>, e: any) {\n        const { datas } = e;\n        const controlPoses = datas.controlPoses as ControlPose[];\n\n        if (!datas.isRound || !datas.isControl || !controlPoses.length) {\n            return false;\n        }\n        const index = datas.controlIndex as number;\n\n        const [distX, distY] = getDragDist(e);\n        const dist = [distX, distY];\n        const delta = minus(dist, datas.prevDist);\n        const {\n            maxRoundControls = [4, 4],\n        } = moveable.props;\n        const { width, height } = moveable.state;\n        const selectedControlPose = controlPoses[index];\n\n        const selectedVertical = selectedControlPose.vertical;\n        const selectedHorizontal = selectedControlPose.horizontal;\n\n        // 0: [0, 1, 2, 3] maxCount === 1\n        // 0: [0, 2] maxCount === 2\n        // 1: [1, 3] maxCount === 2\n\n        // 0: [0] maxCount === 3\n        // 1: [1, 3] maxCount === 3\n\n        const dists = controlPoses.map(pose => {\n            const { horizontal, vertical } = pose;\n            const poseDist = [\n                horizontal * selectedHorizontal * dist[0],\n                vertical * selectedVertical * dist[1],\n            ];\n            if (horizontal) {\n                if (maxRoundControls[0] === 1) {\n                    return poseDist;\n                } else if (maxRoundControls[0] < 4 && horizontal !== selectedHorizontal) {\n                    return poseDist;\n                }\n            } else if (maxRoundControls[1] === 0) {\n                poseDist[1] = vertical * selectedHorizontal * dist[0] / width * height;\n\n                return poseDist;\n            } else if (selectedVertical) {\n                if (maxRoundControls[1] === 1) {\n                    return poseDist;\n                } else if (maxRoundControls[1] < 4 && vertical !== selectedVertical) {\n                    return poseDist;\n                }\n            }\n            return [0, 0];\n        });\n\n        dists[index] = dist;\n        const nextPoses = controlPoses.map((info, i) => {\n            return {\n                ...info,\n                pos: plus(info.pos, dists[i]),\n            };\n        });\n\n        if (index < 4) {\n            nextPoses.slice(0, index + 1).forEach(info => {\n                info.virtual = false;\n            });\n        } else {\n            nextPoses.slice(4, index + 1).forEach(info => {\n                info.virtual = false;\n            });\n        }\n\n        datas.prevDist = [distX, distY];\n\n        return triggerRoundEvent(\n            moveable,\n            e,\n            dist,\n            delta,\n            nextPoses,\n        );\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<RoundableProps, RoundableState>, e: any) {\n        const state = moveable.state;\n\n        state.borderRadiusState = \"\";\n        const { datas, isDouble } = e;\n        if (!datas.isRound) {\n            return false;\n        }\n        const {\n            isControl,\n            controlIndex,\n            isLine,\n            lineIndex,\n        } = datas;\n        const controlPoses = datas.controlPoses as ControlPose[];\n        const length = controlPoses.filter(({ virtual }) => virtual).length;\n        const {\n            roundClickable = true,\n        } = moveable.props;\n\n        if (isDouble && roundClickable) {\n            if (isControl && (roundClickable === true || roundClickable === \"control\")) {\n                removeBorderRadius(controlPoses, controlIndex);\n            } else if (isLine && (roundClickable === true || roundClickable === \"line\")) {\n                const [distX, distY] = calculatePointerDist(moveable, e);\n\n                addBorderRadiusByLine(controlPoses, lineIndex, distX, distY);\n            }\n\n            if (length !== controlPoses.filter(({ virtual }) => virtual).length) {\n                triggerRoundEvent(\n                    moveable,\n                    e,\n                    [0, 0],\n                    [0, 0],\n                    controlPoses,\n                );\n            }\n        }\n        const params = fillEndParams<OnRoundEnd>(moveable, e, {});\n\n        triggerEvent(moveable, \"onRoundEnd\", params);\n        state.borderRadiusState = \"\";\n        return params;\n    },\n    dragGroupControlStart(moveable: MoveableGroupInterface<RoundableProps, RoundableState>, e: any) {\n        const result = this.dragControlStart(moveable, e);\n\n        if (!result) {\n            return false;\n        }\n\n        const moveables = moveable.moveables;\n        const targets = moveable.props.targets!;\n        const events = fillChildEvents(moveable, \"roundable\", e);\n\n        const nextParams: OnRoundGroupStart = {\n            targets: moveable.props.targets!,\n            events: events.map((ev, i) => {\n                return {\n                    ...ev,\n                    target: targets[i],\n                    moveable: moveables[i],\n                    currentTarget: moveables[i],\n                };\n            }),\n            ...result,\n        };\n\n        triggerEvent(moveable, \"onRoundGroupStart\", nextParams);\n        return result;\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<RoundableProps, RoundableState>, e: any) {\n        const result = this.dragControl(moveable, e);\n\n\n        if (!result) {\n            return false;\n        }\n\n        const moveables = moveable.moveables;\n        const targets = moveable.props.targets!;\n        const events = fillChildEvents(moveable, \"roundable\", e);\n\n        const nextParams: OnRoundGroup = {\n            targets: moveable.props.targets!,\n            events: events.map((ev, i) => {\n                return {\n                    ...ev,\n                    target: targets[i],\n                    moveable: moveables[i],\n                    currentTarget: moveables[i],\n                    ...fillCSSObject({\n                        borderRadius: result.borderRadius,\n                    }, ev),\n                };\n            }),\n            ...result,\n        };\n\n        triggerEvent(moveable, \"onRoundGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<RoundableProps, RoundableState>, e: any) {\n        const moveables = moveable.moveables;\n        const targets = moveable.props.targets!;\n        const events = fillChildEvents(moveable, \"roundable\", e);\n\n        catchEvent(moveable, \"onRound\", parentEvent => {\n            const nextParams: OnRoundGroup = {\n                targets: moveable.props.targets!,\n                events: events.map((ev, i) => {\n                    return {\n                        ...ev,\n                        target: targets[i],\n                        moveable: moveables[i],\n                        currentTarget: moveables[i],\n                        ...fillCSSObject({\n                            borderRadius: parentEvent.borderRadius,\n                        }, ev),\n                    };\n                }),\n                ...parentEvent,\n            };\n            triggerEvent(moveable, \"onRoundGroup\", nextParams);\n        });\n        const result = this.dragControlEnd(moveable, e);\n\n        if (!result) {\n            return false;\n        }\n        const nextParams: OnRoundGroupEnd = {\n            targets: moveable.props.targets!,\n            events: events.map((ev, i) => {\n                return {\n                    ...ev,\n                    target: targets[i],\n                    moveable: moveables[i],\n                    currentTarget: moveables[i],\n                    lastEvent: ev.datas?.lastEvent,\n                };\n            }),\n            ...result,\n        };\n\n        triggerEvent(moveable, \"onRoundGroupEnd\", nextParams);\n        return nextParams;\n    },\n    unset(moveable: MoveableManagerInterface<RoundableProps, RoundableState>) {\n        moveable.state.borderRadiusState = \"\";\n    },\n};\n/**\n * Whether to show and drag or double click border-radius, (default: false)\n * @name Moveable.Roundable#roundable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * % Can be used instead of the absolute px\n * @name Moveable.Roundable#roundRelative\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * Minimum number of round controls. It moves in proportion by control. [horizontal, vertical] (default: [0, 0])\n * @name Moveable.Roundable#minRoundControls\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n *     minRoundControls: [0, 0],\n * });\n * moveable.minRoundControls = [1, 0];\n */\n/**\n * Maximum number of round controls. It moves in proportion by control. [horizontal, vertical] (default: [4, 4])\n * @name Moveable.Roundable#maxRoundControls\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n *     maxRoundControls: [4, 4],\n * });\n * moveable.maxRoundControls = [1, 0];\n */\n/**\n * Whether you can add/delete round controls by double-clicking a line or control.\n * @name Moveable.Roundable#roundClickable\n * @default true\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n *     roundClickable: true,\n * });\n * moveable.roundClickable = false;\n */\n\n/**\n * Whether to show a round control that does not actually exist as a shadow\n * @name Moveable.Roundable#isDisplayShadowRoundControls\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     isDisplayShadowRoundControls: false,\n * });\n * moveable.isDisplayShadowRoundControls = true;\n */\n\n\n/**\n * The padding value of the position of the round control\n * @name Moveable.Roundable#roundPadding\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundPadding: 0,\n * });\n * moveable.roundPadding = 15;\n */\n\n/**\n * When drag start the clip area or controls, the `roundStart` event is called.\n * @memberof Moveable.Roundable\n * @event roundStart\n * @param {Moveable.Roundable.OnRoundStart} - Parameters for the `roundStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n\n\n/**\n * When drag or double click the border area or controls, the `round` event is called.\n * @memberof Moveable.Roundable\n * @event round\n * @param {Moveable.Roundable.OnRound} - Parameters for the `round` event\n * @example\n  * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n\n\n/**\n * When drag end the border area or controls, the `roundEnd` event is called.\n * @memberof Moveable.Roundable\n * @event roundEnd\n * @param {Moveable.Roundable.onRoundEnd} - Parameters for the `roundEnd` event\n * @example\n  * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n\n\n/**\n * When drag start the clip area or controls, the `roundGroupStart` event is called.\n * @memberof Moveable.Roundable\n * @event roundGroupStart\n * @param {Moveable.Roundable.OnRoundGroupStart} - Parameters for the `roundGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     targets: [target1, target2, target3],\n *     roundable: true,\n * });\n * moveable.on(\"roundGroupStart\", e => {\n *     console.log(e.targets);\n * }).on(\"roundGroup\", e => {\n *   e.events.forEach(ev => {\n *       ev.target.style.cssText += ev.cssText;\n *   });\n * }).on(\"roundGroupEnd\", e => {\n *     console.log(e);\n * });\n */\n\n\n/**\n * When drag or double click the border area or controls, the `roundGroup` event is called.\n * @memberof Moveable.Roundable\n * @event roundGroup\n * @param {Moveable.Roundable.OnRoundGroup} - Parameters for the `roundGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     targets: [target1, target2, target3],\n *     roundable: true,\n * });\n * moveable.on(\"roundGroupStart\", e => {\n *     console.log(e.targets);\n * }).on(\"roundGroup\", e => {\n *   e.events.forEach(ev => {\n *       ev.target.style.cssText += ev.cssText;\n *   });\n * }).on(\"roundGroupEnd\", e => {\n *     console.log(e);\n * });\n */\n\n\n/**\n * When drag end the border area or controls, the `roundGroupEnd` event is called.\n * @memberof Moveable.Roundable\n * @event roundGroupEnd\n * @param {Moveable.Roundable.onRoundGroupEnd} - Parameters for the `roundGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     targets: [target1, target2, target3],\n *     roundable: true,\n * });\n * moveable.on(\"roundGroupStart\", e => {\n *     console.log(e.targets);\n * }).on(\"roundGroup\", e => {\n *     e.events.forEach(ev => {\n *         ev.target.style.cssText += ev.cssText;\n *     });\n * }).on(\"roundGroupEnd\", e => {\n *     console.log(e);\n * });\n */\n", "/*\nCopyright (c) 2019 Daybrush\nname: gesto\nlicense: MIT\nauthor: Daybrush\nrepository: git+https://github.com/daybrush/gesto.git\nversion: 1.19.4\n*/\nimport EventEmitter from '@scena/event-emitter';\nimport { removeEvent, addEvent, now, isWindow, getWindow } from '@daybrush/utils';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\n\nfunction getRad(pos1, pos2) {\n    var distX = pos2[0] - pos1[0];\n    var distY = pos2[1] - pos1[1];\n    var rad = Math.atan2(distY, distX);\n    return rad >= 0 ? rad : rad + Math.PI * 2;\n}\nfunction getRotatiion(touches) {\n    return getRad([\n        touches[0].clientX,\n        touches[0].clientY,\n    ], [\n        touches[1].clientX,\n        touches[1].clientY,\n    ]) / Math.PI * 180;\n}\nfunction isMultiTouch(e) {\n    return e.touches && e.touches.length >= 2;\n}\nfunction getEventClients(e) {\n    if (!e) {\n        return [];\n    }\n    if (e.touches) {\n        return getClients(e.touches);\n    }\n    else {\n        return [getClient(e)];\n    }\n}\nfunction isMouseEvent(e) {\n    return e && (e.type.indexOf(\"mouse\") > -1 || \"button\" in e);\n}\nfunction getPosition(clients, prevClients, startClients) {\n    var length = startClients.length;\n    var _a = getAverageClient(clients, length), clientX = _a.clientX, clientY = _a.clientY, originalClientX = _a.originalClientX, originalClientY = _a.originalClientY;\n    var _b = getAverageClient(prevClients, length), prevX = _b.clientX, prevY = _b.clientY;\n    var _c = getAverageClient(startClients, length), startX = _c.clientX, startY = _c.clientY;\n    var deltaX = clientX - prevX;\n    var deltaY = clientY - prevY;\n    var distX = clientX - startX;\n    var distY = clientY - startY;\n    return {\n        clientX: originalClientX,\n        clientY: originalClientY,\n        deltaX: deltaX,\n        deltaY: deltaY,\n        distX: distX,\n        distY: distY,\n    };\n}\nfunction getDist(clients) {\n    return Math.sqrt(Math.pow(clients[0].clientX - clients[1].clientX, 2)\n        + Math.pow(clients[0].clientY - clients[1].clientY, 2));\n}\nfunction getClients(touches) {\n    var length = Math.min(touches.length, 2);\n    var clients = [];\n    for (var i = 0; i < length; ++i) {\n        clients.push(getClient(touches[i]));\n    }\n    return clients;\n}\nfunction getClient(e) {\n    return {\n        clientX: e.clientX,\n        clientY: e.clientY,\n    };\n}\nfunction getAverageClient(clients, length) {\n    if (length === void 0) { length = clients.length; }\n    var sumClient = {\n        clientX: 0,\n        clientY: 0,\n        originalClientX: 0,\n        originalClientY: 0,\n    };\n    var minLength = Math.min(clients.length, length);\n    for (var i = 0; i < minLength; ++i) {\n        var client = clients[i];\n        sumClient.originalClientX += \"originalClientX\" in client ? client.originalClientX : client.clientX;\n        sumClient.originalClientY += \"originalClientY\" in client ? client.originalClientY : client.clientY;\n        sumClient.clientX += client.clientX;\n        sumClient.clientY += client.clientY;\n    }\n    if (!length) {\n        return sumClient;\n    }\n    return {\n        clientX: sumClient.clientX / length,\n        clientY: sumClient.clientY / length,\n        originalClientX: sumClient.originalClientX / length,\n        originalClientY: sumClient.originalClientY / length,\n    };\n}\n\nvar ClientStore = /*#__PURE__*/ (function () {\n    function ClientStore(clients) {\n        this.prevClients = [];\n        this.startClients = [];\n        this.movement = 0;\n        this.length = 0;\n        this.startClients = clients;\n        this.prevClients = clients;\n        this.length = clients.length;\n    }\n    ClientStore.prototype.getAngle = function (clients) {\n        if (clients === void 0) { clients = this.prevClients; }\n        return getRotatiion(clients);\n    };\n    ClientStore.prototype.getRotation = function (clients) {\n        if (clients === void 0) { clients = this.prevClients; }\n        return getRotatiion(clients) - getRotatiion(this.startClients);\n    };\n    ClientStore.prototype.getPosition = function (clients, isAdd) {\n        if (clients === void 0) { clients = this.prevClients; }\n        var position = getPosition(clients || this.prevClients, this.prevClients, this.startClients);\n        var deltaX = position.deltaX, deltaY = position.deltaY;\n        this.movement += Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n        this.prevClients = clients;\n        return position;\n    };\n    ClientStore.prototype.getPositions = function (clients) {\n        if (clients === void 0) { clients = this.prevClients; }\n        var prevClients = this.prevClients;\n        var startClients = this.startClients;\n        var minLength = Math.min(this.length, prevClients.length);\n        var positions = [];\n        for (var i = 0; i < minLength; ++i) {\n            positions[i] = getPosition([clients[i]], [prevClients[i]], [startClients[i]]);\n        }\n        return positions;\n    };\n    ClientStore.prototype.getMovement = function (clients) {\n        var movement = this.movement;\n        if (!clients) {\n            return movement;\n        }\n        var currentClient = getAverageClient(clients, this.length);\n        var prevClient = getAverageClient(this.prevClients, this.length);\n        var deltaX = currentClient.clientX - prevClient.clientX;\n        var deltaY = currentClient.clientY - prevClient.clientY;\n        return Math.sqrt(deltaX * deltaX + deltaY * deltaY) + movement;\n    };\n    ClientStore.prototype.getDistance = function (clients) {\n        if (clients === void 0) { clients = this.prevClients; }\n        return getDist(clients);\n    };\n    ClientStore.prototype.getScale = function (clients) {\n        if (clients === void 0) { clients = this.prevClients; }\n        return getDist(clients) / getDist(this.startClients);\n    };\n    ClientStore.prototype.move = function (deltaX, deltaY) {\n        this.startClients.forEach(function (client) {\n            client.clientX -= deltaX;\n            client.clientY -= deltaY;\n        });\n        this.prevClients.forEach(function (client) {\n            client.clientX -= deltaX;\n            client.clientY -= deltaY;\n        });\n    };\n    return ClientStore;\n}());\n\nvar INPUT_TAGNAMES = [\"textarea\", \"input\"];\n/**\n * You can set up drag, pinch events in any browser.\n */\nvar Gesto = /*#__PURE__*/ (function (_super) {\n    __extends(Gesto, _super);\n    /**\n     *\n     */\n    function Gesto(targets, options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this) || this;\n        _this.options = {};\n        _this.flag = false;\n        _this.pinchFlag = false;\n        _this.data = {};\n        _this.isDrag = false;\n        _this.isPinch = false;\n        _this.clientStores = [];\n        _this.targets = [];\n        _this.prevTime = 0;\n        _this.doubleFlag = false;\n        _this._useMouse = false;\n        _this._useTouch = false;\n        _this._useDrag = false;\n        _this._dragFlag = false;\n        _this._isTrusted = false;\n        _this._isMouseEvent = false;\n        _this._isSecondaryButton = false;\n        _this._preventMouseEvent = false;\n        _this._prevInputEvent = null;\n        _this._isDragAPI = false;\n        _this._isIdle = true;\n        _this._preventMouseEventId = 0;\n        _this._window = window;\n        _this.onDragStart = function (e, isTrusted) {\n            if (isTrusted === void 0) { isTrusted = true; }\n            if (!_this.flag && e.cancelable === false) {\n                return;\n            }\n            var isDragAPI = e.type.indexOf(\"drag\") >= -1;\n            if (_this.flag && isDragAPI) {\n                return;\n            }\n            _this._isDragAPI = true;\n            var _a = _this.options, container = _a.container, pinchOutside = _a.pinchOutside, preventWheelClick = _a.preventWheelClick, preventRightClick = _a.preventRightClick, preventDefault = _a.preventDefault, checkInput = _a.checkInput, dragFocusedInput = _a.dragFocusedInput, preventClickEventOnDragStart = _a.preventClickEventOnDragStart, preventClickEventOnDrag = _a.preventClickEventOnDrag, preventClickEventByCondition = _a.preventClickEventByCondition;\n            var useTouch = _this._useTouch;\n            var isDragStart = !_this.flag;\n            _this._isSecondaryButton = e.which === 3 || e.button === 2;\n            if ((preventWheelClick && (e.which === 2 || e.button === 1))\n                || (preventRightClick && (e.which === 3 || e.button === 2))) {\n                _this.stop();\n                return false;\n            }\n            if (isDragStart) {\n                var activeElement = _this._window.document.activeElement;\n                var target = e.target;\n                if (target) {\n                    var tagName = target.tagName.toLowerCase();\n                    var hasInput = INPUT_TAGNAMES.indexOf(tagName) > -1;\n                    var hasContentEditable = target.isContentEditable;\n                    if (hasInput || hasContentEditable) {\n                        if (checkInput || (!dragFocusedInput && activeElement === target)) {\n                            // force false or already focused.\n                            return false;\n                        }\n                        // no focus\n                        if (activeElement && (activeElement === target\n                            || (hasContentEditable && activeElement.isContentEditable && activeElement.contains(target)))) {\n                            if (dragFocusedInput) {\n                                target.blur();\n                            }\n                            else {\n                                return false;\n                            }\n                        }\n                    }\n                    else if ((preventDefault || e.type === \"touchstart\") && activeElement) {\n                        var activeTagName = activeElement.tagName.toLowerCase();\n                        if (activeElement.isContentEditable || INPUT_TAGNAMES.indexOf(activeTagName) > -1) {\n                            activeElement.blur();\n                        }\n                    }\n                    if (preventClickEventOnDragStart || preventClickEventOnDrag || preventClickEventByCondition) {\n                        addEvent(_this._window, \"click\", _this._onClick, true);\n                    }\n                }\n                _this.clientStores = [new ClientStore(getEventClients(e))];\n                _this._isIdle = false;\n                _this.flag = true;\n                _this.isDrag = false;\n                _this._isTrusted = isTrusted;\n                _this._dragFlag = true;\n                _this._prevInputEvent = e;\n                _this.data = {};\n                _this.doubleFlag = now() - _this.prevTime < 200;\n                _this._isMouseEvent = isMouseEvent(e);\n                if (!_this._isMouseEvent && _this._preventMouseEvent) {\n                    _this._allowMouseEvent();\n                }\n                var result = _this._preventMouseEvent || _this.emit(\"dragStart\", __assign(__assign({ data: _this.data, datas: _this.data, inputEvent: e, isMouseEvent: _this._isMouseEvent, isSecondaryButton: _this._isSecondaryButton, isTrusted: isTrusted, isDouble: _this.doubleFlag }, _this.getCurrentStore().getPosition()), { preventDefault: function () {\n                        e.preventDefault();\n                    }, preventDrag: function () {\n                        _this._dragFlag = false;\n                    } }));\n                if (result === false) {\n                    _this.stop();\n                }\n                if (_this._isMouseEvent && _this.flag && preventDefault) {\n                    e.preventDefault();\n                }\n            }\n            if (!_this.flag) {\n                return false;\n            }\n            var timer = 0;\n            if (isDragStart) {\n                _this._attchDragEvent();\n                // wait pinch\n                if (useTouch && pinchOutside) {\n                    timer = setTimeout(function () {\n                        addEvent(container, \"touchstart\", _this.onDragStart, {\n                            passive: false\n                        });\n                    });\n                }\n            }\n            else if (useTouch && pinchOutside) {\n                // pinch is occured\n                removeEvent(container, \"touchstart\", _this.onDragStart);\n            }\n            if (_this.flag && isMultiTouch(e)) {\n                clearTimeout(timer);\n                if (isDragStart && (e.touches.length !== e.changedTouches.length)) {\n                    return;\n                }\n                if (!_this.pinchFlag) {\n                    _this.onPinchStart(e);\n                }\n            }\n        };\n        _this.onDrag = function (e, isScroll) {\n            if (!_this.flag) {\n                return;\n            }\n            var preventDefault = _this.options.preventDefault;\n            if (!_this._isMouseEvent && preventDefault) {\n                e.preventDefault();\n            }\n            _this._prevInputEvent = e;\n            var clients = getEventClients(e);\n            var result = _this.moveClients(clients, e, false);\n            if (_this._dragFlag) {\n                if (_this.pinchFlag || result.deltaX || result.deltaY) {\n                    var dragResult = _this._preventMouseEvent || _this.emit(\"drag\", __assign(__assign({}, result), { isScroll: !!isScroll, inputEvent: e }));\n                    if (dragResult === false) {\n                        _this.stop();\n                        return;\n                    }\n                }\n                if (_this.pinchFlag) {\n                    _this.onPinch(e, clients);\n                }\n            }\n            _this.getCurrentStore().getPosition(clients, true);\n        };\n        _this.onDragEnd = function (e) {\n            if (!_this.flag) {\n                return;\n            }\n            var _a = _this.options, pinchOutside = _a.pinchOutside, container = _a.container, preventClickEventOnDrag = _a.preventClickEventOnDrag, preventClickEventOnDragStart = _a.preventClickEventOnDragStart, preventClickEventByCondition = _a.preventClickEventByCondition;\n            var isDrag = _this.isDrag;\n            if (preventClickEventOnDrag || preventClickEventOnDragStart || preventClickEventByCondition) {\n                requestAnimationFrame(function () {\n                    _this._allowClickEvent();\n                });\n            }\n            if (!preventClickEventByCondition && !preventClickEventOnDragStart && preventClickEventOnDrag && !isDrag) {\n                _this._allowClickEvent();\n            }\n            if (_this._useTouch && pinchOutside) {\n                removeEvent(container, \"touchstart\", _this.onDragStart);\n            }\n            if (_this.pinchFlag) {\n                _this.onPinchEnd(e);\n            }\n            var clients = (e === null || e === void 0 ? void 0 : e.touches) ? getEventClients(e) : [];\n            var clientsLength = clients.length;\n            if (clientsLength === 0 || !_this.options.keepDragging) {\n                _this.flag = false;\n            }\n            else {\n                _this._addStore(new ClientStore(clients));\n            }\n            var position = _this._getPosition();\n            var currentTime = now();\n            var isDouble = !isDrag && _this.doubleFlag;\n            _this._prevInputEvent = null;\n            _this.prevTime = isDrag || isDouble ? 0 : currentTime;\n            if (!_this.flag) {\n                _this._dettachDragEvent();\n                _this._preventMouseEvent || _this.emit(\"dragEnd\", __assign({ data: _this.data, datas: _this.data, isDouble: isDouble, isDrag: isDrag, isClick: !isDrag, isMouseEvent: _this._isMouseEvent, isSecondaryButton: _this._isSecondaryButton, inputEvent: e, isTrusted: _this._isTrusted }, position));\n                _this.clientStores = [];\n                if (!_this._isMouseEvent) {\n                    _this._preventMouseEvent = true;\n                    // Prevent the problem of touch event and mouse event occurring simultaneously\n                    clearTimeout(_this._preventMouseEventId);\n                    _this._preventMouseEventId = setTimeout(function () {\n                        _this._preventMouseEvent = false;\n                    }, 200);\n                }\n                _this._isIdle = true;\n            }\n        };\n        _this.onBlur = function () {\n            _this.onDragEnd();\n        };\n        _this._allowClickEvent = function () {\n            removeEvent(_this._window, \"click\", _this._onClick, true);\n        };\n        _this._onClick = function (e) {\n            _this._allowClickEvent();\n            _this._allowMouseEvent();\n            var preventClickEventByCondition = _this.options.preventClickEventByCondition;\n            if (preventClickEventByCondition === null || preventClickEventByCondition === void 0 ? void 0 : preventClickEventByCondition(e)) {\n                return;\n            }\n            e.stopPropagation();\n            e.preventDefault();\n        };\n        _this._onContextMenu = function (e) {\n            var options = _this.options;\n            if (!options.preventRightClick) {\n                e.preventDefault();\n            }\n            else {\n                _this.onDragEnd(e);\n            }\n        };\n        _this._passCallback = function () { };\n        var elements = [].concat(targets);\n        var firstTarget = elements[0];\n        _this._window = isWindow(firstTarget) ? firstTarget : getWindow(firstTarget);\n        _this.options = __assign({ checkInput: false, container: firstTarget && !(\"document\" in firstTarget) ? getWindow(firstTarget) : firstTarget, preventRightClick: true, preventWheelClick: true, preventClickEventOnDragStart: false, preventClickEventOnDrag: false, preventClickEventByCondition: null, preventDefault: true, checkWindowBlur: false, keepDragging: false, pinchThreshold: 0, events: [\"touch\", \"mouse\"] }, options);\n        var _a = _this.options, container = _a.container, events = _a.events, checkWindowBlur = _a.checkWindowBlur;\n        _this._useDrag = events.indexOf(\"drag\") > -1;\n        _this._useTouch = events.indexOf(\"touch\") > -1;\n        _this._useMouse = events.indexOf(\"mouse\") > -1;\n        _this.targets = elements;\n        if (_this._useDrag) {\n            elements.forEach(function (el) {\n                addEvent(el, \"dragstart\", _this.onDragStart);\n            });\n        }\n        if (_this._useMouse) {\n            elements.forEach(function (el) {\n                addEvent(el, \"mousedown\", _this.onDragStart);\n                addEvent(el, \"mousemove\", _this._passCallback);\n            });\n            addEvent(container, \"contextmenu\", _this._onContextMenu);\n        }\n        if (checkWindowBlur) {\n            addEvent(getWindow(), \"blur\", _this.onBlur);\n        }\n        if (_this._useTouch) {\n            var passive_1 = {\n                passive: false,\n            };\n            elements.forEach(function (el) {\n                addEvent(el, \"touchstart\", _this.onDragStart, passive_1);\n                addEvent(el, \"touchmove\", _this._passCallback, passive_1);\n            });\n        }\n        return _this;\n    }\n    /**\n     * Stop Gesto's drag events.\n     */\n    Gesto.prototype.stop = function () {\n        this.isDrag = false;\n        this.data = {};\n        this.clientStores = [];\n        this.pinchFlag = false;\n        this.doubleFlag = false;\n        this.prevTime = 0;\n        this.flag = false;\n        this._isIdle = true;\n        this._allowClickEvent();\n        this._dettachDragEvent();\n        this._isDragAPI = false;\n    };\n    /**\n     * The total moved distance\n     */\n    Gesto.prototype.getMovement = function (clients) {\n        return this.getCurrentStore().getMovement(clients) + this.clientStores.slice(1).reduce(function (prev, cur) {\n            return prev + cur.movement;\n        }, 0);\n    };\n    /**\n     * Whether to drag\n     */\n    Gesto.prototype.isDragging = function () {\n        return this.isDrag;\n    };\n    /**\n     * Whether the operation of gesto is finished and is in idle state\n     */\n    Gesto.prototype.isIdle = function () {\n        return this._isIdle;\n    };\n    /**\n     * Whether to start drag\n     */\n    Gesto.prototype.isFlag = function () {\n        return this.flag;\n    };\n    /**\n     * Whether to start pinch\n     */\n    Gesto.prototype.isPinchFlag = function () {\n        return this.pinchFlag;\n    };\n    /**\n     * Whether to start double click\n     */\n    Gesto.prototype.isDoubleFlag = function () {\n        return this.doubleFlag;\n    };\n    /**\n     * Whether to pinch\n     */\n    Gesto.prototype.isPinching = function () {\n        return this.isPinch;\n    };\n    /**\n     * If a scroll event occurs, it is corrected by the scroll distance.\n     */\n    Gesto.prototype.scrollBy = function (deltaX, deltaY, e, isCallDrag) {\n        if (isCallDrag === void 0) { isCallDrag = true; }\n        if (!this.flag) {\n            return;\n        }\n        this.clientStores[0].move(deltaX, deltaY);\n        isCallDrag && this.onDrag(e, true);\n    };\n    /**\n     * Create a virtual drag event.\n     */\n    Gesto.prototype.move = function (_a, inputEvent) {\n        var deltaX = _a[0], deltaY = _a[1];\n        var store = this.getCurrentStore();\n        var nextClients = store.prevClients;\n        return this.moveClients(nextClients.map(function (_a) {\n            var clientX = _a.clientX, clientY = _a.clientY;\n            return {\n                clientX: clientX + deltaX,\n                clientY: clientY + deltaY,\n                originalClientX: clientX,\n                originalClientY: clientY,\n            };\n        }), inputEvent, true);\n    };\n    /**\n     * The dragStart event is triggered by an external event.\n     */\n    Gesto.prototype.triggerDragStart = function (e) {\n        this.onDragStart(e, false);\n    };\n    /**\n     * Set the event data while dragging.\n     */\n    Gesto.prototype.setEventData = function (data) {\n        var currentData = this.data;\n        for (var name_1 in data) {\n            currentData[name_1] = data[name_1];\n        }\n        return this;\n    };\n    /**\n     * Set the event data while dragging.\n     * Use `setEventData`\n     * @deprecated\n     */\n    Gesto.prototype.setEventDatas = function (data) {\n        return this.setEventData(data);\n    };\n    /**\n     * Get the current event state while dragging.\n     */\n    Gesto.prototype.getCurrentEvent = function (inputEvent) {\n        if (inputEvent === void 0) { inputEvent = this._prevInputEvent; }\n        return __assign(__assign({ data: this.data, datas: this.data }, this._getPosition()), { movement: this.getMovement(), isDrag: this.isDrag, isPinch: this.isPinch, isScroll: false, inputEvent: inputEvent });\n    };\n    /**\n     * Get & Set the event data while dragging.\n     */\n    Gesto.prototype.getEventData = function () {\n        return this.data;\n    };\n    /**\n     * Get & Set the event data while dragging.\n     * Use getEventData method\n     * @depreacated\n     */\n    Gesto.prototype.getEventDatas = function () {\n        return this.data;\n    };\n    /**\n     * Unset Gesto\n     */\n    Gesto.prototype.unset = function () {\n        var _this = this;\n        var targets = this.targets;\n        var container = this.options.container;\n        this.off();\n        removeEvent(this._window, \"blur\", this.onBlur);\n        if (this._useDrag) {\n            targets.forEach(function (el) {\n                removeEvent(el, \"dragstart\", _this.onDragStart);\n            });\n        }\n        if (this._useMouse) {\n            targets.forEach(function (target) {\n                removeEvent(target, \"mousedown\", _this.onDragStart);\n            });\n            removeEvent(container, \"contextmenu\", this._onContextMenu);\n        }\n        if (this._useTouch) {\n            targets.forEach(function (target) {\n                removeEvent(target, \"touchstart\", _this.onDragStart);\n            });\n            removeEvent(container, \"touchstart\", this.onDragStart);\n        }\n        this._prevInputEvent = null;\n        this._allowClickEvent();\n        this._dettachDragEvent();\n    };\n    Gesto.prototype.onPinchStart = function (e) {\n        var _this = this;\n        var pinchThreshold = this.options.pinchThreshold;\n        if (this.isDrag && this.getMovement() > pinchThreshold) {\n            return;\n        }\n        var store = new ClientStore(getEventClients(e));\n        this.pinchFlag = true;\n        this._addStore(store);\n        var result = this.emit(\"pinchStart\", __assign(__assign({ data: this.data, datas: this.data, angle: store.getAngle(), touches: this.getCurrentStore().getPositions() }, store.getPosition()), { inputEvent: e, isTrusted: this._isTrusted, preventDefault: function () {\n                e.preventDefault();\n            }, preventDrag: function () {\n                _this._dragFlag = false;\n            } }));\n        if (result === false) {\n            this.pinchFlag = false;\n        }\n    };\n    Gesto.prototype.onPinch = function (e, clients) {\n        if (!this.flag || !this.pinchFlag || clients.length < 2) {\n            return;\n        }\n        var store = this.getCurrentStore();\n        this.isPinch = true;\n        this.emit(\"pinch\", __assign(__assign({ data: this.data, datas: this.data, movement: this.getMovement(clients), angle: store.getAngle(clients), rotation: store.getRotation(clients), touches: store.getPositions(clients), scale: store.getScale(clients), distance: store.getDistance(clients) }, store.getPosition(clients)), { inputEvent: e, isTrusted: this._isTrusted }));\n    };\n    Gesto.prototype.onPinchEnd = function (e) {\n        if (!this.pinchFlag) {\n            return;\n        }\n        var isPinch = this.isPinch;\n        this.isPinch = false;\n        this.pinchFlag = false;\n        var store = this.getCurrentStore();\n        this.emit(\"pinchEnd\", __assign(__assign({ data: this.data, datas: this.data, isPinch: isPinch, touches: store.getPositions() }, store.getPosition()), { inputEvent: e }));\n    };\n    Gesto.prototype.getCurrentStore = function () {\n        return this.clientStores[0];\n    };\n    Gesto.prototype.moveClients = function (clients, inputEvent, isAdd) {\n        var position = this._getPosition(clients, isAdd);\n        var isPrevDrag = this.isDrag;\n        if (position.deltaX || position.deltaY) {\n            this.isDrag = true;\n        }\n        var isFirstDrag = false;\n        if (!isPrevDrag && this.isDrag) {\n            isFirstDrag = true;\n        }\n        return __assign(__assign({ data: this.data, datas: this.data }, position), { movement: this.getMovement(clients), isDrag: this.isDrag, isPinch: this.isPinch, isScroll: false, isMouseEvent: this._isMouseEvent, isSecondaryButton: this._isSecondaryButton, inputEvent: inputEvent, isTrusted: this._isTrusted, isFirstDrag: isFirstDrag });\n    };\n    Gesto.prototype._addStore = function (store) {\n        this.clientStores.splice(0, 0, store);\n    };\n    Gesto.prototype._getPosition = function (clients, isAdd) {\n        var store = this.getCurrentStore();\n        var position = store.getPosition(clients, isAdd);\n        var _a = this.clientStores.slice(1).reduce(function (prev, cur) {\n            var storePosition = cur.getPosition();\n            prev.distX += storePosition.distX;\n            prev.distY += storePosition.distY;\n            return prev;\n        }, position), distX = _a.distX, distY = _a.distY;\n        return __assign(__assign({}, position), { distX: distX, distY: distY });\n    };\n    Gesto.prototype._attchDragEvent = function () {\n        var win = this._window;\n        var container = this.options.container;\n        var passive = {\n            passive: false\n        };\n        if (this._isDragAPI) {\n            addEvent(container, \"dragover\", this.onDrag, passive);\n            addEvent(win, \"dragend\", this.onDragEnd);\n        }\n        if (this._useMouse) {\n            addEvent(container, \"mousemove\", this.onDrag);\n            addEvent(win, \"mouseup\", this.onDragEnd);\n        }\n        if (this._useTouch) {\n            addEvent(container, \"touchmove\", this.onDrag, passive);\n            addEvent(win, \"touchend\", this.onDragEnd, passive);\n            addEvent(win, \"touchcancel\", this.onDragEnd, passive);\n        }\n    };\n    Gesto.prototype._dettachDragEvent = function () {\n        var win = this._window;\n        var container = this.options.container;\n        if (this._isDragAPI) {\n            removeEvent(container, \"dragover\", this.onDrag);\n            removeEvent(win, \"dragend\", this.onDragEnd);\n        }\n        if (this._useMouse) {\n            removeEvent(container, \"mousemove\", this.onDrag);\n            removeEvent(win, \"mouseup\", this.onDragEnd);\n        }\n        if (this._useTouch) {\n            removeEvent(container, \"touchstart\", this.onDragStart);\n            removeEvent(container, \"touchmove\", this.onDrag);\n            removeEvent(win, \"touchend\", this.onDragEnd);\n            removeEvent(win, \"touchcancel\", this.onDragEnd);\n        }\n    };\n    Gesto.prototype._allowMouseEvent = function () {\n        this._preventMouseEvent = false;\n        clearTimeout(this._preventMouseEventId);\n    };\n    return Gesto;\n}(EventEmitter));\n\nexport { Gesto as default };\n//# sourceMappingURL=gesto.esm.js.map\n", "import {\n    MoveableManagerInterface, BeforeRenderableProps,\n    OnBeforeRenderStart, OnBeforeRender, OnBeforeRenderEnd,\n    MoveableGroupInterface, OnBeforeRenderGroupStart,\n    OnBeforeRenderGroup, OnBeforeRenderGroupEnd,\n} from \"../types\";\nimport { fillParams, triggerEvent } from \"../utils\";\nimport { convertMatrixtoCSS, createIdentityMatrix } from \"@scena/matrix\";\nimport { isArray, splitSpace } from \"@daybrush/utils\";\nimport { fillChildEvents } from \"../groupUtils\";\n\n\nfunction isIdentityMatrix(matrix: string, is3d?: boolean) {\n    const n = is3d ? 4 : 3;\n    const identityMatrix = createIdentityMatrix(n);\n    const value = `matrix${is3d ? \"3d\" : \"\"}(${identityMatrix.join(\",\")})`;\n\n    return matrix === value || matrix === `matrix(1,0,0,1,0,0)`;\n}\nexport default {\n    isPinch: true,\n    name: \"beforeRenderable\",\n    props: [] as const,\n    events: [\n        \"beforeRenderStart\",\n        \"beforeRender\",\n        \"beforeRenderEnd\",\n        \"beforeRenderGroupStart\",\n        \"beforeRenderGroup\",\n        \"beforeRenderGroupEnd\",\n    ] as const,\n    dragRelation: \"weak\",\n    setTransform(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        const {\n            is3d,\n            targetMatrix,\n            inlineTransform,\n        } = moveable.state;\n        const cssMatrix = is3d\n            ? `matrix3d(${targetMatrix.join(\",\")})`\n            : `matrix(${convertMatrixtoCSS(targetMatrix, true)})`;\n        const startTransform = !inlineTransform || inlineTransform === \"none\" ? cssMatrix : inlineTransform;\n\n        e.datas.startTransforms = isIdentityMatrix(startTransform, is3d) ? [] : splitSpace(startTransform);\n    },\n    resetStyle(e: any) {\n        const datas = e.datas;\n\n        datas.nextStyle = {};\n        datas.nextTransforms = e.datas.startTransforms;\n        datas.nextTransformAppendedIndexes = [];\n    },\n    fillDragStartParams(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        return fillParams<OnBeforeRenderStart>(moveable, e, {\n            setTransform: (transform: string | string[]) => {\n                e.datas.startTransforms = isArray(transform) ? transform : splitSpace(transform);\n            },\n            isPinch: !!e.isPinch,\n        });\n    },\n    fillDragParams(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        return fillParams<OnBeforeRender>(moveable, e, {\n            isPinch: !!e.isPinch,\n        });\n    },\n    dragStart(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        this.setTransform(moveable, e);\n        this.resetStyle(e);\n\n        triggerEvent(moveable, `onBeforeRenderStart`, this.fillDragStartParams(moveable, e));\n    },\n    drag(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        if (!e.datas.startTransforms) {\n            this.setTransform(moveable, e);\n        }\n        this.resetStyle(e);\n        triggerEvent(moveable, `onBeforeRender`, fillParams<OnBeforeRender>(moveable, e, {\n            isPinch: !!e.isPinch,\n        }));\n    },\n    dragEnd(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        if (!e.datas.startTransforms) {\n            this.setTransform(moveable, e);\n            this.resetStyle(e);\n        }\n        triggerEvent(moveable, `onBeforeRenderEnd`, fillParams<OnBeforeRenderEnd>(moveable, e, {\n            isPinch: !!e.isPinch,\n            isDrag: e.isDrag,\n        }));\n    },\n    dragGroupStart(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n        this.dragStart(moveable, e);\n\n        const events = fillChildEvents(moveable, \"beforeRenderable\", e);\n        const moveables = moveable.moveables;\n        const params = events.map((childEvent, i) => {\n            const childMoveable = moveables[i];\n\n            this.setTransform(childMoveable, childEvent);\n            this.resetStyle(childEvent);\n\n            return this.fillDragStartParams(childMoveable, childEvent);\n        });\n        triggerEvent(moveable, `onBeforeRenderGroupStart`, fillParams<OnBeforeRenderGroupStart>(moveable, e, {\n            isPinch: !!e.isPinch,\n            targets: moveable.props.targets,\n            setTransform() { },\n            events: params,\n        }));\n    },\n    dragGroup(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n        this.drag(moveable, e);\n\n        const events = fillChildEvents(moveable, \"beforeRenderable\", e);\n        const moveables = moveable.moveables;\n        const params = events.map((childEvent, i) => {\n            const childMoveable = moveables[i];\n\n            this.resetStyle(childEvent);\n            return this.fillDragParams(childMoveable, childEvent);\n        });\n        triggerEvent(moveable, `onBeforeRenderGroup`, fillParams<OnBeforeRenderGroup>(moveable, e, {\n            isPinch: !!e.isPinch,\n            targets: moveable.props.targets,\n            events: params,\n        }));\n    },\n    dragGroupEnd(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n        this.dragEnd(moveable, e);\n\n        triggerEvent(moveable, `onBeforeRenderGroupEnd`, fillParams<OnBeforeRenderGroupEnd>(moveable, e, {\n            isPinch: !!e.isPinch,\n            isDrag: e.isDrag,\n            targets: moveable.props.targets,\n        }));\n    },\n    dragControlStart(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        return this.dragStart(moveable, e);\n    },\n    dragControl(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        return this.drag(moveable, e);\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<BeforeRenderableProps>, e: any) {\n        return this.dragEnd(moveable, e);\n    },\n    dragGroupControlStart(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n        return this.dragGroupStart(moveable, e);\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n        return this.dragGroup(moveable, e);\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<BeforeRenderableProps>, e: any) {\n        return this.dragGroupEnd(moveable, e);\n    },\n} as const;\n", "import { parse } from \"css-to-mat\";\nimport { getNextStyle, getNextTransformText, getNextTransforms } from \"../gesto/GestoUtils\";\nimport { fillChildEvents } from \"../groupUtils\";\nimport {\n    MoveableManagerInterface, RenderableProps, OnRenderStart, OnRender,\n    OnRenderEnd, MoveableGroupInterface,\n    OnRenderGroupStart, OnRenderGroup, OnRenderGroupEnd,\n} from \"../types\";\nimport { triggerEvent, fillParams, fillCSSObject } from \"../utils\";\n\nexport default {\n    name: \"renderable\",\n    props: [] as const,\n    events: [\n        \"renderStart\",\n        \"render\",\n        \"renderEnd\",\n        \"renderGroupStart\",\n        \"renderGroup\",\n        \"renderGroupEnd\",\n    ] as const,\n    dragRelation: \"weak\",\n    dragStart(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        triggerEvent(moveable, `onRenderStart`, fillParams<OnRenderStart>(moveable, e, {\n            isPinch: !!e.isPinch,\n        }));\n    },\n    drag(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        triggerEvent(moveable, `onRender`, this.fillDragParams(moveable, e));\n    },\n    dragAfter(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        return this.drag(moveable, e);\n    },\n    dragEnd(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        triggerEvent(moveable, `onRenderEnd`, this.fillDragEndParams(moveable, e));\n    },\n    dragGroupStart(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n        triggerEvent(moveable, `onRenderGroupStart`, fillParams<OnRenderGroupStart>(moveable, e, {\n            isPinch: !!e.isPinch,\n            targets: moveable.props.targets,\n        }));\n    },\n    dragGroup(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n        const events = fillChildEvents(moveable, \"beforeRenderable\", e);\n        const moveables = moveable.moveables;\n        const params = events.map((childEvent, i) => {\n            const childMoveable = moveables[i];\n\n            return this.fillDragParams(childMoveable, childEvent);\n        });\n\n        triggerEvent(moveable, `onRenderGroup`, fillParams<OnRenderGroup>(moveable, e, {\n            isPinch: !!e.isPinch,\n            targets: moveable.props.targets,\n            transform: getNextTransformText(e),\n            transformObject: {},\n            ...fillCSSObject(getNextStyle(e)),\n            events: params,\n        },));\n    },\n    dragGroupEnd(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n        const events = fillChildEvents(moveable, \"beforeRenderable\", e);\n        const moveables = moveable.moveables;\n        const params = events.map((childEvent, i) => {\n            const childMoveable = moveables[i];\n\n            return this.fillDragEndParams(childMoveable, childEvent);\n        });\n\n        triggerEvent(moveable, `onRenderGroupEnd`, fillParams<OnRenderGroupEnd>(moveable, e, {\n            isPinch: !!e.isPinch,\n            isDrag: e.isDrag,\n            targets: moveable.props.targets,\n            events: params,\n            transformObject: {},\n            transform: getNextTransformText(e),\n            ...fillCSSObject(getNextStyle(e)),\n        }));\n    },\n    dragControlStart(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        return this.dragStart(moveable, e);\n    },\n    dragControl(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        return this.drag(moveable, e);\n    },\n    dragControlAfter(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        return this.dragAfter(moveable, e);\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        return this.dragEnd(moveable, e);\n    },\n    dragGroupControlStart(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n        return this.dragGroupStart(moveable, e);\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n        return this.dragGroup(moveable, e);\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<RenderableProps>, e: any) {\n        return this.dragGroupEnd(moveable, e);\n    },\n    fillDragParams(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        const transformObject: Record<string, any> = {};\n\n        parse(getNextTransforms(e) || []).forEach(matrixInfo => {\n            transformObject[matrixInfo.name] = matrixInfo.functionValue;\n        });\n\n        return fillParams<OnRender>(moveable, e, {\n            isPinch: !!e.isPinch,\n            transformObject,\n            transform: getNextTransformText(e),\n            ...fillCSSObject(getNextStyle(e)),\n        });\n    },\n    fillDragEndParams(moveable: MoveableManagerInterface<RenderableProps>, e: any) {\n        const transformObject: Record<string, any> = {};\n\n        parse(getNextTransforms(e) || []).forEach(matrixInfo => {\n            transformObject[matrixInfo.name] = matrixInfo.functionValue;\n        });\n        return fillParams<OnRenderEnd>(moveable, e, {\n            isPinch: !!e.isPinch,\n            isDrag: e.isDrag,\n            transformObject,\n            transform: getNextTransformText(e),\n            ...fillCSSObject(getNextStyle(e)),\n        });\n    },\n} as const;\n", "import { Able, MoveableManagerInterface, MoveableGroupInterface } from \"../types\";\nimport { getWindow, hasClass, IObject } from \"@daybrush/utils\";\nimport { convertDragDist, defaultSync, getRefTarget } from \"../utils\";\nimport Gesto, { GestoOptions } from \"gesto\";\nimport BeforeRenderable from \"../ables/BeforeRenderable\";\nimport Renderable from \"../ables/Renderable\";\n\nexport function triggerAble(\n    moveable: MoveableManagerInterface,\n    moveableAbles: Able[],\n    eventOperations: string[],\n    eventAffix: string,\n    eventType: any,\n    e: any,\n    requestInstant?: boolean,\n) {\n    // pre setting\n    e.clientDistX = e.distX;\n    e.clientDistY = e.distY;\n\n    const isStart = eventType === \"Start\";\n    const isEnd = eventType === \"End\";\n    const isAfter = eventType === \"After\";\n    const target = moveable.state.target;\n    const isRequest = e.isRequest;\n    const isControl = eventAffix.indexOf(\"Control\") > -1;\n\n    if (\n        !target\n        || (isStart && isControl && !isRequest && moveable.areaElement === e.inputEvent.target)\n    ) {\n        return false;\n    }\n    const ables: Able[] = [...moveableAbles];\n\n    if (isRequest) {\n        const requestAble = e.requestAble;\n\n        if (!ables.some(able => able.name === requestAble)) {\n            ables.push(...moveable.props.ables!.filter(able => able.name === requestAble));\n        }\n    }\n    if (!ables.length || ables.every(able => able.dragRelation)) {\n        return false;\n    }\n    // \"drag\" \"Control\" \"After\"\n\n    const inputEvent = e.inputEvent;\n    let inputTarget: Element;\n\n    if (isEnd && inputEvent) {\n        inputTarget = document.elementFromPoint(e.clientX, e.clientY) || inputEvent.target;\n    }\n    let isDragStop = false;\n    const stop = () => {\n        isDragStop = true;\n        e.stop?.();\n    };\n    const isFirstStart = isStart && (\n        !moveable.targetGesto || !moveable.controlGesto\n        || (!moveable.targetGesto.isFlag() || !moveable.controlGesto.isFlag())\n    );\n\n    if (isFirstStart) {\n        moveable.updateRect(eventType, true, false);\n    }\n\n\n    // trigger ables\n    const datas = e.datas;\n    const gestoType = isControl ? \"controlGesto\" : \"targetGesto\";\n    const prevGesto = moveable[gestoType];\n\n    const trigger = (able: any, eventName: string, conditionName?: string) => {\n        if (!(eventName in able) || prevGesto !== moveable[gestoType]) {\n            return false;\n        }\n        const ableName = able.name;\n        const nextDatas = datas[ableName] || (datas[ableName] = {});\n\n        if (isStart) {\n            nextDatas.isEventStart = !conditionName\n                || !able[conditionName] || able[conditionName](moveable, e);\n        }\n\n        if (!nextDatas.isEventStart) {\n            return false;\n        }\n        const result = able[eventName](moveable, {\n            ...e,\n            stop,\n            datas: nextDatas,\n            originalDatas: datas,\n            inputTarget,\n        });\n        (moveable as any)._emitter.off();\n\n        if (isStart && result === false) {\n            nextDatas.isEventStart = false;\n        }\n        return result;\n    };\n\n    // unset ables for first drag start\n    if (isFirstStart) {\n        ables.forEach(able => {\n            able.unset && able.unset(moveable);\n        });\n    }\n    // BeforeRenderable\n    trigger(BeforeRenderable, `drag${eventAffix}${eventType}`);\n\n    let forceEndedCount = 0;\n    let updatedCount = 0;\n\n    eventOperations.forEach(eventOperation => {\n        if (isDragStop) {\n            return false;\n        }\n        const eventName = `${eventOperation}${eventAffix}${eventType}`;\n        const conditionName = `${eventOperation}${eventAffix}Condition`;\n\n        if (eventType === \"\" && !isRequest) {\n            // Convert distX, distY\n            convertDragDist(moveable.state, e);\n        }\n        // const isGroup = eventAffix.indexOf(\"Group\") > -1;\n        let eventAbles: Able[] = ables.filter((able: any) => able[eventName]);\n\n        eventAbles = eventAbles.filter((able, i) => {\n            return able.name && eventAbles.indexOf(able) === i;\n        });\n\n        const results = eventAbles.filter(able => trigger(able, eventName, conditionName));\n        const isUpdate = results.length;\n\n        // end ables\n        if (isDragStop) {\n            ++forceEndedCount;\n        }\n        if (isUpdate) {\n            ++updatedCount;\n        }\n\n        if (!isDragStop && isStart && eventAbles.length && !isUpdate) {\n            forceEndedCount += eventAbles.filter(able => {\n                const ableName = able.name;\n                const nextDatas = datas[ableName];\n\n                if (nextDatas.isEventStart) {\n                    if (able.dragRelation === \"strong\") {\n                        return false;\n                    }\n                    // stop drag\n                    return true;\n                }\n                // pre stop drag\n                return false;\n            }).length ? 1 : 0;\n        }\n    });\n\n\n    if (!isAfter || updatedCount) {\n        trigger(Renderable, `drag${eventAffix}${eventType}`);\n    }\n    // stop gesto condition\n    const isForceEnd = prevGesto !== moveable[gestoType] || forceEndedCount === eventOperations.length;\n\n    if (isEnd || isDragStop || isForceEnd) {\n        moveable.state.gestos = {};\n\n        if ((moveable as MoveableGroupInterface).moveables) {\n            (moveable as MoveableGroupInterface).moveables.forEach(childMoveable => {\n                childMoveable.state.gestos = {};\n            });\n        }\n        ables.forEach(able => {\n            able.unset && able.unset(moveable);\n        });\n    }\n    if (isStart && !isForceEnd && !isRequest && updatedCount && moveable.props.preventDefault) {\n        e?.preventDefault();\n    }\n    if (moveable.isUnmounted || isForceEnd) {\n        return false;\n    }\n    if ((!isStart && updatedCount && !requestInstant) || isEnd) {\n        const flushSync = moveable.props.flushSync || defaultSync;\n\n        flushSync(() => {\n            moveable.updateRect(isEnd ? eventType : \"\", true, false);\n            moveable.forceUpdate();\n        });\n\n    }\n    if (!isStart && !isEnd && !isAfter && updatedCount && !requestInstant) {\n        triggerAble(moveable, moveableAbles, eventOperations, eventAffix, eventType + \"After\", e);\n    }\n    return true;\n}\n\nexport function checkMoveableTarget(moveable: MoveableManagerInterface, isControl?: boolean) {\n    return (e: { inputEvent: Event }, target: EventTarget | null = e.inputEvent.target) => {\n        const eventTarget = target as Element;\n        const areaElement = moveable.areaElement;\n        const dragTargetElement = (moveable as any)._dragTarget;\n\n        if (!dragTargetElement || (!isControl && moveable.controlGesto?.isFlag())) {\n            return false;\n        }\n\n        return eventTarget === dragTargetElement\n            || dragTargetElement.contains(eventTarget)\n            || eventTarget === areaElement\n            || (!moveable.isMoveableElement(eventTarget) && !moveable.controlBox.contains(eventTarget))\n            || hasClass(eventTarget, \"moveable-area\")\n            || hasClass(eventTarget, \"moveable-padding\")\n            || hasClass(eventTarget, \"moveable-edgeDraggable\");\n    };\n}\n\nexport function getTargetAbleGesto(\n    moveable: MoveableManagerInterface,\n    moveableTarget: HTMLElement | SVGElement,\n    eventAffix: string,\n) {\n    const controlBox = moveable.controlBox;\n    const targets: Array<HTMLElement | SVGElement> = [];\n    const props = moveable.props;\n    const dragArea =  props.dragArea;\n    const target = moveable.state.target;\n    const dragTarget = props.dragTarget;\n\n    targets.push(controlBox);\n\n    if (!dragArea || dragTarget) {\n        targets.push(moveableTarget);\n    }\n\n    if (!dragArea && dragTarget && target && moveableTarget !== target && props.dragTargetSelf) {\n        targets.push(target);\n    }\n    const checkTarget = checkMoveableTarget(moveable);\n\n    return getAbleGesto(moveable, targets, \"targetAbles\", eventAffix, {\n        dragStart: checkTarget,\n        pinchStart: checkTarget,\n    });\n}\n\nexport function getControlAbleGesto(\n    moveable: MoveableManagerInterface,\n    eventAffix: string,\n) {\n    const controlBox = moveable.controlBox;\n    const targets: Array<HTMLElement | SVGElement> = [];\n\n    targets.push(controlBox);\n\n    const checkTarget = checkMoveableTarget(moveable, true);\n    const checkControlTarget = (e: any, target: EventTarget | null = e.inputEvent.target) => {\n        if (target === controlBox) {\n            return true;\n        }\n        const result = checkTarget(e, target);\n\n        return !result;\n    };\n\n    return getAbleGesto(moveable, targets, \"controlAbles\", eventAffix, {\n        dragStart: checkControlTarget,\n        pinchStart: checkControlTarget,\n    });\n}\n\nexport function getAbleGesto(\n    moveable: MoveableManagerInterface,\n    target: HTMLElement | SVGElement | Array<HTMLElement | SVGElement>,\n    ableType: string,\n    eventAffix: string,\n    conditionFunctions: IObject<any> = {},\n) {\n    const isTargetAbles = ableType === \"targetAbles\";\n    const {\n        pinchOutside,\n        pinchThreshold,\n        preventClickEventOnDrag,\n        preventClickDefault,\n        checkInput,\n        dragFocusedInput,\n        preventDefault = true,\n        preventRightClick = true,\n        preventWheelClick = true,\n        dragContainer: dragContaienrOption,\n    } = moveable.props;\n    const dragContainer = getRefTarget(dragContaienrOption, true);\n\n    const options: GestoOptions = {\n        preventDefault,\n        preventRightClick,\n        preventWheelClick,\n        container: dragContainer || getWindow(moveable.getControlBoxElement()),\n        pinchThreshold,\n        pinchOutside,\n        preventClickEventOnDrag: isTargetAbles ? preventClickEventOnDrag : false,\n        preventClickEventOnDragStart: isTargetAbles ? preventClickDefault : false,\n        preventClickEventByCondition: isTargetAbles ? null : (e: MouseEvent) => {\n            return moveable.controlBox.contains(e.target as Element);\n        },\n        checkInput: isTargetAbles ? checkInput : false,\n        dragFocusedInput,\n    };\n    const gesto = new Gesto(target!, options);\n    const isControl = eventAffix === \"Control\";\n\n    [\"drag\", \"pinch\"].forEach(eventOperation => {\n        [\"Start\", \"\", \"End\"].forEach(eventType => {\n\n            gesto.on(`${eventOperation}${eventType}` as any, e => {\n                const eventName = e.eventType;\n                const isPinchScheduled = eventOperation === \"drag\" && e.isPinch;\n\n                if (conditionFunctions[eventName] && !conditionFunctions[eventName](e)) {\n                    e.stop();\n                    return;\n                }\n\n                if (isPinchScheduled) {\n                    return;\n                }\n                const eventOperations = eventOperation === \"drag\" ? [eventOperation] : [\"drag\", eventOperation];\n                const moveableAbles: Able[] = [...(moveable as any)[ableType]];\n                const result = triggerAble(moveable, moveableAbles, eventOperations, eventAffix, eventType, e);\n\n                if (!result) {\n                    e.stop();\n                } else if (moveable.props.stopPropagation || (eventType === \"Start\" && isControl)) {\n                    e?.inputEvent?.stopPropagation();\n                }\n            });\n        });\n    });\n\n    return gesto;\n}\n", "import { Able, MoveableManagerInterface } from './types';\n\nexport default class EventManager {\n  private ables: Able[] = [];\n  constructor(\n    private target: HTMLElement | SVGElement | null,\n    private moveable: MoveableManagerInterface | null,\n    private eventName: string,\n  ) {\n    target!.addEventListener(eventName.toLowerCase(), this._onEvent);\n  }\n  public setAbles(ables: Able[]) {\n    this.ables = ables;\n  }\n  public destroy() {\n    this.target!.removeEventListener(\n      this.eventName.toLowerCase(),\n      this._onEvent,\n    );\n    this.target = null;\n    this.moveable = null;\n  }\n  private _onEvent = (e: Event) => {\n    const eventName = this.eventName;\n    const moveable = this.moveable!;\n\n    if (moveable.state.disableNativeEvent) {\n      return;\n    }\n    this.ables.forEach((able) => {\n      (able as any)[eventName](moveable, {\n        inputEvent: e,\n      });\n    });\n  };\n}\n", "/*\nCopyright (c) Daybrush\nname: css-styled\nlicense: MIT\nauthor: Daybrush\nrepository: git+https://github.com/daybrush/css-styled.git\nversion: 1.0.8\n*/\nimport { getDocument, splitComma } from '@daybrush/utils';\n\nfunction hash(str) {\n  var hash = 5381,\n      i    = str.length;\n\n  while(i) {\n    hash = (hash * 33) ^ str.charCodeAt(--i);\n  }\n\n  /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed\n   * integers. Since we want the results to be always positive, convert the\n   * signed int to an unsigned by doing an unsigned bitshift. */\n  return hash >>> 0;\n}\n\nvar stringHash = hash;\n\nfunction getHash(str) {\n  return stringHash(str).toString(36);\n}\nfunction getShadowRoot(parentElement) {\n  if (parentElement && parentElement.getRootNode) {\n    var rootNode = parentElement.getRootNode();\n    if (rootNode.nodeType === 11) {\n      return rootNode;\n    }\n  }\n  return;\n}\nfunction replaceStyle(className, css, options) {\n  if (options.original) {\n    return css;\n  }\n  return css.replace(/([^};{\\s}][^};{]*|^\\s*){/mg, function (_, selector) {\n    var trimmedSelector = selector.trim();\n    return (trimmedSelector ? splitComma(trimmedSelector) : [\"\"]).map(function (subSelector) {\n      var trimmedSubSelector = subSelector.trim();\n      if (trimmedSubSelector.indexOf(\"@\") === 0) {\n        return trimmedSubSelector;\n      } else if (trimmedSubSelector.indexOf(\":global\") > -1) {\n        return trimmedSubSelector.replace(/\\:global/g, \"\");\n      } else if (trimmedSubSelector.indexOf(\":host\") > -1) {\n        return \"\".concat(trimmedSubSelector.replace(/\\:host/g, \".\".concat(className)));\n      } else if (trimmedSubSelector) {\n        return \".\".concat(className, \" \").concat(trimmedSubSelector);\n      } else {\n        return \".\".concat(className);\n      }\n    }).join(\", \") + \" {\";\n  });\n}\nfunction injectStyle(className, css, options, el, shadowRoot) {\n  var doc = getDocument(el);\n  var style = doc.createElement(\"style\");\n  style.setAttribute(\"type\", \"text/css\");\n  style.setAttribute(\"data-styled-id\", className);\n  style.setAttribute(\"data-styled-count\", \"1\");\n  if (options.nonce) {\n    style.setAttribute(\"nonce\", options.nonce);\n  }\n  style.innerHTML = replaceStyle(className, css, options);\n  (shadowRoot || doc.head || doc.body).appendChild(style);\n  return style;\n}\n\n/**\n * Create an styled object that can be defined and inserted into the css.\n * @param - css styles\n */\nfunction styled(css) {\n  var injectClassName = \"rCS\" + getHash(css);\n  return {\n    className: injectClassName,\n    inject: function (el, options) {\n      if (options === void 0) {\n        options = {};\n      }\n      var shadowRoot = getShadowRoot(el);\n      var styleElement = (shadowRoot || el.ownerDocument || document).querySelector(\"style[data-styled-id=\\\"\".concat(injectClassName, \"\\\"]\"));\n      if (!styleElement) {\n        styleElement = injectStyle(injectClassName, css, options, el, shadowRoot);\n      } else {\n        var count = parseFloat(styleElement.getAttribute(\"data-styled-count\")) || 0;\n        styleElement.setAttribute(\"data-styled-count\", \"\".concat(count + 1));\n      }\n      return {\n        destroy: function () {\n          var _a;\n          var injectCount = parseFloat(styleElement.getAttribute(\"data-styled-count\")) || 0;\n          if (injectCount <= 1) {\n            if (styleElement.remove) {\n              styleElement.remove();\n            } else {\n              (_a = styleElement.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(styleElement);\n            }\n            styleElement = null;\n          } else {\n            styleElement.setAttribute(\"data-styled-count\", \"\".concat(injectCount - 1));\n          }\n        }\n      };\n    }\n  };\n}\n\nexport default styled;\n//# sourceMappingURL=styled.esm.js.map\n", "/*\nCopyright (c) 2019 Daybrush\nname: react-css-styled\nlicense: MIT\nauthor: Daybrush\nrepository: https://github.com/daybrush/css-styled/tree/master/packages/react-css-styled\nversion: 1.1.9\n*/\nimport cssStyled from 'css-styled';\nimport { version, createElement, Component, forwardRef, useRef, useImperativeHandle, useEffect } from 'react';\nimport { ref } from 'framework-utils';\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n  };\n  return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nvar StyledElement = /*#__PURE__*/function (_super) {\n  __extends(StyledElement, _super);\n  function StyledElement() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.injectResult = null;\n    _this.tag = \"div\";\n    return _this;\n  }\n  var __proto = StyledElement.prototype;\n  __proto.render = function () {\n    var _a = this.props,\n      _b = _a.className,\n      className = _b === void 0 ? \"\" : _b,\n      cspNonce = _a.cspNonce,\n      portalContainer = _a.portalContainer,\n      attributes = __rest(_a, [\"className\", \"cspNonce\", \"portalContainer\"]);\n    var cssId = this.injector.className;\n    var Tag = this.tag;\n    var portalAttributes = {};\n    if ((version || \"\").indexOf(\"simple\") > -1 && portalContainer) {\n      portalAttributes = {\n        portalContainer: portalContainer\n      };\n    }\n    return createElement(Tag, __assign(__assign({\n      \"ref\": ref(this, \"element\"),\n      \"data-styled-id\": cssId,\n      \"className\": \"\".concat(className, \" \").concat(cssId)\n    }, portalAttributes), attributes));\n  };\n  __proto.componentDidMount = function () {\n    this.injectResult = this.injector.inject(this.element, {\n      nonce: this.props.cspNonce\n    });\n  };\n  __proto.componentWillUnmount = function () {\n    this.injectResult.destroy();\n    this.injectResult = null;\n  };\n  __proto.getElement = function () {\n    return this.element;\n  };\n  return StyledElement;\n}(Component);\n\nfunction defaultStyled(tag, css) {\n  var injector = cssStyled(css);\n  return (/*#__PURE__*/function (_super) {\n      __extends(Styled, _super);\n      function Styled() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.injector = injector;\n        _this.tag = tag;\n        return _this;\n      }\n      return Styled;\n    }(StyledElement)\n  );\n}\nfunction styled(Tag, css) {\n  var injector = cssStyled(css);\n  var cssId = injector.className;\n  return forwardRef(function (props, ref) {\n    var _a = props.className,\n      className = _a === void 0 ? \"\" : _a,\n      cspNonce = props.cspNonce,\n      attributes = __rest(props, [\"className\", \"cspNonce\"]);\n    var targetRef = useRef();\n    useImperativeHandle(ref, function () {\n      return targetRef.current;\n    }, []);\n    useEffect(function () {\n      var injectResult = injector.inject(targetRef.current, {\n        nonce: props.cspNonce\n      });\n      return function () {\n        injectResult.destroy();\n      };\n    }, []);\n    return createElement(Tag, __assign({\n      \"ref\": targetRef,\n      \"data-styled-id\": cssId,\n      \"className\": \"\".concat(className, \" \").concat(cssId)\n    }, attributes));\n  });\n}\n\nexport default defaultStyled;\nexport { StyledElement, styled };\n//# sourceMappingURL=styled.esm.js.map\n", "import {\n  createIdentityMatrix,\n  convertDimension,\n  multiply,\n  createOriginMatrix,\n  ignoreDimension,\n} from '@scena/matrix';\nimport { getCachedMatrixContainerInfo } from '../store/Store';\nimport {\n  convert3DMatrixes,\n  getOffsetInfo,\n  getSVGOffset,\n  makeMatrixCSS,\n} from '../utils';\nimport { getMatrixStackInfo } from './getMatrixStackInfo';\nimport { getDocumentBody } from '@daybrush/utils';\nimport { MatrixInfo } from '../types';\n\nexport interface MoveableElementMatrixInfo {\n  hasZoom: boolean;\n  hasFixed: boolean;\n  originalRootMatrix: number[];\n  rootMatrix: number[];\n  beforeMatrix: number[];\n  offsetMatrix: number[];\n  allMatrix: number[];\n  targetMatrix: number[];\n  transformOrigin: number[];\n  targetOrigin: number[];\n  is3d: boolean;\n  targetTransform: string;\n  inlineTransform: string;\n  offsetContainer: HTMLElement | null;\n  offsetRootContainer: HTMLElement | null;\n  matrixes: MatrixInfo[];\n}\n\nexport function calculateMatrixStack(\n  target: SVGElement | HTMLElement,\n  container?: SVGElement | HTMLElement | null,\n  rootContainer: SVGElement | HTMLElement | null | undefined = container,\n  isAbsolute3d?: boolean,\n  // prevMatrix?: number[],\n  // prevRootMatrix?: number[],\n  // prevN?: number,\n): MoveableElementMatrixInfo {\n  const {\n    matrixes,\n    is3d,\n    targetMatrix: prevTargetMatrix,\n    transformOrigin,\n    targetOrigin,\n    offsetContainer,\n    hasFixed,\n    zoom: containerZoom,\n  } = getMatrixStackInfo(target, container); // prevMatrix\n\n  const {\n    matrixes: rootMatrixes,\n    is3d: isRoot3d,\n    offsetContainer: offsetRootContainer,\n    zoom: rootZoom,\n  } = getCachedMatrixContainerInfo(offsetContainer, rootContainer); // prevRootMatrix\n\n  // if (rootContainer === document.body) {\n  //     console.log(offsetContainer, rootContainer, rootMatrixes);\n  // }\n  const isNext3d = isAbsolute3d || isRoot3d || is3d;\n  const n = isNext3d ? 4 : 3;\n  const isSVGGraphicElement =\n    target.tagName.toLowerCase() !== 'svg' && 'ownerSVGElement' in target;\n  let targetMatrix = prevTargetMatrix;\n  // let allMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\n  // let rootMatrix = prevRootMatrix ? convertDimension(prevRootMatrix, prevN!, n) : createIdentityMatrix(n);\n  // let beforeMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\n  let allMatrix = createIdentityMatrix(n);\n  let rootMatrix = createIdentityMatrix(n);\n  let beforeMatrix = createIdentityMatrix(n);\n  let offsetMatrix = createIdentityMatrix(n);\n  const length = matrixes.length;\n  const nextRootMatrixes = rootMatrixes\n    .map((info) => {\n      return {\n        ...info,\n        matrix: info.matrix ? [...info.matrix] : undefined,\n      };\n    })\n    .reverse();\n  matrixes.reverse();\n\n  if (!is3d && isNext3d) {\n    targetMatrix = convertDimension(targetMatrix, 3, 4);\n\n    convert3DMatrixes(matrixes);\n  }\n  if (!isRoot3d && isNext3d) {\n    convert3DMatrixes(nextRootMatrixes);\n  }\n\n  // rootMatrix = (...) -> container -> offset -> absolute -> offset -> absolute(targetMatrix)\n  // rootMatrixBeforeOffset = lastOffsetMatrix -> (...) -> container\n  // beforeMatrix = (... -> container -> offset -> absolute) -> offset -> absolute(targetMatrix)\n  // offsetMatrix = (... -> container -> offset -> absolute -> offset) -> absolute(targetMatrix)\n\n  nextRootMatrixes.forEach((info) => {\n    rootMatrix = multiply(rootMatrix, info.matrix!, n);\n  });\n  const originalRootContainer = rootContainer || getDocumentBody(target);\n  const endContainer =\n    nextRootMatrixes[0]?.target ||\n    getOffsetInfo(originalRootContainer, originalRootContainer, true)\n      .offsetParent;\n  const rootMatrixBeforeOffset = nextRootMatrixes\n    .slice(1)\n    .reduce((matrix, info) => {\n      return multiply(matrix, info.matrix!, n);\n    }, createIdentityMatrix(n));\n  matrixes.forEach((info, i) => {\n    if (length - 2 === i) {\n      // length - 3\n      beforeMatrix = allMatrix.slice();\n    }\n    if (length - 1 === i) {\n      // length - 2\n      offsetMatrix = allMatrix.slice();\n    }\n\n    // calculate for SVGElement\n    if (!info.matrix) {\n      const nextInfo = matrixes[i + 1];\n      const offset = getSVGOffset(\n        info,\n        nextInfo,\n        endContainer,\n        n,\n        multiply(rootMatrixBeforeOffset, allMatrix, n),\n      );\n      info.matrix = createOriginMatrix(offset, n);\n    }\n    allMatrix = multiply(allMatrix, info.matrix!, n);\n  });\n  const isMatrix3d = !isSVGGraphicElement && is3d;\n\n  if (!targetMatrix) {\n    targetMatrix = createIdentityMatrix(isMatrix3d ? 4 : 3);\n  }\n  const targetTransform = makeMatrixCSS(\n    isSVGGraphicElement && targetMatrix.length === 16\n      ? convertDimension(targetMatrix, 4, 3)\n      : targetMatrix,\n    isMatrix3d,\n  );\n\n  const originalRootMatrix = rootMatrix;\n  rootMatrix = ignoreDimension(rootMatrix, n, n);\n\n  return {\n    hasZoom: containerZoom !== 1 || rootZoom !== 1,\n    hasFixed,\n    matrixes,\n    rootMatrix,\n    originalRootMatrix,\n    beforeMatrix,\n    offsetMatrix,\n    allMatrix,\n    targetMatrix,\n    targetTransform,\n    inlineTransform: target.style.transform,\n    transformOrigin,\n    targetOrigin,\n    is3d: isNext3d,\n    offsetContainer,\n    offsetRootContainer,\n  };\n}\n", "import { createIdentityMatrix } from \"@scena/matrix\";\nimport { ElementSizes, MoveablePosition } from \"../types\";\nimport { getSize, getRotationRad } from \"../utils\";\nimport { calculateMatrixStack, MoveableElementMatrixInfo } from \"./calculateMatrixStack\";\nimport { calculateElementPosition } from \"./calculateElementPosition\";\n\nexport interface MoveableElementInfo extends MoveableElementMatrixInfo, MoveablePosition, ElementSizes {\n    width: number;\n    height: number;\n    rotation: number;\n}\n\nexport function calculateElementInfo(\n    target?: SVGElement | HTMLElement | null,\n    container?: SVGElement | HTMLElement | null,\n    rootContainer: HTMLElement | SVGElement | null | undefined = container,\n    isAbsolute3d?: boolean,\n): MoveableElementInfo {\n    let width = 0;\n    let height = 0;\n    let rotation = 0;\n    let allResult: {} = {};\n\n    const sizes = getSize(target);\n\n    if (target) {\n        width = sizes.offsetWidth;\n        height = sizes.offsetHeight;\n    }\n\n    if (target) {\n        const result = calculateMatrixStack(\n            target,\n            container,\n            rootContainer,\n            isAbsolute3d,\n            // prevMatrix, prevRootMatrix, prevN,\n        );\n\n        const position = calculateElementPosition(\n            result.allMatrix,\n            result.transformOrigin,\n            width, height,\n        );\n        allResult = {\n            ...result,\n            ...position,\n        };\n        const rotationPosition = calculateElementPosition(\n            result.allMatrix, [50, 50], 100, 100,\n        );\n        rotation = getRotationRad([rotationPosition.pos1, rotationPosition.pos2], rotationPosition.direction);\n    }\n    const n = isAbsolute3d ? 4 : 3;\n\n    return {\n        hasZoom: false,\n        width,\n        height,\n        rotation,\n        ...sizes,\n        originalRootMatrix: createIdentityMatrix(n),\n        rootMatrix: createIdentityMatrix(n),\n        beforeMatrix: createIdentityMatrix(n),\n        offsetMatrix: createIdentityMatrix(n),\n        allMatrix: createIdentityMatrix(n),\n        targetMatrix: createIdentityMatrix(n),\n        targetTransform: \"\",\n        inlineTransform: \"\",\n        transformOrigin: [0, 0],\n        targetOrigin: [0, 0],\n        is3d: !!isAbsolute3d,\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0,\n        origin: [0, 0],\n        pos1: [0, 0],\n        pos2: [0, 0],\n        pos3: [0, 0],\n        pos4: [0, 0],\n        direction: 1,\n        hasFixed: false,\n        offsetContainer: null,\n        offsetRootContainer: null,\n        matrixes: [],\n        ...allResult,\n    };\n}\n\n\nexport function getElementInfo(\n    target: SVGElement | HTMLElement,\n    container?: SVGElement | HTMLElement | null,\n    rootContainer: SVGElement | HTMLElement | null | undefined = container,\n) {\n    return calculateElementInfo(target, container, rootContainer, true);\n}\n", "import { plus, getOrigin, multiply, minus } from \"@scena/matrix\";\nimport { getCachedClientRect, getCachedStyle } from \"../store/Store\";\nimport { MoveableClientRect, Writable } from \"../types\";\nimport {\n    calculateInversePosition,\n    getClientRect, getClientRectByPosition, getOffsetInfo, resetClientRect,\n    getTransformOriginArray,\n} from \"../utils\";\nimport { calculateElementInfo, MoveableElementInfo } from \"./getElementInfo\";\nimport { calculateElementPosition } from \"./calculateElementPosition\";\n\n\nexport interface MoveableTargetInfo extends MoveableElementInfo {\n    targetClientRect: MoveableClientRect;\n    containerClientRect: MoveableClientRect;\n    moveableClientRect: MoveableClientRect;\n    rootContainerClientRect: MoveableClientRect;\n    beforeDirection: 1 | -1;\n    beforeOrigin: number[];\n    offsetDelta: number[],\n    originalBeforeOrigin: number[];\n    target: HTMLElement | SVGElement | null | undefined;\n    style: Partial<Writable<CSSStyleDeclaration>>;\n}\n\nexport function getMoveableTargetInfo(\n    moveableElement?: HTMLElement | null,\n    target?: HTMLElement | SVGElement | null,\n    container?: HTMLElement | SVGElement | null,\n    parentContainer?: HTMLElement | SVGElement | null,\n    rootContainer?: HTMLElement | SVGElement | null,\n    requestStyles: Array<keyof CSSStyleDeclaration> = [],\n): MoveableTargetInfo {\n    let beforeDirection: 1 | -1 = 1;\n    let beforeOrigin = [0, 0];\n    let targetClientRect = resetClientRect();\n    let moveableClientRect = resetClientRect();\n    let containerClientRect = resetClientRect();\n    let rootContainerClientRect = resetClientRect();\n    let offsetDelta = [0, 0];\n    const style: Partial<Writable<CSSStyleDeclaration>> = {};\n\n    const result = calculateElementInfo(\n        target, container!, rootContainer!,\n        true,\n    );\n    if (target) {\n        const getStyle = getCachedStyle(target);\n\n        requestStyles.forEach(name => {\n            (style as any)[name] = getStyle(name as any);\n        });\n        const n = result.is3d ? 4 : 3;\n        const beforePosition = calculateElementPosition(\n            result.offsetMatrix,\n            plus(result.transformOrigin, getOrigin(result.targetMatrix, n)),\n            result.width, result.height,\n        );\n        beforeDirection = beforePosition.direction;\n        beforeOrigin = plus(\n            beforePosition.origin,\n            [beforePosition.left - result.left, beforePosition.top - result.top],\n        );\n\n        rootContainerClientRect = getClientRect(result.offsetRootContainer!);\n\n\n        const offsetContainer = getOffsetInfo(parentContainer, parentContainer, true).offsetParent\n            || result.offsetRootContainer!;\n\n        if (result.hasZoom) {\n            const absoluteTargetPosition = calculateElementPosition(\n                multiply(result.originalRootMatrix, result.allMatrix),\n                result.transformOrigin,\n                result.width, result.height,\n            );\n            const absoluteContainerPosition = calculateElementPosition(\n                result.originalRootMatrix,\n                getTransformOriginArray(getCachedStyle(offsetContainer)(\"transformOrigin\")).map(pos => parseFloat(pos)),\n                offsetContainer.offsetWidth, offsetContainer.offsetHeight,\n            );\n            targetClientRect = getClientRectByPosition(absoluteTargetPosition, rootContainerClientRect);\n            containerClientRect = getClientRectByPosition(\n                absoluteContainerPosition,\n                rootContainerClientRect,\n                offsetContainer,\n                true,\n            );\n\n            if (moveableElement) {\n                const left = absoluteTargetPosition.left;\n                const top = absoluteTargetPosition.top;\n                moveableClientRect = getClientRectByPosition({\n                    left,\n                    top,\n                    bottom: top,\n                    right: top,\n                }, rootContainerClientRect);\n            }\n        } else {\n            targetClientRect = getClientRect(target);\n            containerClientRect = getCachedClientRect(offsetContainer);\n\n            if (moveableElement) {\n                moveableClientRect = getClientRect(moveableElement);\n            }\n            const {\n                left: containerClientRectLeft,\n                top: containerClientRectTop,\n                clientLeft: containterClientLeft,\n                clientTop: containerClientTop,\n            } = containerClientRect;\n            const clientDelta = [\n                targetClientRect.left - containerClientRectLeft,\n                targetClientRect.top - containerClientRectTop,\n            ];\n\n            offsetDelta = minus(\n                calculateInversePosition(result.rootMatrix, clientDelta, 4),\n                [containterClientLeft! + result.left, containerClientTop! + result.top],\n            );\n        }\n    }\n\n    return {\n        targetClientRect,\n        containerClientRect,\n        moveableClientRect,\n        rootContainerClientRect,\n        beforeDirection,\n        beforeOrigin,\n        originalBeforeOrigin: beforeOrigin,\n        target,\n        style,\n        offsetDelta,\n        ...result,\n    };\n}\n", "import { minus } from \"@scena/matrix\";\nimport { getMinMaxs } from \"overlap-area\";\nimport { MoveableManagerState, PersistRectData } from \"../types\";\n\n\nexport function getPersistState(rect: PersistRectData): Partial<MoveableManagerState> | null {\n    let {\n        pos1,\n        pos2,\n        pos3,\n        pos4,\n    } = rect;\n    if (!pos1 || !pos2 || !pos3 || !pos4) {\n        return null;\n    }\n    const minPos = getMinMaxs([pos1!, pos2!, pos3!, pos4!]);\n    const posDelta = [minPos.minX, minPos.minY];\n    const origin = minus(rect.origin!, posDelta);\n\n    pos1 = minus(pos1, posDelta);\n    pos2 = minus(pos2, posDelta);\n    pos3 = minus(pos3, posDelta);\n    pos4 = minus(pos4, posDelta);\n    return {\n        ...rect,\n        left: rect.left,\n        top: rect.top,\n        posDelta,\n        pos1,\n        pos2,\n        pos3,\n        pos4,\n        origin,\n        beforeOrigin: origin,\n        // originalBeforeOrigin: origin,\n        isPersisted: true,\n    };\n}\n", "import * as React from 'react';\nimport { createElement } from 'react';\nimport { PREFIX } from './consts';\nimport {\n  prefix,\n  unsetGesto,\n  getAbsolutePosesByState,\n  getRect,\n  filterAbles,\n  equals,\n  flat,\n  groupByMap,\n  calculatePadding,\n  getAbsoluteRotation,\n  defaultSync,\n  getRefTarget,\n  groupBy,\n  unsetAbles,\n  getPaddingBox,\n} from './utils';\nimport Gesto from 'gesto';\nimport { ref } from './utils/framework-utils';\nimport {\n  MoveableManagerProps,\n  MoveableManagerState,\n  Able,\n  RectInfo,\n  Requester,\n  HitRect,\n  MoveableManagerInterface,\n  MoveableDefaultOptions,\n  GroupableProps,\n  MoveableRefType,\n} from './types';\nimport {\n  triggerAble,\n  getTargetAbleGesto,\n  checkMoveableTarget,\n  getControlAbleGesto,\n} from './gesto/getAbleGesto';\nimport { createOriginMatrix, multiplies, plus } from '@scena/matrix';\nimport {\n  addClass,\n  cancelAnimationFrame,\n  find,\n  getKeys,\n  getWindow,\n  IObject,\n  isNode,\n  removeClass,\n  requestAnimationFrame,\n} from '@daybrush/utils';\nimport { renderLine } from './render-directions';\nimport { fitPoints, getAreaSize, getOverlapSize, isInside } from 'overlap-area';\nimport EventManager from './EventManager';\nimport { styled } from 'react-css-styled';\nimport EventEmitter from '@scena/event-emitter';\nimport { getMoveableTargetInfo } from './utils/getMoveableTargetInfo';\nimport { VIEW_DRAGGING } from './classNames';\nimport { diff } from '@egjs/list-differ';\nimport { getPersistState } from './utils/persist';\nimport { setStoreCache } from './store/Store';\n\nexport default class MoveableManager<T = {}> extends React.PureComponent<\n  MoveableManagerProps<T>,\n  MoveableManagerState\n> {\n  public static defaultProps: Required<MoveableManagerProps> = {\n    dragTargetSelf: false,\n    target: null,\n    dragTarget: null,\n    container: null,\n    rootContainer: null,\n    origin: true,\n    parentMoveable: null,\n    wrapperMoveable: null,\n    isWrapperMounted: false,\n    parentPosition: null,\n    warpSelf: false,\n    svgOrigin: '',\n    dragContainer: null,\n    useResizeObserver: false,\n    useMutationObserver: false,\n    preventDefault: true,\n    preventRightClick: true,\n    preventWheelClick: true,\n    linePadding: 0,\n    controlPadding: 0,\n    ables: [],\n    pinchThreshold: 20,\n    dragArea: false,\n    passDragArea: false,\n    transformOrigin: '',\n    className: '',\n    zoom: 1,\n    triggerAblesSimultaneously: false,\n    padding: {},\n    pinchOutside: true,\n    checkInput: false,\n    dragFocusedInput: false,\n    groupable: false,\n    hideDefaultLines: false,\n    cspNonce: '',\n    translateZ: 0,\n    cssStyled: null,\n    customStyledMap: {},\n    props: {},\n    stopPropagation: false,\n    preventClickDefault: false,\n    preventClickEventOnDrag: true,\n    flushSync: defaultSync,\n    firstRenderState: null,\n    persistData: null,\n    viewContainer: null,\n    requestStyles: [],\n    useAccuratePosition: false,\n  };\n  public state: MoveableManagerState = {\n    container: null,\n    gestos: {},\n    renderLines: [\n      [\n        [0, 0],\n        [0, 0],\n      ],\n      [\n        [0, 0],\n        [0, 0],\n      ],\n      [\n        [0, 0],\n        [0, 0],\n      ],\n      [\n        [0, 0],\n        [0, 0],\n      ],\n    ],\n    renderPoses: [\n      [0, 0],\n      [0, 0],\n      [0, 0],\n      [0, 0],\n    ],\n    disableNativeEvent: false,\n    posDelta: [0, 0],\n    ...getMoveableTargetInfo(null),\n  };\n  public renderState: Record<string, any> = {};\n  public enabledAbles: Able[] = [];\n  public targetAbles: Able[] = [];\n  public controlAbles: Able[] = [];\n  public controlBox!: HTMLElement;\n  public areaElement!: HTMLElement;\n  public targetGesto!: Gesto;\n  public controlGesto!: Gesto;\n  public rotation = 0;\n  public scale: number[] = [1, 1];\n  public isMoveableMounted = false;\n  public isUnmounted = false;\n\n  public events: Record<string, EventManager | null> = {\n    mouseEnter: null,\n    mouseLeave: null,\n  };\n\n  protected _emitter: EventEmitter = new EventEmitter();\n\n  protected _prevOriginalDragTarget: MoveableRefType | null = null;\n  protected _originalDragTarget: MoveableRefType | null = null;\n\n  protected _prevDragTarget: HTMLElement | SVGElement | null | undefined = null;\n  protected _dragTarget: HTMLElement | SVGElement | null | undefined = null;\n\n  protected _prevPropTarget: HTMLElement | SVGElement | null | undefined = null;\n  protected _propTarget: HTMLElement | SVGElement | null | undefined = null;\n\n  protected _prevDragArea = false;\n  protected _isPropTargetChanged = false;\n  protected _hasFirstTarget = false;\n\n  private _reiszeObserver: ResizeObserver | null = null;\n  private _observerId = 0;\n  private _mutationObserver: MutationObserver | null = null;\n  public _rootContainer: HTMLElement | null | undefined = null;\n  private _viewContainer: HTMLElement | null | undefined = null;\n  private _viewClassNames: string[] = [];\n  private _store: Record<string, any> = {};\n\n  public render() {\n    const props = this.props;\n    const state = this.getState();\n    const {\n      parentPosition,\n      className,\n      target: propsTarget,\n      zoom,\n      cspNonce,\n      translateZ,\n      cssStyled: ControlBoxElement,\n      groupable,\n      linePadding,\n      controlPadding,\n    } = props;\n\n    this._checkUpdateRootContainer();\n    this.checkUpdate();\n    this.updateRenderPoses();\n\n    const [parentLeft, parentTop] = (parentPosition as number[]) || [0, 0];\n    const {\n      left,\n      top,\n      target: stateTarget,\n      direction,\n      hasFixed,\n      offsetDelta,\n    } = state;\n    const groupTargets = (props as any).targets;\n    const isDragging = this.isDragging();\n    const ableAttributes: IObject<boolean> = {};\n    this.getEnabledAbles().forEach((able) => {\n      ableAttributes[`data-able-${able.name.toLowerCase()}`] = true;\n    });\n    const ableClassName = this._getAbleClassName();\n    const isDisplay =\n      (groupTargets && groupTargets.length && (stateTarget || groupable)) ||\n      propsTarget ||\n      (!this._hasFirstTarget && this.state.isPersisted);\n    const isVisible =\n      this.controlBox || this.props.firstRenderState || this.props.persistData;\n    const translate = [left - parentLeft, top - parentTop];\n\n    if (!groupable && props.useAccuratePosition) {\n      translate[0] += offsetDelta[0];\n      translate[1] += offsetDelta[1];\n    }\n    const style: Record<string, any> = {\n      position: hasFixed ? 'fixed' : 'absolute',\n      display: isDisplay ? 'block' : 'none',\n      visibility: isVisible ? 'visible' : 'hidden',\n      transform: `translate3d(${translate[0]}px, ${translate[1]}px, ${translateZ})`,\n      '--zoom': zoom,\n      '--zoompx': `${zoom}px`,\n    };\n    if (linePadding) {\n      style['--moveable-line-padding'] = linePadding;\n    }\n    if (controlPadding) {\n      style['--moveable-control-padding'] = controlPadding;\n    }\n    return (\n      <ControlBoxElement\n        cspNonce={cspNonce}\n        ref={ref(this, 'controlBox')}\n        className={`${prefix('control-box', direction === -1 ? 'reverse' : '', isDragging ? 'dragging' : '')} ${ableClassName} ${className}`}\n        {...ableAttributes}\n        onClick={this._onPreventClick}\n        style={style}\n      >\n        {this.renderAbles()}\n        {this._renderLines()}\n      </ControlBoxElement>\n    );\n  }\n  public componentDidMount() {\n    this.isMoveableMounted = true;\n    this.isUnmounted = false;\n    const props = this.props;\n    const { parentMoveable, container } = props;\n\n    this._checkUpdateRootContainer();\n    this._checkUpdateViewContainer();\n    this._updateTargets();\n    this._updateNativeEvents();\n    this._updateEvents();\n    this.updateCheckInput();\n    this._updateObserver(this.props);\n\n    if (!container && !parentMoveable && !this.state.isPersisted) {\n      this.updateRect('', false, false);\n      this.forceUpdate();\n    }\n  }\n  public componentDidUpdate(prevProps: any) {\n    this._checkUpdateRootContainer();\n    this._checkUpdateViewContainer();\n    this._updateNativeEvents();\n    this._updateTargets();\n    this._updateEvents();\n    this.updateCheckInput();\n    this._updateObserver(prevProps);\n  }\n  public componentWillUnmount() {\n    this.isMoveableMounted = false;\n    this.isUnmounted = true;\n    this._emitter.off();\n    this._reiszeObserver?.disconnect();\n    this._mutationObserver?.disconnect();\n\n    const viewContainer = this._viewContainer;\n\n    if (viewContainer) {\n      this._changeAbleViewClassNames([]);\n    }\n    unsetGesto(this, false);\n    unsetGesto(this, true);\n\n    const events = this.events;\n    for (const name in events) {\n      const manager = events[name];\n      manager && manager.destroy();\n    }\n  }\n  public getTargets(): Array<HTMLElement | SVGElement> {\n    const target = this.props.target;\n    return target ? [target] : [];\n  }\n  /**\n   * Get the able used in MoveableManager.\n   * @method Moveable#getAble\n   * @param - able name\n   */\n  public getAble<T extends Able>(ableName: string): T | undefined {\n    const ables: Able[] = this.props.ables || [];\n\n    return find(ables, (able) => able.name === ableName) as T;\n  }\n  public getContainer(): HTMLElement | SVGElement {\n    const { parentMoveable, wrapperMoveable, container } = this.props;\n\n    return (\n      container! ||\n      (wrapperMoveable && wrapperMoveable.getContainer()) ||\n      (parentMoveable && parentMoveable.getContainer()) ||\n      this.controlBox.parentElement!\n    );\n  }\n  /**\n   * Returns the element of the control box.\n   * @method Moveable#getControlBoxElement\n   */\n  public getControlBoxElement(): HTMLElement {\n    return this.controlBox;\n  }\n  /**\n   * Target element to be dragged in moveable\n   * @method Moveable#getDragElement\n   */\n  public getDragElement(): HTMLElement | SVGElement | null | undefined {\n    return this._dragTarget;\n  }\n  /**\n   * Check if the target is an element included in the moveable.\n   * @method Moveable#isMoveableElement\n   * @param - the target\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * window.addEventListener(\"click\", e => {\n   *     if (!moveable.isMoveableElement(e.target)) {\n   *         moveable.target = e.target;\n   *     }\n   * });\n   */\n  public isMoveableElement(target: Element) {\n    return (\n      target && (target.getAttribute?.('class') || '').indexOf(PREFIX) > -1\n    );\n  }\n  /**\n   * You can drag start the Moveable through the external `MouseEvent`or `TouchEvent`. (Angular: ngDragStart)\n   * @method Moveable#dragStart\n   * @param - external `MouseEvent`or `TouchEvent`\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * document.body.addEventListener(\"mousedown\", e => {\n   *     if (!moveable.isMoveableElement(e.target)) {\n   *          moveable.dragStart(e);\n   *     }\n   * });\n   */\n  public dragStart(\n    e: MouseEvent | TouchEvent,\n    target: EventTarget | null = e.target,\n  ) {\n    const targetGesto = this.targetGesto;\n    const controlGesto = this.controlGesto;\n\n    if (targetGesto && checkMoveableTarget(this)({ inputEvent: e }, target)) {\n      if (!targetGesto.isFlag()) {\n        targetGesto.triggerDragStart(e);\n      }\n    } else if (controlGesto && this.isMoveableElement(target as Element)) {\n      if (!controlGesto.isFlag()) {\n        controlGesto.triggerDragStart(e);\n      }\n    }\n    return this;\n  }\n  /**\n   * Hit test an element or rect on a moveable target.\n   * (100% = 100)\n   * @method Moveable#hitTest\n   * @param - element or rect to test\n   * @return - Get hit test rate (rate > 0 is hitted)\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * document.body.addEventListener(\"mousedown\", e => {\n   *     if (moveable.hitTest(e.target) > 0) {\n   *          console.log(\"hiited\");\n   *     }\n   * });\n   */\n  public hitTest(el: Element | HitRect): number {\n    const { target, pos1, pos2, pos3, pos4, targetClientRect } = this.state;\n\n    if (!target) {\n      return 0;\n    }\n    let rect: Required<HitRect>;\n\n    if (isNode(el)) {\n      const clientRect = el.getBoundingClientRect();\n\n      rect = {\n        left: clientRect.left,\n        top: clientRect.top,\n        width: clientRect.width,\n        height: clientRect.height,\n      };\n    } else {\n      rect = { width: 0, height: 0, ...el };\n    }\n\n    const {\n      left: rectLeft,\n      top: rectTop,\n      width: rectWidth,\n      height: rectHeight,\n    } = rect;\n    const points = fitPoints([pos1, pos2, pos4, pos3], targetClientRect);\n    const size = getOverlapSize(points, [\n      [rectLeft, rectTop],\n      [rectLeft + rectWidth, rectTop],\n      [rectLeft + rectWidth, rectTop + rectHeight],\n      [rectLeft, rectTop + rectHeight],\n    ]);\n    const totalSize = getAreaSize(points);\n\n    if (!size || !totalSize) {\n      return 0;\n    }\n\n    return Math.min(100, (size / totalSize) * 100);\n  }\n  /**\n   * Whether the coordinates are inside Moveable\n   * @method Moveable#isInside\n   * @param - x coordinate\n   * @param - y coordinate\n   * @return - True if the coordinate is in moveable or false\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * document.body.addEventListener(\"mousedown\", e => {\n   *     if (moveable.isInside(e.clientX, e.clientY)) {\n   *          console.log(\"inside\");\n   *     }\n   * });\n   */\n  public isInside(clientX: number, clientY: number) {\n    const { target, pos1, pos2, pos3, pos4, targetClientRect } = this.state;\n\n    if (!target) {\n      return false;\n    }\n    return isInside(\n      [clientX, clientY],\n      fitPoints([pos1, pos2, pos4, pos3], targetClientRect),\n    );\n  }\n  /**\n   * If the width, height, left, and top of all elements change, update the shape of the moveable.\n   * @method Moveable#updateRect\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * window.addEventListener(\"resize\", e => {\n   *     moveable.updateRect();\n   * });\n   */\n  public updateRect(\n    type?: 'Start' | '' | 'End',\n    isTarget?: boolean,\n    isSetState: boolean = true,\n  ) {\n    const props = this.props;\n    const isSingle = !props.parentPosition && !props.wrapperMoveable;\n\n    if (isSingle) {\n      setStoreCache(true);\n    }\n    const parentMoveable = props.parentMoveable;\n    const state = this.state;\n    const target = (state.target || props.target) as HTMLElement | SVGElement;\n    const container = this.getContainer();\n    const rootContainer = parentMoveable\n      ? (parentMoveable as any)._rootContainer\n      : this._rootContainer;\n    const nextState = getMoveableTargetInfo(\n      this.controlBox,\n      target,\n      container,\n      container,\n      rootContainer || container,\n      this._getRequestStyles(),\n    );\n\n    if (!target && this._hasFirstTarget && props.persistData) {\n      const persistState = getPersistState(props.persistData);\n\n      for (const name in persistState) {\n        (nextState as any)[name] = (persistState as any)[name];\n      }\n    }\n\n    if (isSingle) {\n      setStoreCache();\n    }\n    this.updateState(nextState, parentMoveable ? false : isSetState);\n  }\n  /**\n   * Check if the moveable state is being dragged.\n   * @method Moveable#isDragging\n   * @param - If you want to check if able is dragging, specify ableName.\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * // false\n   * console.log(moveable.isDragging());\n   *\n   * moveable.on(\"drag\", () => {\n   *   // true\n   *   console.log(moveable.isDragging());\n   * });\n   */\n  public isDragging(ableName?: string) {\n    const targetGesto = this.targetGesto;\n    const controlGesto = this.controlGesto;\n\n    if (targetGesto?.isFlag()) {\n      if (!ableName) {\n        return true;\n      }\n      const data = targetGesto.getEventData();\n\n      return !!data[ableName]?.isEventStart;\n    }\n    if (controlGesto?.isFlag()) {\n      if (!ableName) {\n        return true;\n      }\n      const data = controlGesto.getEventData();\n\n      return !!data[ableName]?.isEventStart;\n    }\n    return false;\n  }\n  /**\n   * If the width, height, left, and top of the only target change, update the shape of the moveable.\n   * Use `.updateRect()` method\n   * @method Moveable#updateTarget\n   * @deprecated\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * moveable.updateTarget();\n   */\n  public updateTarget(type?: 'Start' | '' | 'End') {\n    this.updateRect(type, true);\n  }\n  /**\n   * You can get the vertex information, position and offset size information of the target based on the container.\n   * @method Moveable#getRect\n   * @return - The Rect Info\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * const rectInfo = moveable.getRect();\n   */\n  public getRect(): RectInfo {\n    const state = this.state;\n    const poses = getAbsolutePosesByState(this.state);\n    const [pos1, pos2, pos3, pos4] = poses;\n    const rect = getRect(poses);\n    const { width: offsetWidth, height: offsetHeight } = state;\n    const { width, height, left, top } = rect;\n    const statePos = [state.left, state.top];\n    const origin = plus(statePos, state.origin);\n    const beforeOrigin = plus(statePos, state.beforeOrigin);\n    const transformOrigin = state.transformOrigin;\n\n    return {\n      width,\n      height,\n      left,\n      top,\n      pos1,\n      pos2,\n      pos3,\n      pos4,\n      offsetWidth,\n      offsetHeight,\n      beforeOrigin,\n      origin,\n      transformOrigin,\n      rotation: this.getRotation(),\n    };\n  }\n  /**\n   * Get a manager that manages the moveable's state and props.\n   * @method Moveable#getManager\n   * @return - The Rect Info\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * const manager = moveable.getManager(); // real moveable class instance\n   */\n  public getManager(): MoveableManagerInterface<any, any> {\n    return this as any;\n  }\n  /**\n   * You can stop the dragging currently in progress through a method from outside.\n   * @method Moveable#stopDrag\n   * @return - The Rect Info\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * moveable.stopDrag();\n   */\n  public stopDrag(type?: 'target' | 'control'): void {\n    if (!type || type === 'target') {\n      const gesto = this.targetGesto;\n\n      if (gesto?.isIdle() === false) {\n        unsetAbles(this, false);\n      }\n      gesto?.stop();\n    }\n    if (!type || type === 'control') {\n      const gesto = this.controlGesto;\n\n      if (gesto?.isIdle() === false) {\n        unsetAbles(this, true);\n      }\n      gesto?.stop();\n    }\n  }\n  public getRotation() {\n    const { pos1, pos2, direction } = this.state;\n\n    return getAbsoluteRotation(pos1, pos2, direction);\n  }\n  /**\n   * Request able through a method rather than an event.\n   * At the moment of execution, requestStart is executed,\n   * and then request and requestEnd can be executed through Requester.\n   * @method Moveable#request\n   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Draggable.html#request|Draggable Requester}\n   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Resizable.html#request|Resizable Requester}\n   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Scalable.html#request|Scalable Requester}\n   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Rotatable.html#request|Rotatable Requester}\n   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.OriginDraggable.html#request|OriginDraggable Requester}\n   * @param - ableName\n   * @param - request to be able params.\n   * @param - If isInstant is true, request and requestEnd are executed immediately.\n   * @return - Able Requester. If there is no request in able, nothing will work.\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * // Instantly Request (requestStart - request - requestEnd)\n   * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10 }, true);\n   *\n   * // Start move\n   * const requester = moveable.request(\"draggable\");\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * requester.requestEnd();\n   */\n  public request(\n    ableName: string,\n    param: IObject<any> = {},\n    isInstant?: boolean,\n  ): Requester {\n    const self = this;\n    const props = self.props;\n    const manager = props.parentMoveable || props.wrapperMoveable || self;\n    const allAbles = manager.props.ables!;\n    const groupable = props.groupable;\n    const requsetAble = find(allAbles, (able: Able) => able.name === ableName);\n\n    if (this.isDragging() || !requsetAble || !requsetAble.request) {\n      return {\n        request() {\n          return this;\n        },\n        requestEnd() {\n          return this;\n        },\n      };\n    }\n\n    const ableRequester = requsetAble.request(self);\n    const requestInstant = isInstant || param.isInstant;\n    const ableType = ableRequester.isControl ? 'controlAbles' : 'targetAbles';\n    const eventAffix = `${groupable ? 'Group' : ''}${ableRequester.isControl ? 'Control' : ''}`;\n    const moveableAbles: Able[] = [...manager[ableType]];\n\n    const requester = {\n      request(ableParam: IObject<any>) {\n        triggerAble(\n          self,\n          moveableAbles,\n          ['drag'],\n          eventAffix,\n          '',\n          {\n            ...ableRequester.request(ableParam),\n            requestAble: ableName,\n            isRequest: true,\n          },\n          requestInstant,\n        );\n        return requester;\n      },\n      requestEnd() {\n        triggerAble(\n          self,\n          moveableAbles,\n          ['drag'],\n          eventAffix,\n          'End',\n          {\n            ...ableRequester.requestEnd(),\n            requestAble: ableName,\n            isRequest: true,\n          },\n          requestInstant,\n        );\n        return requester;\n      },\n    };\n\n    triggerAble(\n      self,\n      moveableAbles,\n      ['drag'],\n      eventAffix,\n      'Start',\n      {\n        ...ableRequester.requestStart(param),\n        requestAble: ableName,\n        isRequest: true,\n      },\n      requestInstant,\n    );\n\n    return requestInstant ? requester.request(param).requestEnd() : requester;\n  }\n  /**\n   * moveable is the top level that manages targets\n   * `Single`: MoveableManager instance\n   * `Group`: MoveableGroup instance\n   * `IndividualGroup`: MoveableIndividaulGroup instance\n   * Returns leaf target MoveableManagers.\n   */\n  public getMoveables(): MoveableManagerInterface[] {\n    return [this];\n  }\n  /**\n   * Remove the Moveable object and the events.\n   * @method Moveable#destroy\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * moveable.destroy();\n   */\n  public destroy(): void {\n    this.componentWillUnmount();\n  }\n  public updateRenderPoses() {\n    const state = this.getState();\n    const props = this.props;\n    const padding = props.padding;\n    const {\n      originalBeforeOrigin,\n      transformOrigin,\n      allMatrix,\n      is3d,\n      pos1,\n      pos2,\n      pos3,\n      pos4,\n      left: stateLeft,\n      top: stateTop,\n      isPersisted,\n    } = state;\n    const zoom = props.zoom || 1;\n\n    if (!padding && zoom <= 1) {\n      state.renderPoses = [pos1, pos2, pos3, pos4];\n      state.renderLines = [\n        [pos1, pos2],\n        [pos2, pos4],\n        [pos4, pos3],\n        [pos3, pos1],\n      ];\n      return;\n    }\n    const { left, top, bottom, right } = getPaddingBox(padding || {});\n    const n = is3d ? 4 : 3;\n\n    // const clipPathInfo = getClipPath(\n    //     props.target,\n    //     offsetWidth,\n    //     offsetHeight,\n    // );\n\n    // if (clipPathInfo) {\n    //     left -= Math.max(0, clipPathInfo.left);\n    //     top -= Math.max(0, clipPathInfo.top);\n    //     bottom -= Math.max(0, offsetHeight - clipPathInfo.bottom);\n    //     right -= Math.max(0, offsetWidth - clipPathInfo.right);\n    // }\n\n    let absoluteOrigin: number[] = [];\n\n    if (isPersisted) {\n      absoluteOrigin = transformOrigin;\n    } else if (this.controlBox && props.groupable) {\n      absoluteOrigin = originalBeforeOrigin;\n    } else {\n      absoluteOrigin = plus(originalBeforeOrigin, [stateLeft, stateTop]);\n    }\n\n    const nextMatrix = multiplies(\n      n,\n      createOriginMatrix(\n        absoluteOrigin.map((v) => -v),\n        n,\n      ),\n      allMatrix,\n      createOriginMatrix(transformOrigin, n),\n    );\n\n    const renderPos1 = calculatePadding(nextMatrix, pos1, [-left, -top], n);\n    const renderPos2 = calculatePadding(nextMatrix, pos2, [right, -top], n);\n    const renderPos3 = calculatePadding(nextMatrix, pos3, [-left, bottom], n);\n    const renderPos4 = calculatePadding(nextMatrix, pos4, [right, bottom], n);\n\n    state.renderPoses = [renderPos1, renderPos2, renderPos3, renderPos4];\n    state.renderLines = [\n      [renderPos1, renderPos2],\n      [renderPos2, renderPos4],\n      [renderPos4, renderPos3],\n      [renderPos3, renderPos1],\n    ];\n\n    if (zoom) {\n      const zoomOffset = zoom / 2;\n\n      state.renderLines = [\n        [\n          calculatePadding(nextMatrix, pos1, [-left - zoomOffset, -top], n),\n          calculatePadding(nextMatrix, pos2, [right + zoomOffset, -top], n),\n        ],\n        [\n          calculatePadding(nextMatrix, pos2, [right, -top - zoomOffset], n),\n          calculatePadding(nextMatrix, pos4, [right, bottom + zoomOffset], n),\n        ],\n        [\n          calculatePadding(nextMatrix, pos4, [right + zoomOffset, bottom], n),\n          calculatePadding(nextMatrix, pos3, [-left - zoomOffset, bottom], n),\n        ],\n        [\n          calculatePadding(nextMatrix, pos3, [-left, bottom + zoomOffset], n),\n          calculatePadding(nextMatrix, pos1, [-left, -top - zoomOffset], n),\n        ],\n      ];\n    }\n  }\n  public checkUpdate() {\n    this._isPropTargetChanged = false;\n    const { target, container, parentMoveable } = this.props;\n    const { target: stateTarget, container: stateContainer } = this.state;\n\n    if (!stateTarget && !target) {\n      return;\n    }\n    this.updateAbles();\n\n    const isTargetChanged = !equals(stateTarget, target);\n    const isChanged = isTargetChanged || !equals(stateContainer, container);\n\n    if (!isChanged) {\n      return;\n    }\n    const moveableContainer = container || this.controlBox;\n\n    if (moveableContainer) {\n      this.unsetAbles();\n    }\n    this.updateState({ target, container });\n\n    if (!parentMoveable && moveableContainer) {\n      this.updateRect('End', false, false);\n    }\n    this._isPropTargetChanged = isTargetChanged;\n  }\n  public waitToChangeTarget(): Promise<void> {\n    return new Promise(() => {});\n  }\n  public triggerEvent(name: string, e: any): any {\n    const props = this.props;\n\n    this._emitter.trigger(name, e);\n\n    if (props.parentMoveable && e.isRequest && !e.isRequestChild) {\n      return props.parentMoveable.triggerEvent(name, e, true);\n    }\n\n    const callback = (props as any)[name];\n\n    return callback && callback(e);\n  }\n  public useCSS(tag: string, css: string) {\n    const customStyleMap = this.props.customStyledMap as Record<string, any>;\n\n    const key = tag + css;\n\n    if (!customStyleMap[key]) {\n      customStyleMap[key] = styled(tag, css);\n    }\n    return customStyleMap[key];\n  }\n  public checkUpdateRect = () => {\n    if (this.isDragging()) {\n      return;\n    }\n    const parentMoveable = this.props.parentMoveable;\n\n    if (parentMoveable) {\n      (parentMoveable as any).checkUpdateRect();\n      return;\n    }\n    cancelAnimationFrame(this._observerId);\n    this._observerId = requestAnimationFrame(() => {\n      if (this.isDragging()) {\n        return;\n      }\n      this.updateRect();\n    });\n  };\n  public getState(): MoveableManagerState {\n    const props = this.props;\n    if (props.target || (props as any).targets?.length) {\n      this._hasFirstTarget = true;\n    }\n    const hasControlBox = this.controlBox;\n    const persistData = props.persistData;\n    const firstRenderState = props.firstRenderState;\n\n    if (firstRenderState && !hasControlBox) {\n      return firstRenderState;\n    }\n    if (!this._hasFirstTarget && persistData) {\n      const persistState = getPersistState(persistData);\n\n      if (persistState) {\n        this.updateState(persistState, false);\n        return this.state;\n      }\n    }\n    (this.state as any).isPersisted = false;\n    return this.state;\n  }\n  public updateSelectors() {}\n  protected unsetAbles() {\n    this.targetAbles.forEach((able) => {\n      if (able.unset) {\n        able.unset(this);\n      }\n    });\n  }\n  protected updateAbles(\n    ables: Able[] = this.props.ables!,\n    eventAffix: string = '',\n  ) {\n    const props = this.props as any;\n    const triggerAblesSimultaneously = props.triggerAblesSimultaneously;\n    const enabledAbles = this.getEnabledAbles(ables);\n\n    const dragStart = `drag${eventAffix}Start` as 'dragStart';\n    const pinchStart = `pinch${eventAffix}Start` as 'pinchStart';\n    const dragControlStart =\n      `drag${eventAffix}ControlStart` as 'dragControlStart';\n\n    const targetAbles = filterAbles(\n      enabledAbles,\n      [dragStart, pinchStart],\n      triggerAblesSimultaneously,\n    );\n    const controlAbles = filterAbles(\n      enabledAbles,\n      [dragControlStart],\n      triggerAblesSimultaneously,\n    );\n\n    this.enabledAbles = enabledAbles;\n    this.targetAbles = targetAbles;\n    this.controlAbles = controlAbles;\n  }\n  protected updateState(nextState: any, isSetState?: boolean) {\n    if (isSetState) {\n      if (this.isUnmounted) {\n        return;\n      }\n      this.setState(nextState);\n    } else {\n      const state = this.state;\n\n      for (const name in nextState) {\n        (state as any)[name] = nextState[name];\n      }\n    }\n  }\n  protected getEnabledAbles(ables: Able[] = this.props.ables!) {\n    const props = this.props as any;\n\n    return ables.filter(\n      (able) =>\n        able &&\n        ((able.always && props[able.name] !== false) || props[able.name]),\n    );\n  }\n  protected renderAbles() {\n    const props = this.props as any;\n    const triggerAblesSimultaneously = props.triggerAblesSimultaneously;\n    const Renderer = {\n      createElement,\n    };\n\n    this.renderState = {};\n\n    return groupByMap(\n      flat<any>(\n        filterAbles(\n          this.getEnabledAbles(),\n          ['render'],\n          triggerAblesSimultaneously,\n        ).map(({ render }) => {\n          return render!(this, Renderer) || [];\n        }),\n      ).filter((el) => el),\n      ({ key }) => key,\n    ).map((group) => group[0]);\n  }\n  protected updateCheckInput() {\n    this.targetGesto &&\n      (this.targetGesto.options.checkInput = this.props.checkInput);\n  }\n  protected _getRequestStyles() {\n    const styleNames = this.getEnabledAbles().reduce(\n      (names, able) => {\n        const ableStyleNames = (able.requestStyle?.() ?? []) as Array<\n          keyof CSSStyleDeclaration\n        >;\n\n        return [...names, ...ableStyleNames];\n      },\n      [...(this.props.requestStyles || [])] as Array<keyof CSSStyleDeclaration>,\n    );\n\n    return styleNames;\n  }\n  protected _updateObserver(prevProps: MoveableDefaultOptions) {\n    this._updateResizeObserver(prevProps);\n    this._updateMutationObserver(prevProps);\n  }\n  protected _updateEvents() {\n    const hasTargetAble = this.targetAbles.length;\n    const hasControlAble = this.controlAbles.length;\n    const target = this._dragTarget;\n    const isUnset =\n      (!hasTargetAble && this.targetGesto) || this._isTargetChanged(true);\n\n    if (isUnset) {\n      unsetGesto(this, false);\n      this.updateState({ gestos: {} });\n    }\n    if (!hasControlAble) {\n      unsetGesto(this, true);\n    }\n\n    if (target && hasTargetAble && !this.targetGesto) {\n      this.targetGesto = getTargetAbleGesto(this, target!, '');\n    }\n    if (!this.controlGesto && hasControlAble) {\n      this.controlGesto = getControlAbleGesto(this, 'Control');\n    }\n  }\n  protected _updateTargets() {\n    const props = this.props;\n\n    this._prevPropTarget = this._propTarget;\n    this._prevDragTarget = this._dragTarget;\n    this._prevOriginalDragTarget = this._originalDragTarget;\n    this._prevDragArea = props.dragArea!;\n\n    this._propTarget = props.target;\n    this._originalDragTarget = props.dragTarget || props.target;\n    this._dragTarget = getRefTarget(this._originalDragTarget, true);\n  }\n  private _renderLines() {\n    const props = this.props;\n    const {\n      zoom,\n      hideDefaultLines,\n      hideChildMoveableDefaultLines,\n      parentMoveable,\n    } = props as MoveableManagerProps<GroupableProps>;\n\n    if (hideDefaultLines || (parentMoveable && hideChildMoveableDefaultLines)) {\n      return [];\n    }\n    const state = this.getState();\n    const Renderer = {\n      createElement,\n    };\n\n    return state.renderLines.map((line, i) => {\n      return renderLine(\n        Renderer,\n        '',\n        line[0],\n        line[1],\n        zoom!,\n        `render-line-${i}`,\n      );\n    });\n  }\n  private _onPreventClick = (e: any) => {\n    e.stopPropagation();\n    e.preventDefault();\n    // removeEvent(window, \"click\", this._onPreventClick, true);\n  };\n  private _isTargetChanged(useDragArea?: boolean) {\n    const props = this.props;\n    const nextTarget = props.dragTarget || props.target;\n    const prevTarget = this._prevOriginalDragTarget;\n    const prevDragArea = this._prevDragArea;\n    const dragArea = props.dragArea;\n\n    // check target without dragArea\n    const isDragTargetChanged = !dragArea && prevTarget !== nextTarget;\n    const isDragAreaChanged =\n      (useDragArea || dragArea) && prevDragArea !== dragArea;\n\n    return (\n      isDragTargetChanged ||\n      isDragAreaChanged ||\n      this._prevPropTarget != this._propTarget\n    );\n  }\n  private _updateNativeEvents() {\n    const props = this.props;\n    const target = props.dragArea ? this.areaElement : this.state.target;\n    const events = this.events;\n    const eventKeys = getKeys(events);\n\n    if (this._isTargetChanged()) {\n      for (const eventName in events) {\n        const manager = events[eventName];\n        manager && manager.destroy();\n        events[eventName] = null;\n      }\n    }\n    if (!target) {\n      return;\n    }\n    const enabledAbles = this.enabledAbles;\n    eventKeys.forEach((eventName) => {\n      const ables = filterAbles(enabledAbles, [eventName] as any);\n      const hasAbles = ables.length > 0;\n      let manager = events[eventName];\n\n      if (!hasAbles) {\n        if (manager) {\n          manager.destroy();\n          events[eventName] = null;\n        }\n        return;\n      }\n      if (!manager) {\n        manager = new EventManager(target, this, eventName);\n        events[eventName] = manager;\n      }\n      manager.setAbles(ables);\n    });\n  }\n  private _checkUpdateRootContainer() {\n    const rootContainer = this.props.rootContainer;\n\n    if (!this._rootContainer && rootContainer) {\n      this._rootContainer = getRefTarget(rootContainer, true);\n    }\n  }\n  private _checkUpdateViewContainer() {\n    const viewContainerOption = this.props.viewContainer;\n\n    if (!this._viewContainer && viewContainerOption) {\n      this._viewContainer = getRefTarget(viewContainerOption, true);\n    }\n    const viewContainer = this._viewContainer;\n\n    if (viewContainer) {\n      this._changeAbleViewClassNames([\n        ...this._getAbleViewClassNames(),\n        this.isDragging() ? VIEW_DRAGGING : '',\n      ]);\n    }\n  }\n  private _changeAbleViewClassNames(classNames: string[]) {\n    const viewContainer = this._viewContainer!;\n    const nextClassNames = groupBy(classNames.filter(Boolean), (el) => el).map(\n      ([className]) => className,\n    );\n    const prevClassNames = this._viewClassNames;\n\n    const { removed, added } = diff(prevClassNames, nextClassNames);\n\n    removed.forEach((index) => {\n      removeClass(viewContainer, prevClassNames[index]);\n    });\n    added.forEach((index) => {\n      addClass(viewContainer, nextClassNames[index]);\n    });\n\n    this._viewClassNames = nextClassNames;\n  }\n  private _getAbleViewClassNames() {\n    return (\n      this.getEnabledAbles()\n        .map((able) => {\n          return able.viewClassName?.(this) || '';\n        })\n        .join(' ') + ` ${this._getAbleClassName('-view')}`\n    ).split(/\\s+/g);\n  }\n  private _getAbleClassName(classPrefix = '') {\n    const ables = this.getEnabledAbles();\n\n    const targetGesto = this.targetGesto;\n    const controlGesto = this.controlGesto;\n    const targetGestoData: Record<string, any> = targetGesto?.isFlag()\n      ? targetGesto.getEventData()\n      : {};\n    const controlGestoData: Record<string, any> = controlGesto?.isFlag()\n      ? controlGesto.getEventData()\n      : {};\n\n    return ables\n      .map((able) => {\n        const name = able.name;\n        let className = able.className?.(this) || '';\n\n        if (\n          targetGestoData[name]?.isEventStart ||\n          controlGestoData[name]?.isEventStart\n        ) {\n          className += ` ${prefix(`${name}${classPrefix}-dragging`)}`;\n        }\n        return className.trim();\n      })\n      .filter(Boolean)\n      .join(' ');\n  }\n  private _updateResizeObserver(prevProps: MoveableDefaultOptions) {\n    const props = this.props;\n    const target = props.target;\n    const win = getWindow(this.getControlBoxElement());\n\n    if (!win.ResizeObserver || !target || !props.useResizeObserver) {\n      this._reiszeObserver?.disconnect();\n      return;\n    }\n\n    if (prevProps.target === target && this._reiszeObserver) {\n      return;\n    }\n\n    const observer = new win.ResizeObserver(this.checkUpdateRect);\n\n    observer.observe(target!, {\n      box: 'border-box',\n    });\n    this._reiszeObserver = observer;\n  }\n  private _updateMutationObserver(prevProps: MoveableDefaultOptions) {\n    const props = this.props;\n    const target = props.target;\n    const win = getWindow(this.getControlBoxElement());\n\n    if (!win.MutationObserver || !target || !props.useMutationObserver) {\n      this._mutationObserver?.disconnect();\n      return;\n    }\n\n    if (prevProps.target === target && this._mutationObserver) {\n      return;\n    }\n\n    const observer = new win.MutationObserver((records) => {\n      for (const mutation of records) {\n        if (\n          mutation.type === 'attributes' &&\n          mutation.attributeName === 'style'\n        ) {\n          this.checkUpdateRect();\n        }\n      }\n    });\n\n    observer.observe(target!, {\n      attributes: true,\n    });\n    this._mutationObserver = observer;\n  }\n}\n\n/**\n * The target to indicate Moveable Control Box.\n * @name Moveable#target\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.target = document.querySelector(\".target\");\n */\n/**\n * Zooms in the elements of a moveable.\n * @name Moveable#zoom\n * @default 1\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.zoom = 2;\n */\n\n/**\n * Whether the target size is detected and updated whenever it changes.\n * @name Moveable#useResizeObserver\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.useResizeObserver = true;\n */\n\n/**\n * Resize, Scale Events at edges\n * @name Moveable#edge\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.edge = true;\n */\n\n/**\n * You can specify the className of the moveable controlbox.\n * @name Moveable#className\n * @default \"\"\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   className: \"\",\n * });\n *\n * moveable.className = \"moveable1\";\n */\n\n/**\n * The target(s) to drag Moveable target(s)\n * @name Moveable#dragTarget\n * @default target\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.target = document.querySelector(\".target\");\n * moveable.dragTarget = document.querySelector(\".dragTarget\");\n */\n\n/**\n * `renderStart` event occurs at the first start of all events.\n * @memberof Moveable\n * @event renderStart\n * @param {Moveable.OnRenderStart} - Parameters for the `renderStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"renderStart\", ({ target }) => {\n *     console.log(\"onRenderStart\", target);\n * });\n */\n\n/**\n * `render` event occurs before the target is drawn on the screen.\n * @memberof Moveable\n * @event render\n * @param {Moveable.OnRender} - Parameters for the `render` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"render\", ({ target }) => {\n *     console.log(\"onRender\", target);\n * });\n */\n\n/**\n * `renderEnd` event occurs at the end of all events.\n * @memberof Moveable\n * @event renderEnd\n * @param {Moveable.OnRenderEnd} - Parameters for the `renderEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"renderEnd\", ({ target }) => {\n *     console.log(\"onRenderEnd\", target);\n * });\n */\n\n/**\n * `renderGroupStart` event occurs at the first start of all events in group.\n * @memberof Moveable\n * @event renderGroupStart\n * @param {Moveable.OnRenderGroupStart} - Parameters for the `renderGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroupStart\", ({ targets }) => {\n *     console.log(\"onRenderGroupStart\", targets);\n * });\n */\n\n/**\n * `renderGroup` event occurs before the target is drawn on the screen in group.\n * @memberof Moveable\n * @event renderGroup\n * @param {Moveable.OnRenderGroup} - Parameters for the `renderGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroup\", ({ targets }) => {\n *     console.log(\"onRenderGroup\", targets);\n * });\n */\n\n/**\n * `renderGroupEnd` event occurs at the end of all events in group.\n * @memberof Moveable\n * @event renderGroupEnd\n * @param {Moveable.OnRenderGroupEnd} - Parameters for the `renderGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroupEnd\", ({ targets }) => {\n *     console.log(\"onRenderGroupEnd\", targets);\n * });\n */\n", "import { minus } from '@scena/matrix';\nimport { refs } from '../utils/framework-utils';\nimport MoveableManager from '../MoveableManager';\nimport { renderLine } from '../render-directions';\nimport { Renderer, MoveableGroupInterface, GroupableProps } from '../types';\nimport { flat, watchValue } from '../utils';\n\nexport default {\n  name: 'groupable',\n  props: [\n    'defaultGroupRotate',\n    'useDefaultGroupRotate',\n    'defaultGroupOrigin',\n    'groupable',\n    'groupableProps',\n    'targetGroups',\n    'hideChildMoveableDefaultLines',\n  ] as const,\n  events: [] as const,\n  render(\n    moveable: MoveableGroupInterface<GroupableProps>,\n    React: Renderer,\n  ): any[] {\n    const props = moveable.props;\n    let targets: Array<HTMLElement | SVGElement | undefined | null> =\n      props.targets || [];\n\n    const { left, top, isPersisted } = moveable.getState();\n    const zoom = props.zoom || 1;\n    const renderGroupRects = moveable.renderGroupRects;\n    let persistDatChildren = props.persistData?.children || [];\n\n    if (isPersisted) {\n      targets = persistDatChildren.map(() => null);\n    } else {\n      persistDatChildren = [];\n    }\n    const parentPosition = watchValue(\n      moveable,\n      'parentPosition',\n      [left, top],\n      (styles) => styles.join(','),\n    );\n    const requestStyles = watchValue(\n      moveable,\n      'requestStyles',\n      moveable.getRequestChildStyles(),\n      (styles) => styles.join(','),\n    );\n\n    moveable.moveables = moveable.moveables.slice(0, targets.length);\n    return [\n      ...targets.map((target, i) => {\n        return (\n          <MoveableManager<GroupableProps>\n            key={'moveable' + i}\n            ref={refs(moveable, 'moveables', i)}\n            target={target}\n            origin={false}\n            requestStyles={requestStyles}\n            cssStyled={props.cssStyled}\n            customStyledMap={props.customStyledMap}\n            useResizeObserver={props.useResizeObserver}\n            useMutationObserver={props.useMutationObserver}\n            hideChildMoveableDefaultLines={props.hideChildMoveableDefaultLines}\n            parentMoveable={moveable}\n            parentPosition={[left, top]}\n            persistData={persistDatChildren[i]}\n            zoom={zoom}\n          />\n        );\n      }),\n      ...flat(\n        renderGroupRects.map(({ pos1, pos2, pos3, pos4 }, i) => {\n          const poses = [pos1, pos2, pos3, pos4];\n\n          return [\n            [0, 1],\n            [1, 3],\n            [3, 2],\n            [2, 0],\n          ].map(([from, to], j) => {\n            return renderLine(\n              React,\n              '',\n              minus(poses[from], parentPosition),\n              minus(poses[to], parentPosition),\n              zoom,\n              `group-rect-${i}-${j}`,\n            );\n          });\n        }),\n      ),\n    ];\n  },\n};\n", "import {\n    MoveableManagerInterface, MoveableGroupInterface,\n    ClickableProps, OnClick, OnClickGroup,\n} from \"../types\";\nimport { triggerEvent, fillParams } from \"../utils\";\nimport { findIndex } from \"@daybrush/utils\";\nimport { makeAble } from \"./AbleManager\";\n\nexport default makeAble(\"clickable\", {\n    props: [\n        \"clickable\",\n    ] as const,\n    events: [\n        \"click\",\n        \"clickGroup\",\n    ] as const,\n    always: true,\n    dragRelation: \"weak\",\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    dragStart() {\n        return;\n    },\n    dragControlStart() {\n        return;\n    },\n    dragGroupStart(moveable: MoveableManagerInterface<ClickableProps>, e: any) {\n        e.datas.inputTarget = e.inputEvent && e.inputEvent.target;\n    },\n    dragEnd(moveable: MoveableManagerInterface<ClickableProps>, e: any) {\n        const target = moveable.props.target!;\n        const inputEvent = e.inputEvent;\n        const inputTarget = e.inputTarget;\n        const isMoveableElement = moveable.isMoveableElement(inputTarget);\n        const containsElement = !isMoveableElement && moveable.controlBox.contains(inputTarget);\n\n        if (\n            !inputEvent || !inputTarget || e.isDrag\n            || moveable.isMoveableElement(inputTarget)\n            || containsElement\n            // External event duplicate target or dragAreaElement\n        ) {\n            return;\n        }\n        const containsTarget = target.contains(inputTarget);\n\n        triggerEvent(moveable, \"onClick\", fillParams<OnClick>(moveable, e, {\n            isDouble: e.isDouble,\n            inputTarget,\n            isTarget: target === inputTarget,\n            moveableTarget: moveable.props.target!,\n            containsTarget,\n        }));\n    },\n    dragGroupEnd(moveable: MoveableGroupInterface<ClickableProps>, e: any) {\n        const inputEvent = e.inputEvent;\n        const inputTarget = e.inputTarget;\n\n        if (\n            !inputEvent || !inputTarget || e.isDrag\n            || moveable.isMoveableElement(inputTarget)\n            // External event duplicate target or dragAreaElement\n            || e.datas.inputTarget === inputTarget\n        ) {\n            return;\n        }\n        const targets = moveable.props.targets!;\n        let targetIndex = targets.indexOf(inputTarget);\n        const isTarget = targetIndex > -1;\n        let containsTarget = false;\n\n        if (targetIndex === -1) {\n            targetIndex = findIndex(targets, parentTarget => parentTarget.contains(inputTarget));\n            containsTarget = targetIndex > -1;\n        }\n\n        triggerEvent(moveable, \"onClickGroup\", fillParams<OnClickGroup>(moveable, e, {\n            isDouble: e.isDouble,\n            targets,\n            inputTarget,\n            targetIndex,\n            isTarget,\n            containsTarget,\n            moveableTarget: targets[targetIndex],\n        }));\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<ClickableProps>, e: any) {\n        this.dragEnd(moveable, e);\n    },\n    dragGroupControlEnd(moveable: MoveableManagerInterface<ClickableProps>, e: any) {\n        this.dragEnd(moveable, e);\n    },\n});\n\n/**\n * When you click on the element, the `click` event is called.\n * @memberof Moveable\n * @event click\n * @param {Moveable.OnClick} - Parameters for the `click` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"click\", ({ hasTarget, containsTarget, targetIndex }) => {\n *     // If you click on an element other than the target and not included in the target, index is -1.\n *     console.log(\"onClickGroup\", target, hasTarget, containsTarget, targetIndex);\n * });\n */\n\n/**\n * When you click on the element inside the group, the `clickGroup` event is called.\n * @memberof Moveable\n * @event clickGroup\n * @param {Moveable.OnClickGroup} - Parameters for the `clickGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"clickGroup\", ({ inputTarget, isTarget, containsTarget, targetIndex }) => {\n *     // If you click on an element other than the target and not included in the target, index is -1.\n *     console.log(\"onClickGroup\", inputTarget, isTarget, containsTarget, targetIndex);\n * });\n */\n", "import { hasClass } from '@daybrush/utils';\nimport {\n  DraggableProps,\n  MoveableGroupInterface,\n  MoveableManagerInterface,\n  Renderer,\n} from '../types';\nimport { prefix } from '../utils';\nimport Draggable from './Draggable';\nimport { makeAble } from './AbleManager';\nimport { renderEdgeLines } from '../render-directions';\n\nfunction getDraggableEvent(e: any) {\n  let datas = e.originalDatas.draggable;\n  if (!datas) {\n    e.originalDatas.draggable = {};\n    datas = e.originalDatas.draggable;\n  }\n  return { ...e, datas };\n}\nexport default makeAble('edgeDraggable', {\n  css: [\n    `.edge.edgeDraggable.line {\ncursor: move;\n}`,\n  ],\n  render(moveable: MoveableManagerInterface<DraggableProps>, React: Renderer) {\n    const props = moveable.props;\n    const edge = props.edgeDraggable!;\n\n    if (!edge) {\n      return [];\n    }\n    return renderEdgeLines(\n      React,\n      'edgeDraggable',\n      edge,\n      moveable.getState().renderPoses,\n      props.zoom!,\n    );\n  },\n  dragCondition(moveable: MoveableManagerInterface<DraggableProps>, e: any) {\n    const props = moveable.props;\n    const target = e.inputEvent?.target;\n\n    if (!props.edgeDraggable || !target) {\n      return false;\n    }\n\n    return (\n      !props.draggable &&\n      hasClass(target, prefix('direction')) &&\n      hasClass(target, prefix('edge')) &&\n      hasClass(target, prefix('edgeDraggable'))\n    );\n  },\n  dragStart(moveable: MoveableManagerInterface<DraggableProps>, e: any) {\n    return Draggable.dragStart(moveable, getDraggableEvent(e));\n  },\n  drag(moveable: MoveableManagerInterface<DraggableProps>, e: any) {\n    return Draggable.drag(moveable, getDraggableEvent(e));\n  },\n  dragEnd(moveable: MoveableManagerInterface<DraggableProps, any>, e: any) {\n    return Draggable.dragEnd(moveable, getDraggableEvent(e));\n  },\n  dragGroupCondition(moveable: MoveableGroupInterface<DraggableProps>, e: any) {\n    const props = moveable.props;\n    const target = e.inputEvent?.target;\n\n    if (!props.edgeDraggable || !target) {\n      return false;\n    }\n    return (\n      !props.draggable &&\n      hasClass(target, prefix('direction')) &&\n      hasClass(target, prefix('line'))\n    );\n  },\n  dragGroupStart(moveable: MoveableGroupInterface<DraggableProps>, e: any) {\n    return Draggable.dragGroupStart(moveable, getDraggableEvent(e));\n  },\n  dragGroup(moveable: MoveableGroupInterface<DraggableProps>, e: any) {\n    return Draggable.dragGroup(moveable, getDraggableEvent(e));\n  },\n  dragGroupEnd(moveable: MoveableGroupInterface<DraggableProps, any>, e: any) {\n    return Draggable.dragGroupEnd(moveable, getDraggableEvent(e));\n  },\n  unset(moveable: any) {\n    return Draggable.unset(moveable);\n  },\n});\n\n/**\n * Whether to move by dragging the edge line (default: false)\n * @name Moveable.Draggable#edgeDraggable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  draggable: true,\n *  edgeDraggable: false,\n * });\n *\n * moveable.edgeDraggable = true;\n */\n", "export default {\n    name: \"individualGroupable\",\n    props: [\n        \"individualGroupable\",\n        \"individualGroupableProps\",\n    ] as const,\n    events: [] as const,\n} as const;\n", "import Pinchable from \"./Pinchable\";\nimport Rotatable from \"./Rotatable\";\nimport Draggable from \"./Draggable\";\nimport Resizable from \"./Resizable\";\nimport Scalable from \"./Scalable\";\nimport Warpable from \"./Warpable\";\nimport Snappable from \"./Snappable\";\nimport DragArea from \"./DragArea\";\nimport Origin from \"./Origin\";\nimport Scrollable from \"./Scrollable\";\nimport Default from \"./Default\";\nimport Padding from \"./Padding\";\nimport Clippable from \"./Clippable\";\nimport OriginDraggable from \"./OriginDraggable\";\nimport Roundable from \"./Roundable\";\nimport Groupable from \"./Groupable\";\nimport BeforeRenderable from \"./BeforeRenderable\";\nimport Renderable from \"./Renderable\";\nimport Clickable from \"./Clickable\";\nimport edgeDraggable from \"./edgeDraggable\";\nimport IndividualGroupable from \"./IndividualGroupable\";\nimport { camelize, pushSet } from \"@daybrush/utils\";\nimport { Able } from \"../types\";\n\nexport const MOVEABLE_ABLES = /*#__PURE__*/[\n    BeforeRenderable,\n    Default, Snappable, Pinchable,\n    Draggable, edgeDraggable,\n    Resizable, Scalable, Warpable, Rotatable,\n    Scrollable, Padding, Origin,\n    OriginDraggable,\n    Clippable, Roundable, Groupable, IndividualGroupable,\n    Clickable,\n    DragArea,\n    Renderable,\n] as const;\n\n\nexport const MOVEABLE_EVENTS = /*#__PURE__*/(MOVEABLE_ABLES as readonly Able[]).reduce((current, able) => {\n    (able.events || []).forEach(name => {\n        pushSet(current, name);\n    });\n    return current;\n}, [] as any[]) as Array<typeof MOVEABLE_ABLES[number][\"events\"][number]>;\n\nexport const MOVEABLE_PROPS = /*#__PURE__*/(MOVEABLE_ABLES as readonly Able[]).reduce((current, able) => {\n    (able.props || []).forEach(name => {\n        pushSet(current, name);\n    });\n    return current;\n}, [] as any[]) as Array<typeof MOVEABLE_ABLES[number][\"props\"][number]>;\n\n\nexport const MOVEABLE_REACT_EVENTS = /*#__PURE__*/MOVEABLE_EVENTS.map(name => {\n    return camelize(`on ${name}`);\n}) as Array<`on${Capitalize<typeof MOVEABLE_ABLES[number][\"events\"][number]>}`>;\n\n", "export function solveConstantsDistance(\n    [a, b, c]: [number, number, number],\n    pos: number[],\n) {\n    return (a * pos[0] + b * pos[1] + c) / Math.sqrt(a * a + b * b);\n}\n\nexport function solveC(\n    [a, b]: [number, number],\n    pos: number[],\n) {\n    // ax + by + c = 0\n    // -ax -by;\n    return -a * pos[0] - b * pos[1];\n}\n", "import MoveableManager from './MoveableManager';\nimport {\n  GroupableProps,\n  GroupRect,\n  MoveableManagerInterface,\n  MoveableTargetGroupsType,\n  RectInfo,\n} from './types';\nimport ChildrenDiffer from '@egjs/children-differ';\nimport { getControlAbleGesto, getTargetAbleGesto } from './gesto/getAbleGesto';\nimport Groupable from './ables/Groupable';\nimport { MIN_NUM, MAX_NUM, TINY_NUM } from './consts';\nimport {\n  getAbsolutePosesByState,\n  equals,\n  unsetGesto,\n  rotatePosesInfo,\n  convertTransformOriginArray,\n  isDeepArrayEquals,\n  sign,\n  getRefTarget,\n} from './utils';\nimport { minus, plus } from '@scena/matrix';\nimport { getIntersectionPointsByConstants, getMinMaxs } from 'overlap-area';\nimport { find, isArray, throttle } from '@daybrush/utils';\nimport { getMoveableTargetInfo } from './utils/getMoveableTargetInfo';\nimport { solveC, solveConstantsDistance } from './snappable/utils';\nimport { setStoreCache } from './store/Store';\n\nfunction getMaxPos(poses: number[][][], index: number) {\n  return Math.max(\n    ...poses.map(([pos1, pos2, pos3, pos4]) => {\n      return Math.max(pos1[index], pos2[index], pos3[index], pos4[index]);\n    }),\n  );\n}\nfunction getMinPos(poses: number[][][], index: number) {\n  return Math.min(\n    ...poses.map(([pos1, pos2, pos3, pos4]) => {\n      return Math.min(pos1[index], pos2[index], pos3[index], pos4[index]);\n    }),\n  );\n}\n\nfunction getGroupRect(parentPoses: number[][][], rotation: number): GroupRect {\n  let pos1 = [0, 0];\n  let pos2 = [0, 0];\n  let pos3 = [0, 0];\n  let pos4 = [0, 0];\n  let width = 0;\n  let height = 0;\n\n  if (!parentPoses.length) {\n    return {\n      pos1,\n      pos2,\n      pos3,\n      pos4,\n      minX: 0,\n      minY: 0,\n      maxX: 0,\n      maxY: 0,\n      width,\n      height,\n      rotation,\n    };\n  }\n  const fixedRotation = throttle(rotation, TINY_NUM);\n\n  if (fixedRotation % 90) {\n    const rad = (fixedRotation / 180) * Math.PI;\n    const a1 = Math.tan(rad);\n    const a2 = -1 / a1;\n    // ax = y  // -ax + y = 0 // 0 => 1\n    // -ax = y // ax + y = 0  // 0 => 3\n    const a1MinMax = [MAX_NUM, MIN_NUM];\n    const a1MinMaxPos = [\n      [0, 0],\n      [0, 0],\n    ];\n    const a2MinMax = [MAX_NUM, MIN_NUM];\n    const a2MinMaxPos = [\n      [0, 0],\n      [0, 0],\n    ];\n\n    parentPoses.forEach((poses) => {\n      poses.forEach((pos) => {\n        // const b1 = pos[1] - a1 * pos[0];\n        // const b2 = pos[1] - a2 * pos[0];\n\n        const a1Dist = solveConstantsDistance([-a1, 1, 0], pos);\n        const a2Dist = solveConstantsDistance([-a2, 1, 0], pos);\n\n        if (a1MinMax[0] > a1Dist) {\n          a1MinMaxPos[0] = pos;\n          a1MinMax[0] = a1Dist;\n        }\n        if (a1MinMax[1] < a1Dist) {\n          a1MinMaxPos[1] = pos;\n          a1MinMax[1] = a1Dist;\n        }\n        if (a2MinMax[0] > a2Dist) {\n          a2MinMaxPos[0] = pos;\n          a2MinMax[0] = a2Dist;\n        }\n        if (a2MinMax[1] < a2Dist) {\n          a2MinMaxPos[1] = pos;\n          a2MinMax[1] = a2Dist;\n        }\n      });\n    });\n\n    const [a1MinPos, a1MaxPos] = a1MinMaxPos;\n    const [a2MinPos, a2MaxPos] = a2MinMaxPos;\n\n    const minHorizontalLine = [-a1, 1, solveC([-a1, 1], a1MinPos)];\n    const maxHorizontalLine = [-a1, 1, solveC([-a1, 1], a1MaxPos)];\n\n    const minVerticalLine = [-a2, 1, solveC([-a2, 1], a2MinPos)];\n    const maxVerticalLine = [-a2, 1, solveC([-a2, 1], a2MaxPos)];\n\n    [pos1, pos2, pos3, pos4] = [\n      [minHorizontalLine, minVerticalLine],\n      [minHorizontalLine, maxVerticalLine],\n      [maxHorizontalLine, minVerticalLine],\n      [maxHorizontalLine, maxVerticalLine],\n    ].map(\n      ([line1, line2]) => getIntersectionPointsByConstants(line1, line2)[0],\n    );\n\n    width = a2MinMax[1] - a2MinMax[0];\n    height = a1MinMax[1] - a1MinMax[0];\n  } else {\n    const minX = getMinPos(parentPoses, 0);\n    const minY = getMinPos(parentPoses, 1);\n    const maxX = getMaxPos(parentPoses, 0);\n    const maxY = getMaxPos(parentPoses, 1);\n\n    pos1 = [minX, minY];\n    pos2 = [maxX, minY];\n    pos3 = [minX, maxY];\n    pos4 = [maxX, maxY];\n    width = maxX - minX;\n    height = maxY - minY;\n    if (fixedRotation % 180) {\n      // 0\n      // 1 2\n      // 3 4\n      // 90\n      // 3 1\n      // 4 2\n      // 180\n      // 4 3\n      // 2 1\n      // 270\n      // 2 4\n      // 1 3\n      // 1, 2, 3,4 = 3 1 4 2\n      const changedX = [pos3, pos1, pos4, pos2];\n\n      [pos1, pos2, pos3, pos4] = changedX;\n      width = maxY - minY;\n      height = maxX - minX;\n    }\n  }\n  if (fixedRotation % 360 > 180) {\n    // 1 2   4 3\n    // 3 4   2 1\n    const changedX = [pos4, pos3, pos2, pos1];\n\n    [pos1, pos2, pos3, pos4] = changedX;\n  }\n  const { minX, minY, maxX, maxY } = getMinMaxs([pos1, pos2, pos3, pos4]);\n\n  return {\n    pos1,\n    pos2,\n    pos3,\n    pos4,\n    width,\n    height,\n    minX,\n    minY,\n    maxX,\n    maxY,\n    rotation,\n  };\n}\ntype SelfGroup = Array<MoveableManager | null | SelfGroup>;\ntype CheckedMoveableManager = { finded: boolean; manager: MoveableManager };\n\nfunction findMoveableGroups(\n  moveables: CheckedMoveableManager[],\n  childTargetGroups: MoveableTargetGroupsType,\n): SelfGroup {\n  const groups = childTargetGroups\n    .map((targetGroup) => {\n      if (isArray(targetGroup)) {\n        const childMoveableGroups = findMoveableGroups(moveables, targetGroup);\n        const length = childMoveableGroups.length;\n\n        if (length > 1) {\n          return childMoveableGroups;\n        } else if (length === 1) {\n          return childMoveableGroups[0];\n        } else {\n          return null;\n        }\n      } else {\n        const checked = find(\n          moveables,\n          ({ manager }) => manager.props.target === targetGroup,\n        )!;\n\n        if (checked) {\n          checked.finded = true;\n          return checked.manager;\n        }\n        return null;\n      }\n    })\n    .filter(Boolean);\n\n  if (groups.length === 1 && isArray(groups[0])) {\n    return groups[0];\n  }\n  return groups;\n}\n\n/**\n * @namespace Moveable.Group\n * @description You can make targets moveable.\n */\nclass MoveableGroup extends MoveableManager<GroupableProps> {\n  public static defaultProps = {\n    ...MoveableManager.defaultProps,\n    transformOrigin: ['50%', '50%'],\n    groupable: true,\n    dragArea: true,\n    keepRatio: true,\n    targets: [],\n    defaultGroupRotate: 0,\n    defaultGroupOrigin: '50% 50%',\n  };\n  public differ: ChildrenDiffer<HTMLElement | SVGElement> =\n    new ChildrenDiffer();\n  public moveables: MoveableManager[] = [];\n  public transformOrigin = '50% 50%';\n  public renderGroupRects: GroupRect[] = [];\n  private _targetGroups: MoveableTargetGroupsType = [];\n  private _hasFirstTargets = false;\n\n  public componentDidMount() {\n    super.componentDidMount();\n  }\n  public checkUpdate() {\n    this._isPropTargetChanged = false;\n    this.updateAbles();\n  }\n  public getTargets() {\n    return this.props.targets!;\n  }\n  public updateRect(\n    type?: 'Start' | '' | 'End',\n    isTarget?: boolean,\n    isSetState = true,\n  ) {\n    const state = this.state;\n\n    if (!this.controlBox || state.isPersisted) {\n      return;\n    }\n    setStoreCache(true);\n    this.moveables.forEach((moveable) => {\n      moveable.updateRect(type, false, false);\n    });\n\n    const props = this.props;\n    const moveables = this.moveables;\n    const target = state.target! || props.target!;\n    const checkeds = moveables.map((moveable) => ({\n      finded: false,\n      manager: moveable,\n    }));\n    const targetGroups = this.props.targetGroups || [];\n    const moveableGroups = findMoveableGroups(checkeds, targetGroups);\n    const useDefaultGroupRotate = props.useDefaultGroupRotate;\n\n    moveableGroups.push(\n      ...checkeds.filter(({ finded }) => !finded).map(({ manager }) => manager),\n    );\n\n    const renderGroupRects: GroupRect[] = [];\n    const isReset = !isTarget || (type !== '' && props.updateGroup);\n    let defaultGroupRotate = props.defaultGroupRotate || 0;\n\n    if (!this._hasFirstTargets) {\n      const persistedRoatation = props.persistData?.rotation;\n\n      if (persistedRoatation != null) {\n        defaultGroupRotate = persistedRoatation;\n      }\n    }\n\n    function getMoveableGroupRect(\n      group: SelfGroup,\n      parentRotation: number,\n      isRoot?: boolean,\n    ): GroupRect {\n      const posesRotations = group.map((moveable) => {\n        if (isArray(moveable)) {\n          const rect = getMoveableGroupRect(moveable, parentRotation);\n          const poses = [rect.pos1, rect.pos2, rect.pos3, rect.pos4];\n\n          renderGroupRects.push(rect);\n          return { poses, rotation: rect.rotation };\n        } else {\n          return {\n            poses: getAbsolutePosesByState(moveable!.state),\n            rotation: moveable!.getRotation(),\n          };\n        }\n      });\n      const rotations = posesRotations.map(({ rotation }) => rotation);\n\n      let groupRotation = 0;\n      const firstRotation = rotations[0];\n      const isSameRotation = rotations.every((nextRotation) => {\n        return Math.abs(firstRotation - nextRotation) < 0.1;\n      });\n\n      if (isReset) {\n        groupRotation =\n          !useDefaultGroupRotate && isSameRotation\n            ? firstRotation\n            : defaultGroupRotate;\n      } else {\n        groupRotation =\n          !useDefaultGroupRotate && !isRoot && isSameRotation\n            ? firstRotation\n            : parentRotation;\n      }\n      const groupPoses = posesRotations.map(({ poses }) => poses);\n      const groupRect = getGroupRect(groupPoses, groupRotation);\n\n      return groupRect;\n    }\n    const rootGroupRect = getMoveableGroupRect(\n      moveableGroups,\n      this.rotation,\n      true,\n    );\n\n    if (isReset) {\n      // reset rotataion\n      this.rotation = rootGroupRect.rotation;\n      this.transformOrigin = props.defaultGroupOrigin || '50% 50%';\n      this.scale = [1, 1];\n    }\n\n    this._targetGroups = targetGroups;\n    this.renderGroupRects = renderGroupRects;\n    const transformOrigin = this.transformOrigin;\n    const rotation = this.rotation;\n    const scale = this.scale;\n    const { width, height, minX, minY } = rootGroupRect;\n    const posesInfo = rotatePosesInfo(\n      [\n        [0, 0],\n        [width, 0],\n        [0, height],\n        [width, height],\n      ],\n      convertTransformOriginArray(transformOrigin, width, height),\n      (this.rotation / 180) * Math.PI,\n    );\n\n    const { minX: deltaX, minY: deltaY } = getMinMaxs(posesInfo.result);\n    const rotateScale =\n      ` rotate(${rotation}deg)` +\n      ` scale(${sign(scale[0])}, ${sign(scale[1])})`;\n    const transform = `translate(${-deltaX}px, ${-deltaY}px)${rotateScale}`;\n\n    this.controlBox.style.transform = `translate3d(${minX}px, ${minY}px, ${this.props.translateZ || 0})`;\n\n    target.style.cssText +=\n      `left:0px;top:0px;` +\n      `transform-origin:${transformOrigin};` +\n      `width:${width}px;height:${height}px;` +\n      `transform: ${transform}`;\n    state.width = width;\n    state.height = height;\n\n    const container = this.getContainer();\n    const info = getMoveableTargetInfo(\n      this.controlBox,\n      target,\n      this.controlBox,\n      this.getContainer(),\n      this._rootContainer || container,\n      [],\n    );\n    const pos = [info.left!, info.top!];\n    const [pos1, pos2, pos3, pos4] = getAbsolutePosesByState(info); // info.left + info.pos(1 ~ 4)\n\n    const minPos = getMinMaxs([pos1, pos2, pos3, pos4]);\n    const delta = [minPos.minX, minPos.minY];\n    const direction = sign(scale[0] * scale[1]);\n\n    info.pos1 = minus(pos1, delta);\n    info.pos2 = minus(pos2, delta);\n    info.pos3 = minus(pos3, delta);\n    info.pos4 = minus(pos4, delta);\n    // info.left = info.left + delta[0];\n    // info.top = info.top + delta[1];\n    info.left = minX - info.left! + delta[0];\n    info.top = minY - info.top! + delta[1];\n    info.origin = minus(plus(pos, info.origin!), delta);\n    info.beforeOrigin = minus(plus(pos, info.beforeOrigin!), delta);\n    info.originalBeforeOrigin = plus(pos, info.originalBeforeOrigin!);\n    info.transformOrigin = minus(plus(pos, info.transformOrigin!), delta);\n    target.style.transform =\n      `translate(${-deltaX - delta[0]}px, ${-deltaY - delta[1]}px)` +\n      rotateScale;\n\n    setStoreCache();\n    this.updateState(\n      {\n        ...info,\n        posDelta: delta,\n        direction,\n        beforeDirection: direction,\n      },\n      isSetState,\n    );\n  }\n  public getRect(): RectInfo {\n    return {\n      ...super.getRect(),\n      children: this.moveables.map((child) => child.getRect()),\n    };\n  }\n  public triggerEvent(name: string, e: any, isManager?: boolean): any {\n    if (isManager || name.indexOf('Group') > -1) {\n      return super.triggerEvent(name as any, e);\n    } else {\n      this._emitter.trigger(name, e);\n    }\n  }\n  public getRequestChildStyles() {\n    const styleNames = this.getEnabledAbles().reduce(\n      (names, able) => {\n        const ableStyleNames = (able.requestChildStyle?.() ?? []) as Array<\n          keyof CSSStyleDeclaration\n        >;\n\n        return [...names, ...ableStyleNames];\n      },\n      [] as Array<keyof CSSStyleDeclaration>,\n    );\n\n    return styleNames;\n  }\n\n  public getMoveables(): MoveableManagerInterface[] {\n    return [...this.moveables];\n  }\n  protected updateAbles() {\n    super.updateAbles([...this.props.ables!, Groupable], 'Group');\n  }\n  protected _updateTargets() {\n    super._updateTargets();\n    this._originalDragTarget = this.props.dragTarget || this.areaElement;\n    this._dragTarget = getRefTarget(this._originalDragTarget, true);\n  }\n  protected _updateEvents() {\n    const state = this.state;\n    const props = this.props;\n\n    const prevTarget = this._prevDragTarget;\n    const nextTarget = props.dragTarget || this.areaElement;\n    const targets = props.targets!;\n    const { added, changed, removed } = this.differ.update(targets);\n    const isTargetChanged = added.length || removed.length;\n\n    if (\n      isTargetChanged ||\n      this._prevOriginalDragTarget !== this._originalDragTarget\n    ) {\n      unsetGesto(this, false);\n      unsetGesto(this, true);\n      this.updateState({ gestos: {} });\n    }\n    if (prevTarget !== nextTarget) {\n      state.target = null;\n    }\n    if (!state.target) {\n      state.target = this.areaElement;\n      this.controlBox.style.display = 'block';\n    }\n    if (state.target) {\n      if (!this.targetGesto) {\n        this.targetGesto = getTargetAbleGesto(this, this._dragTarget!, 'Group');\n      }\n      if (!this.controlGesto) {\n        this.controlGesto = getControlAbleGesto(this, 'GroupControl');\n      }\n    }\n    const isContainerChanged = !equals(state.container, props.container);\n\n    if (isContainerChanged) {\n      state.container = props.container;\n    }\n\n    if (\n      isContainerChanged ||\n      isTargetChanged ||\n      this.transformOrigin !== (props.defaultGroupOrigin || '50% 50%') ||\n      changed.length ||\n      (targets.length &&\n        !isDeepArrayEquals(this._targetGroups, props.targetGroups || []))\n    ) {\n      this.updateRect();\n      this._hasFirstTargets = true;\n    }\n    this._isPropTargetChanged = !!isTargetChanged;\n  }\n  protected _updateObserver() {}\n}\n\n/**\n * Sets the initial rotation of the group.\n * @name Moveable.Group#defaultGroupRotate\n * @default 0\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   target: [].slice.call(document.querySelectorAll(\".target\")),\n *   defaultGroupRotate: 0,\n * });\n *\n * moveable.defaultGroupRotate = 40;\n */\n\n/**\n * Sets the initial origin of the group.\n * @name Moveable.Group#defaultGroupOrigin\n * @default 0\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   target: [].slice.call(document.querySelectorAll(\".target\")),\n *   defaultGroupOrigin: \"50% 50%\",\n * });\n *\n * moveable.defaultGroupOrigin = \"20% 40%\";\n */\n\n/**\n * Whether to hide the line in child moveable for group corresponding to the rect of the target.\n * @name Moveable.Group#hideChildMoveableDefaultLines\n * @default false\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   target: [].slice.call(document.querySelectorAll(\".target\")),\n *   hideChildMoveableDefaultLines: false,\n * });\n *\n * moveable.hideChildMoveableDefaultLines = true;\n */\nexport default MoveableGroup;\n", "import { ref, refs } from './utils/framework-utils';\nimport * as React from 'react';\nimport MoveableManager from './MoveableManager';\nimport {\n  GroupableProps,\n  IndividualGroupableProps,\n  MoveableManagerInterface,\n  RectInfo,\n  Requester,\n} from './types';\nimport { prefix } from './utils';\nimport { setStoreCache } from './store/Store';\nimport { find } from '@daybrush/utils';\n\n/**\n * @namespace Moveable.IndividualGroup\n * @description Create targets individually, not as a group.Create targets individually, not as a group.\n */\nclass MoveableIndividualGroup extends MoveableManager<\n  GroupableProps & IndividualGroupableProps\n> {\n  public moveables: MoveableManager[] = [];\n  public render() {\n    const props = this.props;\n    const { cspNonce, cssStyled: ControlBoxElement, persistData } = props;\n\n    let targets: Array<HTMLElement | SVGElement | null | undefined> =\n      props.targets || [];\n    const length = targets.length;\n    const canPersist = this.isUnmounted || !length;\n    let persistDatChildren = persistData?.children ?? [];\n\n    if (canPersist && !length && persistDatChildren.length) {\n      targets = persistDatChildren.map(() => null);\n    } else if (!canPersist) {\n      persistDatChildren = [];\n    }\n\n    return (\n      <ControlBoxElement\n        cspNonce={cspNonce}\n        ref={ref(this, 'controlBox')}\n        className={prefix('control-box')}\n      >\n        {targets!.map((target, i) => {\n          const individualProps =\n            props.individualGroupableProps?.(target, i) ?? {};\n          return (\n            <MoveableManager\n              key={'moveable' + i}\n              ref={refs(this, 'moveables', i)}\n              {...props}\n              {...individualProps}\n              target={target}\n              wrapperMoveable={this}\n              isWrapperMounted={this.isMoveableMounted}\n              persistData={persistDatChildren[i]}\n            />\n          );\n        })}\n      </ControlBoxElement>\n    );\n  }\n  public componentDidMount() {}\n  public componentDidUpdate() {}\n  public getTargets() {\n    return this.props.targets!;\n  }\n  public updateRect(\n    type?: 'Start' | '' | 'End',\n    isTarget?: boolean,\n    isSetState: boolean = true,\n  ) {\n    setStoreCache(true);\n    this.moveables.forEach((moveable) => {\n      moveable.updateRect(type, isTarget, isSetState);\n    });\n    setStoreCache();\n  }\n  public getRect(): RectInfo {\n    return {\n      ...super.getRect(),\n      children: this.moveables.map((child) => child.getRect()),\n    };\n  }\n  public request(\n    ableName: string,\n    param: Record<string, any> = {},\n    isInstant?: boolean,\n  ): Requester {\n    const results = this.moveables.map((m) =>\n      m.request(ableName, { ...param, isInstant: false }, false),\n    );\n    const requestInstant = isInstant || param.isInstant;\n    const requester: Requester = {\n      request(ableParam: Record<string, any>) {\n        results.forEach((r) => r.request(ableParam));\n        return this;\n      },\n      requestEnd() {\n        results.forEach((r) => r.requestEnd());\n        return this;\n      },\n    };\n    return requestInstant ? requester.request(param).requestEnd() : requester;\n  }\n  public dragStart(\n    e: MouseEvent | TouchEvent,\n    target: EventTarget | null = e.target,\n  ) {\n    const inputTarget = target as HTMLElement;\n    const childMoveable = find(this.moveables, (child) => {\n      const target = child.getTargets()[0];\n      const controlBoxElement = child.getControlBoxElement();\n      const dragElement = child.getDragElement();\n\n      if (!target || !dragElement) {\n        return false;\n      }\n      return (\n        dragElement === inputTarget ||\n        dragElement.contains(inputTarget) ||\n        (dragElement !== target && target === inputTarget) ||\n        target.contains(inputTarget) ||\n        controlBoxElement === inputTarget ||\n        controlBoxElement.contains(inputTarget)\n      );\n    });\n\n    if (childMoveable) {\n      childMoveable.dragStart(e, target);\n    }\n    return this;\n  }\n  public hitTest() {\n    return 0;\n  }\n  public isInside() {\n    return false;\n  }\n  public isDragging() {\n    return false;\n  }\n  public getDragElement() {\n    return null;\n  }\n  public getMoveables(): MoveableManagerInterface[] {\n    return [...this.moveables];\n  }\n  public updateRenderPoses() {}\n  public checkUpdate() {}\n  public triggerEvent() {}\n  protected updateAbles() {}\n  protected _updateEvents() {}\n  protected _updateObserver() {}\n}\n\n/**\n * Create targets individually, not as a group.\n * @name Moveable.IndividualGroup#individualGroupable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   target: [].slice.call(document.querySelectorAll(\".target\")),\n *   individualGroupable: true,\n * });\n */\nexport default MoveableIndividualGroup;\n", "import * as React from 'react';\nimport {\n  Able,\n  MoveableInterface,\n  GroupableProps,\n  MoveableDefaultProps,\n  IndividualGroupableProps,\n  MoveableManagerInterface,\n  MoveableRefTargetsResultType,\n  MoveableTargetGroupsType,\n  BeforeRenderableProps,\n  RenderableProps,\n  MoveableManagerState,\n} from './types';\nimport MoveableManager from './MoveableManager';\nimport MoveableGroup from './MoveableGroup';\nimport { ref, prefixCSS } from './utils/framework-utils';\nimport { find, getKeys, IObject, isArray, isString } from '@daybrush/utils';\nimport { MOVEABLE_METHODS, PREFIX, MOVEABLE_CSS } from './consts';\nimport Default from './ables/Default';\nimport Groupable from './ables/Groupable';\nimport DragArea from './ables/DragArea';\nimport { styled } from 'react-css-styled';\nimport { getRefTargets } from './utils';\nimport IndividualGroupable from './ables/IndividualGroupable';\nimport MoveableIndividualGroup from './MoveableIndividualGroup';\nimport ChildrenDiffer from '@egjs/children-differ';\n\nfunction getElementTargets(\n  refTargets: MoveableRefTargetsResultType,\n  selectorMap: IObject<Array<HTMLElement | SVGElement>>,\n): Array<SVGElement | HTMLElement> {\n  const elementTargets: Array<SVGElement | HTMLElement> = [];\n\n  refTargets.forEach((target) => {\n    if (!target) {\n      return;\n    }\n    if (isString(target)) {\n      if (selectorMap[target]) {\n        elementTargets.push(...selectorMap[target]);\n      }\n      return;\n    }\n    if (isArray(target)) {\n      elementTargets.push(...getElementTargets(target, selectorMap));\n    } else {\n      elementTargets.push(target);\n    }\n  });\n\n  return elementTargets;\n}\n\nfunction getTargetGroups(\n  refTargets: MoveableRefTargetsResultType,\n  selectorMap: IObject<Array<HTMLElement | SVGElement>>,\n) {\n  const targetGroups: MoveableTargetGroupsType = [];\n\n  refTargets.forEach((target) => {\n    if (!target) {\n      return;\n    }\n    if (isString(target)) {\n      if (selectorMap[target]) {\n        targetGroups.push(...selectorMap[target]);\n      }\n      return;\n    }\n    if (isArray(target)) {\n      targetGroups.push(getTargetGroups(target, selectorMap));\n    } else {\n      targetGroups.push(target);\n    }\n  });\n\n  return targetGroups;\n}\n\nfunction compareRefTargets(\n  prevRefTargets: MoveableRefTargetsResultType,\n  nextRefTargets: MoveableRefTargetsResultType,\n): boolean {\n  return (\n    prevRefTargets.length !== nextRefTargets.length ||\n    prevRefTargets.some((target, i) => {\n      const nextTarget = nextRefTargets[i];\n\n      if (!target && !nextTarget) {\n        return false;\n      } else if (target != nextTarget) {\n        if (isArray(target) && isArray(nextTarget)) {\n          return compareRefTargets(target, nextTarget);\n        }\n        return true;\n      }\n      return false;\n    })\n  );\n}\n\ntype DefaultAbles = GroupableProps &\n  IndividualGroupableProps &\n  BeforeRenderableProps &\n  RenderableProps;\n\nexport class InitialMoveable<T = {}> extends React.PureComponent<\n  MoveableDefaultProps & DefaultAbles & T\n> {\n  public static defaultAbles: readonly Able<any>[] = [];\n  public static customStyledMap: Record<string, any> = {};\n  public static defaultStyled: any = null;\n  public static makeStyled() {\n    const cssMap: IObject<boolean> = {};\n\n    const ables = this.getTotalAbles();\n    ables.forEach(({ css }: Able) => {\n      if (!css) {\n        return;\n      }\n      css.forEach((text) => {\n        cssMap[text] = true;\n      });\n    });\n    const style = getKeys(cssMap).join('\\n');\n\n    this.defaultStyled = styled('div', prefixCSS(PREFIX, MOVEABLE_CSS + style));\n  }\n  public static getTotalAbles(): Able[] {\n    return [\n      Default,\n      Groupable,\n      IndividualGroupable,\n      DragArea,\n      ...this.defaultAbles,\n    ];\n  }\n  // @withMethods(MOVEABLE_METHODS)\n  public moveable!: MoveableManager | MoveableGroup | MoveableIndividualGroup;\n  public refTargets: MoveableRefTargetsResultType = [];\n  public selectorMap: IObject<Array<HTMLElement | SVGElement>> = {};\n  private _differ: ChildrenDiffer<HTMLElement | SVGElement> =\n    new ChildrenDiffer();\n  private _elementTargets: Array<HTMLElement | SVGElement> = [];\n  private _tmpRefTargets: MoveableRefTargetsResultType = [];\n  private _tmpSelectorMap: IObject<Array<HTMLElement | SVGElement>> = {};\n  private _onChangeTargets: (() => void) | null = null;\n  public render() {\n    const moveableContructor = this.constructor as typeof InitialMoveable;\n\n    if (!moveableContructor.defaultStyled) {\n      moveableContructor.makeStyled();\n    }\n    const { ables: userAbles, props: userProps, ...props } = this.props;\n    const [refTargets, nextSelectorMap] = this._updateRefs(true);\n    const elementTargets = getElementTargets(refTargets, nextSelectorMap);\n\n    let isGroup = elementTargets.length > 1;\n    const totalAbles = moveableContructor.getTotalAbles();\n    const ables = [...totalAbles, ...((userAbles as any) || [])];\n    const nextProps = {\n      ...props,\n      ...(userProps || {}),\n      ables,\n      cssStyled: moveableContructor.defaultStyled,\n      customStyledMap: moveableContructor.customStyledMap,\n    };\n\n    this._elementTargets = elementTargets;\n\n    let firstRenderState: MoveableManagerState | null = null;\n    const prevMoveable = this.moveable;\n\n    const persistData = props.persistData;\n\n    if (persistData?.children) {\n      isGroup = true;\n    }\n    // Even one child is treated as a group if individualGroupable is enabled. #867\n    if (props.individualGroupable) {\n      return (\n        <MoveableIndividualGroup\n          key=\"individual-group\"\n          ref={ref(this, 'moveable')}\n          {...nextProps}\n          target={null}\n          targets={elementTargets}\n        />\n      );\n    }\n    if (isGroup) {\n      const targetGroups = getTargetGroups(refTargets, nextSelectorMap);\n\n      // manager\n      if (\n        prevMoveable &&\n        !prevMoveable.props.groupable &&\n        !(prevMoveable.props as any).individualGroupable\n      ) {\n        const target = prevMoveable.props.target!;\n\n        if (target && elementTargets.indexOf(target) > -1) {\n          firstRenderState = { ...prevMoveable.state };\n        }\n      }\n\n      return (\n        <MoveableGroup\n          key=\"group\"\n          ref={ref(this, 'moveable')}\n          {...nextProps}\n          {...(props.groupableProps ?? {})}\n          target={null}\n          targets={elementTargets}\n          targetGroups={targetGroups}\n          firstRenderState={firstRenderState}\n        />\n      );\n    } else {\n      const target = elementTargets[0];\n      // manager\n      if (\n        prevMoveable &&\n        (prevMoveable.props.groupable ||\n          (prevMoveable.props as any).individualGroupable)\n      ) {\n        const moveables =\n          (prevMoveable as MoveableGroup | MoveableIndividualGroup).moveables ||\n          [];\n        const prevTargetMoveable = find(\n          moveables,\n          (mv) => mv.props.target === target,\n        );\n\n        if (prevTargetMoveable) {\n          firstRenderState = { ...prevTargetMoveable.state };\n        }\n      }\n\n      return (\n        <MoveableManager<any>\n          key=\"single\"\n          ref={ref(this, 'moveable')}\n          {...nextProps}\n          target={target}\n          firstRenderState={firstRenderState}\n        />\n      );\n    }\n  }\n  public componentDidMount() {\n    this._checkChangeTargets();\n  }\n  public componentDidUpdate() {\n    this._checkChangeTargets();\n  }\n  public componentWillUnmount() {\n    this.selectorMap = {};\n    this.refTargets = [];\n  }\n  /**\n   * Get targets set in moveable through target or targets of props.\n   * @method Moveable#getTargets\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body, {\n   *    target: [targetRef, \".target\", document.querySelectorAll(\".target\")],\n   * });\n   *\n   * console.log(moveable.getTargets());\n   */\n  public getTargets() {\n    return this.moveable?.getTargets() ?? [];\n  }\n  /**\n   * If the element list corresponding to the selector among the targets is changed, it is updated.\n   * @method Moveable#updateSelectors\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body, {\n   *    target: \".target\",\n   * });\n   *\n   * moveable.updateSelectors();\n   */\n  public updateSelectors() {\n    this.selectorMap = {};\n    this._updateRefs();\n    this.forceUpdate();\n  }\n  /**\n   * User changes target and waits for target to change.\n   * @method Moveable#waitToChangeTarget\n   * @story combination-with-other-components--components-selecto\n   * @example\n   * document.querySelector(\".target\").addEventListener(\"mousedown\", e => {\n   *   moveable.waitToChangeTarget().then(() => {\n   *      moveable.dragStart(e, e.currentTarget);\n   *   });\n   *   moveable.target = e.currentTarget;\n   * });\n   */\n  public waitToChangeTarget(): Promise<void> {\n    // let resolvePromise: (e: OnChangeTarget) => void;\n\n    // this._onChangeTargets = () => {\n    //     this._onChangeTargets = null;\n    //     resolvePromise({\n    //         moveable: this.getManager(),\n    //         targets: this._elementTargets,\n    //     });\n    // };\n\n    // return new Promise<OnChangeTarget>(resolve => {\n    //     resolvePromise = resolve;\n    // });\n    let resolvePromise: () => void;\n\n    this._onChangeTargets = () => {\n      this._onChangeTargets = null;\n      resolvePromise();\n    };\n\n    return new Promise((resolve) => {\n      resolvePromise = resolve;\n    });\n  }\n  public waitToChangeTargets(): Promise<void> {\n    return this.waitToChangeTarget();\n  }\n  public getManager(): MoveableManagerInterface<any, any> {\n    return this.moveable;\n  }\n  public getMoveables(): MoveableManagerInterface[] {\n    return this.moveable.getMoveables();\n  }\n  public getDragElement(): HTMLElement | SVGElement | null | undefined {\n    return this.moveable.getDragElement();\n  }\n  private _updateRefs(isRender?: boolean) {\n    const prevRefTargets = this.refTargets;\n    const nextRefTargets = getRefTargets(\n      (this.props.target || this.props.targets) as any,\n    );\n    const isBrowser = typeof document !== 'undefined';\n\n    let isUpdate = compareRefTargets(prevRefTargets, nextRefTargets);\n    const selectorMap = this.selectorMap;\n    const nextSelectorMap: IObject<Array<HTMLElement | SVGElement>> = {};\n\n    this.refTargets.forEach(function updateSelectorMap(target) {\n      if (isString(target)) {\n        const selectorTarget = selectorMap[target];\n\n        if (selectorTarget) {\n          nextSelectorMap[target] = selectorMap[target];\n        } else if (isBrowser) {\n          isUpdate = true;\n          nextSelectorMap[target] = [].slice.call(\n            document.querySelectorAll(target),\n          );\n        }\n      } else if (isArray(target)) {\n        target.forEach(updateSelectorMap);\n      }\n    });\n\n    this._tmpRefTargets = nextRefTargets;\n    this._tmpSelectorMap = nextSelectorMap;\n\n    return [nextRefTargets, nextSelectorMap, !isRender && isUpdate] as const;\n  }\n  private _checkChangeTargets() {\n    this.refTargets = this._tmpRefTargets;\n    this.selectorMap = this._tmpSelectorMap;\n\n    const { added, removed } = this._differ.update(this._elementTargets);\n    const isTargetChanged = added.length || removed.length;\n\n    if (isTargetChanged) {\n      this.props.onChangeTargets?.({\n        moveable: this.moveable,\n        targets: this._elementTargets,\n      });\n      this._onChangeTargets?.();\n    }\n    const [refTargets, selectorMap, isUpdate] = this._updateRefs();\n\n    this.refTargets = refTargets;\n    this.selectorMap = selectorMap;\n\n    if (isUpdate) {\n      this.forceUpdate();\n    }\n  }\n}\nexport interface InitialMoveable<T = {}>\n  extends React.PureComponent<MoveableDefaultProps & DefaultAbles & T>,\n    MoveableInterface {\n  setState(state: any, callback?: () => any): any;\n  forceUpdate(callback?: () => any): any;\n}\n", "import { MoveableProps, Able } from \"./types\";\nimport { MOVEABLE_ABLES } from \"./ables/consts\";\nimport { InitialMoveable } from \"./InitialMoveable\";\n\nexport default class Moveable<T = {}> extends InitialMoveable<MoveableProps & T> {\n    public static defaultAbles: Able[] = MOVEABLE_ABLES as any;\n}\n", "import { Able } from \"./types\";\nimport { InitialMoveable } from \"./InitialMoveable\";\n\nexport function makeMoveable<T extends Record<string, any> = {}>(\n    ables: Array<Able<T>>,\n): typeof InitialMoveable & (new (...args: any[]) => InitialMoveable<T>) {\n    return class Moveable extends InitialMoveable<T> {\n        public static defaultAbles = ables;\n    };\n}\n"],
  "mappings": "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",
  "names": ["makeAble", "name", "able", "some", "arr", "callback", "length", "i", "find", "getUserAgentString", "agent", "userAgent", "execRegExp", "pattern", "text", "hasUserAgentData", "userAgentData", "brands", "findVersion", "versionTest", "result", "convertVersion", "findPreset", "presets", "userPreset", "version", "preset", "findPresetBrand", "brandInfo", "findBrand", "_a", "brand", "BROWSER_PRESETS", "CHROMIUM_PRESETS", "WEBKIT_PRESETS", "WEBVIEW_PRESETS", "OS_PRESETS", "isWebView", "getLegacyAgent", "nextAgent", "isMobile", "browser", "os", "browserPreset", "browserVersion", "_b", "osPreset", "osVersion", "chromiumPreset", "webkitPreset", "getClientHintsAgent", "osData", "firstBrand", "platform", "chromiumBrand", "webkitBrand", "platfomResult", "browserBrand", "DIRECTIONS4", "DIRECTIONS", "getSVGCursor", "scale", "degree", "getCursorCSS", "x1", "degree45", "defaultCursor", "getAgent", "IS_WEBKIT", "IS_WEBKIT605", "navi", "res", "browserName", "IS_CHROME", "IS_CHROMIUM", "chromiumVersion", "IS_CHROMIUM109", "IS_FIREFOX", "IS_SAFARI_ABOVE15", "PREFIX", "directionCSS", "dir", "top", "left", "originX", "originY", "offset", "MOVEABLE_CSS", "NEARBY_POS", "FLOAT_POINT_NUM", "TINY_NUM", "MIN_SCALE", "MAX_NUM", "MIN_NUM", "DIRECTION_REGION_TO_DIRECTION", "DIRECTION_INDEXES", "DIRECTION_ROTATIONS", "MOVEABLE_METHODS", "prefixNames", "prefix", "classNames", "className", "prefixCSS", "css", "_", "selector", "ref", "target", "e", "refs", "FUNCTION", "OBJECT", "STRING", "NUMBER", "UNDEFINED", "IS_WINDOW", "doc", "OPEN_CLOSED_CHARACTERS", "DEFAULT_UNIT_PRESETS", "pos", "size", "__spreadArrays", "s", "il", "k", "a", "j", "jl", "dot", "a1", "a2", "b1", "b2", "isUndefined", "value", "isObject", "isArray", "isString", "isNumber", "isFunction", "isEqualSeparator", "character", "separator", "isCharacterSpace", "isSeparatorSpace", "findOpen", "openCharacter", "texts", "index", "openCloseCharacters", "isIgnore", "findIgnore", "findClose", "otherText", "closeCharacter", "_loop_1", "nextIndex", "open", "out_i_1", "state_1", "splitText", "splitOptions", "isSeparateFirst", "isSeparateOnlyOpenClose", "_c", "isSeparateOpenClose", "_d", "openClosedText", "close", "regexText", "regex", "chr", "values", "tempValues", "resetTemp", "_loop_2", "out_i_2", "nextOpenCloseCharacters", "state_2", "splitSpace", "splitComma", "splitBracket", "matches", "splitUnit", "unit", "decamelize", "str", "all", "letter", "letter2", "now", "findIndex", "defaultIndex", "defalutValue", "requestAnimationFrame", "firstTime", "raf", "currTime", "id", "cancelAnimationFrame", "caf", "handle", "getKeys", "obj", "convertUnitSize", "sizeFunction", "between", "min", "max", "checkBoundSize", "targetSize", "compareSize", "isMax", "ratio", "throttle", "defaultSize", "throttledSize", "calculateBoundSize", "minSize", "maxSize", "keepRatio", "width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "sum", "nums", "total", "average", "getRad", "pos1", "pos2", "distX", "distY", "rad", "getCenterPoint", "points", "getShapeDirection", "center", "pos1Rad", "pos2Rad", "getDist", "b", "num", "reverseUnit", "throttleArray", "counter", "flat", "prev", "cur", "pushSet", "elements", "element", "hasClass", "addClass", "removeClass", "reg", "addEvent", "el", "type", "listener", "options", "removeEvent", "getDocument", "getDocumentElement", "getDocumentBody", "getWindow", "isWindow", "val", "isNode", "add", "matrix", "inverseMatrix", "startIndex", "fromIndex", "n", "x", "fromX", "swap", "v", "iv", "divide", "ignoreDimension", "m", "newMatrix", "invert", "createIdentityMatrix", "identityIndex", "targetStartIndex", "targetIndex", "transpose", "getOrigin", "originMatrix", "w", "fromTranslation", "convertPositionMatrix", "convertDimension", "multiplies", "matrixes", "_i", "multiply", "matrix2", "l", "plus", "nextPos", "minus", "convertCSStoMatrix", "is2d", "convertMatrixtoCSS", "calculate", "rotateX3d", "rotateY3d", "rotateZ3d", "createRotateMatrix", "scale3d", "sx", "sy", "sz", "rotate", "translate3d", "tx", "ty", "tz", "matrix3d", "matrix1", "cos", "sin", "createScaleMatrix", "createOriginMatrix", "origin", "createWarpMatrix", "pos0", "pos3", "nextPos0", "nextPos1", "nextPos2", "nextPos3", "x0", "y0", "y1", "x2", "y2", "x3", "y3", "u0", "v0", "u1", "v1", "u2", "v2", "u3", "v3", "h", "__assign", "t", "p", "createMatrix", "parseMat", "transform", "toMat", "parse", "calculateMatrixDist", "matrixInfos", "info", "matrixFunction", "functionValue", "transforms", "functionName", "nextSize_1", "posX", "posY", "posZ", "nextSize", "_e", "_f", "_g", "_h", "unitValue", "setCustomDrag", "state", "delta", "isPinch", "isConvert", "ableName", "datas", "ableDatas", "CustomGesto", "__publicField", "client", "originalDatas", "inputEvent", "clientX", "clientY", "isFirstDrag", "isPrevDrag", "calculateElementPosition", "poses", "calculatePoses", "x4", "y4", "calculatePosition", "right", "bottom", "direction", "sign", "calculatePointerDist", "moveable", "moveableClientRect", "rootMatrix", "is3d", "calculateInversePosition", "getDragDist", "setDragStart", "allMatrix", "beforeMatrix", "offsetMatrix", "targetMatrix", "transformOrigin", "getTransformDirection", "resolveTransformEvent", "event", "nextTransforms", "nextTransformAppendedIndexes", "convertTransformInfo", "targetFunction", "matFunctionName", "convertTransformFormat", "dist", "getTransformDist", "bx", "by", "getBeforeDragDist", "getTransfromMatrix", "isAfter", "beforeTransform", "afterTransform", "beforeTransform2", "afterTransform2", "targetAllTransform", "nextTargetMatrix", "res1", "inverseBeforeMatrix", "startDragBeforeDist", "absoluteOrigin", "isBefore", "startDragDist", "getInverseDragDist", "calculateTransformOrigin", "prevWidth", "prevHeight", "prevOrigin", "prevSize", "measureRatio", "getPosIndexesByDirection", "indexes", "getPosesByDirection", "getPosBySingleDirection", "getPosByDirection", "startPos", "fixedDirection", "fixedPos", "getNextMatrix", "getAbsoluteMatrix", "getNextTransformMatrix", "isAllTransform", "targetTransform", "scaleMatrix", "fillTransformStartEvent", "getBeforeRenderableDatas", "setTransformIndex", "setDefaultTransformIndex", "property", "startTransforms", "func", "fillOriginalTransform", "getNextTransforms", "getNextTransformText", "getNextStyle", "fillTransformEvent", "nextTransform", "drag", "Draggable", "fillCSSObject", "getTranslateFixedPosition", "fixedOffset", "nextMatrix", "getDirectionOffset", "getTranslateDist", "fixedPosition", "nextFixedPosition", "groupable", "groupLeft", "groupTop", "getScaleDist", "getDirectionByPos", "fixedOffsetPosition", "getRotateDist", "rotateDist", "getResizeDist", "nextOrigin", "getAbsolutePosition", "getAbsolutePosesByState", "getGestoData", "targetGesto", "controlGesto", "data", "getShadowRoot", "parentElement", "rootNode", "getIndividualTransforms", "getStyle", "translate", "individualTransforms", "getMatrixStackInfo", "container", "checkContainer", "documentElement", "requestEnd", "isEnd", "targetTransformOrigin", "hasFixed", "offsetContainer", "getOffsetInfo", "zoom", "getCachedStyle", "position", "getElementTransform", "isFixed", "getTransformMatrix", "offsetParent", "isOffsetEnd", "isStatic", "parentClientLeft", "parentClientTop", "fixedClientLeft", "fixedClientTop", "fixedInfo", "getPositionFixedInfo", "convert3DMatrixes", "tagName", "hasOffset", "isSVG", "targetOrigin", "offsetPos", "getOffsetPosInfo", "offsetLeft", "offsetTop", "getSVGMatrix", "targetZoom", "offsetInfo", "offsetZoom", "customOffsetParent", "customOffsetLeft", "customOffsetTop", "margin", "getBodyOffset", "isElementTarget", "scrollLeft", "scrollTop", "cacheStyleMap", "clientRectStyleMap", "matrixContainerInfos", "setStoreCache", "useCache", "getCachedClientRect", "clientRect", "nextClientRect", "getClientRect", "getCachedMatrixContainerInfo", "cache", "nextStyle", "cached", "style", "React", "require$$0", "REACT_ELEMENT_TYPE", "REACT_PORTAL_TYPE", "REACT_FRAGMENT_TYPE", "REACT_STRICT_MODE_TYPE", "REACT_PROFILER_TYPE", "REACT_PROVIDER_TYPE", "REACT_CONTEXT_TYPE", "REACT_FORWARD_REF_TYPE", "REACT_SUSPENSE_TYPE", "REACT_SUSPENSE_LIST_TYPE", "REACT_MEMO_TYPE", "REACT_LAZY_TYPE", "REACT_OFFSCREEN_TYPE", "MAYBE_ITERATOR_SYMBOL", "FAUX_ITERATOR_SYMBOL", "getIteratorFn", "maybeIterable", "maybeIterator", "ReactSharedInternals", "error", "format", "_len2", "args", "_key2", "printWarning", "level", "ReactDebugCurrentFrame", "stack", "argsWithFormat", "item", "enableScopeAPI", "enableCacheElement", "enableTransitionTracing", "enableLegacyHidden", "enableDebugTracing", "REACT_MODULE_REFERENCE", "isValidElementType", "type", "getWrappedName", "outerType", "innerType", "wrapperName", "displayName", "functionName", "getContextName", "getComponentNameFromType", "context", "provider", "outerName", "lazyComponent", "payload", "init", "assign", "disabledDepth", "prevLog", "prevInfo", "prevWarn", "prevError", "prevGroup", "prevGroupCollapsed", "prevGroupEnd", "disabledLog", "disableLogs", "props", "reenableLogs", "ReactCurrentDispatcher", "prefix", "describeBuiltInComponentFrame", "name", "source", "ownerFn", "x", "match", "reentry", "componentFrameCache", "PossiblyWeakMap", "describeNativeComponentFrame", "fn", "construct", "frame", "control", "previousPrepareStackTrace", "previousDispatcher", "Fake", "sample", "sampleLines", "controlLines", "s", "c", "_frame", "syntheticFrame", "describeFunctionComponentFrame", "shouldConstruct", "Component", "prototype", "describeUnknownElementTypeFrameInDEV", "hasOwnProperty", "loggedTypeFailures", "setCurrentlyValidatingElement", "element", "owner", "checkPropTypes", "typeSpecs", "values", "location", "componentName", "has", "typeSpecName", "error$1", "err", "ex", "isArrayImpl", "isArray", "a", "typeName", "value", "hasToStringTag", "willCoercionThrow", "testStringCoercion", "checkKeyStringCoercion", "ReactCurrentOwner", "RESERVED_PROPS", "specialPropKeyWarningShown", "specialPropRefWarningShown", "didWarnAboutStringRefs", "hasValidRef", "config", "getter", "hasValidKey", "warnIfStringRefCannotBeAutoConverted", "self", "defineKeyPropWarningGetter", "warnAboutAccessingKey", "defineRefPropWarningGetter", "warnAboutAccessingRef", "ReactElement", "key", "ref", "jsxDEV", "maybeKey", "propName", "defaultProps", "ReactCurrentOwner$1", "ReactDebugCurrentFrame$1", "setCurrentlyValidatingElement$1", "propTypesMisspellWarningShown", "isValidElement", "object", "getDeclarationErrorAddendum", "getSourceInfoErrorAddendum", "ownerHasKeyUseWarning", "getCurrentComponentErrorInfo", "parentType", "info", "parentName", "validateExplicitKey", "currentComponentErrorInfo", "childOwner", "validateChildKeys", "node", "i", "child", "iteratorFn", "iterator", "step", "validatePropTypes", "propTypes", "_name", "validateFragmentProps", "fragment", "keys", "didWarnAboutKeySpread", "jsxWithValidation", "isStaticChildren", "validType", "sourceInfo", "typeString", "children", "k", "beforeExample", "afterExample", "jsxWithValidationStatic", "jsxWithValidationDynamic", "jsx", "jsxs", "reactJsxRuntime_development", "jsxRuntimeModule", "require$$1", "fillChildEvents", "moveable", "e", "datas", "groupableDatas", "childDatas", "_", "triggerChildGesto", "able", "delta", "isConvert", "ableName", "isStart", "isEnd", "isPinch", "events", "moveables", "childEvents", "eventParams", "ev", "childMoveable", "state", "gestos", "childEvent", "CustomGesto", "setCustomDrag", "result", "triggerChildAbles", "eachEvent", "callback", "startChildDist", "parentDatas", "fixedDirection", "fixedPosition", "startPositions", "getAbsolutePosesByState", "pos", "getPosByDirection", "originalX", "originalY", "calculate", "createRotateMatrix", "renderDirectionControlsByInfos", "renderDirections", "renderPoses", "rotationRad", "direction", "zoom", "getProps", "degRotation", "absDegree", "directionMap", "renderState", "renderDirectionMap", "dir", "directionSign", "sign", "data", "classNames", "indexes", "DIRECTION_INDEXES", "directionRotation", "throttle", "DIRECTION_ROTATIONS", "dataAttrs", "getKeys", "createElement", "getControlTransform", "index", "renderDirectionControls", "defaultDirections", "directions", "displayAroundControls", "DIRECTIONS", "renderAroundControls", "renderLine", "pos1", "pos2", "rad", "getRad", "rotation", "getLineStyle", "renderEdgeLines", "edge", "poses", "DIRECTIONS4", "index1", "index2", "getRenderDirections", "renderDiagonalDirections", "renderAllDirections", "checkBoundPoses", "bounds", "verticalPoses", "horizontalPoses", "position", "left", "top", "right", "bottom", "nextBounds", "checkBounds", "getBounds", "externalBounds", "containerHeight", "containerWidth", "clientLeft", "clientTop", "snapOffsetLeft", "snapOffsetTop", "snapOffsetRight", "snapOffsetBottom", "isCSS", "checkBoundKeepRatio", "startPos", "endPos", "endX", "endY", "dx", "dy", "minus", "abs", "TINY_NUM", "isBottom", "isRight", "verticalInfo", "horizontalInfo", "b", "y", "isBound", "isVertical", "startBoundPos", "endBoundPos", "minPos", "maxPos", "boundInfos", "isBoundRotate", "relativePoses", "boundRect", "rotate", "boundRotate", "vec", "boundPos", "getDistSize", "nextPos", "checkRotateBounds", "prevPoses", "nextPoses", "origin", "relativeLeft", "relativeRight", "relativeTop", "relativeBottom", "relativeRad1", "relativeRad2", "nextRad", "VERTICAL_NAMES", "HORIZONTAL_NAMES", "SNAP_SKIP_NAMES_MAP", "VERTICAL_NAMES_MAP", "HORIZONTAL_NAMES_MAP", "getInitialBounds", "hasGuidelines", "snappable", "innerBounds", "verticalGuidelines", "horizontalGuidelines", "snapGridWidth", "snapGridHeight", "guidelines", "enableSnap", "getSnapDirections", "snapDirections", "mapSnapDirectionPoses", "snapPoses", "nextSnapDirections", "nextSnapPoses", "splitSnapDirectionPoses", "horizontalNames", "verticalNames", "calculateContainerPos", "rootMatrix", "containerRect", "clientPos", "calculatePosition", "solveLineConstants", "point1", "point2", "v", "NAME_snapRotationThreshold", "NAME_snapRotationDegrees", "NAME_snapHorizontalThreshold", "NAME_snapVerticalThreshold", "checkMoveableSnapPoses", "posesX", "posesY", "dirXs", "dirYs", "customSnapVerticalThreshold", "customSnapHorizontalThreshold", "snapThresholdMultiples", "_a", "snapHorizontalThreshold", "selectValue", "snapVerticalThreshold", "checkSnapPoses", "multiples", "checkSnap", "checkSnapKeepRatio", "startX", "startY", "getTinyDist", "verticalSnapInfo", "horizontalSnapInfo", "isVerticalSnap", "verticalGuideline", "getNearestSnapGuidelineInfo", "isHorizontalSnap", "horizontalGuideline", "horizontalPos", "verticalPos", "isSnap", "getStringDirection", "stringDirection", "checkSnaps", "rect", "horizontalDirection", "verticalDirection", "snapInfo", "posInfo", "guidelineInfo", "offset", "dist", "guideline", "targetType", "targetPoses", "snapThreshold", "dirs", "posType", "snapPosInfos", "targetPos", "guidelineInfos", "snapPosInfo", "getSnapInfosByDirection", "snapDirection", "arr", "nextDir", "getPosesByDirection", "xs", "ys", "checkSnapBoundPriority", "aDist", "bDist", "getNearOffsetInfo", "offsets", "aSign", "bSign", "aOffset", "bOffset", "getCheckSnapDirections", "keepRatio", "endDirection", "signX", "signY", "nextDirection", "isStartLine", "dot", "line", "cx", "average", "cy", "hitTestLine", "test1", "test2", "isSameStartLine", "dots", "centerSign", "checkInnerBoundDot", "start", "end", "threshold", "checkInnerBound", "verticalSign", "horizontalSign", "lineConstants", "width", "height", "leftLine", "topLine", "rightLine", "bottomLine", "topBoundInfo", "checkLineBoundCollision", "bottomBoundInfo", "leftBoundInfo", "rightBoundInfo", "isAllVerticalBound", "isVerticalBound", "isAllHorizontalBound", "isHorizontalBound", "verticalOffset", "maxOffset", "horizontalOffset", "isAllBound", "boundLine", "isRender", "dot1", "boundDot1", "boundDot2", "dy2", "dx2", "hasDx", "hasDy", "slope", "getInnerBoundInfo", "lineInfos", "multiple", "sizeOffset", "getDragDist", "size", "getInnerBoundDragInfo", "lines", "getCheckInnerBoundLineInfos", "innerBoundInfo", "widthOffsetInfo", "heightOffsetInfo", "getInverseDragDist", "getCheckSnapLineDirections", "lineDirections", "allMatrix", "is3d", "virtualPoses", "calculatePoses", "center", "dir1", "dir2", "virtualLine", "boundDots", "getDistPointLine", "solveReverseLine", "checkRotateInnerBounds", "dotInfos", "lineRad", "lineDist", "dotDist", "dotRad", "distRad", "nextRad1", "nextRad2", "prev", "cur", "checkInnerBoundPoses", "boundMap", "pos3", "pos4", "lineInfo", "isHorizontalStart", "isVerticalStart", "solveEquation", "snapOffset", "solveNextOffset", "getDist", "dist1", "dist2", "isOutside", "widthOffset", "heightOffset", "getSnapBound", "boundInfo", "checkThrottleDragRotate", "throttleDragRotate", "distX", "distY", "offsetX", "offsetY", "adjustPoses", "adjustPos", "prevDistY", "scale", "checkSnapBoundsDrag", "ignoreSnap", "getAbsolutePoses", "getRect", "boundPoses", "verticalSnapBoundInfo", "horizontalSnapBoundInfo", "checkMoveableSnapBounds", "verticalInnerBoundInfo", "horizontalInnerBoundInfo", "horizontalBoundInfos", "verticalBoundInfos", "horizontalDist", "verticalDist", "checkSnapBounds", "guideines", "checkSnapRightLine", "snapBoundInfo", "rad180", "isHorizontalLine", "isVerticalLine", "getSnapBoundInfo", "isRequest", "startDirection", "otherStartPos", "otherEndPos", "checkSnapBoundsKeepRatio", "otherHorizontalOffset", "isOtherHorizontalBound", "isOtherHorizontalSnap", "otherVerticalOffset", "isOtherVerticalBound", "isOtherVerticalSnap", "snapLine", "getSnapBoundOffset", "horizontalBoundInfo", "verticalBoundInfo", "checkMaxBounds", "maxWidth", "maxHeight", "otherDirection", "isCheckVertical", "isCheckHorizontal", "otherPos", "deg", "nextOtherPos", "isHeightOutside", "isWidthOutside", "Draggable", "hideThrottleDragRotateLine", "dragInfo", "beforeOrigin", "parentEvent", "parentGesto", "style", "setDragStart", "setDefaultTransformIndex", "startCheckSnapDrag", "params", "fillParams", "translate", "fillTransformStartEvent", "triggerEvent", "resolveTransformEvent", "parentFlag", "deltaOffset", "useSnap", "isGroup", "parentThrottleDrag", "isDrag", "prevDist", "prevBeforeDist", "startValue", "parentMoveable", "throttleDrag", "dragRotateRad", "startDragRotate", "ry", "rx", "r", "beforeTranslate", "plus", "getBeforeDragDist", "getTransformDist", "throttleArray", "beforeDist", "beforeDelta", "nextTransform", "convertTransformFormat", "fillOriginalTransform", "num", "fillCSSObject", "param", "fillEndParams", "clientX", "clientY", "nextParams", "passDelta", "getFixedDirectionInfo", "getOffsetFixedDirectionInfo", "n", "nextFixedOffset", "getOffsetFixedPositionInfo", "offsetFixedPosition", "getDirectionByPos", "nextFixedPosition", "fixedOffset", "directionCondition", "getDirectionCondition", "Resizable", "getDirectionViewClassName", "inputEvent", "parentDirection", "parentFixedDirection", "getTotalDirection", "target", "transformOrigin", "isString", "setRatio", "ratio", "setFixedDirection", "setFixedPosition", "setMin", "minSize", "convertUnitSize", "setMax", "maxSize", "nextMaxSize", "isNumber", "startWidth", "startHeight", "parentKeepRatio", "dragClient", "parentDist", "resolveMatrix", "isResize", "prevWidth", "prevHeight", "startOffsetWidth", "startOffsetHeight", "isWidth", "startOffsetMatrix", "startTransformOrigin", "targetMatrix", "parseMat", "getNextTransforms", "targetN", "convertDimension", "nextAllMatrix", "getNextMatrix", "resizeFormat", "throttleResize", "keepRatioFinally", "sizeDirection", "distWidth", "distHeight", "getNextBoundingSize", "nextSize", "getOffsetSizeDist", "nextWidth", "nextHeight", "boundingWidth", "boundingHeight", "nextFixedDirection", "getAbsolutePosition", "snapDist", "checkSnapResize", "computeSize", "isNoSnap", "calculateBoundSize", "inverseDelta", "getResizeDist", "drag", "transform", "fillAfterTransform", "errorWidth", "errorHeight", "isErrorWidth", "isErrorHeight", "originalEvents", "parentStartOffsetWidth", "parentStartOffsetHeight", "updateGroupMin", "originalMinSize", "childMinSize", "childStartOffsetWidth", "childStartOffsetHeight", "parentMinWidth", "parentMinHeight", "updateGroupMax", "originalMaxSize", "childMaxSize", "parentMaxWidth", "parentMaxHeight", "catchEvent", "parentScale", "setRotateStartInfo", "groupable", "nextOrigin", "startAbsoluteOrigin", "getAbsoluteDist", "defaultDeg", "prevDeg", "normalizedPrevDeg", "loop", "getAbsoluteDistByClient", "getRotateInfo", "moveableRect", "throttleRotate", "prevSnapDeg", "snapRotation", "checkSnapRotate", "snapDeg", "getRotationPositions", "rotationPosition", "radPoses", "getRotationRad", "isReverse", "dragControlCondition", "hasClass", "rotationTarget", "getRefTargets", "css", "Rotatable", "rotatable", "rotateAroundControls", "resolveAblesWithRotatable", "positions", "ables", "resolveMap", "directionControlInfos", "parentRotate", "beforeDirection", "targetTransform", "moveableClientRect", "offsetMatrix", "resizeStart", "startClientX", "startClientY", "externalRotate", "inputTarget", "regionDirection", "controlDirection", "DIRECTION_REGION_TO_DIRECTION", "resolve", "clientPoses", "calculateMoveableClientPositions", "originalFixedPosition", "originX", "originY", "getOrigin", "fixedBeforeOrigin", "convertPositionMatrix", "fixedAfterOrigin", "posDelta", "dragStart", "getTotalOrigin", "rotatation", "clientDistX", "clientDistY", "groupDelta", "beforeInfo", "afterInfo", "absoluteInfo", "isRotate", "targetDirection", "getTransformDirection", "beforeRotation", "absoluteDelta", "absoluteDist", "absoluteRotation", "startRotation", "absoluteStartRotation", "nextClientX", "nextClientY", "nextRotation", "getTranslateFixedPosition", "inverseDist", "getRotateDist", "dragEvent", "fillTransformEvent", "transformEvent", "parentDistance", "resize", "resizeEvent", "parentLeft", "parentTop", "parentBeforeOrigin", "childClient", "startGroupClient", "prevClientX", "prevClientY", "rotateMatrix", "distRotate", "renderGuideline", "isHorizontal", "scaleType", "renderInnerGuideline", "className", "renderSnapPoses", "renderPos", "renderGuidelines", "targetRect", "isDisplayInnerSnapDigit", "mainNames", "targetStart", "targetEnd", "hide", "elementRect", "renderDigitLine", "lineType", "gap", "snapDigit", "isDisplaySnapDigit", "snapDistFormat", "sizeName", "absGap", "snapSize", "groupByElementGuidelines", "otherIndex", "names", "groupBy", "nextGuidelines", "inner", "elementRect1", "elementRect2", "nextPos1", "nextPos2", "renderDashedGuidelines", "rendered", "groups", "sideNames", "total", "sidePos", "prevRect", "nextRect", "size1", "size2", "renderPos1", "renderPos2", "renderGapGuidelines", "targetSideStart", "targetSideEnd", "gapRects", "sideStartPos", "sideEndPos", "sideCenterPos", "PolyMap", "__proto", "prevIndex", "HashMap", "SUPPORT_MAP", "Link", "prevLink", "nextLink", "link", "orderChanged", "changed", "fixed", "fromLinks", "toLinks", "from", "to", "fromLink", "toLink", "fromIndex", "toIndex", "Result", "prevList", "list", "added", "removed", "maintained", "changedBeforeAdded", "ordered", "pureChanged", "_b", "fromBefore", "toBefore", "diff", "findKeyCallback", "mapClass", "prevKeys", "prevKeyMap", "keyMap", "removedMap", "addedCount", "removedCount", "prevListIndex", "listIndex", "ListDiffer", "newData", "extendStatics", "d", "p", "__extends", "__", "childrenCount", "el", "ChildrenDiffer", "_super", "diff$1", "getTotalGuidelines", "containerClientRect", "hasFixed", "overflow", "containerClientHeight", "containerClientWidth", "snapGap", "maxSnapElementGuidelineDistance", "isDisplayGridGuidelines", "totalGuidelines", "getElementGuidelines", "getGapGuidelines", "getGridGuidelines", "getDefaultGuidelines", "checkBetweenRects", "snapThresholds", "maxSnapElementGapDistance", "elementRects", "gapGuidelines", "targetCenter", "targetStart2", "targetEnd2", "snapThresholdMap", "nextElementRects", "snapRect1", "snapRect2", "rect1", "rect2", "rect1Start", "rect1End", "rect2Start", "rect2End", "isCenter", "startGridGroupGuidelines", "snapGridAll", "snapRenderInfo", "hasDirection", "posName", "clientOffset", "rectSize", "rectPos", "childSizes", "flat", "firstChildSize", "childSnapSizes", "rectRatio", "childSize", "offsetPos", "startOffset", "snapThresholdInfo", "defaultSnapGridWidth", "defaultSnapGridHeight", "pushGuideline", "distance", "elementGuidelines", "prevValues", "snapRect", "nextElementGuidelines", "isObject", "getRefTarget", "nextValues", "nextIndex", "getSnapElementRects", "elementSnapDirections", "topValue", "leftValue", "rightValue", "bottomValue", "centerValue", "middleValue", "horizontal", "vertical", "rectTop", "rectLeft", "sizes", "getObjectGuidelines", "containerSize", "posGuideline", "snapWidth", "snapHeight", "offsetDelta", "containerLeft", "containerTop", "offsetLeft", "offsetTop", "elementLeft", "elementTop", "calculateInversePosition", "elementRight", "elementBottom", "checkSnapInfo", "container", "snapContainer", "snapContainerTarget", "snapContainerRect", "getClientRect", "offset1", "getDragDistByState", "offset2", "getNextFixedPoses", "matrix", "fixedPos", "nextFixedPos", "normalized", "getSizeOffsetInfo", "innerBoundLineInfos", "recheckSizeByTwoDirection", "snapPos", "FLOAT_POINT_NUM", "nextWidthOffset", "nextHeightOffset", "checkSizeDist", "getNextPoses", "isWidthBound", "isHeightBound", "widthDist", "heightDist", "bumpDegree", "baseDeg", "count", "deg1", "deg2", "getMinDegreeDistance", "deg3", "snapRotationThreshold", "snapRotationDegrees", "origin2", "firstDegree", "checkSnapScale", "sizeDist", "scaleMatrix", "getSnapGuidelines", "posInfos", "find", "addBoundGuidelines", "verticalSnapPoses", "horizontalSnapPoses", "innerBoundMap", "verticalInnerBoundPoses", "horizontalInnerBoundPoses", "innerPos", "findIndex", "Snappable", "targetTop", "targetLeft", "snapRenderThreshold", "watchValue", "minLeft", "minTop", "externalPoses", "snapInfos", "hasExternalPoses", "externalRect", "verticalPosInfos", "horizontalPosInfos", "allGuidelines", "nextBoundMap", "nextInnerBoundMap", "rotatableDragControlCondtion", "multiply2", "prefixNames", "PREFIX", "defaultSync", "getTransformMatrix", "getAbsoluteMatrix", "multiplies", "createOriginMatrix", "measureSVGSize", "unit", "getSVGViewBox", "getBeforeTransformOrigin", "getTransformOrigin", "getComputedStyle", "o", "splitUnit", "getTransformOriginArray", "getElementTransform", "computedTransform", "getCachedStyle", "baseVal", "length", "matrixes", "chr", "getOffsetInfo", "lastParent", "isParent", "checkZoom", "getTargetStyle", "documentElement", "getDocumentElement", "getDocumentBody", "hasSlot", "parentSlotElement", "assignedSlotParentElement", "parentElement", "isCustomElement", "offsetZoom", "targetZoom", "targetPosition", "getStyle", "tagName", "willChange", "slotParentNode", "targetParentNode", "parentNode", "getOffsetPosInfo", "isSVG", "isUndefined", "hasOffset", "targetOrigin", "IS_WEBKIT605", "getSVGGraphicsOffset", "getBodyOffset", "getBodyStyle", "bodyPosition", "marginLeft", "marginTop", "convert3DMatrixes", "getPositionFixedInfo", "fixedContainer", "hasTransform", "body", "makeMatrixCSS", "convertMatrixtoCSS", "clientWidth", "clientHeight", "viewBox", "getSVGMatrix", "viewBoxWidth", "viewBoxHeight", "scaleX", "scaleY", "preserveAspectRatio", "align", "meetOrSlice", "svgOrigin", "xAlign", "yAlign", "scaleDimension", "createScaleMatrix", "isGTarget", "isFillBox", "bbox", "rectWidth", "rectHeight", "calculateRect", "getSVGOffset", "offsetInfo", "targetInfo", "beforeMatrix", "getSize", "margin", "mat", "prevLeft", "prevTop", "posOrigin", "prevOrigin", "rectOrigin", "inverseBeforeMatrix", "invert", "mat2", "nextLeft", "nextTop", "distLeft", "distTop", "rootClientRect", "rootPoses", "getDiagonalSize", "offsetWidth", "offsetHeight", "cssWidth", "cssHeight", "contentWidth", "contentHeight", "minWidth", "minHeight", "minOffsetWidth", "minOffsetHeight", "maxOffsetWidth", "maxOffsetHeight", "inlineCSSWidth", "inlineCSSHeight", "svg", "targetStyle", "boxSizing", "borderLeft", "borderRight", "borderTop", "borderBottom", "paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "horizontalPadding", "verticalPadding", "horizontalBorder", "verticalBorder", "getParentStyle", "between", "resetClientRect", "getExtendsRect", "isRoot", "extendsRect", "getClientRectByPosition", "base", "isExtends", "baseTop", "baseLeft", "clientRect", "convertTransformOriginArray", "getDirection", "direciton", "unsetAbles", "isControl", "unsetGesto", "gestoName", "gesto", "resolvedEvent", "originalDatas", "getBeforeRenderableDatas", "decamelize", "prevEvent", "nextEvent", "afterTransform", "isBeforeEvent", "isManager", "pseudoElt", "getWindow", "filterAbles", "methods", "triggerAblesSimultaneously", "enabledAbles", "ableGroups", "method", "equals", "a1", "a2", "func", "groupKeys", "groupKey", "keyIndex", "group", "groupByMap", "convertDragDist", "calculatePadding", "xAdded", "yAdded", "nextAdded", "convertCSSSize", "isRelative", "getGestoData", "checkAbles", "convertTransformInfo", "transforms", "matrixInfos", "parse", "beforeFunctionTexts", "beforeFunctionTexts2", "targetFunctionText", "afterFunctionTexts", "afterFunctionTexts2", "beforeFunctions", "beforeFunctions2", "targetFunction", "afterFunctions", "afterFunctions2", "targetFunctions", "beforeFunctionMatrix", "toMat", "beforeFunctionMatrix2", "afterFunctionMatrix", "afterFunctionMatrix2", "allFunctionMatrix", "multiply", "isArrayFormat", "isNode", "isSelector", "isFunction", "isWindow", "targets", "getAbsoluteRotation", "inverseMatrix", "calculateMatrixDist", "getSizeDistByDist", "startSize", "standardRad", "signSize", "startWidthSize", "startHeightSize", "secondRad", "firstRad", "distSize", "pinchScale", "startFixedDirection", "directionsDists", "directionRatios", "ratioDistance", "convertTransformUnit", "xy", "leftOrigin", "rightOrigin", "originObject", "nextOriginObject", "rotatePosesInfo", "isDeepArrayEquals", "arr1", "arr2", "value1", "value2", "isArray1", "isArray2", "property", "nextValue", "valueKey", "defaultValue", "store", "prevValue", "countEach", "counter", "getPaddingBox", "padding", "Pinchable", "makeAble", "angle", "pinchable", "eventName", "controlEventName", "pinchAbles", "ableEvent", "Scalable", "setMinScaleSize", "min", "setMaxScaleSize", "max", "isScale", "throttleScale", "tempScaleValue", "getNextScale", "MIN_SCALE", "stateDirection", "nextScale", "distSign", "isSelfPinch", "startOffsetSize", "scaleSize", "distText", "scaleText", "isZeroScale", "getScaleDist", "scaleEndParam", "moveableScale", "getMiddleLinePos", "getTriangleRad", "rad1", "isValidPos", "poses1", "poses2", "rad2", "pi", "Warpable", "resizable", "scalable", "warpable", "linePosFrom1", "linePosFrom2", "linePosFrom3", "linePosFrom4", "linePosTo1", "linePosTo2", "linePosTo3", "linePosTo4", "ignoreDimension", "createIdentityMatrix", "getPosIndexesByDirection", "targetInverseMatrix", "prevMatrix", "isWarp", "posIndexes", "absolutePoses", "selectedPoses", "NEARBY_POS", "nearByPoses", "createWarpMatrix", "afterMatrix", "getTransfromMatrix", "totalMatrix", "AREA_PIECES", "AREA_PIECE", "AVOID", "VIEW_DRAGGING", "restoreStyle", "removeClass", "renderPieces", "DragArea", "dragArea", "passDragArea", "h", "areaElement", "posX", "posY", "rects", "addClass", "requestAnimationFrame", "Origin", "originStyle", "__assign", "t", "__spreadArrays", "il", "j", "jl", "EventEmitter", "listener", "_this", "isStop", "options", "listeners", "getDefaultScrollPosition", "checkDefaultScrollEvent", "getContainerElement", "DragScroll", "_startRect", "_startPos", "prevScrollPos", "throttleTime", "nextScrollPos", "getScrollPosition", "useScroll", "nowTime", "now", "distTime", "checkScrollEvent", "scrollContainer", "Scrollable", "scrollOptions", "dragScroll", "scrollContainerElement", "next", "scrollThreshold", "scrollThrottleTime", "Default", "Padding", "paddingDirections", "paddingPos1", "paddingPos2", "paddingPos3", "paddingPos4", "RADIUS_DIRECTIONS", "calculateRatio", "sumSize", "sumRatio", "HORIZONTAL_RADIUS_ORDER", "VERTICAL_RADIUS_ORDER", "HORIZONTAL_RADIUS_DIRECTIONS", "VERTICAL_RADIUS_DIRECTIONS", "getRadiusStyles", "clipStyles", "radiusPoses", "raws", "rawPos", "getRadiusRange", "controlPoses", "horizontalRange", "verticalRange", "clipPose", "getRadiusValues", "minCounts", "full", "splitIndex", "splitLength", "horizontalValues", "verticalValues", "horizontalValuesLength", "verticalValuesLength", "hasVerticalValues", "nwValue", "neValue", "seValue", "swValue", "wnValue", "enValue", "esValue", "wsValue", "horizontalRawPoses", "verticalRawPoses", "nextHorizontalPoses", "nextVerticalPoses", "removeRadiusPos", "startIndex", "radiuslIndex", "deleteCount", "addRadiusPos", "horizontalIndex", "verticalIndex", "radiusX", "radiusY", "startVerticalIndex", "splitRadiusPoses", "horizontals", "verticals", "tinyThrottle", "isSameConstants", "linearConstants1", "linearConstants2", "isSamePoint", "getAreaSize", "points", "sum", "point", "nextPoint", "fitPoints", "getMinMaxs", "minX", "minY", "maxX", "maxY", "ratioX", "ratioY", "isInside", "excludeLine", "xLine", "xLinearConstants", "getLinearConstants", "convertLines", "intersectionPosInfos", "linearConstants", "standardPoint", "xPoints", "getPointsOnLines", "getIntersectionPointsByConstants", "linePoint", "intersectionCount", "xMap", "x1", "y1", "x2", "y2", "b1", "c1", "b2", "c2", "isZeroA", "isZeroB", "results", "minMaxs", "order", "minMax", "pointX", "pointY", "getOverlapPointInfos", "points1", "points2", "targetPoints1", "targetPoints2", "getShapeDirection", "lines1", "lines2", "linearConstantsList1", "line1", "linearConstantsList2", "line2", "overlapInfos", "linePointInfos", "intersectionPoints", "isNext", "pointMap", "getOverlapPoints", "infos", "getOverlapSize", "CLIP_DIRECTIONS", "CLIP_RECT_DIRECTIONS", "getClipStyles", "clipPath", "clipRelative", "clipType", "clipPoses", "isRect", "isCircle", "subWidth", "subHeight", "getRectPoses", "dirx", "diry", "getControlSize", "xRange", "yRange", "getClipPath", "defaultClip", "customClip", "clipText", "clipPrefix", "splitBracket", "splitter", "splitComma", "xPos", "yPos", "splitSpace", "radius", "xRadius", "yRadius", "centerPos", "roundIndex", "rectLength", "radiusValues", "nextRight", "nextBottom", "posValue", "moveControlPos", "sub", "dists", "verticalDirections", "horizontalDirections", "fixedIndex", "nextDist", "nextControlPoses", "controlPose", "controlDir", "dirDir", "dirHorizontal", "dirVertical", "addClipPath", "calculatePointerDist", "clipIndex", "clipStyle", "removeClipPath", "Clippable", "customClipPath", "defaultClipPath", "clipArea", "clipPathState", "snapBoundInfos", "calculatedPos", "controls", "isInset", "isPolygon", "linePoses", "clipLeft", "clipTop", "ellipseClipPath", "piece", "areaPoses", "allWidth", "allHeight", "allLeft", "allTop", "directionType", "snapPos1", "snapPos2", "dragWithClip", "isDragTarget", "isLine", "isArea", "originalDraggable", "originalDist", "firstDist", "isDragWithTarget", "isAll", "shouldKeepRatio", "guidePoses", "isEllipse", "guideRect", "guideXPoses", "guideYPoses", "rectPoses", "rectDists", "boundDelta", "snapOffsetY", "snapOffsetX", "distSnapX", "distSnapY", "nextClipStyles", "dragDist", "isDouble", "isClipStart", "OriginDraggable", "originRelative", "distOrigin", "nextMatrix", "dragDelta", "addBorderRadiusByLine", "lineIndex", "horizontalsLength", "virtual", "verticalsLength", "controlIndex", "controlPoseInfo", "addBorderRadius", "removeBorderRadius", "getBorderRadius", "borderRadius", "triggerRoundEvent", "styles", "getStyleBorderRadius", "firstMoveable", "firstTarget", "Roundable", "roundClickable", "borderRadiusState", "minRoundControls", "maxRoundControls", "roundPadding", "isDisplayShadowRoundControls", "verticalCount", "horizontalCount", "basePos", "originalPos", "isDisplayVerticalShadow", "isDisplay", "indexAttr", "roundRelative", "selectedControlPose", "selectedVertical", "selectedHorizontal", "pose", "poseDist", "getRotatiion", "touches", "isMultiTouch", "getEventClients", "getClients", "getClient", "isMouseEvent", "getPosition", "clients", "prevClients", "startClients", "getAverageClient", "originalClientX", "originalClientY", "prevX", "prevY", "_c", "deltaX", "deltaY", "sumClient", "minLength", "client", "ClientStore", "isAdd", "movement", "currentClient", "prevClient", "INPUT_TAGNAMES", "Gesto", "isTrusted", "isDragAPI", "pinchOutside", "preventWheelClick", "preventRightClick", "preventDefault", "checkInput", "dragFocusedInput", "preventClickEventOnDragStart", "preventClickEventOnDrag", "preventClickEventByCondition", "useTouch", "isDragStart", "activeElement", "hasInput", "hasContentEditable", "activeTagName", "addEvent", "timer", "removeEvent", "isScroll", "dragResult", "clientsLength", "currentTime", "elements", "checkWindowBlur", "passive_1", "isCallDrag", "nextClients", "currentData", "name_1", "pinchThreshold", "isPrevDrag", "isFirstDrag", "storePosition", "win", "passive", "isIdentityMatrix", "identityMatrix", "BeforeRenderable", "inlineTransform", "cssMatrix", "startTransform", "Renderable", "getNextTransformText", "getNextStyle", "transformObject", "matrixInfo", "triggerAble", "moveableAbles", "eventOperations", "eventAffix", "eventType", "requestInstant", "isAfter", "requestAble", "isDragStop", "stop", "isFirstStart", "gestoType", "prevGesto", "trigger", "conditionName", "nextDatas", "forceEndedCount", "updatedCount", "eventOperation", "eventAbles", "isUpdate", "isForceEnd", "checkMoveableTarget", "eventTarget", "dragTargetElement", "getTargetAbleGesto", "moveableTarget", "controlBox", "dragTarget", "checkTarget", "getAbleGesto", "getControlAbleGesto", "checkControlTarget", "ableType", "conditionFunctions", "isTargetAbles", "preventClickDefault", "dragContaienrOption", "dragContainer", "isPinchScheduled", "EventManager", "__publicField", "hash", "str", "stringHash", "getHash", "getShadowRoot", "rootNode", "replaceStyle", "selector", "trimmedSelector", "subSelector", "trimmedSubSelector", "injectStyle", "shadowRoot", "doc", "getDocument", "styled", "injectClassName", "styleElement", "injectCount", "__rest", "Tag", "injector", "cssStyled", "cssId", "forwardRef", "attributes", "targetRef", "useRef", "useImperativeHandle", "useEffect", "injectResult", "calculateMatrixStack", "rootContainer", "isAbsolute3d", "prevTargetMatrix", "offsetContainer", "containerZoom", "getMatrixStackInfo", "rootMatrixes", "isRoot3d", "offsetRootContainer", "rootZoom", "getCachedMatrixContainerInfo", "isNext3d", "isSVGGraphicElement", "nextRootMatrixes", "originalRootContainer", "endContainer", "rootMatrixBeforeOffset", "nextInfo", "isMatrix3d", "originalRootMatrix", "calculateElementInfo", "allResult", "calculateElementPosition", "getElementInfo", "getMoveableTargetInfo", "moveableElement", "parentContainer", "requestStyles", "targetClientRect", "rootContainerClientRect", "beforePosition", "absoluteTargetPosition", "absoluteContainerPosition", "getCachedClientRect", "containerClientRectLeft", "containerClientRectTop", "containterClientLeft", "containerClientTop", "clientDelta", "getPersistState", "MoveableManager", "cancelAnimationFrame", "parentPosition", "propsTarget", "cspNonce", "translateZ", "ControlBoxElement", "linePadding", "controlPadding", "stateTarget", "groupTargets", "isDragging", "ableAttributes", "ableClassName", "isVisible", "prevProps", "manager", "wrapperMoveable", "targetGesto", "controlGesto", "totalSize", "isTarget", "isSetState", "isSingle", "setStoreCache", "nextState", "persistState", "statePos", "isInstant", "allAbles", "requsetAble", "ableRequester", "requester", "ableParam", "originalBeforeOrigin", "stateLeft", "stateTop", "isPersisted", "absoluteOrigin", "renderPos3", "renderPos4", "zoomOffset", "stateContainer", "isTargetChanged", "moveableContainer", "tag", "customStyleMap", "hasControlBox", "persistData", "firstRenderState", "pinchStart", "dragControlStart", "targetAbles", "controlAbles", "Renderer", "render", "ableStyleNames", "hasTargetAble", "hasControlAble", "hideDefaultLines", "hideChildMoveableDefaultLines", "useDragArea", "nextTarget", "prevTarget", "prevDragArea", "eventKeys", "hasAbles", "viewContainerOption", "viewContainer", "nextClassNames", "prevClassNames", "classPrefix", "targetGestoData", "controlGestoData", "observer", "records", "mutation", "Groupable", "renderGroupRects", "persistDatChildren", "refs", "Clickable", "containsElement", "containsTarget", "targetIndex", "parentTarget", "getDraggableEvent", "edgeDraggable", "IndividualGroupable", "MOVEABLE_ABLES", "MOVEABLE_EVENTS", "current", "pushSet", "MOVEABLE_PROPS", "solveConstantsDistance", "solveC", "getMaxPos", "getMinPos", "getGroupRect", "parentPoses", "fixedRotation", "a1MinMax", "MAX_NUM", "MIN_NUM", "a1MinMaxPos", "a2MinMax", "a2MinMaxPos", "a1Dist", "a2Dist", "a1MinPos", "a1MaxPos", "a2MinPos", "a2MaxPos", "minHorizontalLine", "maxHorizontalLine", "minVerticalLine", "maxVerticalLine", "findMoveableGroups", "childTargetGroups", "targetGroup", "childMoveableGroups", "checked", "MoveableGroup", "checkeds", "targetGroups", "moveableGroups", "useDefaultGroupRotate", "finded", "isReset", "defaultGroupRotate", "persistedRoatation", "getMoveableGroupRect", "parentRotation", "posesRotations", "rotations", "groupRotation", "firstRotation", "isSameRotation", "groupPoses", "rootGroupRect", "posesInfo", "rotateScale", "isContainerChanged", "MoveableIndividualGroup", "canPersist", "individualProps", "m", "controlBoxElement", "dragElement", "getElementTargets", "refTargets", "selectorMap", "elementTargets", "getTargetGroups", "compareRefTargets", "prevRefTargets", "nextRefTargets", "InitialMoveable", "cssMap", "text", "prefixCSS", "MOVEABLE_CSS", "moveableContructor", "userAbles", "userProps", "nextSelectorMap", "nextProps", "prevMoveable", "prevTargetMoveable", "mv", "resolvePromise", "isBrowser", "updateSelectorMap", "Moveable", "makeMoveable"]
}

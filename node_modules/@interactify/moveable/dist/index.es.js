var $a = Object.defineProperty;
var Fa = (t, e, n) => e in t ? $a(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var X = (t, e, n) => Fa(t, typeof e != "symbol" ? e + "" : e, n);
import * as _o from "react";
import To, { createElement as Bn, forwardRef as La, useRef as Na, useImperativeHandle as Wa, useEffect as Ya } from "react";
function dn(t, e) {
  return {
    events: [],
    props: [],
    name: t,
    ...e
  };
}
function Vr(t, e) {
  for (var n = t.length, r = 0; r < n; ++r)
    if (e(t[r], r))
      return !0;
  return !1;
}
function Oo(t, e) {
  for (var n = t.length, r = 0; r < n; ++r)
    if (e(t[r], r))
      return t[r];
  return null;
}
function wo(t) {
  var e = t;
  if (typeof e > "u") {
    if (typeof navigator > "u" || !navigator)
      return "";
    e = navigator.userAgent || "";
  }
  return e.toLowerCase();
}
function jr(t, e) {
  try {
    return new RegExp(t, "g").exec(e);
  } catch {
    return null;
  }
}
function Va() {
  if (typeof navigator > "u" || !navigator || !navigator.userAgentData)
    return !1;
  var t = navigator.userAgentData, e = t.brands || t.uaList;
  return !!(e && e.length);
}
function ja(t, e) {
  var n = jr("(" + t + ")((?:\\/|\\s|:)([0-9|\\.|_]+))", e);
  return n ? n[3] : "";
}
function Sr(t) {
  return t.replace(/_/g, ".");
}
function Ke(t, e) {
  var n = null, r = "-1";
  return Vr(t, function(s) {
    var o = jr("(" + s.test + ")((?:\\/|\\s|:)([0-9|\\.|_]+))?", e);
    return !o || s.brand ? !1 : (n = s, r = o[3] || "-1", s.versionAlias ? r = s.versionAlias : s.versionTest && (r = ja(s.versionTest.toLowerCase(), e) || r), r = Sr(r), !0);
  }), {
    preset: n,
    version: r
  };
}
function xn(t, e) {
  var n = {
    brand: "",
    version: "-1"
  };
  return Vr(t, function(r) {
    var s = Io(e, r);
    return s ? (n.brand = r.id, n.version = r.versionAlias || s.version, n.version !== "-1") : !1;
  }), n;
}
function Io(t, e) {
  return Oo(t, function(n) {
    var r = n.brand;
    return jr("" + e.test, r.toLowerCase());
  });
}
var Bo = [{
  test: "phantomjs",
  id: "phantomjs"
}, {
  test: "whale",
  id: "whale"
}, {
  test: "edgios|edge|edg",
  id: "edge"
}, {
  test: "msie|trident|windows phone",
  id: "ie",
  versionTest: "iemobile|msie|rv"
}, {
  test: "miuibrowser",
  id: "miui browser"
}, {
  test: "samsungbrowser",
  id: "samsung internet"
}, {
  test: "samsung",
  id: "samsung internet",
  versionTest: "version"
}, {
  test: "chrome|crios",
  id: "chrome"
}, {
  test: "firefox|fxios",
  id: "firefox"
}, {
  test: "android",
  id: "android browser",
  versionTest: "version"
}, {
  test: "safari|iphone|ipad|ipod",
  id: "safari",
  versionTest: "version"
}], zo = [{
  test: "(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\schrome)",
  id: "chrome",
  versionTest: "chrome"
}, {
  test: "chromium",
  id: "chrome"
}, {
  test: "whale",
  id: "chrome",
  versionAlias: "-1",
  brand: !0
}], Er = [{
  test: "applewebkit",
  id: "webkit",
  versionTest: "applewebkit|safari"
}], Ao = [{
  test: "(?=(iphone|ipad))(?!(.*version))",
  id: "webview"
}, {
  test: "(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))",
  id: "webview"
}, {
  // test webview
  test: "webview",
  id: "webview"
}], Go = [{
  test: "windows phone",
  id: "windows phone"
}, {
  test: "windows 2000",
  id: "window",
  versionAlias: "5.0"
}, {
  test: "windows nt",
  id: "window"
}, {
  test: "win32|windows",
  id: "window"
}, {
  test: "iphone|ipad|ipod",
  id: "ios",
  versionTest: "iphone os|cpu os"
}, {
  test: "macos|macintel|mac os x",
  id: "mac"
}, {
  test: "android|linux armv81",
  id: "android"
}, {
  test: "tizen",
  id: "tizen"
}, {
  test: "webos|web0s",
  id: "webos"
}];
function ko(t) {
  return !!Ke(Ao, t).preset;
}
function Xa(t) {
  var e = wo(t), n = !!/mobi/g.exec(e), r = {
    name: "unknown",
    version: "-1",
    majorVersion: -1,
    webview: ko(e),
    chromium: !1,
    chromiumVersion: "-1",
    webkit: !1,
    webkitVersion: "-1"
  }, s = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  }, o = Ke(Bo, e), i = o.preset, a = o.version, c = Ke(Go, e), l = c.preset, u = c.version, f = Ke(zo, e);
  if (r.chromium = !!f.preset, r.chromiumVersion = f.version, !r.chromium) {
    var d = Ke(Er, e);
    r.webkit = !!d.preset, r.webkitVersion = d.version;
  }
  return l && (s.name = l.id, s.version = u, s.majorVersion = parseInt(u, 10)), i && (r.name = i.id, r.version = a, r.webview && s.name === "ios" && r.name !== "safari" && (r.webview = !1)), r.majorVersion = parseInt(r.version, 10), {
    browser: r,
    os: s,
    isMobile: n,
    isHints: !1
  };
}
function Ha(t) {
  var e = navigator.userAgentData, n = (e.uaList || e.brands).slice(), r = e.mobile || !1, s = n[0], o = (e.platform || navigator.platform).toLowerCase(), i = {
    name: s.brand,
    version: s.version,
    majorVersion: -1,
    webkit: !1,
    webkitVersion: "-1",
    chromium: !1,
    chromiumVersion: "-1",
    webview: !!xn(Ao, n).brand || ko(wo())
  }, a = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  };
  i.webkit = !i.chromium && Vr(Er, function(d) {
    return Io(n, d);
  });
  var c = xn(zo, n);
  if (i.chromium = !!c.brand, i.chromiumVersion = c.version, !i.chromium) {
    var l = xn(Er, n);
    i.webkit = !!l.brand, i.webkitVersion = l.version;
  }
  var u = Oo(Go, function(d) {
    return new RegExp("" + d.test, "g").exec(o);
  });
  a.name = u ? u.id : "";
  {
    var f = xn(Bo, n);
    i.name = f.brand || i.name, i.version = f.brand && t ? t.uaFullVersion : f.version;
  }
  return i.webkit && (a.name = r ? "ios" : "mac"), a.name === "ios" && i.webview && (i.version = "-1"), a.version = Sr(a.version), i.version = Sr(i.version), a.majorVersion = parseInt(a.version, 10), i.majorVersion = parseInt(i.version, 10), {
    browser: i,
    os: a,
    isMobile: r,
    isHints: !0
  };
}
function qa(t) {
  return Va() ? Ha() : Xa(t);
}
const Ua = ["n", "w", "s", "e"], Xr = ["n", "w", "s", "e", "nw", "ne", "sw", "se"];
function Ka(t, e) {
  return `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="${32 * t}px" height="${32 * t}px" viewBox="0 0 32 32" ><path d="M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z" stroke-linejoin="round" stroke-width="1.2" fill="black" stroke="white" style="transform:rotate(${e}deg);transform-origin: 16px 16px"></path></svg>`;
}
function Za(t) {
  const e = Ka(1, t), n = Math.round(t / 45) * 45 % 180;
  let r = "ns-resize";
  return n === 135 ? r = "nwse-resize" : n === 45 ? r = "nesw-resize" : n === 90 && (r = "ew-resize"), `cursor:${r};cursor: url('${e}') 16 16, ${r};`;
}
const Ye = qa(), $o = Ye.browser.webkit, Fo = $o && (() => {
  const t = typeof window > "u" ? { userAgent: "" } : window.navigator, e = /applewebkit\/([^\s]+)/g.exec(t.userAgent.toLowerCase());
  return e ? parseFloat(e[1]) < 605 : !1;
})(), Lo = Ye.browser.name, No = parseInt(Ye.browser.version, 10), Ja = Lo === "chrome", Qa = Ye.browser.chromium, tc = parseInt(Ye.browser.chromiumVersion, 10) || 0, ec = Ja && No >= 109 || Qa && tc >= 109, nc = Lo === "firefox", rc = parseInt(Ye.browser.webkitVersion, 10) >= 612 || No >= 15, Hr = "moveable-", sc = Xr.map((t) => {
  let e = "", n = "", r = "center", s = "center";
  const o = "calc(var(--moveable-control-padding, 20) * -1px)";
  return t.indexOf("n") > -1 && (e = `top: ${o};`, s = "bottom"), t.indexOf("s") > -1 && (e = "top: 0px;", s = "top"), t.indexOf("w") > -1 && (n = `left: ${o};`, r = "right"), t.indexOf("e") > -1 && (n = "left: 0px;", r = "left"), `.around-control[data-direction*="${t}"] {
        ${n}${e}
        transform-origin: ${r} ${s};
    }`;
}).join(`
`), oc = `
{
position: absolute;
width: 1px;
height: 1px;
left: 0;
top: 0;
z-index: 3000;
--moveable-color: #4af;
--zoom: 1;
--zoompx: 1px;
--moveable-line-padding: 0;
--moveable-control-padding: 0;
will-change: transform;
outline: 1px solid transparent;
}
.control-box {
z-index: 0;
}
.line, .control {
position: absolute;
left: 0;
top: 0;
will-change: transform;
}
.control {
width: 14px;
height: 14px;
border-radius: 50%;
border: 2px solid #fff;
box-sizing: border-box;
background: #4af;
background: var(--moveable-color);
margin-top: -7px;
margin-left: -7px;
border: 2px solid #fff;
z-index: 10;
}
.around-control {
position: absolute;
will-change: transform;
width: calc(var(--moveable-control-padding, 20) * 1px);
height: calc(var(--moveable-control-padding, 20) * 1px);
left: calc(var(--moveable-control-padding, 20) * -0.5px);
top: calc(var(--moveable-control-padding, 20) * -0.5px);
box-sizing: border-box;
background: transparent;
z-index: 8;
cursor: alias;
transform-origin: center center;
}
${sc}
.padding {
position: absolute;
top: 0px;
left: 0px;
width: 100px;
height: 100px;
transform-origin: 0 0;
}
.line {
width: 1px;
height: 1px;
background: #4af;
background: var(--moveable-color);
transform-origin: 0px 50%;
}
.line.edge {
z-index: 1;
background: transparent;
}
.line.dashed {
box-sizing: border-box;
background: transparent;
}
.line.dashed.horizontal {
border-top: 1px dashed #4af;
border-top-color: #4af;
border-top-color: var(--moveable-color);
}
.line.dashed.vertical {
border-left: 1px dashed #4af;
border-left-color: #4af;
border-left-color: var(--moveable-color);
}
.line.vertical {
transform: translateX(-50%);
}
.line.horizontal {
transform: translateY(-50%);
}
.line.vertical.bold {
width: 2px;
}
.line.horizontal.bold {
height: 2px;
}

.control.origin {
border-color: #f55;
background: #fff;
width: 12px;
height: 12px;
margin-top: -6px;
margin-left: -6px;
pointer-events: none;
}
${[0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map((t) => `
.direction[data-rotation="${t}"], :global .view-control-rotation${t} {
${Za(t)}
}
`).join(`
`)}

.line.direction:before {
content: "";
position: absolute;
width: 100%;
height: calc(var(--moveable-line-padding, 0) * 1px);
bottom: 0;
left: 0;
}
.group {
z-index: -1;
}
.area {
position: absolute;
}
.area-pieces {
position: absolute;
top: 0;
left: 0;
display: none;
}
.area.avoid, .area.pass {
pointer-events: none;
}
.area.avoid+.area-pieces {
display: block;
}
.area-piece {
position: absolute;
}

${Fo ? `:global svg *:before {
content:"";
transform-origin: inherit;
}` : ""}
`, ic = [
  [0, 1, 2],
  [1, 0, 3],
  [2, 0, 3],
  [3, 1, 2]
], Cr = 1e-4, Bt = 1e-7, Sn = 1e-9, Dr = Math.pow(10, 10), Fs = -Dr, ac = {
  n: [0, -1],
  e: [1, 0],
  s: [0, 1],
  w: [-1, 0],
  nw: [-1, -1],
  ne: [1, -1],
  sw: [-1, 1],
  se: [1, 1]
}, qr = {
  n: [0, 1],
  e: [1, 3],
  s: [3, 2],
  w: [2, 0],
  nw: [0],
  ne: [1],
  sw: [2],
  se: [3]
}, Wo = {
  n: 0,
  s: 180,
  w: 270,
  e: 90,
  nw: 315,
  ne: 45,
  sw: 225,
  se: 135
}, wf = [
  "isMoveableElement",
  "updateRect",
  "updateTarget",
  "destroy",
  "dragStart",
  "isInside",
  "hitTest",
  "setState",
  "getRect",
  "request",
  "isDragging",
  "getManager",
  "forceUpdate",
  "waitToChangeTarget",
  "updateSelectors",
  "getTargets",
  "stopDrag",
  "getControlBoxElement",
  "getMoveables",
  "getDragElement"
];
function cc(t, ...e) {
  return e.map(
    (n) => n.split(" ").map((r) => r ? `${t}${r}` : "").join(" ")
  ).join(" ");
}
function lc(t, e) {
  return e.replace(/([^}{]*){/gm, (n, r) => `${r.replace(/\.([^{,\s\d.]+)/g, `.${t}$1`)}{`);
}
function Se(t, e) {
  return (n) => {
    n && (t[e] = n);
  };
}
function Yo(t, e, n) {
  return (r) => {
    r && (t[e][n] = r);
  };
}
var uc = "function", fc = "object", dc = "string", pc = "number", Ur = "undefined", Vo = typeof window !== Ur, gc = typeof document !== Ur && document, hc = [{
  open: "(",
  close: ")"
}, {
  open: '"',
  close: '"'
}, {
  open: "'",
  close: "'"
}, {
  open: '\\"',
  close: '\\"'
}, {
  open: "\\'",
  close: "\\'"
}], Dt = 1e-7, En = {
  cm: function(t) {
    return t * 96 / 2.54;
  },
  mm: function(t) {
    return t * 96 / 254;
  },
  in: function(t) {
    return t * 96;
  },
  pt: function(t) {
    return t * 96 / 72;
  },
  pc: function(t) {
    return t * 96 / 6;
  },
  "%": function(t, e) {
    return t * e / 100;
  },
  vw: function(t, e) {
    return e === void 0 && (e = window.innerWidth), t / 100 * e;
  },
  vh: function(t, e) {
    return e === void 0 && (e = window.innerHeight), t / 100 * e;
  },
  vmax: function(t, e) {
    return e === void 0 && (e = Math.max(window.innerWidth, window.innerHeight)), t / 100 * e;
  },
  vmin: function(t, e) {
    return e === void 0 && (e = Math.min(window.innerWidth, window.innerHeight)), t / 100 * e;
  }
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function vc() {
  for (var t = 0, e = 0, n = arguments.length; e < n; e++) t += arguments[e].length;
  for (var r = Array(t), s = 0, e = 0; e < n; e++) for (var o = arguments[e], i = 0, a = o.length; i < a; i++, s++) r[s] = o[i];
  return r;
}
function zn(t, e, n, r) {
  return (t * r + e * n) / (n + r);
}
function Kr(t) {
  return typeof t === Ur;
}
function qt(t) {
  return t && typeof t === fc;
}
function Rt(t) {
  return Array.isArray(t);
}
function re(t) {
  return typeof t === dc;
}
function an(t) {
  return typeof t === pc;
}
function Zr(t) {
  return typeof t === uc;
}
function mc(t, e) {
  var n = t === "" || t == " ", r = e === "" || e == " ";
  return r && n || t === e;
}
function jo(t, e, n, r, s) {
  var o = Jr(t, e, n);
  return o ? n : xc(t, e, n + 1, r, s);
}
function Jr(t, e, n) {
  if (!t.ignore)
    return null;
  var r = e.slice(Math.max(n - 3, 0), n + 3).join("");
  return new RegExp(t.ignore).exec(r);
}
function xc(t, e, n, r, s) {
  for (var o = function(l) {
    var u = e[l].trim();
    if (u === t.close && !Jr(t, e, l))
      return {
        value: l
      };
    var f = l, d = kt(s, function(p) {
      var g = p.open;
      return g === u;
    });
    if (d && (f = jo(d, e, l, r, s)), f === -1)
      return i = l, "break";
    l = f, i = l;
  }, i, a = n; a < r; ++a) {
    var c = o(a);
    if (a = i, typeof c == "object") return c.value;
    if (c === "break") break;
  }
  return -1;
}
function Qr(t, e) {
  var n = re(e) ? {
    separator: e
  } : e, r = n.separator, s = r === void 0 ? "," : r, o = n.isSeparateFirst, i = n.isSeparateOnlyOpenClose, a = n.isSeparateOpenClose, c = a === void 0 ? i : a, l = n.openCloseCharacters, u = l === void 0 ? hc : l, f = u.map(function(R) {
    var y = R.open, M = R.close;
    return y === M ? y : y + "|" + M;
  }).join("|"), d = "(\\s*" + s + "\\s*|" + f + "|\\s+)", p = new RegExp(d, "g"), g = t.split(p).filter(function(R) {
    return R && R !== "undefined";
  }), h = g.length, v = [], m = [];
  function S() {
    return m.length ? (v.push(m.join("")), m = [], !0) : !1;
  }
  for (var x = function(R) {
    var y = g[R].trim(), M = R, P = kt(u, function(T) {
      var w = T.open;
      return w === y;
    }), _ = kt(u, function(T) {
      var w = T.close;
      return w === y;
    });
    if (P) {
      if (M = jo(P, g, R, h, u), M !== -1 && c)
        return S() && o || (v.push(g.slice(R, M + 1).join("")), R = M, o) ? (C = R, "break") : (C = R, "continue");
    } else if (_ && !Jr(_, g, R)) {
      var O = vc(u);
      return O.splice(u.indexOf(_), 1), {
        value: Qr(t, {
          separator: s,
          isSeparateFirst: o,
          isSeparateOnlyOpenClose: i,
          isSeparateOpenClose: c,
          openCloseCharacters: O
        })
      };
    } else if (mc(y, s) && !i)
      return S(), o ? (C = R, "break") : (C = R, "continue");
    M === -1 && (M = h - 1), m.push(g.slice(R, M + 1).join("")), R = M, C = R;
  }, C, E = 0; E < h; ++E) {
    var D = x(E);
    if (E = C, typeof D == "object") return D.value;
    if (D === "break") break;
  }
  return m.length && v.push(m.join("")), v;
}
function ce(t) {
  return Qr(t, "");
}
function xe(t) {
  return Qr(t, ",");
}
function Xo(t) {
  var e = /([^(]*)\(([\s\S]*)\)([\s\S]*)/g.exec(t);
  return !e || e.length < 4 ? {} : {
    prefix: e[1],
    value: e[2],
    suffix: e[3]
  };
}
function pn(t) {
  var e = /^([^\d|e|\-|\+]*)((?:\d|\.|-|e-|e\+)+)(\S*)$/g.exec(t);
  if (!e)
    return {
      prefix: "",
      unit: "",
      value: NaN
    };
  var n = e[1], r = e[2], s = e[3];
  return {
    prefix: n,
    unit: s,
    value: parseFloat(r)
  };
}
function Sc(t, e) {
  return t.replace(/([a-z])([A-Z])/g, function(n, r, s) {
    return "" + r + e + s.toLowerCase();
  });
}
function cn() {
  return Date.now ? Date.now() : (/* @__PURE__ */ new Date()).getTime();
}
function ne(t, e, n) {
  n === void 0 && (n = -1);
  for (var r = t.length, s = 0; s < r; ++s)
    if (e(t[s], s, t))
      return s;
  return n;
}
function kt(t, e, n) {
  var r = ne(t, e);
  return r > -1 ? t[r] : n;
}
var Ho = /* @__PURE__ */ function() {
  var t = cn(), e = Vo && (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame);
  return e ? e.bind(window) : function(n) {
    var r = cn(), s = setTimeout(function() {
      n(r - t);
    }, 1e3 / 60);
    return s;
  };
}(), Ec = /* @__PURE__ */ function() {
  var t = Vo && (window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame);
  return t ? t.bind(window) : function(e) {
    clearTimeout(e);
  };
}();
function Ve(t) {
  return Object.keys(t);
}
function ft(t, e) {
  var n = pn(t), r = n.value, s = n.unit;
  if (qt(e)) {
    var o = e[s];
    if (o) {
      if (Zr(o))
        return o(r);
      if (En[s])
        return En[s](r, o);
    }
  } else if (s === "%")
    return r * e / 100;
  return En[s] ? En[s](r) : r;
}
function br(t, e, n) {
  return Math.max(e, Math.min(t, n));
}
function Ls(t, e, n, r) {
  return r === void 0 && (r = t[0] / t[1]), [[tt(e[0], Dt), tt(e[0] / r, Dt)], [tt(e[1] * r, Dt), tt(e[1], Dt)]].filter(function(s) {
    return s.every(function(o, i) {
      var a = e[i], c = tt(a, Dt);
      return n ? o <= a || o <= c : o >= a || o >= c;
    });
  })[0] || t;
}
function qo(t, e, n, r) {
  if (!r)
    return t.map(function(p, g) {
      return br(p, e[g], n[g]);
    });
  var s = t[0], o = t[1], i = r === !0 ? s / o : r, a = Ls(t, e, !1, i), c = a[0], l = a[1], u = Ls(t, n, !0, i), f = u[0], d = u[1];
  return s < c || o < l ? (s = c, o = l) : (s > f || o > d) && (s = f, o = d), [s, o];
}
function Cc(t) {
  for (var e = t.length, n = 0, r = e - 1; r >= 0; --r)
    n += t[r];
  return n;
}
function yr(t) {
  for (var e = t.length, n = 0, r = e - 1; r >= 0; --r)
    n += t[r];
  return e ? n / e : 0;
}
function xt(t, e) {
  var n = e[0] - t[0], r = e[1] - t[1], s = Math.atan2(r, n);
  return s >= 0 ? s : s + Math.PI * 2;
}
function Dc(t) {
  return [0, 1].map(function(e) {
    return yr(t.map(function(n) {
      return n[e];
    }));
  });
}
function Ns(t) {
  var e = Dc(t), n = xt(e, t[0]), r = xt(e, t[1]);
  return n < r && r - n < Math.PI || n > r && r - n < -Math.PI ? 1 : -1;
}
function te(t, e) {
  return Math.sqrt(Math.pow((e ? e[0] : 0) - t[0], 2) + Math.pow((e ? e[1] : 0) - t[1], 2));
}
function tt(t, e) {
  if (!e)
    return t;
  var n = 1 / e;
  return Math.round(t / e) / n;
}
function Ws(t, e) {
  return t.forEach(function(n, r) {
    t[r] = tt(t[r], e);
  }), t;
}
function bc(t) {
  for (var e = [], n = 0; n < t; ++n)
    e.push(n);
  return e;
}
function yc(t) {
  return t.reduce(function(e, n) {
    return e.concat(n);
  }, []);
}
function Uo(t, e) {
  t.indexOf(e) === -1 && t.push(e);
}
function bt(t, e) {
  return t.classList ? t.classList.contains(e) : !!t.className.match(new RegExp("(\\s|^)" + e + "(\\s|$)"));
}
function Ko(t, e) {
  t.classList ? t.classList.add(e) : t.className += " " + e;
}
function Zo(t, e) {
  if (t.classList)
    t.classList.remove(e);
  else {
    var n = new RegExp("(\\s|^)" + e + "(\\s|$)");
    t.className = t.className.replace(n, " ");
  }
}
function Pt(t, e, n, r) {
  t.addEventListener(e, n, r);
}
function Mt(t, e, n, r) {
  t.removeEventListener(e, n, r);
}
function ts(t) {
  return (t == null ? void 0 : t.ownerDocument) || gc;
}
function es(t) {
  return ts(t).documentElement;
}
function fe(t) {
  return ts(t).body;
}
function ae(t) {
  var e;
  return ((e = t == null ? void 0 : t.ownerDocument) === null || e === void 0 ? void 0 : e.defaultView) || window;
}
function Jo(t) {
  return t && "postMessage" in t && "blur" in t && "self" in t;
}
function ns(t) {
  return qt(t) && t.nodeName && t.nodeType && "ownerDocument" in t;
}
function Rc(t, e, n, r, s, o) {
  for (var i = 0; i < s; ++i) {
    var a = n + i * s, c = r + i * s;
    t[a] += t[c] * o, e[a] += e[c] * o;
  }
}
function Mc(t, e, n, r, s) {
  for (var o = 0; o < s; ++o) {
    var i = n + o * s, a = r + o * s, c = t[i], l = e[i];
    t[i] = t[a], t[a] = c, e[i] = e[a], e[a] = l;
  }
}
function Pc(t, e, n, r, s) {
  for (var o = 0; o < r; ++o) {
    var i = n + o * r;
    t[i] /= s, e[i] /= s;
  }
}
function Qo(t, e, n) {
  for (var r = t.slice(), s = 0; s < n; ++s)
    r[s * n + e - 1] = 0, r[(e - 1) * n + s] = 0;
  return r[(e - 1) * (n + 1)] = 1, r;
}
function Jt(t, e) {
  e === void 0 && (e = Math.sqrt(t.length));
  for (var n = t.slice(), r = gt(e), s = 0; s < e; ++s) {
    var o = e * s + s;
    if (!tt(n[o], Dt)) {
      for (var i = s + 1; i < e; ++i)
        if (n[e * s + i]) {
          Mc(n, r, s, i, e);
          break;
        }
    }
    if (!tt(n[o], Dt))
      return [];
    Pc(n, r, s, e, n[o]);
    for (var i = 0; i < e; ++i) {
      var a = i, c = i + s * e, l = n[c];
      !tt(l, Dt) || s === i || Rc(n, r, a, s, e, -l);
    }
  }
  return r;
}
function _c(t, e) {
  e === void 0 && (e = Math.sqrt(t.length));
  for (var n = [], r = 0; r < e; ++r)
    for (var s = 0; s < e; ++s)
      n[s * e + r] = t[e * r + s];
  return n;
}
function ti(t, e) {
  e === void 0 && (e = Math.sqrt(t.length));
  for (var n = [], r = t[e * e - 1], s = 0; s < e - 1; ++s)
    n[s] = t[e * (e - 1) + s] / r;
  return n[e - 1] = 0, n;
}
function Tc(t, e) {
  for (var n = gt(e), r = 0; r < e - 1; ++r)
    n[e * (e - 1) + r] = t[r] || 0;
  return n;
}
function Ee(t, e) {
  for (var n = t.slice(), r = t.length; r < e - 1; ++r)
    n[r] = 0;
  return n[e - 1] = 1, n;
}
function Ut(t, e, n) {
  if (e === void 0 && (e = Math.sqrt(t.length)), e === n)
    return t;
  for (var r = gt(n), s = Math.min(e, n), o = 0; o < s - 1; ++o) {
    for (var i = 0; i < s - 1; ++i)
      r[o * n + i] = t[o * e + i];
    r[(o + 1) * n - 1] = t[(o + 1) * e - 1], r[(n - 1) * n + o] = t[(e - 1) * e + o];
  }
  return r[n * n - 1] = t[e * e - 1], r;
}
function An(t) {
  for (var e = [], n = 1; n < arguments.length; n++)
    e[n - 1] = arguments[n];
  var r = gt(t);
  return e.forEach(function(s) {
    r = dt(r, s, t);
  }), r;
}
function dt(t, e, n) {
  n === void 0 && (n = Math.sqrt(t.length));
  var r = [], s = t.length / n, o = e.length / s;
  if (s) {
    if (!o)
      return t;
  } else return e;
  for (var i = 0; i < n; ++i)
    for (var a = 0; a < o; ++a) {
      r[a * n + i] = 0;
      for (var c = 0; c < s; ++c)
        r[a * n + i] += t[c * n + i] * e[a * s + c];
    }
  return r;
}
function at(t, e) {
  for (var n = Math.min(t.length, e.length), r = t.slice(), s = 0; s < n; ++s)
    r[s] = r[s] + e[s];
  return r;
}
function K(t, e) {
  for (var n = Math.min(t.length, e.length), r = t.slice(), s = 0; s < n; ++s)
    r[s] = r[s] - e[s];
  return r;
}
function Oc(t, e) {
  return e === void 0 && (e = t.length === 6), e ? [t[0], t[1], 0, t[2], t[3], 0, t[4], t[5], 1] : t;
}
function ei(t, e) {
  return e === void 0 && (e = t.length === 9), e ? [t[0], t[1], t[3], t[4], t[6], t[7]] : t;
}
function _t(t, e, n) {
  n === void 0 && (n = e.length);
  var r = dt(t, e, n), s = r[n - 1];
  return r.map(function(o) {
    return o / s;
  });
}
function wc(t, e) {
  return dt(t, [1, 0, 0, 0, 0, Math.cos(e), Math.sin(e), 0, 0, -Math.sin(e), Math.cos(e), 0, 0, 0, 0, 1], 4);
}
function Ic(t, e) {
  return dt(t, [Math.cos(e), 0, -Math.sin(e), 0, 0, 1, 0, 0, Math.sin(e), 0, Math.cos(e), 0, 0, 0, 0, 1], 4);
}
function Bc(t, e) {
  return dt(t, hn(e, 4));
}
function Cn(t, e) {
  var n = e[0], r = n === void 0 ? 1 : n, s = e[1], o = s === void 0 ? 1 : s, i = e[2], a = i === void 0 ? 1 : i;
  return dt(t, [r, 0, 0, 0, 0, o, 0, 0, 0, 0, a, 0, 0, 0, 0, 1], 4);
}
function gn(t, e) {
  return _t(hn(e, 3), Ee(t, 3));
}
function ir(t, e) {
  var n = e[0], r = n === void 0 ? 0 : n, s = e[1], o = s === void 0 ? 0 : s, i = e[2], a = i === void 0 ? 0 : i;
  return dt(t, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, r, o, a, 1], 4);
}
function Ys(t, e) {
  return dt(t, e, 4);
}
function hn(t, e) {
  var n = Math.cos(t), r = Math.sin(t), s = gt(e);
  return s[0] = n, s[1] = r, s[e] = -r, s[e + 1] = n, s;
}
function gt(t) {
  for (var e = t * t, n = [], r = 0; r < e; ++r)
    n[r] = r % (t + 1) ? 0 : 1;
  return n;
}
function rs(t, e) {
  for (var n = gt(e), r = Math.min(t.length, e - 1), s = 0; s < r; ++s)
    n[(e + 1) * s] = t[s];
  return n;
}
function Ce(t, e) {
  for (var n = gt(e), r = Math.min(t.length, e - 1), s = 0; s < r; ++s)
    n[e * (e - 1) + s] = t[s];
  return n;
}
function ss(t, e, n, r, s, o, i, a) {
  var c = t[0], l = t[1], u = e[0], f = e[1], d = n[0], p = n[1], g = r[0], h = r[1], v = s[0], m = s[1], S = o[0], x = o[1], C = i[0], E = i[1], D = a[0], R = a[1], y = [c, 0, u, 0, d, 0, g, 0, l, 0, f, 0, p, 0, h, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, c, 0, u, 0, d, 0, g, 0, l, 0, f, 0, p, 0, h, 0, 1, 0, 1, 0, 1, 0, 1, -v * c, -m * c, -S * u, -x * u, -C * d, -E * d, -D * g, -R * g, -v * l, -m * l, -S * f, -x * f, -C * p, -E * p, -D * h, -R * h], M = Jt(y, 8);
  if (!M.length)
    return [];
  var P = dt(M, [v, m, S, x, C, E, D, R], 8);
  return P[8] = 1, Ut(_c(P), 3, 4);
}
var Qe = function() {
  return Qe = Object.assign || function(e) {
    for (var n, r = 1, s = arguments.length; r < s; r++) {
      n = arguments[r];
      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, Qe.apply(this, arguments);
};
function zc() {
  return [
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
  ];
}
function ln(t, e) {
  return e === void 0 && (e = 0), we($e(t, e));
}
function Ac(t, e) {
  var n = _t(t, [e[0], e[1] || 0, e[2] || 0, 1], 4), r = n[3] || 1;
  return [
    n[0] / r,
    n[1] / r,
    n[2] / r
  ];
}
function we(t) {
  var e = zc();
  return t.forEach(function(n) {
    var r = n.matrixFunction, s = n.functionValue;
    r && (e = r(e, s));
  }), e;
}
function $e(t, e) {
  e === void 0 && (e = 0);
  var n = Rt(t) ? t : ce(t);
  return n.map(function(r) {
    var s = Xo(r), o = s.prefix, i = s.value, a = null, c = o, l = "";
    if (o === "translate" || o === "translateX" || o === "translate3d") {
      var u = qt(e) ? Qe(Qe({}, e), { "o%": e["%"] }) : {
        "%": e,
        "o%": e
      }, f = xe(i).map(function(T, w) {
        return w === 0 && "x%" in u ? u["%"] = e["x%"] : w === 1 && "y%" in u ? u["%"] = e["y%"] : u["%"] = e["o%"], ft(T, u);
      }), d = f[0], p = f[1], g = p === void 0 ? 0 : p, h = f[2], v = h === void 0 ? 0 : h;
      a = ir, l = [d, g, v];
    } else if (o === "translateY") {
      var m = qt(e) ? Qe({ "%": e["y%"] }, e) : {
        "%": e
      }, g = ft(i, m);
      a = ir, l = [0, g, 0];
    } else if (o === "translateZ") {
      var v = parseFloat(i);
      a = ir, l = [0, 0, v];
    } else if (o === "scale" || o === "scale3d") {
      var S = xe(i).map(function(T) {
        return parseFloat(T);
      }), x = S[0], C = S[1], E = C === void 0 ? x : C, D = S[2], R = D === void 0 ? 1 : D;
      a = Cn, l = [x, E, R];
    } else if (o === "scaleX") {
      var x = parseFloat(i);
      a = Cn, l = [x, 1, 1];
    } else if (o === "scaleY") {
      var E = parseFloat(i);
      a = Cn, l = [1, E, 1];
    } else if (o === "scaleZ") {
      var R = parseFloat(i);
      a = Cn, l = [1, 1, R];
    } else if (o === "rotate" || o === "rotateZ" || o === "rotateX" || o === "rotateY") {
      var y = pn(i), M = y.unit, P = y.value, _ = M === "rad" ? P : P * Math.PI / 180;
      o === "rotate" || o === "rotateZ" ? (c = "rotateZ", a = Bc) : o === "rotateX" ? a = wc : o === "rotateY" && (a = Ic), l = _;
    } else if (o === "matrix3d")
      a = Ys, l = xe(i).map(function(T) {
        return parseFloat(T);
      });
    else if (o === "matrix") {
      var O = xe(i).map(function(T) {
        return parseFloat(T);
      });
      a = Ys, l = [
        O[0],
        O[1],
        0,
        0,
        O[2],
        O[3],
        0,
        0,
        0,
        0,
        1,
        0,
        O[4],
        O[5],
        0,
        1
      ];
    } else
      c = "";
    return {
      name: o,
      functionName: c,
      value: i,
      matrixFunction: a,
      functionValue: l
    };
  });
}
function vn(t, e, n, r, s, o = "draggable") {
  var l;
  const i = ((l = e.gestos[o]) == null ? void 0 : l.move(n, t.inputEvent)) ?? {}, a = i.originalDatas || i.datas, c = a[o] || (a[o] = {});
  return {
    ...i,
    isPinch: !!r,
    parentEvent: !0,
    datas: c,
    originalDatas: t.originalDatas
  };
}
class Fe {
  constructor(e = "draggable") {
    X(this, "prevX", 0);
    X(this, "prevY", 0);
    X(this, "startX", 0);
    X(this, "startY", 0);
    X(this, "isDrag", !1);
    X(this, "isFlag", !1);
    X(this, "datas", {
      draggable: {}
    });
    this.ableName = e, this.datas = {
      [e]: {}
    };
  }
  dragStart(e, n) {
    this.isDrag = !1, this.isFlag = !1;
    const r = n.originalDatas;
    return this.datas = r, r[this.ableName] || (r[this.ableName] = {}), {
      ...this.move(e, n.inputEvent),
      type: "dragstart"
    };
  }
  drag(e, n) {
    return this.move([
      e[0] - this.prevX,
      e[1] - this.prevY
    ], n);
  }
  move(e, n) {
    let r, s, o = !1;
    if (!this.isFlag)
      this.prevX = e[0], this.prevY = e[1], this.startX = e[0], this.startY = e[1], r = e[0], s = e[1], this.isFlag = !0;
    else {
      const i = this.isDrag;
      r = this.prevX + e[0], s = this.prevY + e[1], (e[0] || e[1]) && (this.isDrag = !0), !i && this.isDrag && (o = !0);
    }
    return this.prevX = r, this.prevY = s, {
      type: "drag",
      clientX: r,
      clientY: s,
      inputEvent: n,
      isFirstDrag: o,
      isDrag: this.isDrag,
      distX: r - this.startX,
      distY: s - this.startY,
      deltaX: e[0],
      deltaY: e[1],
      datas: this.datas[this.ableName],
      originalDatas: this.datas,
      parentEvent: !0,
      parentGesto: this
    };
  }
}
function ke(t, e, n, r) {
  const o = t.length === 16 ? 4 : 3, i = Me(t, n, r, o);
  let [[a, c], [l, u], [f, d], [p, g]] = i, [h, v] = ht(t, e, o);
  const m = Math.min(a, l, f, p), S = Math.min(c, u, d, g), x = Math.max(a, l, f, p), C = Math.max(c, u, d, g);
  a = a - m || 0, l = l - m || 0, f = f - m || 0, p = p - m || 0, c = c - S || 0, u = u - S || 0, d = d - S || 0, g = g - S || 0, h = h - m || 0, v = v - S || 0;
  const E = t[0], D = t[o + 1], R = wt(E * D);
  return {
    left: m,
    top: S,
    right: x,
    bottom: C,
    origin: [h, v],
    pos1: [a, c],
    pos2: [l, u],
    pos3: [f, d],
    pos4: [p, g],
    direction: R
  };
}
function ni(t, e) {
  const { clientX: n, clientY: r, datas: s } = e, {
    moveableClientRect: o,
    rootMatrix: i,
    is3d: a,
    pos1: c
  } = t.state, { left: l, top: u } = o, f = a ? 4 : 3, [d, p] = K(We(i, [n - l, r - u], f), c), [g, h] = Qt({ datas: s, distX: d, distY: p });
  return [g, h];
}
function Re(t, { datas: e }) {
  const {
    allMatrix: n,
    beforeMatrix: r,
    is3d: s,
    left: o,
    top: i,
    origin: a,
    offsetMatrix: c,
    targetMatrix: l,
    transformOrigin: u
  } = t.state, f = s ? 4 : 3;
  e.is3d = s, e.matrix = n, e.targetMatrix = l, e.beforeMatrix = r, e.offsetMatrix = c, e.transformOrigin = u, e.inverseMatrix = Jt(n, f), e.inverseBeforeMatrix = Jt(r, f), e.absoluteOrigin = Ee(at([o, i], a), f), e.startDragBeforeDist = _t(e.inverseBeforeMatrix, e.absoluteOrigin, f), e.startDragDist = _t(e.inverseMatrix, e.absoluteOrigin, f);
}
function Gc(t) {
  return ke(t.datas.beforeTransform, [50, 50], 100, 100).direction;
}
function jn(t, e, n) {
  const {
    datas: r,
    originalDatas: {
      beforeRenderable: s
    }
  } = e, o = r.transformIndex, i = s.nextTransforms, a = i.length, c = s.nextTransformAppendedIndexes;
  let l = -1;
  o === -1 ? (n === "translate" ? l = 0 : n === "rotate" && (l = ne(i, (p) => p.match(/scale\(/g))), l === -1 && (l = i.length), r.transformIndex = l) : kt(c, (p) => p.index === o && p.functionName === n) ? l = o : l = o + c.filter((p) => p.index < o).length;
  const u = Su(i, t.state, l), f = u.targetFunction, d = n === "rotate" ? "rotateZ" : n;
  r.beforeFunctionTexts = u.beforeFunctionTexts, r.afterFunctionTexts = u.afterFunctionTexts, r.beforeTransform = u.beforeFunctionMatrix, r.beforeTransform2 = u.beforeFunctionMatrix2, r.targetTansform = u.targetFunctionMatrix, r.afterTransform = u.afterFunctionMatrix, r.afterTransform2 = u.afterFunctionMatrix2, r.targetAllTransform = u.allFunctionMatrix, f.functionName === d ? (r.afterFunctionTexts.splice(0, 1), r.isAppendTransform = !1) : a > l && (r.isAppendTransform = !0, s.nextTransformAppendedIndexes = [...c, {
    functionName: n,
    index: l,
    isAppend: !0
  }]);
}
function Xn(t, e, n) {
  return `${t.beforeFunctionTexts.join(" ")} ${t.isAppendTransform ? n : e} ${t.afterFunctionTexts.join(" ")}`;
}
function kc({ datas: t, distX: e, distY: n }) {
  const [r, s] = si({ datas: t, distX: e, distY: n }), o = ri(t, Tc([r, s], 4));
  return _t(o, Ee([0, 0, 0], 4), 4);
}
function ri(t, e, n) {
  const {
    beforeTransform: r,
    afterTransform: s,
    beforeTransform2: o,
    afterTransform2: i,
    targetAllTransform: a
  } = t, c = n ? dt(a, e, 4) : dt(e, a, 4), l = dt(Jt(n ? o : r, 4), c, 4);
  return dt(l, Jt(n ? i : s, 4), 4);
}
function si({ datas: t, distX: e, distY: n }) {
  const {
    inverseBeforeMatrix: r,
    is3d: s,
    startDragBeforeDist: o,
    absoluteOrigin: i
  } = t, a = s ? 4 : 3;
  return K(
    _t(
      r,
      at(i, [e, n]),
      a
    ),
    o
  );
}
function Qt({ datas: t, distX: e, distY: n }, r) {
  const {
    inverseBeforeMatrix: s,
    inverseMatrix: o,
    is3d: i,
    startDragBeforeDist: a,
    startDragDist: c,
    absoluteOrigin: l
  } = t, u = i ? 4 : 3;
  return K(
    _t(
      r ? s : o,
      at(l, [e, n]),
      u
    ),
    r ? a : c
  );
}
function $c({ datas: t, distX: e, distY: n }, r) {
  const {
    beforeMatrix: s,
    matrix: o,
    is3d: i,
    startDragBeforeDist: a,
    startDragDist: c,
    absoluteOrigin: l
  } = t, u = i ? 4 : 3;
  return K(
    _t(
      o,
      at(c, [e, n]),
      u
    ),
    l
  );
}
function Fc(t, e, n, r = e, s = n, o = [0, 0]) {
  return t ? t.map((i, a) => {
    const { value: c, unit: l } = pn(i), u = a ? s : r, f = a ? n : e;
    if (i === "%" || isNaN(c)) {
      const d = u ? o[a] / u : 0;
      return f * d;
    } else if (l !== "%")
      return c;
    return f * c / 100;
  }) : o;
}
function oi(t) {
  const e = [];
  return t[1] >= 0 && (t[0] >= 0 && e.push(3), t[0] <= 0 && e.push(2)), t[1] <= 0 && (t[0] >= 0 && e.push(1), t[0] <= 0 && e.push(0)), e;
}
function Lc(t, e) {
  return oi(e).map((n) => t[n]);
}
function ar(t, e) {
  const n = (e + 1) / 2;
  return [
    zn(t[0][0], t[1][0], n, 1 - n),
    zn(t[0][1], t[1][1], n, 1 - n)
  ];
}
function yt(t, e) {
  const n = ar([t[0], t[1]], e[0]), r = ar([t[2], t[3]], e[0]);
  return ar([n, r], e[1]);
}
function Nc(t, e, n, r, s, o) {
  const i = Me(e, n, r, s), a = yt(i, o), c = t[0] - a[0], l = t[1] - a[1];
  return [c, l];
}
function mn(t, e, n, r) {
  return dt(
    t,
    en(e, r, n),
    r
  );
}
function Wc(t, e, n, r) {
  const {
    transformOrigin: s,
    offsetMatrix: o,
    is3d: i
  } = t, a = i ? 4 : 3;
  let c;
  if (re(n)) {
    const {
      beforeTransform: l,
      afterTransform: u
    } = e;
    r ? c = Ut(ln(n), 4, a) : c = Ut(
      dt(dt(l, ln([n]), 4), u, 4),
      4,
      a
    );
  } else
    c = n;
  return mn(
    o,
    c,
    s,
    a
  );
}
function Yc(t, e) {
  const {
    transformOrigin: n,
    offsetMatrix: r,
    is3d: s,
    targetMatrix: o,
    targetAllTransform: i
  } = t, a = s ? 4 : 3;
  return mn(
    r,
    dt(i || o, rs(e, a), a),
    n,
    a
  );
}
function Hn(t, e) {
  const n = je(e);
  return {
    setTransform: (r, s = -1) => {
      n.startTransforms = Rt(r) ? r : ce(r), Rr(t, e, s);
    },
    setTransformIndex: (r) => {
      Rr(t, e, r);
    }
  };
}
function qn(t, e, n) {
  const s = je(e).startTransforms;
  Rr(t, e, ne(s, (o) => o.indexOf(`${n}(`) === 0));
}
function Rr(t, e, n) {
  const r = je(e), s = e.datas;
  if (s.transformIndex = n, n === -1)
    return;
  const o = r.startTransforms[n];
  if (!o)
    return;
  const i = t.state, a = $e([o], {
    "x%": (c) => c / 100 * i.offsetWidth,
    "y%": (c) => c / 100 * i.offsetHeight
  });
  s.startValue = a[0].functionValue;
}
function os(t, e) {
  const n = je(t);
  n.nextTransforms = ce(e);
}
function je(t) {
  return t.originalDatas.beforeRenderable;
}
function Gn(t) {
  const {
    originalDatas: {
      beforeRenderable: e
    }
  } = t;
  return e.nextTransforms;
}
function Dn(t) {
  return (Gn(t) || []).join(" ");
}
function bn(t) {
  return je(t).nextStyle;
}
function ii(t, e, n, r, s) {
  os(s, e);
  const o = Ot.drag(
    t,
    vn(s, t.state, n, r)
  ), i = o ? o.transform : e;
  return {
    transform: e,
    drag: o,
    ...It({
      transform: i
    }, s),
    afterTransform: i
  };
}
function is(t, e, n, r, s, o) {
  const i = Wc(t.state, s, e, o);
  return Xc(
    t,
    n,
    r,
    i
  );
}
function ai(t, e, n, r, s, o, i) {
  const a = is(
    t,
    e,
    n,
    s,
    o,
    i
  ), c = t.state, {
    left: l,
    top: u
  } = c, f = t.props.groupable, d = f ? l : 0, p = f ? u : 0, g = K(r, a);
  return K(g, [d, p]);
}
function Vc(t, e, n, r, s, o, i) {
  return ai(
    t,
    e,
    n,
    r,
    s,
    o,
    i
  );
}
function jc(t, e, n) {
  return [
    e ? -1 + t[0] / (e / 2) : 0,
    n ? -1 + t[1] / (n / 2) : 0
  ];
}
function Xc(t, e, n, r = t.state.allMatrix) {
  const {
    width: s,
    height: o,
    is3d: i
  } = t.state, a = i ? 4 : 3, c = [
    s / 2 * (1 + e[0]) + n[0],
    o / 2 * (1 + e[1]) + n[1]
  ];
  return ht(r, c, a);
}
function Hc(t, e, n) {
  const r = n.fixedDirection, s = n.fixedPosition, o = n.fixedOffset;
  return ai(
    t,
    `rotate(${e}deg)`,
    r,
    s,
    o,
    n
  );
}
function qc(t, e, n, r, s, o) {
  const {
    groupable: i
  } = t.props, a = t.state, {
    transformOrigin: c,
    offsetMatrix: l,
    is3d: u,
    width: f,
    height: d,
    left: p,
    top: g
  } = a, h = o.fixedDirection, v = o.nextTargetMatrix || a.targetMatrix, m = u ? 4 : 3, S = Fc(
    s,
    e,
    n,
    f,
    d,
    c
  ), x = i ? p : 0, C = i ? g : 0, E = mn(l, v, S, m), D = Nc(r, E, e, n, m, h);
  return K(D, [x, C]);
}
function Uc(t, e) {
  return yt(jt(t.state), e);
}
function Kc(t, e) {
  const n = t.targetGesto, r = t.controlGesto;
  let s;
  return n != null && n.isFlag() && (s = n.getEventData()[e]), !s && (r != null && r.isFlag()) && (s = r.getEventData()[e]), s || {};
}
function Zc(t) {
  if (t && t.getRootNode) {
    const e = t.getRootNode();
    if (e.nodeType === 11)
      return e;
  }
}
function Jc(t) {
  const e = t("scale"), n = t("rotate"), r = t("translate"), s = [];
  return r && r !== "0px" && r !== "none" && s.push(`translate(${r.split(/\s+/).join(",")})`), n && n !== "1" && n !== "none" && s.push(`rotate(${n})`), e && e !== "1" && e !== "none" && s.push(`scale(${e.split(/\s+/).join(",")})`), s;
}
function ci(t, e, n) {
  let r = t;
  const s = [], o = es(t) || fe(t);
  let i = !n && t === e || t === o, a = i, c = !1, l = 3, u, f, d, p = !1, g = fn(e, e, !0).offsetParent, h = 1;
  for (; r && !a; ) {
    a = i;
    const v = Gt(r), m = v("position"), S = zi(r), x = m === "fixed", C = Jc(v);
    let E = Oc(iu(S)), D, R = !1, y = !1, M = 0, P = 0, _ = 0, O = 0, T = {
      hasTransform: !1,
      fixedContainer: null
    };
    x && (p = !0, T = fu(r), g = T.fixedContainer);
    const w = E.length;
    !c && (w === 16 || C.length) && (c = !0, l = 4, Br(s), d && (d = Ut(d, 3, 4))), c && w === 9 && (E = Ut(E, 3, 4));
    const {
      tagName: k,
      hasOffset: I,
      isSVG: $,
      origin: G,
      targetOrigin: L,
      offset: z
    } = uu(r, t);
    let [
      N,
      Z
    ] = z;
    k === "svg" && !r.ownerSVGElement && d && (s.push({
      type: "target",
      target: r,
      matrix: du(r, l)
    }), s.push({
      type: "offset",
      target: r,
      matrix: gt(l)
    }));
    const Y = parseFloat(v("zoom")) || 1;
    if (x)
      D = T.fixedContainer, R = !0;
    else {
      const W = fn(r, e, !1, !0, v), J = W.offsetZoom;
      if (D = W.offsetParent, R = W.isEnd, y = W.isStatic, h *= J, (W.isCustomElement || J !== 1) && y)
        N -= D.offsetLeft, Z -= D.offsetTop;
      else if ((nc || ec) && W.parentSlotElement) {
        let F = D, H = 0, nt = 0;
        for (; F && Zc(F); )
          H += F.offsetLeft, nt += F.offsetTop, F = F.offsetParent;
        N -= H, Z -= nt;
      }
    }
    if ($o && !rc && I && !$ && y && (m === "relative" || m === "static") && (N -= D.offsetLeft, Z -= D.offsetTop, i = i || R), x)
      I && T.hasTransform && (_ = D.clientLeft, O = D.clientTop);
    else if (I && g !== D && (M = D.clientLeft, P = D.clientTop), I && D === o) {
      const W = Ai(r, !1);
      N += W[0], Z += W[1];
    }
    if (s.push({
      type: "target",
      target: r,
      matrix: en(E, l, G)
    }), C.length && (s.push({
      type: "offset",
      target: r,
      matrix: gt(l)
    }), s.push({
      type: "target",
      target: r,
      matrix: en(ln(C), l, G)
    })), I) {
      const W = r === t, J = W ? 0 : r.scrollLeft, q = W ? 0 : r.scrollTop;
      s.push({
        type: "offset",
        target: r,
        matrix: Ce([
          N - J + M - _,
          Z - q + P - O
        ], l)
      });
    } else
      s.push({
        type: "offset",
        target: r,
        origin: G
      });
    if (Y !== 1 && s.push({
      type: "zoom",
      target: r,
      matrix: en(rs([Y, Y], l), l, [0, 0])
    }), d || (d = E), u || (u = G), f || (f = L), a || x)
      break;
    r = D, i = R, (!n || r === o) && (a = i);
  }
  return d || (d = gt(l)), u || (u = [0, 0]), f || (f = [0, 0]), {
    zoom: h,
    offsetContainer: g,
    matrixes: s,
    targetMatrix: d,
    transformOrigin: u,
    targetOrigin: f,
    is3d: c,
    hasFixed: p
  };
}
let ge = null, he = null, Ie = null;
function Le(t) {
  t ? (window.Map && (ge = /* @__PURE__ */ new Map(), he = /* @__PURE__ */ new Map()), Ie = []) : (ge = null, Ie = null, he = null);
}
function Qc(t) {
  const e = he == null ? void 0 : he.get(t);
  if (e)
    return e;
  const n = nn(t, !0);
  return he && he.set(t, n), n;
}
function tl(t, e) {
  if (Ie) {
    const r = kt(Ie, (s) => s[0][0] == t && s[0][1] == e);
    if (r)
      return r[1];
  }
  const n = ci(t, e, !0);
  return Ie && Ie.push([[t, e], n]), n;
}
function Gt(t) {
  let e = ge == null ? void 0 : ge.get(t);
  if (!e) {
    const s = ae(t).getComputedStyle(t);
    if (!ge)
      return (o) => s[o];
    e = {
      style: s,
      cached: {}
    }, ge.set(t, e);
  }
  const n = e.cached, r = e.style;
  return (s) => (s in n || (n[s] = r[s]), n[s]);
}
var Mr = { exports: {} }, qe = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Vs;
function el() {
  if (Vs) return qe;
  Vs = 1;
  var t = To, e = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, s = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function i(a, c, l) {
    var u, f = {}, d = null, p = null;
    l !== void 0 && (d = "" + l), c.key !== void 0 && (d = "" + c.key), c.ref !== void 0 && (p = c.ref);
    for (u in c) r.call(c, u) && !o.hasOwnProperty(u) && (f[u] = c[u]);
    if (a && a.defaultProps) for (u in c = a.defaultProps, c) f[u] === void 0 && (f[u] = c[u]);
    return { $$typeof: e, type: a, key: d, ref: p, props: f, _owner: s.current };
  }
  return qe.Fragment = n, qe.jsx = i, qe.jsxs = i, qe;
}
var Ue = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var js;
function nl() {
  return js || (js = 1, process.env.NODE_ENV !== "production" && function() {
    var t = To, e = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), i = Symbol.for("react.provider"), a = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), u = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), p = Symbol.for("react.offscreen"), g = Symbol.iterator, h = "@@iterator";
    function v(b) {
      if (b === null || typeof b != "object")
        return null;
      var A = g && b[g] || b[h];
      return typeof A == "function" ? A : null;
    }
    var m = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function S(b) {
      {
        for (var A = arguments.length, V = new Array(A > 1 ? A - 1 : 0), Q = 1; Q < A; Q++)
          V[Q - 1] = arguments[Q];
        x("error", b, V);
      }
    }
    function x(b, A, V) {
      {
        var Q = m.ReactDebugCurrentFrame, ct = Q.getStackAddendum();
        ct !== "" && (A += "%s", V = V.concat([ct]));
        var pt = V.map(function(ot) {
          return String(ot);
        });
        pt.unshift("Warning: " + A), Function.prototype.apply.call(console[b], console, pt);
      }
    }
    var C = !1, E = !1, D = !1, R = !1, y = !1, M;
    M = Symbol.for("react.module.reference");
    function P(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === o || y || b === s || b === l || b === u || R || b === p || C || E || D || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === f || b.$$typeof === i || b.$$typeof === a || b.$$typeof === c || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === M || b.getModuleId !== void 0));
    }
    function _(b, A, V) {
      var Q = b.displayName;
      if (Q)
        return Q;
      var ct = A.displayName || A.name || "";
      return ct !== "" ? V + "(" + ct + ")" : V;
    }
    function O(b) {
      return b.displayName || "Context";
    }
    function T(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && S("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case o:
          return "Profiler";
        case s:
          return "StrictMode";
        case l:
          return "Suspense";
        case u:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case a:
            var A = b;
            return O(A) + ".Consumer";
          case i:
            var V = b;
            return O(V._context) + ".Provider";
          case c:
            return _(b, b.render, "ForwardRef");
          case f:
            var Q = b.displayName || null;
            return Q !== null ? Q : T(b.type) || "Memo";
          case d: {
            var ct = b, pt = ct._payload, ot = ct._init;
            try {
              return T(ot(pt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var w = Object.assign, k = 0, I, $, G, L, z, N, Z;
    function Y() {
    }
    Y.__reactDisabledLog = !0;
    function W() {
      {
        if (k === 0) {
          I = console.log, $ = console.info, G = console.warn, L = console.error, z = console.group, N = console.groupCollapsed, Z = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: Y,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        k++;
      }
    }
    function J() {
      {
        if (k--, k === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: w({}, b, {
              value: I
            }),
            info: w({}, b, {
              value: $
            }),
            warn: w({}, b, {
              value: G
            }),
            error: w({}, b, {
              value: L
            }),
            group: w({}, b, {
              value: z
            }),
            groupCollapsed: w({}, b, {
              value: N
            }),
            groupEnd: w({}, b, {
              value: Z
            })
          });
        }
        k < 0 && S("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var q = m.ReactCurrentDispatcher, F;
    function H(b, A, V) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (ct) {
            var Q = ct.stack.trim().match(/\n( *(at )?)/);
            F = Q && Q[1] || "";
          }
        return `
` + F + b;
      }
    }
    var nt = !1, lt;
    {
      var vt = typeof WeakMap == "function" ? WeakMap : Map;
      lt = new vt();
    }
    function st(b, A) {
      if (!b || nt)
        return "";
      {
        var V = lt.get(b);
        if (V !== void 0)
          return V;
      }
      var Q;
      nt = !0;
      var ct = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var pt;
      pt = q.current, q.current = null, W();
      try {
        if (A) {
          var ot = function() {
            throw Error();
          };
          if (Object.defineProperty(ot.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ot, []);
            } catch (zt) {
              Q = zt;
            }
            Reflect.construct(b, [], ot);
          } else {
            try {
              ot.call();
            } catch (zt) {
              Q = zt;
            }
            b.call(ot.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (zt) {
            Q = zt;
          }
          b();
        }
      } catch (zt) {
        if (zt && Q && typeof zt.stack == "string") {
          for (var rt = zt.stack.split(`
`), Tt = Q.stack.split(`
`), mt = rt.length - 1, Et = Tt.length - 1; mt >= 1 && Et >= 0 && rt[mt] !== Tt[Et]; )
            Et--;
          for (; mt >= 1 && Et >= 0; mt--, Et--)
            if (rt[mt] !== Tt[Et]) {
              if (mt !== 1 || Et !== 1)
                do
                  if (mt--, Et--, Et < 0 || rt[mt] !== Tt[Et]) {
                    var Nt = `
` + rt[mt].replace(" at new ", " at ");
                    return b.displayName && Nt.includes("<anonymous>") && (Nt = Nt.replace("<anonymous>", b.displayName)), typeof b == "function" && lt.set(b, Nt), Nt;
                  }
                while (mt >= 1 && Et >= 0);
              break;
            }
        }
      } finally {
        nt = !1, q.current = pt, J(), Error.prepareStackTrace = ct;
      }
      var Te = b ? b.displayName || b.name : "", pe = Te ? H(Te) : "";
      return typeof b == "function" && lt.set(b, pe), pe;
    }
    function Ft(b, A, V) {
      return st(b, !1);
    }
    function Lt(b) {
      var A = b.prototype;
      return !!(A && A.isReactComponent);
    }
    function ut(b, A, V) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return st(b, Lt(b));
      if (typeof b == "string")
        return H(b);
      switch (b) {
        case l:
          return H("Suspense");
        case u:
          return H("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case c:
            return Ft(b.render);
          case f:
            return ut(b.type, A, V);
          case d: {
            var Q = b, ct = Q._payload, pt = Q._init;
            try {
              return ut(pt(ct), A, V);
            } catch {
            }
          }
        }
      return "";
    }
    var St = Object.prototype.hasOwnProperty, Kt = {}, de = m.ReactDebugCurrentFrame;
    function Pe(b) {
      if (b) {
        var A = b._owner, V = ut(b.type, b._source, A ? A.type : null);
        de.setExtraStackFrame(V);
      } else
        de.setExtraStackFrame(null);
    }
    function va(b, A, V, Q, ct) {
      {
        var pt = Function.call.bind(St);
        for (var ot in b)
          if (pt(b, ot)) {
            var rt = void 0;
            try {
              if (typeof b[ot] != "function") {
                var Tt = Error((Q || "React class") + ": " + V + " type `" + ot + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[ot] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Tt.name = "Invariant Violation", Tt;
              }
              rt = b[ot](A, ot, Q, V, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (mt) {
              rt = mt;
            }
            rt && !(rt instanceof Error) && (Pe(ct), S("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Q || "React class", V, ot, typeof rt), Pe(null)), rt instanceof Error && !(rt.message in Kt) && (Kt[rt.message] = !0, Pe(ct), S("Failed %s type: %s", V, rt.message), Pe(null));
          }
      }
    }
    var ma = Array.isArray;
    function tr(b) {
      return ma(b);
    }
    function xa(b) {
      {
        var A = typeof Symbol == "function" && Symbol.toStringTag, V = A && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return V;
      }
    }
    function Sa(b) {
      try {
        return _s(b), !1;
      } catch {
        return !0;
      }
    }
    function _s(b) {
      return "" + b;
    }
    function Ts(b) {
      if (Sa(b))
        return S("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", xa(b)), _s(b);
    }
    var He = m.ReactCurrentOwner, Ea = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Os, ws, er;
    er = {};
    function Ca(b) {
      if (St.call(b, "ref")) {
        var A = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function Da(b) {
      if (St.call(b, "key")) {
        var A = Object.getOwnPropertyDescriptor(b, "key").get;
        if (A && A.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function ba(b, A) {
      if (typeof b.ref == "string" && He.current && A && He.current.stateNode !== A) {
        var V = T(He.current.type);
        er[V] || (S('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', T(He.current.type), b.ref), er[V] = !0);
      }
    }
    function ya(b, A) {
      {
        var V = function() {
          Os || (Os = !0, S("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        V.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: V,
          configurable: !0
        });
      }
    }
    function Ra(b, A) {
      {
        var V = function() {
          ws || (ws = !0, S("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", A));
        };
        V.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: V,
          configurable: !0
        });
      }
    }
    var Ma = function(b, A, V, Q, ct, pt, ot) {
      var rt = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: b,
        key: A,
        ref: V,
        props: ot,
        // Record the component responsible for creating this element.
        _owner: pt
      };
      return rt._store = {}, Object.defineProperty(rt._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(rt, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Q
      }), Object.defineProperty(rt, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ct
      }), Object.freeze && (Object.freeze(rt.props), Object.freeze(rt)), rt;
    };
    function Pa(b, A, V, Q, ct) {
      {
        var pt, ot = {}, rt = null, Tt = null;
        V !== void 0 && (Ts(V), rt = "" + V), Da(A) && (Ts(A.key), rt = "" + A.key), Ca(A) && (Tt = A.ref, ba(A, ct));
        for (pt in A)
          St.call(A, pt) && !Ea.hasOwnProperty(pt) && (ot[pt] = A[pt]);
        if (b && b.defaultProps) {
          var mt = b.defaultProps;
          for (pt in mt)
            ot[pt] === void 0 && (ot[pt] = mt[pt]);
        }
        if (rt || Tt) {
          var Et = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          rt && ya(ot, Et), Tt && Ra(ot, Et);
        }
        return Ma(b, rt, Tt, ct, Q, He.current, ot);
      }
    }
    var nr = m.ReactCurrentOwner, Is = m.ReactDebugCurrentFrame;
    function _e(b) {
      if (b) {
        var A = b._owner, V = ut(b.type, b._source, A ? A.type : null);
        Is.setExtraStackFrame(V);
      } else
        Is.setExtraStackFrame(null);
    }
    var rr;
    rr = !1;
    function sr(b) {
      return typeof b == "object" && b !== null && b.$$typeof === e;
    }
    function Bs() {
      {
        if (nr.current) {
          var b = T(nr.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function _a(b) {
      return "";
    }
    var zs = {};
    function Ta(b) {
      {
        var A = Bs();
        if (!A) {
          var V = typeof b == "string" ? b : b.displayName || b.name;
          V && (A = `

Check the top-level render call using <` + V + ">.");
        }
        return A;
      }
    }
    function As(b, A) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var V = Ta(A);
        if (zs[V])
          return;
        zs[V] = !0;
        var Q = "";
        b && b._owner && b._owner !== nr.current && (Q = " It was passed a child from " + T(b._owner.type) + "."), _e(b), S('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', V, Q), _e(null);
      }
    }
    function Gs(b, A) {
      {
        if (typeof b != "object")
          return;
        if (tr(b))
          for (var V = 0; V < b.length; V++) {
            var Q = b[V];
            sr(Q) && As(Q, A);
          }
        else if (sr(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var ct = v(b);
          if (typeof ct == "function" && ct !== b.entries)
            for (var pt = ct.call(b), ot; !(ot = pt.next()).done; )
              sr(ot.value) && As(ot.value, A);
        }
      }
    }
    function Oa(b) {
      {
        var A = b.type;
        if (A == null || typeof A == "string")
          return;
        var V;
        if (typeof A == "function")
          V = A.propTypes;
        else if (typeof A == "object" && (A.$$typeof === c || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        A.$$typeof === f))
          V = A.propTypes;
        else
          return;
        if (V) {
          var Q = T(A);
          va(V, b.props, "prop", Q, b);
        } else if (A.PropTypes !== void 0 && !rr) {
          rr = !0;
          var ct = T(A);
          S("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ct || "Unknown");
        }
        typeof A.getDefaultProps == "function" && !A.getDefaultProps.isReactClassApproved && S("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function wa(b) {
      {
        for (var A = Object.keys(b.props), V = 0; V < A.length; V++) {
          var Q = A[V];
          if (Q !== "children" && Q !== "key") {
            _e(b), S("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Q), _e(null);
            break;
          }
        }
        b.ref !== null && (_e(b), S("Invalid attribute `ref` supplied to `React.Fragment`."), _e(null));
      }
    }
    var ks = {};
    function $s(b, A, V, Q, ct, pt) {
      {
        var ot = P(b);
        if (!ot) {
          var rt = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (rt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Tt = _a();
          Tt ? rt += Tt : rt += Bs();
          var mt;
          b === null ? mt = "null" : tr(b) ? mt = "array" : b !== void 0 && b.$$typeof === e ? (mt = "<" + (T(b.type) || "Unknown") + " />", rt = " Did you accidentally export a JSX literal instead of a component?") : mt = typeof b, S("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", mt, rt);
        }
        var Et = Pa(b, A, V, ct, pt);
        if (Et == null)
          return Et;
        if (ot) {
          var Nt = A.children;
          if (Nt !== void 0)
            if (Q)
              if (tr(Nt)) {
                for (var Te = 0; Te < Nt.length; Te++)
                  Gs(Nt[Te], b);
                Object.freeze && Object.freeze(Nt);
              } else
                S("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Gs(Nt, b);
        }
        if (St.call(A, "key")) {
          var pe = T(b), zt = Object.keys(A).filter(function(ka) {
            return ka !== "key";
          }), or = zt.length > 0 ? "{key: someKey, " + zt.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!ks[pe + or]) {
            var Ga = zt.length > 0 ? "{" + zt.join(": ..., ") + ": ...}" : "{}";
            S(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, or, pe, Ga, pe), ks[pe + or] = !0;
          }
        }
        return b === r ? wa(Et) : Oa(Et), Et;
      }
    }
    function Ia(b, A, V) {
      return $s(b, A, V, !0);
    }
    function Ba(b, A, V) {
      return $s(b, A, V, !1);
    }
    var za = Ba, Aa = Ia;
    Ue.Fragment = r, Ue.jsx = za, Ue.jsxs = Aa;
  }()), Ue;
}
process.env.NODE_ENV === "production" ? Mr.exports = el() : Mr.exports = nl();
var it = Mr.exports;
function Ht(t, e, n) {
  const r = n.originalDatas;
  r.groupable = r.groupable || {};
  const s = r.groupable;
  s.childDatas = s.childDatas || [];
  const o = s.childDatas;
  return t.moveables.map((i, a) => (o[a] = o[a] || {}, o[a][e] = o[a][e] || {}, {
    ...n,
    isRequestChild: !0,
    datas: o[a][e],
    originalDatas: o[a]
  }));
}
function cr(t, e, n, r, s, o, i) {
  const a = !!n.match(/Start$/g), c = !!n.match(/End$/g), l = s.isPinch, u = s.datas, f = Ht(t, e.name, s), d = t.moveables, p = [], g = f.map((h, v) => {
    const m = d[v], S = m.state, x = S.gestos;
    let C = h;
    if (a)
      C = new Fe(i).dragStart(r, h), p.push(C);
    else {
      if (x[i] || (x[i] = u.childGestos[v]), !x[i])
        return;
      C = vn(h, S, r, l, o, i), p.push(C);
    }
    const E = e[n](m, { ...C, parentFlag: !0 });
    return c && (x[i] = null), E;
  });
  return a && (u.childGestos = d.map((h) => h.state.gestos[i])), {
    eventParams: g,
    childEvents: p
  };
}
function ee(t, e, n, r, s = (i, a) => a, o) {
  const i = !!n.match(/End$/g), a = Ht(t, e.name, r), c = t.moveables;
  return a.map((u, f) => {
    const d = c[f];
    let p = u;
    p = s(d, u);
    const g = e[n](d, { ...p, parentFlag: !0 });
    return g && o && o(d, u, g, f), i && (d.state.gestos = {}), g;
  });
}
function kn(t, e, n, r) {
  const s = n.fixedDirection, o = n.fixedPosition, i = r.datas.startPositions || jt(e.state), a = yt(i, s), [c, l] = _t(
    hn(-t.rotation / 180 * Math.PI, 3),
    [a[0] - o[0], a[1] - o[1], 1],
    3
  );
  return r.datas.originalX = c, r.datas.originalY = l, r;
}
function li(t, e, n, r) {
  const { renderPoses: s, rotation: o, direction: i } = t.getState(), { zoom: a } = De(t.props, e), c = tn(o / Math.PI * 180), l = {}, u = t.renderState;
  u.renderDirectionMap || (u.renderDirectionMap = {});
  const f = u.renderDirectionMap;
  n.forEach(({ dir: p }) => {
    l[p] = !0;
  });
  const d = wt(i);
  return n.map(({ data: p, classNames: g, dir: h }) => {
    const v = qr[h];
    if (!v || !l[h])
      return null;
    f[h] = !0;
    const m = (tt(c, 15) + d * Wo[h] + 720) % 180, S = {};
    return Ve(p).forEach((x) => {
      S[`data-${x}`] = p[x];
    }), /* @__PURE__ */ Bn(
      "div",
      {
        className: U("control", "direction", h, e, ...g),
        "data-rotation": m,
        "data-direction": h,
        ...S,
        key: `direction-${h}`,
        style: Nn(
          o,
          a,
          ...v.map((x) => s[x])
        )
      }
    );
  });
}
function ui(t, e, n, r) {
  const {
    renderDirections: s = e,
    displayAroundControls: o
  } = De(t.props, n);
  if (!s)
    return [];
  const i = s === !0 ? Xr : s;
  return [
    ...o ? gi(t, r, n, i) : [],
    ...li(
      t,
      n,
      i.map((a) => ({
        data: {},
        classNames: [],
        dir: a
      }))
    )
  ];
}
function un(t, e, n, r, s, o, ...i) {
  const a = xt(n, r), c = e ? tt(a / Math.PI * 180, 15) % 180 : -1;
  return /* @__PURE__ */ it.jsx(
    "div",
    {
      className: U(
        "line",
        "direction",
        e ? "edge" : "",
        e,
        ...i
      ),
      "data-rotation": c,
      "data-line-key": o,
      "data-direction": e,
      style: Je(n, r, s, a)
    },
    `line-${o}`
  );
}
function fi(t, e, n, r, s) {
  return (n === !0 ? Ua : n).map((i, a) => {
    const [c, l] = qr[i];
    if (l != null)
      return un(
        t,
        i,
        r[c],
        r[l],
        s,
        `${e}Edge${a}`,
        e
      );
  }).filter(Boolean);
}
function di(t) {
  return (e, n) => {
    const r = De(e.props, t).edge;
    return r && (r === !0 || r.length) ? [
      ...fi(
        n,
        t,
        r,
        e.getState().renderPoses,
        e.props.zoom
      ),
      ...rl(e, t, n)
    ] : pi(e, t, n);
  };
}
function pi(t, e, n) {
  return ui(t, Xr, e, n);
}
function rl(t, e, n) {
  return ui(
    t,
    ["nw", "ne", "sw", "se"],
    e,
    n
  );
}
function gi(t, e, n, r) {
  const s = t.renderState;
  s.renderDirectionMap || (s.renderDirectionMap = {});
  const { renderPoses: o, rotation: i, direction: a } = t.getState(), c = s.renderDirectionMap, { zoom: l } = t.props, u = wt(a), f = i / Math.PI * 180;
  return (r || Ve(c)).map((d) => {
    const p = qr[d];
    if (!p)
      return null;
    const g = (tt(f, 15) + u * Wo[d] + 720) % 180, h = ["around-control"];
    return n && h.push("direction", n), /* @__PURE__ */ it.jsx(
      "div",
      {
        className: U(...h),
        "data-rotation": g,
        "data-direction": d,
        style: Nn(
          i,
          l,
          ...p.map((v) => o[v])
        )
      },
      `direction-around-${d}`
    );
  });
}
function as(t, e, n) {
  const {
    position: r = "client",
    left: s = -1 / 0,
    top: o = -1 / 0,
    right: i = 1 / 0,
    bottom: a = 1 / 0
  } = t || {}, c = {
    position: r,
    left: s,
    top: o,
    right: i,
    bottom: a
  };
  return {
    vertical: Xs(c, e, !0),
    horizontal: Xs(c, n, !1)
  };
}
function Un(t, e) {
  const {
    containerClientRect: {
      clientHeight: n,
      clientWidth: r,
      clientLeft: s,
      clientTop: o
    },
    snapOffset: {
      left: i,
      top: a,
      right: c,
      bottom: l
    }
  } = t.state, u = e || t.props.bounds || {}, d = (u.position || "client") === "css", {
    left: p = -1 / 0,
    top: g = -1 / 0
  } = u;
  let {
    right: h = d ? -1 / 0 : 1 / 0,
    bottom: v = d ? -1 / 0 : 1 / 0
  } = u;
  return d && (h = r + c - i - h, v = n + l - a - v), {
    left: p + i - s,
    right: h + i - s,
    top: g + a - o,
    bottom: v + a - o
  };
}
function sl(t, e, n) {
  const {
    left: r,
    top: s,
    right: o,
    bottom: i
  } = Un(t), [a, c] = n;
  let [l, u] = K(n, e);
  B(l) < Bt && (l = 0), B(u) < Bt && (u = 0);
  const f = u > 0, d = l > 0, p = {
    isBound: !1,
    offset: 0,
    pos: 0
  }, g = {
    isBound: !1,
    offset: 0,
    pos: 0
  };
  if (l === 0 && u === 0)
    return {
      vertical: p,
      horizontal: g
    };
  if (l === 0)
    f ? i < c && (g.pos = i, g.offset = c - i) : s > c && (g.pos = s, g.offset = c - s);
  else if (u === 0)
    d ? o < a && (p.pos = o, p.offset = a - o) : r > a && (p.pos = r, p.offset = a - r);
  else {
    const h = u / l, v = n[1] - h * a;
    let m = 0, S = 0, x = !1;
    d && o <= a ? (m = h * o + v, S = o, x = !0) : !d && a <= r && (m = h * r + v, S = r, x = !0), x && (m < s || m > i) && (x = !1), x || (f && i <= c ? (m = i, S = (m - v) / h, x = !0) : !f && c <= s && (m = s, S = (m - v) / h, x = !0)), x && (p.isBound = !0, p.pos = S, p.offset = a - S, g.isBound = !0, g.pos = m, g.offset = c - m);
  }
  return {
    vertical: p,
    horizontal: g
  };
}
function Xs(t, e, n) {
  const r = t[n ? "left" : "top"], s = t[n ? "right" : "bottom"], o = Math.min(...e), i = Math.max(...e), a = [];
  return r + 1 > o && a.push({
    direction: "start",
    isBound: !0,
    offset: o - r,
    pos: r
  }), s - 1 < i && a.push({
    direction: "end",
    isBound: !0,
    offset: i - s,
    pos: s
  }), a.length || a.push({
    isBound: !1,
    offset: 0,
    pos: 0
  }), a.sort((c, l) => B(l.offset) - B(c.offset));
}
function Hs(t, e, n) {
  return (n ? t.map((s) => gn(s, n)) : t).some((s) => s[0] < e.left && B(s[0] - e.left) > 0.1 || s[0] > e.right && B(s[0] - e.right) > 0.1 || s[1] < e.top && B(s[1] - e.top) > 0.1 || s[1] > e.bottom && B(s[1] - e.bottom) > 0.1);
}
function ol(t, e, n) {
  const r = Vt(t), s = Math.sqrt(r * r - e * e) || 0;
  return [s, -s].sort((o, i) => B(o - t[n ? 0 : 1]) - B(i - t[n ? 0 : 1])).map((o) => xt([0, 0], n ? [o, e] : [e, o]));
}
function il(t, e, n, r, s) {
  if (!t.props.bounds)
    return [];
  const o = s * Math.PI / 180, {
    left: i,
    top: a,
    right: c,
    bottom: l
  } = Un(t), u = i - r[0], f = c - r[0], d = a - r[1], p = l - r[1], g = {
    left: u,
    top: d,
    right: f,
    bottom: p
  };
  if (!Hs(n, g, 0))
    return [];
  const h = [];
  return [
    [u, 0],
    [f, 0],
    [d, 1],
    [p, 1]
  ].forEach(([v, m]) => {
    n.forEach((S) => {
      const x = xt([0, 0], S);
      h.push(...ol(S, v, m).map((C) => o + C - x).filter((C) => !Hs(e, g, C)).map((C) => tt(C * 180 / Math.PI, Bt)));
    });
  }), h;
}
const al = ["left", "right", "center"], cl = ["top", "bottom", "middle"], qs = {
  left: "start",
  right: "end",
  center: "center",
  top: "start",
  bottom: "end",
  middle: "center"
}, le = {
  start: "left",
  end: "right",
  center: "center"
}, ue = {
  start: "top",
  end: "bottom",
  center: "middle"
};
function Be() {
  return {
    left: !1,
    top: !1,
    right: !1,
    bottom: !1
  };
}
function Xe(t, e) {
  const {
    props: {
      snappable: n,
      bounds: r,
      innerBounds: s,
      verticalGuidelines: o,
      horizontalGuidelines: i,
      snapGridWidth: a,
      snapGridHeight: c
    },
    state: { guidelines: l, enableSnap: u }
  } = t;
  return !n || !u || e && n !== !0 && n.indexOf(e) < 0 ? !1 : !!(a || c || r || s || l && l.length || o && o.length || i && i.length);
}
function cs(t) {
  return t === !1 ? {} : t === !0 || !t ? { left: !0, right: !0, top: !0, bottom: !0 } : t;
}
function ll(t, e) {
  const n = cs(t), r = {};
  for (const s in n)
    s in e && n[s] && (r[s] = e[s]);
  return r;
}
function ls(t, e) {
  const n = ll(t, e), r = cl.filter((o) => o in n), s = al.filter((o) => o in n);
  return {
    horizontalNames: r,
    verticalNames: s,
    horizontal: r.map((o) => n[o]),
    vertical: s.map((o) => n[o])
  };
}
function ul(t, e, n) {
  const r = ht(
    t,
    [e.clientLeft, e.clientTop],
    n
  );
  return [
    e.left + r[0],
    e.top + r[1]
  ];
}
function fl([t, e]) {
  let n = e[0] - t[0], r = e[1] - t[1];
  Math.abs(n) < Dt && (n = 0), Math.abs(r) < Dt && (r = 0);
  let s = 0, o = 0, i = 0;
  return n ? r ? (s = -r / n, o = 1, i = s * t[0] - t[1]) : (o = 1, i = -t[1]) : (s = -1, i = t[0]), [s, o, i].map((a) => tt(a, Dt));
}
const hi = "snapRotationThreshold", vi = "snapRotationDegrees", mi = "snapHorizontalThreshold", xi = "snapVerticalThreshold";
function Kn(t, e, n, r = [], s = [], o, i) {
  var f;
  const a = t.props, c = ((f = t.state.snapThresholdInfo) == null ? void 0 : f.multiples) || [1, 1], l = lo(
    i,
    a[mi],
    5
  ), u = lo(
    o,
    a[xi],
    5
  );
  return Si(
    t.state.guidelines,
    e,
    n,
    r,
    s,
    l,
    u,
    c
  );
}
function Si(t, e, n, r, s, o, i, a) {
  return {
    vertical: Ks(t, "vertical", e, i * a[0], r),
    horizontal: Ks(t, "horizontal", n, o * a[1], s)
  };
}
function dl(t, e, n) {
  const [r, s] = n, [o, i] = e;
  let [a, c] = K(n, e);
  const l = c > 0, u = a > 0;
  a = Wn(a), c = Wn(c);
  const f = {
    isSnap: !1,
    offset: 0,
    pos: 0
  }, d = {
    isSnap: !1,
    offset: 0,
    pos: 0
  };
  if (a === 0 && c === 0)
    return {
      vertical: f,
      horizontal: d
    };
  const {
    vertical: p,
    horizontal: g
  } = Kn(
    t,
    a ? [r] : [],
    c ? [s] : [],
    [],
    [],
    void 0,
    void 0
  );
  p.posInfos.filter(({ pos: E }) => u ? E >= o : E <= o), g.posInfos.filter(({ pos: E }) => l ? E >= i : E <= i), p.isSnap = p.posInfos.length > 0, g.isSnap = g.posInfos.length > 0;
  const {
    isSnap: h,
    guideline: v
  } = Pr(p), {
    isSnap: m,
    guideline: S
  } = Pr(g), x = m ? S.pos[1] : 0, C = h ? v.pos[0] : 0;
  if (a === 0)
    m && (d.isSnap = !0, d.pos = S.pos[1], d.offset = s - d.pos);
  else if (c === 0)
    h && (f.isSnap = !0, f.pos = C, f.offset = r - C);
  else {
    const E = c / a, D = n[1] - E * r;
    let R = 0, y = 0, M = !1;
    h ? (y = C, R = E * y + D, M = !0) : m && (R = x, y = (R - D) / E, M = !0), M && (f.isSnap = !0, f.pos = y, f.offset = r - y, d.isSnap = !0, d.pos = R, d.offset = s - R);
  }
  return {
    vertical: f,
    horizontal: d
  };
}
function oe(t) {
  let e = "";
  return t === -1 || t === "top" || t === "left" ? e = "start" : t === 0 || t === "center" || t === "middle" ? e = "center" : (t === 1 || t === "right" || t === "bottom") && (e = "end"), e;
}
function Us(t, e, n, r) {
  const s = ls(t.props.snapDirections, e), o = Kn(
    t,
    s.vertical,
    s.horizontal,
    s.verticalNames.map((c) => oe(c)),
    s.horizontalNames.map((c) => oe(c)),
    n,
    r
  ), i = oe(s.horizontalNames[o.horizontal.index]), a = oe(s.verticalNames[o.vertical.index]);
  return {
    vertical: {
      ...o.vertical,
      direction: a
    },
    horizontal: {
      ...o.horizontal,
      direction: i
    }
  };
}
function Pr(t) {
  const e = t.isSnap;
  if (!e)
    return {
      isSnap: !1,
      offset: 0,
      dist: -1,
      pos: 0,
      guideline: null
    };
  const n = t.posInfos[0], r = n.guidelineInfos[0], s = r.offset, o = r.dist, i = r.guideline;
  return {
    isSnap: e,
    offset: s,
    dist: o,
    pos: n.pos,
    guideline: i
  };
}
function Ks(t, e, n, r, s = []) {
  var l;
  if (!t || !t.length)
    return {
      isSnap: !1,
      index: -1,
      direction: "",
      posInfos: []
    };
  const i = e === "vertical" ? 0 : 1, a = n.map((u, f) => {
    const d = s[f] || "", p = t.map((g) => {
      const { pos: h } = g, v = u - h[i];
      return {
        offset: v,
        dist: B(v),
        guideline: g,
        direction: d
      };
    }).filter(({ guideline: g, dist: h }) => {
      const { type: v } = g;
      return !(v !== e || h > r);
    }).sort(
      (g, h) => g.dist - h.dist
    );
    return {
      pos: u,
      index: f,
      guidelineInfos: p,
      direction: d
    };
  }).filter((u) => u.guidelineInfos.length > 0).sort((u, f) => u.guidelineInfos[0].dist - f.guidelineInfos[0].dist), c = a.length > 0;
  return {
    isSnap: c,
    index: c ? a[0].index : -1,
    direction: ((l = a[0]) == null ? void 0 : l.direction) ?? "",
    posInfos: a
  };
}
function pl(t, e, n, r, s) {
  let o = [];
  n[0] && n[1] ? o = [
    n,
    [-n[0], n[1]],
    [n[0], -n[1]]
  ] : !n[0] && !n[1] ? [
    [-1, -1],
    [1, -1],
    [1, 1],
    [-1, 1]
  ].forEach((d, p, g) => {
    const h = g[p + 1] || g[0];
    o.push(d), o.push([
      (d[0] + h[0]) / 2,
      (d[1] + h[1]) / 2
    ]);
  }) : t.props.keepRatio ? o.push(
    [-1, -1],
    [-1, 1],
    [1, -1],
    [1, 1],
    n
  ) : (o.push(...Lc([
    [-1, -1],
    [1, -1],
    [-1, -1],
    [1, 1]
  ], n)), o.length > 1 && o.push([
    (o[0][0] + o[1][0]) / 2,
    (o[0][1] + o[1][1]) / 2
  ]));
  const i = o.map((d) => yt(e, d)), a = i.map((d) => d[0]), c = i.map((d) => d[1]), l = Kn(
    t,
    a,
    c,
    o.map((d) => oe(d[0])),
    o.map((d) => oe(d[1])),
    r,
    s
  ), u = oe(o.map((d) => d[0])[l.vertical.index]), f = oe(o.map((d) => d[1])[l.horizontal.index]);
  return {
    vertical: {
      ...l.vertical,
      direction: u
    },
    horizontal: {
      ...l.horizontal,
      direction: f
    }
  };
}
function Ei(t, e) {
  const n = B(t.offset), r = B(e.offset);
  return t.isBound && e.isBound ? r - n : t.isBound ? -1 : e.isBound ? 1 : t.isSnap && e.isSnap ? r - n : t.isSnap ? -1 : e.isSnap || n < Bt ? 1 : r < Bt ? -1 : n - r;
}
function $n(t, e) {
  return t.slice().sort((n, r) => {
    const s = n.sign[e], o = r.sign[e], i = n.offset[e], a = r.offset[e];
    if (s) {
      if (!o)
        return -1;
    } else return 1;
    return Ei(
      { isBound: n.isBound, isSnap: n.isSnap, offset: i },
      { isBound: r.isBound, isSnap: r.isSnap, offset: a }
    );
  })[0];
}
function gl(t, e, n) {
  const r = [];
  if (n)
    B(e[0]) !== 1 || B(e[1]) !== 1 ? r.push(
      [e, [-1, -1]],
      [e, [-1, 1]],
      [e, [1, -1]],
      [e, [1, 1]]
    ) : r.push(
      [e, [t[0], -t[1]]],
      [e, [-t[0], t[1]]]
    ), r.push([e, t]);
  else if (t[0] && t[1] || !t[0] && !t[1]) {
    const s = t[0] ? t : [1, 1];
    [1, -1].forEach((o) => {
      [1, -1].forEach((i) => {
        const a = [o * s[0], i * s[1]];
        e[0] === a[0] && e[1] === a[1] || r.push([e, a]);
      });
    });
  } else t[0] ? (B(e[0]) === 1 ? [1] : [1, -1]).forEach((o) => {
    r.push(
      [
        [e[0], -1],
        [o * t[0], -1]
      ],
      [
        [e[0], 0],
        [o * t[0], 0]
      ],
      [
        [e[0], 1],
        [o * t[0], 1]
      ]
    );
  }) : t[1] && (B(e[1]) === 1 ? [1] : [1, -1]).forEach((o) => {
    r.push(
      [
        [-1, e[1]],
        [-1, o * t[1]]
      ],
      [
        [0, e[1]],
        [0, o * t[1]]
      ],
      [
        [1, e[1]],
        [1, o * t[1]]
      ]
    );
  });
  return r;
}
function Ci(t, e) {
  const n = yr([e[0][0], e[1][0]]), r = yr([e[0][1], e[1][1]]);
  return {
    vertical: n <= t[0],
    horizontal: r <= t[1]
  };
}
function us(t, [e, n]) {
  let r = n[0] - e[0], s = n[1] - e[1];
  B(r) < Bt && (r = 0), B(s) < Bt && (s = 0);
  let o, i;
  return r ? s ? (o = s / r * (t[0] - e[0]) + e[1], i = t[1]) : (o = e[1], i = t[1]) : (o = e[0], i = t[0]), o - i;
}
function Di(t, e, n, r = Bt) {
  return t.every((s) => {
    const o = us(s, e);
    return o <= 0 === n || B(o) <= r;
  });
}
function Zs(t, e, n, r, s = 0) {
  return r && e - s <= t || !r && t <= n + s ? {
    isBound: !0,
    offset: r ? e - t : n - t
  } : {
    isBound: !1,
    offset: 0
  };
}
function hl(t, { line: e, centerSign: n, verticalSign: r, horizontalSign: s, lineConstants: o }) {
  const i = t.props.innerBounds;
  if (!i)
    return {
      isAllBound: !1,
      isBound: !1,
      isVerticalBound: !1,
      isHorizontalBound: !1,
      offset: [0, 0]
    };
  const { left: a, top: c, width: l, height: u } = i, f = [[a, c], [a, c + u]], d = [[a, c], [a + l, c]], p = [[a + l, c], [a + l, c + u]], g = [[a, c + u], [a + l, c + u]];
  if (Di([
    [a, c],
    [a + l, c],
    [a, c + u],
    [a + l, c + u]
  ], e, n))
    return {
      isAllBound: !1,
      isBound: !1,
      isVerticalBound: !1,
      isHorizontalBound: !1,
      offset: [0, 0]
    };
  const h = ie(e, o, d, r), v = ie(e, o, g, r), m = ie(e, o, f, s), S = ie(e, o, p, s), x = h.isBound && v.isBound, C = h.isBound || v.isBound, E = m.isBound && S.isBound, D = m.isBound || S.isBound, R = Ne(h.offset, v.offset), y = Ne(m.offset, S.offset);
  let M = [0, 0], P = !1, _ = !1;
  return B(y) < B(R) ? (M = [R, 0], P = C, _ = x) : (M = [0, y], P = D, _ = E), {
    isAllBound: _,
    isVerticalBound: C,
    isHorizontalBound: D,
    isBound: P,
    offset: M
  };
}
function ie(t, [e, n], r, s, o, i) {
  const a = t[0], c = r[0], l = r[1], u = Wn(l[1] - c[1]), f = Wn(l[0] - c[0]), d = n, p = e, g = -e / n;
  if (f) {
    if (!u) {
      if (i && !d)
        return {
          isBound: !1,
          offset: 0
        };
      if (p) {
        const h = (c[1] - a[1]) / g + a[0];
        return Zs(h, c[0], l[0], s, o);
      } else {
        const h = c[1] - a[1], v = B(h) <= (o || 0);
        return {
          isBound: v,
          offset: v ? h : 0
        };
      }
    }
  } else {
    if (i && !p)
      return {
        isBound: !1,
        offset: 0
      };
    if (d) {
      const h = g * (c[0] - a[0]) + a[1];
      return Zs(h, c[1], l[1], s, o);
    } else {
      const h = c[0] - a[0], v = B(h) <= (o || 0);
      return {
        isBound: v,
        offset: v ? h : 0
      };
    }
  }
  return {
    isBound: !1,
    offset: 0
  };
}
function bi(t, e, n) {
  return e.map((r) => {
    const {
      isBound: s,
      offset: o,
      isVerticalBound: i,
      isHorizontalBound: a
    } = hl(t, r), c = r.multiple, l = Qt({
      datas: n,
      distX: o[0],
      distY: o[1]
    }).map((u, f) => u * (c[f] ? 2 / c[f] : 0));
    return {
      sign: c,
      isBound: s,
      isVerticalBound: i,
      isHorizontalBound: a,
      isSnap: !1,
      offset: l
    };
  });
}
function vl(t, e, n) {
  const r = fs(t, e, [0, 0], !1).map((f) => ({
    ...f,
    multiple: f.multiple.map((d) => B(d) * 2)
  })), s = bi(t, r, n), o = $n(s, 0), i = $n(s, 1);
  let a = 0, c = 0;
  const l = o.isVerticalBound || i.isVerticalBound, u = o.isHorizontalBound || i.isHorizontalBound;
  return (l || u) && ([a, c] = $c({
    datas: n,
    distX: -o.offset[0],
    distY: -i.offset[1]
  })), {
    vertical: {
      isBound: l,
      offset: a
    },
    horizontal: {
      isBound: u,
      offset: c
    }
  };
}
function ml(t, e) {
  const n = [], r = t[0], s = t[1];
  return r && s ? n.push(
    [[0, s * 2], t, [-r, s]],
    [[r * 2, 0], t, [r, -s]]
  ) : r ? (n.push(
    [[r * 2, 0], [r, 1], [r, -1]]
  ), e && n.push(
    [[0, -1], [r, -1], [-r, -1]],
    [[0, 1], [r, 1], [-r, 1]]
  )) : s ? (n.push(
    [[0, s * 2], [1, s], [-1, s]]
  ), e && n.push(
    [[-1, 0], [-1, s], [-1, -s]],
    [[1, 0], [1, s], [1, -s]]
  )) : n.push(
    [[-1, 0], [-1, -1], [-1, 1]],
    [[1, 0], [1, -1], [1, 1]],
    [[0, -1], [-1, -1], [1, -1]],
    [[0, 1], [-1, 1], [1, 1]]
  ), n;
}
function fs(t, e, n, r) {
  const {
    allMatrix: s,
    is3d: o
  } = t.state, i = Me(s, 100, 100, o ? 4 : 3), a = yt(i, [0, 0]);
  return ml(n, r).map(([c, l, u]) => {
    const f = [
      yt(i, l),
      yt(i, u)
    ], d = fl(f), {
      vertical: p,
      horizontal: g
    } = Ci(a, f), h = us(a, f) <= 0;
    return {
      multiple: c,
      centerSign: h,
      verticalSign: p,
      horizontalSign: g,
      lineConstants: d,
      line: [
        yt(e, l),
        yt(e, u)
      ]
    };
  });
}
function Js(t, e, n, r) {
  const s = r ? t.map((o) => gn(o, r)) : t;
  return [
    [s[0], s[1]],
    [s[1], s[3]],
    [s[3], s[2]],
    [s[2], s[0]]
  ].some((o) => {
    const i = us(n, o) <= 0;
    return !Di(e, o, i);
  });
}
function xl([t, e]) {
  const n = e[0] - t[0], r = e[1] - t[1];
  if (!n)
    return B(t[0]);
  if (!r)
    return B(t[1]);
  const s = r / n;
  return B((-s * t[0] + t[1]) / Math.sqrt(Math.pow(s, 2) + 1));
}
function Sl([t, e]) {
  const n = e[0] - t[0], r = e[1] - t[1];
  if (!n)
    return [t[0], 0];
  if (!r)
    return [0, t[1]];
  const s = r / n, o = -s * t[0] + t[1];
  return [
    -o / (s + 1 / s),
    o / (s * s + 1)
  ];
}
function El(t, e, n, r, s) {
  const o = t.props.innerBounds, i = s * Math.PI / 180;
  if (!o)
    return [];
  const {
    left: a,
    top: c,
    width: l,
    height: u
  } = o, f = a - r[0], d = a + l - r[0], p = c - r[1], g = c + u - r[1], h = [
    [f, p],
    [d, p],
    [f, g],
    [d, g]
  ], v = yt(n, [0, 0]);
  if (!Js(n, h, v, 0))
    return [];
  const m = [], S = h.map((x) => [
    Vt(x),
    xt([0, 0], x)
  ]);
  return [
    [n[0], n[1]],
    [n[1], n[3]],
    [n[3], n[2]],
    [n[2], n[0]]
  ].forEach((x) => {
    const C = xt([0, 0], Sl(x)), E = xl(x);
    m.push(...S.filter(([D]) => D && E <= D).map(([D, R]) => {
      const y = Math.acos(D ? E / D : 0), M = R + y, P = R - y;
      return [
        i + M - C,
        i + P - C
      ];
    }).reduce((D, R) => (D.push(...R), D), []).filter((D) => !Js(e, h, v, D)).map((D) => tt(D * 180 / Math.PI, Bt)));
  }), m;
}
function Cl(t) {
  const e = t.props.innerBounds, n = Be();
  if (!e)
    return {
      boundMap: n,
      vertical: [],
      horizontal: []
    };
  const {
    pos1: r,
    pos2: s,
    pos3: o,
    pos4: i
  } = t.getRect(), a = [r, s, o, i], c = yt(a, [0, 0]), { left: l, top: u, width: f, height: d } = e, p = [[l, u], [l, u + d]], g = [[l, u], [l + f, u]], h = [[l + f, u], [l + f, u + d]], v = [[l, u + d], [l + f, u + d]], m = fs(t, a, [0, 0], !1), S = [], x = [];
  return m.forEach((C) => {
    const { line: E, lineConstants: D } = C, {
      horizontal: R,
      vertical: y
    } = Ci(c, E), M = ie(E, D, g, y, 1, !0), P = ie(E, D, v, y, 1, !0), _ = ie(E, D, p, R, 1, !0), O = ie(E, D, h, R, 1, !0);
    M.isBound && !n.top && (S.push(u), n.top = !0), P.isBound && !n.bottom && (S.push(u + d), n.bottom = !0), _.isBound && !n.left && (x.push(l), n.left = !0), O.isBound && !n.right && (x.push(l + f), n.right = !0);
  }), {
    boundMap: n,
    horizontal: S,
    vertical: x
  };
}
function Dl(t, e, n, r) {
  let s = e[0] - t[0], o = e[1] - t[1];
  if (B(s) < Dt && (s = 0), B(o) < Dt && (o = 0), !s)
    return r ? [0, 0] : [0, n];
  if (!o)
    return r ? [n, 0] : [0, 0];
  const i = o / s, a = t[1] - i * t[0];
  if (r) {
    const c = i * (e[0] + n) + a;
    return [n, c - e[1]];
  } else
    return [(e[1] + n - a) / i - e[0], n];
}
function _r(t, e, n, r, s) {
  const o = Dl(t, e, n, r);
  if (!o)
    return {
      isOutside: !1,
      offset: [0, 0]
    };
  const i = te(t, e), a = te(o, t), c = te(o, e), l = a > i || c > i, [u, f] = Qt({
    datas: s,
    distX: o[0],
    distY: o[1]
  });
  return {
    offset: [u, f],
    isOutside: l
  };
}
function Fn(t, e) {
  return t.isBound ? t.offset : e.isSnap ? Pr(e).offset : 0;
}
function bl(t, [e, n], [r, s], [o, i], [a, c]) {
  let l = -a, u = -c;
  if (t && e && n) {
    l = 0, u = 0;
    const f = [];
    if (r && s ? f.push([0, c], [a, 0]) : r ? f.push([a, 0]) : s ? f.push([0, c]) : o && i ? f.push([0, c], [a, 0]) : o ? f.push([a, 0]) : i && f.push([0, c]), f.length) {
      f.sort((p, g) => Vt(K([e, n], p)) - Vt(K([e, n], g)));
      const d = f[0];
      if (d[0] && B(e) > Dt)
        l = -d[0], u = n * B(e + l) / B(e) - n;
      else if (d[1] && B(n) > Dt) {
        const p = n;
        u = -d[1], l = e * B(n + u) / B(p) - e;
      }
      if (t && s && r)
        if (B(l) > Dt && B(l) < B(a)) {
          const p = B(a) / B(l);
          l *= p, u *= p;
        } else if (B(u) > Dt && B(u) < B(c)) {
          const p = B(c) / B(u);
          l *= p, u *= p;
        } else
          l = Ne(-a, l), u = Ne(-c, u);
    }
  } else
    l = e || r ? -a : 0, u = n || s ? -c : 0;
  return [l, u];
}
function yl(t, e, n, r, s, o) {
  if (!Xe(t, "draggable"))
    return [
      {
        isSnap: !1,
        isBound: !1,
        offset: 0
      },
      {
        isSnap: !1,
        isBound: !1,
        offset: 0
      }
    ];
  const i = hs(o.absolutePoses, [e, n]), { left: a, right: c, top: l, bottom: u } = Yt(i), f = {
    horizontal: i.map((P) => P[1]),
    vertical: i.map((P) => P[0])
  }, d = cs(t.props.snapDirections), p = ls(d, {
    left: a,
    right: c,
    top: l,
    bottom: u,
    center: (a + c) / 2,
    middle: (l + u) / 2
  }), {
    vertical: g,
    horizontal: h
  } = Zn(t, s, p, f), {
    vertical: v,
    horizontal: m
  } = vl(t, i, o), S = g.isSnap, x = h.isSnap, C = g.isBound || v.isBound, E = h.isBound || m.isBound, D = Ne(
    g.offset,
    v.offset
  ), R = Ne(
    h.offset,
    m.offset
  ), [y, M] = bl(
    r,
    [e, n],
    [C, E],
    [S, x],
    [D, R]
  );
  return [
    {
      isBound: C,
      isSnap: S,
      offset: y
    },
    {
      isBound: E,
      isSnap: x,
      offset: M
    }
  ];
}
function Zn(t, e, n, r = n) {
  const {
    horizontal: s,
    vertical: o
  } = as(
    Un(t),
    r.vertical,
    r.horizontal
  ), {
    horizontal: i,
    vertical: a
  } = e ? {
    horizontal: { isSnap: !1, index: -1 },
    vertical: { isSnap: !1, index: -1 }
  } : Kn(
    t,
    n.vertical,
    n.horizontal,
    void 0,
    void 0,
    void 0,
    void 0
  ), c = Fn(
    s[0],
    i
  ), l = Fn(
    o[0],
    a
  ), u = B(c), f = B(l);
  return {
    horizontal: {
      isBound: s[0].isBound,
      isSnap: i.isSnap,
      snapIndex: i.index,
      offset: c,
      dist: u,
      bounds: s,
      snap: i
    },
    vertical: {
      isBound: o[0].isBound,
      isSnap: a.isSnap,
      snapIndex: a.index,
      offset: l,
      dist: f,
      bounds: o,
      snap: a
    }
  };
}
function Qs(t, e, n, r, s, o, i = [1, 1]) {
  const {
    horizontal: a,
    vertical: c
  } = as(e, n, r), {
    horizontal: l,
    vertical: u
  } = Si(
    t,
    n,
    r,
    [],
    [],
    s,
    o,
    i
  ), f = Fn(
    a[0],
    l
  ), d = Fn(
    c[0],
    u
  ), p = B(f), g = B(d);
  return {
    horizontal: {
      isBound: a[0].isBound,
      isSnap: l.isSnap,
      snapIndex: l.index,
      offset: f,
      dist: p,
      bounds: a,
      snap: l
    },
    vertical: {
      isBound: c[0].isBound,
      isSnap: u.isSnap,
      snapIndex: u.index,
      offset: d,
      dist: g,
      bounds: c,
      snap: u
    }
  };
}
function Rl(t, e, n, r) {
  const s = xt(t, e) / Math.PI * 180, {
    vertical: {
      isBound: o,
      isSnap: i,
      dist: a
    },
    horizontal: {
      isBound: c,
      isSnap: l,
      dist: u
    }
  } = n, f = s % 180, d = f < 3 || f > 177, p = f > 87 && f < 93;
  return u < a && (o || i && !p && (!r || !d)) ? "vertical" : c || l && !d && (!r || !p) ? "horizontal" : "";
}
function Ml(t, e, n, r, s, o) {
  return n.map(([i, a]) => {
    const c = yt(e, i), l = yt(e, a), u = r ? Pl(
      t,
      c,
      l,
      s
    ) : Zn(t, s, {
      vertical: [l[0]],
      horizontal: [l[1]]
    }), {
      horizontal: {
        // dist: otherHorizontalDist,
        offset: f,
        isBound: d,
        isSnap: p
      },
      vertical: {
        // dist: otherVerticalDist,
        offset: g,
        isBound: h,
        isSnap: v
      }
    } = u, m = K(a, i);
    if (!g && !f)
      return {
        isBound: h || d,
        isSnap: v || p,
        sign: m,
        offset: [0, 0]
      };
    const S = Rl(
      c,
      l,
      u,
      r
    );
    if (!S)
      return {
        sign: m,
        isBound: !1,
        isSnap: !1,
        offset: [0, 0]
      };
    const x = S === "vertical";
    let C = [0, 0];
    return !r && B(a[0]) === 1 && B(a[1]) === 1 && i[0] !== a[0] && i[1] !== a[1] ? C = Qt({
      datas: o,
      distX: -g,
      distY: -f
    }) : C = _r(
      c,
      l,
      -(x ? g : f),
      x,
      o
    ).offset, C = C.map((E, D) => E * (m[D] ? 2 / m[D] : 0)), {
      sign: m,
      isBound: x ? h : d,
      isSnap: x ? v : p,
      offset: C
    };
  });
}
function to(t, e) {
  return t.isBound ? t.offset : e.isSnap ? e.offset : 0;
}
function Pl(t, e, n, r) {
  const {
    horizontal: s,
    vertical: o
  } = sl(t, e, n), {
    horizontal: i,
    vertical: a
  } = r ? {
    horizontal: { isSnap: !1 },
    vertical: { isSnap: !1 }
  } : dl(t, e, n), c = to(
    s,
    i
  ), l = to(
    o,
    a
  ), u = B(c), f = B(l);
  return {
    horizontal: {
      isBound: s.isBound,
      isSnap: i.isSnap,
      offset: c,
      dist: u
    },
    vertical: {
      isBound: o.isBound,
      isSnap: a.isSnap,
      offset: l,
      dist: f
    }
  };
}
function _l(t, e, n, r, s) {
  const o = [-n[0], -n[1]], { width: i, height: a } = t.state, c = t.props.bounds;
  let l = 1 / 0, u = 1 / 0;
  if (c) {
    const f = [
      [n[0], -n[1]],
      [-n[0], n[1]]
    ], {
      left: d = -1 / 0,
      top: p = -1 / 0,
      right: g = 1 / 0,
      bottom: h = 1 / 0
    } = c;
    f.forEach((v) => {
      const m = v[0] !== o[0], S = v[1] !== o[1], x = yt(e, v), C = xt(r, x) * 360 / Math.PI;
      if (S) {
        const E = x.slice();
        (B(C - 360) < 2 || B(C - 180) < 2) && (E[1] = r[1]);
        const {
          offset: [, D],
          isOutside: R
        } = _r(
          r,
          E,
          (r[1] < x[1] ? h : p) - x[1],
          !1,
          s
        );
        isNaN(D) || (u = a + (R ? 1 : -1) * B(D));
      }
      if (m) {
        const E = x.slice();
        (B(C - 90) < 2 || B(C - 270) < 2) && (E[0] = r[0]);
        const {
          offset: [D],
          isOutside: R
        } = _r(
          r,
          E,
          (r[0] < x[0] ? g : d) - x[0],
          !0,
          s
        );
        isNaN(D) || (l = i + (R ? 1 : -1) * B(D));
      }
    });
  }
  return {
    maxWidth: l,
    maxHeight: u
  };
}
const Ot = {
  name: "draggable",
  props: [
    "draggable",
    "throttleDrag",
    "throttleDragRotate",
    "hideThrottleDragRotateLine",
    "startDragRotate",
    "edgeDraggable"
  ],
  events: [
    "dragStart",
    "drag",
    "dragEnd",
    "dragGroupStart",
    "dragGroup",
    "dragGroupEnd"
  ],
  requestStyle() {
    return ["left", "top", "right", "bottom"];
  },
  requestChildStyle() {
    return ["left", "top", "right", "bottom"];
  },
  render(t, e) {
    const { hideThrottleDragRotateLine: n, throttleDragRotate: r, zoom: s } = t.props, { dragInfo: o, beforeOrigin: i } = t.getState();
    if (n || !r || !o)
      return [];
    const a = o.dist;
    if (!a[0] && !a[1])
      return [];
    const c = Vt(a), l = xt(a, [0, 0]);
    return [/* @__PURE__ */ it.jsx("div", { className: U(
      "line",
      "horizontal",
      "dragline",
      "dashed"
    ), style: {
      width: `${c}px`,
      transform: `translate(${i[0]}px, ${i[1]}px) rotate(${l}rad) scaleY(${s})`
    } }, "dragRotateGuideline")];
  },
  dragStart(t, e) {
    const { datas: n, parentEvent: r, parentGesto: s } = e, o = t.state, {
      gestos: i,
      style: a
    } = o;
    if (i.draggable)
      return !1;
    i.draggable = s || t.targetGesto, n.datas = {}, n.left = parseFloat(a.left || "") || 0, n.top = parseFloat(a.top || "") || 0, n.bottom = parseFloat(a.bottom || "") || 0, n.right = parseFloat(a.right || "") || 0, n.startValue = [0, 0], Re(t, e), qn(t, e, "translate"), nu(t, n), n.prevDist = [0, 0], n.prevBeforeDist = [0, 0], n.isDrag = !1, n.deltaOffset = [0, 0];
    const c = et(t, e, {
      set: (u) => {
        n.startValue = u;
      },
      ...Hn(t, e)
    });
    return (r || j(t, "onDragStart", c)) !== !1 ? (n.isDrag = !0, t.state.dragInfo = {
      startRect: t.getRect(),
      dist: [0, 0]
    }) : (i.draggable = null, n.isPinch = !1), n.isDrag ? c : !1;
  },
  drag(t, e) {
    if (!e)
      return;
    jn(t, e, "translate");
    const {
      datas: n,
      parentEvent: r,
      parentFlag: s,
      isPinch: o,
      deltaOffset: i,
      useSnap: a,
      isRequest: c,
      isGroup: l,
      parentThrottleDrag: u
    } = e;
    let { distX: f, distY: d } = e;
    const { isDrag: p, prevDist: g, prevBeforeDist: h, startValue: v } = n;
    if (!p)
      return;
    i && (f += i[0], d += i[1]);
    const m = t.props, S = m.parentMoveable, x = l ? 0 : m.throttleDrag || u || 0, C = r ? 0 : m.throttleDragRotate || 0;
    let E = 0, D = !1, R = !1, y = !1, M = !1;
    if (!r && C > 0 && (f || d)) {
      const W = m.startDragRotate || 0, J = tt(W + xt([0, 0], [f, d]) * 180 / Math.PI, C) - W, q = d * Math.abs(Math.cos((J - 90) / 180 * Math.PI)), F = f * Math.abs(Math.cos(J / 180 * Math.PI)), H = Vt([F, q]);
      E = J * Math.PI / 180, f = H * Math.cos(E), d = H * Math.sin(E);
    }
    if (!o && !r && !s) {
      const [W, J] = yl(
        t,
        f,
        d,
        C,
        !a && c || i,
        n
      );
      D = W.isSnap, R = W.isBound, y = J.isSnap, M = J.isBound;
      const q = W.offset, F = J.offset;
      f += q, d += F;
    }
    const P = at(si({ datas: n, distX: f, distY: d }), v), _ = at(kc({ datas: n, distX: f, distY: d }), v);
    Ws(_, Bt), Ws(P, Bt), C || (!D && !R && (_[0] = tt(_[0], x), P[0] = tt(P[0], x)), !y && !M && (_[1] = tt(_[1], x), P[1] = tt(P[1], x)));
    const O = K(P, v), T = K(_, v), w = K(T, g), k = K(O, h);
    n.prevDist = T, n.prevBeforeDist = O, n.passDelta = w, n.passDist = T;
    const I = n.left + O[0], $ = n.top + O[1], G = n.right - O[0], L = n.bottom - O[1], z = Xn(
      n,
      `translate(${_[0]}px, ${_[1]}px)`,
      `translate(${T[0]}px, ${T[1]}px)`
    );
    if (os(e, z), t.state.dragInfo.dist = r ? [0, 0] : T, !r && !S && w.every((W) => !W) && k.some((W) => !W))
      return;
    const {
      width: N,
      height: Z
    } = t.state, Y = et(t, e, {
      transform: z,
      dist: T,
      delta: w,
      translate: _,
      beforeDist: O,
      beforeDelta: k,
      beforeTranslate: P,
      left: I,
      top: $,
      right: G,
      bottom: L,
      width: N,
      height: Z,
      isPinch: o,
      ...It({
        transform: z
      }, e)
    });
    return !r && j(t, "onDrag", Y), Y;
  },
  dragAfter(t, e) {
    const n = e.datas, {
      deltaOffset: r
    } = n;
    return r[0] || r[1] ? (n.deltaOffset = [0, 0], this.drag(t, { ...e, deltaOffset: r })) : !1;
  },
  dragEnd(t, e) {
    const { parentEvent: n, datas: r } = e;
    if (t.state.dragInfo = null, !r.isDrag)
      return;
    r.isDrag = !1;
    const s = $t(t, e, {});
    return !n && j(t, "onDragEnd", s), s;
  },
  dragGroupStart(t, e) {
    var f;
    const { datas: n, clientX: r, clientY: s } = e, o = this.dragStart(t, e);
    if (!o)
      return !1;
    const {
      childEvents: i,
      eventParams: a
    } = cr(t, this, "dragStart", [
      r || 0,
      s || 0
    ], e, !1, "draggable"), c = {
      ...o,
      targets: t.props.targets,
      events: a
    }, l = j(t, "onDragGroupStart", c);
    n.isDrag = l !== !1;
    const u = ((f = i[0]) == null ? void 0 : f.datas.startValue) ?? [0, 0];
    return n.throttleOffset = [u[0] % 1, u[1] % 1], n.isDrag ? o : !1;
  },
  dragGroup(t, e) {
    const { datas: n } = e;
    if (!n.isDrag)
      return;
    const r = this.drag(t, {
      ...e,
      parentThrottleDrag: t.props.throttleDrag
    }), { passDelta: s } = e.datas, {
      eventParams: o
    } = cr(t, this, "drag", s, e, !1, "draggable");
    if (!r)
      return;
    const i = {
      targets: t.props.targets,
      events: o,
      ...r
    };
    return j(t, "onDragGroup", i), i;
  },
  dragGroupEnd(t, e) {
    const { isDrag: n, datas: r } = e;
    if (!r.isDrag)
      return;
    this.dragEnd(t, e);
    const {
      eventParams: s
    } = cr(t, this, "dragEnd", [0, 0], e, !1, "draggable");
    return j(t, "onDragGroupEnd", $t(t, e, {
      targets: t.props.targets,
      events: s
    })), n;
  },
  /**
       * @method Moveable.Draggable#request
       * @param {object} [e] - the draggable's request parameter
       * @param {number} [e.x] - x position
       * @param {number} [e.y] - y position
       * @param {number} [e.deltaX] - X number to move
       * @param {number} [e.deltaY] - Y number to move
       * @return {Moveable.Requester} Moveable Requester
       * @example
  
       * // Instantly Request (requestStart - request - requestEnd)
       * // Use Relative Value
       * moveable.request("draggable", { deltaX: 10, deltaY: 10 }, true);
       * // Use Absolute Value
       * moveable.request("draggable", { x: 200, y: 100 }, true);
       *
       * // requestStart
       * const requester = moveable.request("draggable");
       *
       * // request
       * // Use Relative Value
       * requester.request({ deltaX: 10, deltaY: 10 });
       * requester.request({ deltaX: 10, deltaY: 10 });
       * requester.request({ deltaX: 10, deltaY: 10 });
       * // Use Absolute Value
       * moveable.request("draggable", { x: 200, y: 100 });
       * moveable.request("draggable", { x: 220, y: 100 });
       * moveable.request("draggable", { x: 240, y: 100 });
       *
       * // requestEnd
       * requester.requestEnd();
       */
  request(t) {
    const e = {}, n = t.getRect();
    let r = 0, s = 0, o = !1;
    return {
      isControl: !1,
      requestStart(i) {
        return o = i.useSnap, { datas: e, useSnap: o };
      },
      request(i) {
        return "x" in i ? r = i.x - n.left : "deltaX" in i && (r += i.deltaX), "y" in i ? s = i.y - n.top : "deltaY" in i && (s += i.deltaY), { datas: e, distX: r, distY: s, useSnap: o };
      },
      requestEnd() {
        return { datas: e, isDrag: !0, useSnap: o };
      }
    };
  },
  unset(t) {
    t.state.gestos.draggable = null, t.state.dragInfo = null;
  }
};
function yi(t, e) {
  return {
    fixedPosition: yt(t, e),
    fixedDirection: e,
    fixedOffset: [0, 0]
  };
}
function Tl(t, e) {
  const {
    allMatrix: n,
    is3d: r,
    width: s,
    height: o
  } = t, i = r ? 4 : 3, a = [
    s / 2 * (1 + e[0]),
    o / 2 * (1 + e[1])
  ];
  return {
    fixedPosition: ht(n, a, i),
    fixedDirection: e,
    fixedOffset: [0, 0]
  };
}
function Ri(t, e) {
  const {
    allMatrix: n,
    is3d: r,
    width: s,
    height: o
  } = t, i = r ? 4 : 3, a = jc(e, s, o), c = ht(n, e, i), l = [
    s ? 0 : e[0],
    o ? 0 : e[1]
  ];
  return {
    fixedPosition: c,
    fixedDirection: a,
    fixedOffset: l
  };
}
const eo = xs("resizable"), Tr = {
  name: "resizable",
  ableGroup: "size",
  canPinch: !0,
  props: [
    "resizable",
    "throttleResize",
    "renderDirections",
    "displayAroundControls",
    "keepRatio",
    "resizeFormat",
    "keepRatioFinally",
    "edge",
    "checkResizableError"
  ],
  events: [
    "resizeStart",
    "beforeResize",
    "resize",
    "resizeEnd",
    "resizeGroupStart",
    "beforeResizeGroup",
    "resizeGroup",
    "resizeGroupEnd"
  ],
  render: di("resizable"),
  dragControlCondition: eo,
  viewClassName: ms("resizable"),
  dragControlStart(t, e) {
    const {
      inputEvent: n,
      isPinch: r,
      isGroup: s,
      parentDirection: o,
      parentGesto: i,
      datas: a,
      parentFixedDirection: c,
      parentEvent: l
    } = e, u = Li(
      o,
      r,
      n,
      a
    ), f = t.state, { target: d, width: p, height: g, gestos: h } = f;
    if (!u || !d || h.resizable)
      return !1;
    h.resizable = i || t.controlGesto, !r && Re(t, e), a.datas = {}, a.direction = u, a.startOffsetWidth = p, a.startOffsetHeight = g, a.prevWidth = 0, a.prevHeight = 0, a.minSize = [0, 0], a.startWidth = f.inlineCSSWidth || f.cssWidth, a.startHeight = f.inlineCSSHeight || f.cssHeight, a.maxSize = [1 / 0, 1 / 0], s || (a.minSize = [f.minOffsetWidth, f.minOffsetHeight], a.maxSize = [f.maxOffsetWidth, f.maxOffsetHeight]);
    const v = t.props.transformOrigin || "% %";
    a.transformOrigin = v && re(v) ? v.split(" ") : v, a.startOffsetMatrix = f.offsetMatrix, a.startTransformOrigin = f.transformOrigin, a.isWidth = (e == null ? void 0 : e.parentIsWidth) ?? (!u[0] && !u[1] || u[0] || !u[1]);
    function m(y) {
      a.ratio = y && isFinite(y) ? y : 0;
    }
    a.startPositions = jt(t.state);
    function S(y) {
      const M = yi(
        a.startPositions,
        y
      );
      a.fixedDirection = M.fixedDirection, a.fixedPosition = M.fixedPosition, a.fixedOffset = M.fixedOffset;
    }
    function x(y) {
      const M = Ri(t.state, y);
      a.fixedDirection = M.fixedDirection, a.fixedPosition = M.fixedPosition, a.fixedOffset = M.fixedOffset;
    }
    function C(y) {
      a.minSize = [
        ft(`${y[0]}`, 0) || 0,
        ft(`${y[1]}`, 0) || 0
      ];
    }
    function E(y) {
      const M = [y[0] || 1 / 0, y[1] || 1 / 0];
      (!an(M[0]) || isFinite(M[0])) && (M[0] = ft(`${M[0]}`, 0) || 1 / 0), (!an(M[1]) || isFinite(M[1])) && (M[1] = ft(`${M[1]}`, 0) || 1 / 0), a.maxSize = M;
    }
    m(p / g), S(c || [-u[0], -u[1]]), a.setFixedDirection = S, a.setFixedPosition = x, a.setMin = C, a.setMax = E;
    const D = et(t, e, {
      direction: u,
      startRatio: a.ratio,
      set: ([y, M]) => {
        a.startWidth = y, a.startHeight = M;
      },
      setMin: C,
      setMax: E,
      setRatio: m,
      setFixedDirection: S,
      setFixedPosition: x,
      setOrigin: (y) => {
        a.transformOrigin = y;
      },
      dragStart: Ot.dragStart(
        t,
        new Fe().dragStart([0, 0], e)
      )
    }), R = l || j(t, "onResizeStart", D);
    return a.startFixedDirection = a.fixedDirection, a.startFixedPosition = a.fixedPosition, R !== !1 && (a.isResize = !0, t.state.snapRenderInfo = {
      request: e.isRequest,
      direction: u
    }), a.isResize ? D : !1;
  },
  dragControl(t, e) {
    const {
      datas: n,
      parentFlag: r,
      isPinch: s,
      parentKeepRatio: o,
      dragClient: i,
      parentDist: a,
      useSnap: c,
      isRequest: l,
      isGroup: u,
      parentEvent: f,
      resolveMatrix: d
    } = e, {
      isResize: p,
      transformOrigin: g,
      startWidth: h,
      startHeight: v,
      prevWidth: m,
      prevHeight: S,
      minSize: x,
      maxSize: C,
      ratio: E,
      startOffsetWidth: D,
      startOffsetHeight: R,
      isWidth: y
    } = n;
    if (!p)
      return;
    if (d) {
      const { is3d: st } = t.state, { startOffsetMatrix: Ft, startTransformOrigin: Lt } = n, ut = st ? 4 : 3;
      let St = ln(Gn(e));
      const Kt = Math.sqrt(St.length);
      ut !== Kt && (St = Ut(St, Kt, ut));
      const de = mn(
        Ft,
        St,
        Lt,
        ut
      ), Pe = Me(
        de,
        D,
        R,
        ut
      );
      n.startPositions = Pe, n.nextTargetMatrix = St, n.nextAllMatrix = de;
    }
    const M = De(t.props, "resizable"), {
      resizeFormat: P,
      throttleResize: _ = r ? 0 : 1,
      parentMoveable: O,
      keepRatioFinally: T
    } = M, w = n.direction;
    let k = w, I = 0, $ = 0;
    !w[0] && !w[1] && (k = [1, 1]);
    const G = E && (o ?? M.keepRatio) || !1;
    function L() {
      const st = n.fixedDirection, Ft = Xi(k, G, n, e);
      I = Ft.distWidth, $ = Ft.distHeight;
      let Lt = k[0] - st[0] || G ? Math.max(D + I, Bt) : D, ut = k[1] - st[1] || G ? Math.max(R + $, Bt) : R;
      return G && D && R && (y ? ut = Lt / E : Lt = ut * E), [Lt, ut];
    }
    let [z, N] = L();
    f || (n.setFixedDirection(n.fixedDirection), j(
      t,
      "onBeforeResize",
      et(
        t,
        e,
        {
          startFixedDirection: n.startFixedDirection,
          startFixedPosition: n.startFixedPosition,
          setFixedDirection(st) {
            return n.setFixedDirection(st), [z, N] = L(), [z, N];
          },
          setFixedPosition(st) {
            return n.setFixedPosition(st), [z, N] = L(), [z, N];
          },
          boundingWidth: z,
          boundingHeight: N,
          setSize(st) {
            [z, N] = st;
          }
        },
        !0
      )
    ));
    let Z = i;
    i || (!r && s ? Z = Uc(t, [0, 0]) : Z = n.fixedPosition);
    let Y = [0, 0];
    s || (Y = tu(
      t,
      z,
      N,
      w,
      Z,
      !c && l,
      n
    )), a && (!a[0] && (Y[0] = 0), !a[1] && (Y[1] = 0));
    function W() {
      P && ([z, N] = P([
        z,
        N
      ])), z = tt(z, _), N = tt(N, _);
    }
    if (G) {
      k[0] && k[1] && Y[0] && Y[1] && (B(Y[0]) > B(Y[1]) ? Y[1] = 0 : Y[0] = 0);
      const st = !Y[0] && !Y[1];
      st && W(), k[0] && !k[1] || Y[0] && !Y[1] || st && y ? (z += Y[0], N = z / E) : (!k[0] && k[1] || !Y[0] && Y[1] || st && !y) && (N += Y[1], z = N * E);
    } else
      z += Y[0], N += Y[1], z = Math.max(0, z), N = Math.max(0, N);
    [z, N] = qo(
      [z, N],
      x,
      C,
      G ? E : !1
    ), W(), G && (u || T) && (y ? N = z / E : z = N * E), I = z - D, $ = N - R;
    const J = [I - m, $ - S];
    n.prevWidth = I, n.prevHeight = $;
    const q = qc(
      t,
      z,
      N,
      Z,
      g,
      n
    );
    if (!O && J.every((st) => !st) && q.every((st) => !st))
      return;
    const F = Ot.drag(
      t,
      vn(
        e,
        t.state,
        q,
        !!s,
        !1,
        "draggable"
      )
    ), H = F.transform, nt = h + I, lt = v + $, vt = et(t, e, {
      width: nt,
      height: lt,
      offsetWidth: Math.round(z),
      offsetHeight: Math.round(N),
      startRatio: E,
      boundingWidth: z,
      boundingHeight: N,
      direction: w,
      dist: [I, $],
      delta: J,
      isPinch: !!s,
      drag: F,
      ...Wi(
        {
          style: {
            width: `${nt}px`,
            height: `${lt}px`
          },
          transform: H
        },
        F,
        e
      )
    });
    return !f && j(t, "onResize", vt), vt;
  },
  dragControlAfter(t, e) {
    const n = e.datas, {
      isResize: r,
      startOffsetWidth: s,
      startOffsetHeight: o,
      prevWidth: i,
      prevHeight: a
    } = n;
    if (!r || t.props.checkResizableError === !1)
      return;
    const { width: c, height: l } = t.state, u = c - (s + i), f = l - (o + a), d = B(u) > 3, p = B(f) > 3;
    if (d && (n.startWidth += u, n.startOffsetWidth += u, n.prevWidth += u), p && (n.startHeight += f, n.startOffsetHeight += f, n.prevHeight += f), d || p)
      return this.dragControl(t, e);
  },
  dragControlEnd(t, e) {
    const { datas: n, parentEvent: r } = e;
    if (!n.isResize)
      return;
    n.isResize = !1;
    const s = $t(t, e, {});
    return !r && j(t, "onResizeEnd", s), s;
  },
  dragGroupControlCondition: eo,
  dragGroupControlStart(t, e) {
    const { datas: n } = e, r = this.dragControlStart(t, { ...e, isGroup: !0 });
    if (!r)
      return !1;
    const s = Ht(t, "resizable", e), {
      startOffsetWidth: o,
      startOffsetHeight: i
    } = n;
    function a() {
      const p = n.minSize;
      s.forEach((g) => {
        const {
          minSize: h,
          startOffsetWidth: v,
          startOffsetHeight: m
        } = g.datas, S = o * (v ? h[0] / v : 0), x = i * (m ? h[1] / m : 0);
        p[0] = Math.max(p[0], S), p[1] = Math.max(p[1], x);
      });
    }
    function c() {
      const p = n.maxSize;
      s.forEach((g) => {
        const {
          maxSize: h,
          startOffsetWidth: v,
          startOffsetHeight: m
        } = g.datas, S = o * (v ? h[0] / v : 0), x = i * (m ? h[1] / m : 0);
        p[0] = Math.min(p[0], S), p[1] = Math.min(p[1], x);
      });
    }
    const l = ee(
      t,
      this,
      "dragControlStart",
      e,
      (p, g) => kn(t, p, n, g)
    );
    a(), c();
    const u = (p) => {
      r.setFixedDirection(p), l.forEach((g, h) => {
        g.setFixedDirection(p), kn(t, g.moveable, n, s[h]);
      });
    };
    n.setFixedDirection = u;
    const f = {
      ...r,
      targets: t.props.targets,
      events: l.map((p) => ({
        ...p,
        setMin: (g) => {
          p.setMin(g), a();
        },
        setMax: (g) => {
          p.setMax(g), c();
        }
      })),
      setFixedDirection: u,
      setMin: (p) => {
        r.setMin(p), a();
      },
      setMax: (p) => {
        r.setMax(p), c();
      }
    }, d = j(t, "onResizeGroupStart", f);
    return n.isResize = d !== !1, n.isResize ? r : !1;
  },
  dragGroupControl(t, e) {
    const { datas: n } = e;
    if (!n.isResize)
      return;
    const r = De(t.props, "resizable");
    Qn(t, "onBeforeResize", (p) => {
      j(
        t,
        "onBeforeResizeGroup",
        et(
          t,
          e,
          {
            ...p,
            targets: r.targets
          },
          !0
        )
      );
    });
    const s = this.dragControl(t, { ...e, isGroup: !0 });
    if (!s)
      return;
    const { boundingWidth: o, boundingHeight: i, dist: a } = s, c = r.keepRatio, l = [
      o / (o - a[0]),
      i / (i - a[1])
    ], u = n.fixedPosition, f = ee(
      t,
      this,
      "dragControl",
      e,
      (p, g) => {
        const [h, v] = _t(
          hn(t.rotation / 180 * Math.PI, 3),
          [
            g.datas.originalX * l[0],
            g.datas.originalY * l[1],
            1
          ],
          3
        );
        return {
          ...g,
          parentDist: null,
          parentScale: l,
          dragClient: at(u, [h, v]),
          parentKeepRatio: c
        };
      }
    ), d = {
      targets: r.targets,
      events: f,
      ...s
    };
    return j(t, "onResizeGroup", d), d;
  },
  dragGroupControlEnd(t, e) {
    const { isDrag: n, datas: r } = e;
    if (!r.isResize)
      return;
    this.dragControlEnd(t, e);
    const s = ee(t, this, "dragControlEnd", e), o = $t(
      t,
      e,
      {
        targets: t.props.targets,
        events: s
      }
    );
    return j(t, "onResizeGroupEnd", o), n;
  },
  /**
       * @method Moveable.Resizable#request
       * @param {Moveable.Resizable.ResizableRequestParam} e - the Resizable's request parameter
       * @return {Moveable.Requester} Moveable Requester
       * @example
  
       * // Instantly Request (requestStart - request - requestEnd)
       * // Use Relative Value
       * moveable.request("resizable", { deltaWidth: 10, deltaHeight: 10 }, true);
       *
       * // Use Absolute Value
       * moveable.request("resizable", { offsetWidth: 100, offsetHeight: 100 }, true);
       *
       * // requestStart
       * const requester = moveable.request("resizable");
       *
       * // request
       * // Use Relative Value
       * requester.request({ deltaWidth: 10, deltaHeight: 10 });
       * requester.request({ deltaWidth: 10, deltaHeight: 10 });
       * requester.request({ deltaWidth: 10, deltaHeight: 10 });
       *
       * // Use Absolute Value
       * moveable.request("resizable", { offsetWidth: 100, offsetHeight: 100 });
       * moveable.request("resizable", { offsetWidth: 110, offsetHeight: 100 });
       * moveable.request("resizable", { offsetWidth: 120, offsetHeight: 100 });
       *
       * // requestEnd
       * requester.requestEnd();
       */
  request(t) {
    const e = {};
    let n = 0, r = 0, s = !1;
    const o = t.getRect();
    return {
      isControl: !0,
      requestStart(i) {
        return s = i.useSnap, {
          datas: e,
          parentDirection: i.direction || [1, 1],
          parentIsWidth: (i == null ? void 0 : i.horizontal) ?? !0,
          useSnap: s
        };
      },
      request(i) {
        return "offsetWidth" in i ? n = i.offsetWidth - o.offsetWidth : "deltaWidth" in i && (n += i.deltaWidth), "offsetHeight" in i ? r = i.offsetHeight - o.offsetHeight : "deltaHeight" in i && (r += i.deltaHeight), {
          datas: e,
          parentDist: [n, r],
          parentKeepRatio: i.keepRatio,
          useSnap: s
        };
      },
      requestEnd() {
        return { datas: e, isDrag: !0, useSnap: s };
      }
    };
  },
  unset(t) {
    t.state.gestos.resizable = null;
  }
};
function lr(t, e, n, r, s) {
  const o = t.props.groupable, i = t.state, a = i.is3d ? 4 : 3, c = e.origin, l = ht(
    t.state.rootMatrix,
    // TO-DO #710
    K([c[0], c[1]], o ? [0, 0] : [i.left, i.top]),
    a
  ), u = at([s.left, s.top], l);
  e.startAbsoluteOrigin = u, e.prevDeg = xt(u, [n, r]) / Math.PI * 180, e.defaultDeg = e.prevDeg, e.prevSnapDeg = 0, e.loop = 0, e.startDist = te(u, [n, r]);
}
function In(t, e, n) {
  const { defaultDeg: r, prevDeg: s } = n;
  let o = s % 360, i = Math.floor(s / 360);
  o < 0 && (o += 360), o > t && o > 270 && t < 90 ? ++i : o < t && o < 90 && t > 270 && --i;
  const a = e * (i * 360 + t - r);
  return n.prevDeg = r + a, a;
}
function ur(t, e, n, r) {
  return In(
    xt(r.startAbsoluteOrigin, [t, e]) / Math.PI * 180,
    n,
    r
  );
}
function fr(t, e, n, r, s, o) {
  const { throttleRotate: i = 0 } = t.props, a = n.prevSnapDeg;
  let c = 0, l = !1;
  if (o) {
    const f = Ql(
      t,
      e,
      r,
      s + r
    );
    l = f.isSnap, c = s + f.dist;
  }
  l || (c = tt(s + r, i));
  const u = c - s;
  return n.prevSnapDeg = u, [u - a, u, c];
}
function Mi(t, [e, n, r, s], o) {
  if (t === "none")
    return [];
  if (Rt(t))
    return t.map(
      (f) => Mi(f, [e, n, r, s], o)[0]
    );
  const [i, a] = (t || "top").split("-");
  let c = [e, n];
  i === "left" ? c = [r, e] : i === "right" ? c = [n, s] : i === "bottom" && (c = [s, r]);
  let l = [
    (c[0][0] + c[1][0]) / 2,
    (c[0][1] + c[1][1]) / 2
  ];
  const u = $i(c, o);
  if (a) {
    const f = a === "top" || a === "left", d = i === "bottom" || i === "left";
    l = c[f && !d || !f && d ? 0 : 1];
  }
  return [[l, u]];
}
function Or(t, e) {
  if (e.isRequest)
    return e.requestAble === "rotatable";
  const n = e.inputEvent.target;
  if (bt(n, U("rotation-control")) || t.props.rotateAroundControls && bt(n, U("around-control")) || bt(n, U("control")) && bt(n, U("rotatable")))
    return !0;
  const r = t.props.rotationTarget;
  return r ? Ss(r, !0).some((s) => s ? n === s || n.contains(s) : !1) : !1;
}
const Ol = `.rotation {
position: absolute;
height: 40px;
width: 1px;
transform-origin: 50% 100%;
height: calc(40px * var(--zoom));
top: auto;
left: 0;
bottom: 100%;
will-change: transform;
}
.rotation .rotation-line {
display: block;
width: 100%;
height: 100%;
transform-origin: 50% 50%;
}
.rotation .rotation-control {
border-color: #4af;
border-color: var(--moveable-color);
background:#fff;
cursor: alias;
}
:global .view-rotation-dragging, .rotatable.direction.control {
cursor: alias;
}
.rotatable.direction.control.move {
cursor: move;
}
`, wl = {
  name: "rotatable",
  canPinch: !0,
  props: [
    "rotatable",
    "rotationPosition",
    "throttleRotate",
    "renderDirections",
    "rotationTarget",
    "rotateAroundControls",
    "edge",
    "resolveAblesWithRotatable",
    "displayAroundControls"
  ],
  events: [
    "rotateStart",
    "beforeRotate",
    "rotate",
    "rotateEnd",
    "rotateGroupStart",
    "beforeRotateGroup",
    "rotateGroup",
    "rotateGroupEnd"
  ],
  css: [Ol],
  viewClassName(t) {
    return t.isDragging("rotatable") ? U("view-rotation-dragging") : "";
  },
  render(t, e) {
    const {
      rotatable: n,
      rotationPosition: r,
      zoom: s,
      renderDirections: o,
      rotateAroundControls: i,
      resolveAblesWithRotatable: a
    } = De(t.props, "rotatable"), { renderPoses: c, direction: l } = t.getState();
    if (!n)
      return null;
    const u = Mi(
      r,
      c,
      l
    ), f = [];
    if (u.forEach(([d, p], g) => {
      f.push(
        /* @__PURE__ */ it.jsxs(
          "div",
          {
            className: U("rotation"),
            style: {
              // tslint:disable-next-line: max-line-length
              transform: `translate(-50%) translate(${d[0]}px, ${d[1]}px) rotate(${p}rad)`
            },
            children: [
              /* @__PURE__ */ it.jsx(
                "div",
                {
                  className: U("line rotation-line"),
                  style: {
                    transform: `scaleX(${s})`
                  }
                }
              ),
              /* @__PURE__ */ it.jsx(
                "div",
                {
                  className: U("control rotation-control"),
                  style: {
                    transform: `translate(0.5px) scale(${s})`
                  }
                }
              )
            ]
          },
          `rotation${g}`
        )
      );
    }), o) {
      const d = Ve(a || {}), p = {};
      d.forEach((h) => {
        a[h].forEach((v) => {
          p[v] = h;
        });
      });
      let g = [];
      Rt(o) && (g = o.map((h) => {
        const v = p[h];
        return {
          data: v ? { resolve: v } : {},
          classNames: v ? ["move"] : [],
          dir: h
        };
      })), f.push(
        ...li(
          t,
          "rotatable",
          g
        )
      );
    }
    return i && f.push(...gi(t)), f;
  },
  dragControlCondition: Or,
  dragControlStart(t, e) {
    var k;
    const {
      datas: n,
      clientX: r,
      clientY: s,
      parentRotate: o,
      parentFlag: i,
      isPinch: a,
      isRequest: c
    } = e, l = t.state, {
      target: u,
      left: f,
      top: d,
      direction: p,
      beforeDirection: g,
      targetTransform: h,
      moveableClientRect: v,
      offsetMatrix: m,
      targetMatrix: S,
      allMatrix: x,
      width: C,
      height: E
    } = l;
    if (!c && !u)
      return !1;
    const D = t.getRect();
    n.rect = D, n.transform = h, n.left = f, n.top = d;
    let R = (I) => {
      const $ = Ri(t.state, I);
      n.fixedDirection = $.fixedDirection, n.fixedOffset = $.fixedOffset, n.fixedPosition = $.fixedPosition, O && O.setFixedPosition(I);
    }, y = (I) => {
      const $ = Tl(
        t.state,
        I
      );
      n.fixedDirection = $.fixedDirection, n.fixedOffset = $.fixedOffset, n.fixedPosition = $.fixedPosition, O && O.setFixedDirection(I);
    }, M = r, P = s;
    if (c || a || i) {
      const I = o || 0;
      n.beforeInfo = {
        origin: D.beforeOrigin,
        prevDeg: I,
        defaultDeg: I,
        prevSnapDeg: 0,
        startDist: 0
      }, n.afterInfo = {
        ...n.beforeInfo,
        origin: D.origin
      }, n.absoluteInfo = {
        ...n.beforeInfo,
        origin: D.origin,
        startValue: I
      };
    } else {
      const I = (k = e.inputEvent) == null ? void 0 : k.target;
      if (I) {
        const G = I.getAttribute("data-direction") || "", L = ac[G];
        if (L) {
          n.isControl = !0, n.isAroundControl = bt(
            I,
            U("around-control")
          ), n.controlDirection = L;
          const z = I.getAttribute("data-resolve");
          z && (n.resolveAble = z);
          const N = hu(
            l.rootMatrix,
            l.renderPoses,
            v
          );
          [M, P] = yt(
            N,
            L
          );
        }
      }
      n.beforeInfo = { origin: D.beforeOrigin }, n.afterInfo = { origin: D.origin }, n.absoluteInfo = {
        origin: D.origin,
        startValue: D.rotation
      };
      const $ = R;
      R = (G) => {
        const L = l.is3d ? 4 : 3, [z, N] = at(
          ti(S, L),
          G
        ), Z = _t(
          m,
          Ee([z, N], L)
        ), Y = _t(
          x,
          Ee([G[0], G[1]], L)
        );
        $(G);
        const W = l.posDelta;
        n.beforeInfo.origin = K(Z, W), n.afterInfo.origin = K(Y, W), n.absoluteInfo.origin = K(Y, W), lr(
          t,
          n.beforeInfo,
          M,
          P,
          v
        ), lr(
          t,
          n.afterInfo,
          M,
          P,
          v
        ), lr(
          t,
          n.absoluteInfo,
          M,
          P,
          v
        );
      }, y = (G) => {
        const L = yt(
          [
            [0, 0],
            [C, 0],
            [0, E],
            [C, E]
          ],
          G
        );
        R(L);
      };
    }
    n.startClientX = M, n.startClientY = P, n.direction = p, n.beforeDirection = g, n.startValue = 0, n.datas = {}, qn(t, e, "rotate");
    let _ = !1, O = !1;
    n.isControl && n.resolveAble && n.resolveAble === "resizable" && (O = Tr.dragControlStart(t, {
      ...new Fe("resizable").dragStart([0, 0], e),
      parentPosition: n.controlPosition,
      parentFixedPosition: n.fixedPosition
    })), O || (_ = Ot.dragStart(
      t,
      new Fe().dragStart([0, 0], e)
    )), R(vu(t));
    const T = et(t, e, {
      set: (I) => {
        n.startValue = I * Math.PI / 180;
      },
      setFixedDirection: y,
      setFixedPosition: R,
      ...Hn(t, e),
      dragStart: _,
      resizeStart: O
    }), w = j(t, "onRotateStart", T);
    return n.isRotate = w !== !1, l.snapRenderInfo = {
      request: e.isRequest
    }, n.isRotate ? T : !1;
  },
  dragControl(t, e) {
    const {
      datas: n,
      clientDistX: r,
      clientDistY: s,
      parentRotate: o,
      parentFlag: i,
      isPinch: a,
      groupDelta: c,
      resolveMatrix: l
    } = e, {
      beforeDirection: u,
      beforeInfo: f,
      afterInfo: d,
      absoluteInfo: p,
      isRotate: g,
      startValue: h,
      rect: v,
      startClientX: m,
      startClientY: S
    } = n;
    if (!g)
      return;
    jn(t, e, "rotate");
    const x = Gc(e), C = u * x, { parentMoveable: E } = t.props;
    let D = 0, R, y, M = 0, P, _, O = 0, T, w;
    const k = 180 / Math.PI * h, I = p.startValue;
    let $ = !1;
    const G = m + r, L = S + s;
    if (!i && "parentDist" in e) {
      const H = e.parentDist;
      R = H, P = H, T = H;
    } else a || i ? (R = In(o, u, f), P = In(o, C, d), T = In(o, C, p)) : (R = ur(
      G,
      L,
      u,
      f
    ), P = ur(
      G,
      L,
      C,
      d
    ), T = ur(
      G,
      L,
      C,
      p
    ), $ = !0);
    if (y = k + R, _ = k + P, w = I + T, j(
      t,
      "onBeforeRotate",
      et(
        t,
        e,
        {
          beforeRotation: y,
          rotation: _,
          absoluteRotation: w,
          setRotation(H) {
            P = H - k, R = P, T = P;
          }
        },
        !0
      )
    ), [D, R, y] = fr(
      t,
      v,
      f,
      R,
      k,
      $
    ), [M, P, _] = fr(
      t,
      v,
      d,
      P,
      k,
      $
    ), [O, T, w] = fr(
      t,
      v,
      p,
      T,
      I,
      $
    ), !O && !M && !D && !E && !l)
      return;
    const z = Xn(
      n,
      `rotate(${_}deg)`,
      `rotate(${P}deg)`
    );
    l && (n.fixedPosition = is(
      t,
      n.targetAllTransform,
      n.fixedDirection,
      n.fixedOffset,
      n
    ));
    const N = Hc(t, P, n), Z = K(
      at(c || [0, 0], N),
      n.prevInverseDist || [0, 0]
    );
    n.prevInverseDist = N, n.requestValue = null;
    const Y = ii(
      t,
      z,
      Z,
      a,
      e
    );
    let W = Y;
    const J = te([G, L], p.startAbsoluteOrigin) - p.startDist;
    let q;
    if (n.resolveAble === "resizable") {
      const H = Tr.dragControl(t, {
        ...vn(
          e,
          t.state,
          [e.deltaX, e.deltaY],
          !!a,
          !1,
          "resizable"
        ),
        resolveMatrix: !0,
        parentDistance: J
      });
      H && (q = H, W = Wi(W, H, e));
    }
    const F = et(t, e, {
      delta: M,
      dist: P,
      rotate: _,
      rotation: _,
      beforeDist: R,
      beforeDelta: D,
      beforeRotate: y,
      beforeRotation: y,
      absoluteDist: T,
      absoluteDelta: O,
      absoluteRotate: w,
      absoluteRotation: w,
      isPinch: !!a,
      resize: q,
      ...Y,
      ...W
    });
    return j(t, "onRotate", F), F;
  },
  dragControlEnd(t, e) {
    const { datas: n } = e;
    if (!n.isRotate)
      return;
    n.isRotate = !1;
    const r = $t(t, e, {});
    return j(t, "onRotateEnd", r), r;
  },
  dragGroupControlCondition: Or,
  dragGroupControlStart(t, e) {
    const { datas: n } = e, {
      left: r,
      top: s,
      beforeOrigin: o
    } = t.state, i = this.dragControlStart(t, e);
    if (!i)
      return !1;
    i.set(n.beforeDirection * t.rotation);
    const a = ee(
      t,
      this,
      "dragControlStart",
      e,
      (u, f) => {
        const { left: d, top: p, beforeOrigin: g } = u.state, h = at(
          K([d, p], [r, s]),
          K(g, o)
        );
        return f.datas.startGroupClient = h, f.datas.groupClient = h, { ...f, parentRotate: 0 };
      }
    ), c = {
      ...i,
      targets: t.props.targets,
      events: a
    }, l = j(t, "onRotateGroupStart", c);
    return n.isRotate = l !== !1, n.isRotate ? i : !1;
  },
  dragGroupControl(t, e) {
    const { datas: n } = e;
    if (!n.isRotate)
      return;
    Qn(t, "onBeforeRotate", (l) => {
      j(
        t,
        "onBeforeRotateGroup",
        et(
          t,
          e,
          {
            ...l,
            targets: t.props.targets
          },
          !0
        )
      );
    });
    const r = this.dragControl(t, e);
    if (!r)
      return;
    const s = n.beforeDirection, o = r.beforeDist, i = o / 180 * Math.PI, a = ee(
      t,
      this,
      "dragControl",
      e,
      (l, u) => {
        const f = u.datas.startGroupClient, [d, p] = u.datas.groupClient, [g, h] = gn(
          f,
          i * s
        ), v = [g - d, h - p];
        return u.datas.groupClient = [g, h], { ...u, parentRotate: o, groupDelta: v };
      }
    );
    t.rotation = s * r.beforeRotation;
    const c = {
      targets: t.props.targets,
      events: a,
      set(l) {
        t.rotation = l;
      },
      setGroupRotation(l) {
        t.rotation = l;
      },
      ...r
    };
    return j(t, "onRotateGroup", c), c;
  },
  dragGroupControlEnd(t, e) {
    const { isDrag: n, datas: r } = e;
    if (!r.isRotate)
      return;
    this.dragControlEnd(t, e);
    const s = ee(t, this, "dragControlEnd", e), o = $t(t, e, {
      targets: t.props.targets,
      events: s
    });
    return j(t, "onRotateGroupEnd", o), n;
  },
  /**
       * @method Moveable.Rotatable#request
       * @param {object} [e] - the Resizable's request parameter
       * @param {number} [e.deltaRotate=0] -  delta number of rotation
       * @param {number} [e.rotate=0] - absolute number of moveable's rotation
       * @return {Moveable.Requester} Moveable Requester
       * @example
  
       * // Instantly Request (requestStart - request - requestEnd)
       * moveable.request("rotatable", { deltaRotate: 10 }, true);
       *
       * * moveable.request("rotatable", { rotate: 10 }, true);
       *
       * // requestStart
       * const requester = moveable.request("rotatable");
       *
       * // request
       * requester.request({ deltaRotate: 10 });
       * requester.request({ deltaRotate: 10 });
       * requester.request({ deltaRotate: 10 });
       *
       * requester.request({ rotate: 10 });
       * requester.request({ rotate: 20 });
       * requester.request({ rotate: 30 });
       *
       * // requestEnd
       * requester.requestEnd();
       */
  request(t) {
    const e = {};
    let n = 0;
    const r = t.getRotation();
    return {
      isControl: !0,
      requestStart() {
        return { datas: e };
      },
      request(s) {
        return "deltaRotate" in s ? n += s.deltaRotate : "rotate" in s && (n = s.rotate - r), { datas: e, parentDist: n };
      },
      requestEnd() {
        return { datas: e, isDrag: !0 };
      }
    };
  }
};
function Il(t, e) {
  const { direction: n, classNames: r, size: s, pos: o, zoom: i, key: a } = t, c = n === "horizontal", l = c ? "Y" : "X";
  return e.createElement("div", {
    key: a,
    className: r.join(" "),
    style: {
      [c ? "width" : "height"]: `${s}`,
      transform: `translate(${o[0]}, ${o[1]}) translate${l}(-50%) scale${l}(${i})`
    }
  });
}
function ds(t, e) {
  return Il({
    ...t,
    classNames: [
      U("line", "guideline", t.direction),
      ...t.classNames
    ].filter((n) => n),
    size: t.size || `${t.sizeValue}px`,
    pos: t.pos || t.posValue.map((n) => `${tt(n, 0.1)}px`)
  }, e);
}
function no(t, e, n, r, s, o, i, a) {
  const { zoom: c } = t.props;
  return n.map(({ type: l, pos: u }, f) => {
    const d = [0, 0];
    return d[i] = r, d[i ? 0 : 1] = -s + u, ds(
      {
        key: `${e}TargetGuideline${f}`,
        classNames: [U("target", "bold", l)],
        posValue: d,
        sizeValue: o,
        zoom: c,
        direction: e
      },
      a
    );
  });
}
function ro(t, e, n, r, s, o) {
  const { zoom: i, isDisplayInnerSnapDigit: a } = t.props, c = e === "horizontal" ? le : ue, l = s[c.start], u = s[c.end];
  return n.filter(({ hide: f, elementRect: d }) => {
    if (f)
      return !1;
    if (a && d) {
      const p = d.rect;
      if (p[c.start] <= l && u <= p[c.end])
        return !1;
    }
    return !0;
  }).map((f, d) => {
    const { pos: p, size: g, element: h, className: v } = f, m = [
      -r[0] + p[0],
      -r[1] + p[1]
    ];
    return ds(
      {
        key: `${e}-default-guideline-${d}`,
        classNames: h ? [U("bold"), v] : [U("normal"), v],
        direction: e,
        posValue: m,
        sizeValue: g,
        zoom: i
      },
      o
    );
  });
}
function Ze(t, e, n, r, s, o, i, a) {
  const {
    snapDigit: c = 0,
    isDisplaySnapDigit: l = !0,
    snapDistFormat: u = (v, m) => v,
    zoom: f
  } = t.props, d = e === "horizontal" ? "X" : "Y", p = e === "vertical" ? "height" : "width", g = Math.abs(s), h = l ? parseFloat(g.toFixed(c)) : 0;
  return /* @__PURE__ */ it.jsxs(
    "div",
    {
      className: U("guideline-group", e),
      style: {
        left: `${o[0]}px`,
        top: `${o[1]}px`,
        [p]: `${g}px`
      },
      children: [
        ds(
          {
            direction: e,
            classNames: [U(n), i],
            size: "100%",
            posValue: [0, 0],
            sizeValue: g,
            zoom: f
          },
          a
        ),
        /* @__PURE__ */ it.jsx(
          "div",
          {
            className: U("size-value", "gap"),
            style: {
              transform: `translate${d}(-50%) scale(${f})`
            },
            children: h > 0 ? u(h, e) : ""
          }
        )
      ]
    },
    `${e}-${n}-guideline-${r}`
  );
}
function Bl(t, e, n, r) {
  const s = t === "vertical" ? 0 : 1, o = t === "vertical" ? 1 : 0, i = s ? le : ue, a = n[i.start], c = n[i.end];
  return Yi(e, (l) => l.pos[s]).map((l) => {
    const u = [], f = [], d = [];
    return l.forEach((p) => {
      const g = p.element, h = p.elementRect.rect;
      if (h[i.end] < a)
        u.push(p);
      else if (c < h[i.start])
        f.push(p);
      else if (h[i.start] <= a && c <= h[i.end] && r) {
        const v = p.pos, m = { element: g, rect: { ...h, [i.end]: h[i.start] } }, S = { element: g, rect: { ...h, [i.start]: h[i.end] } }, x = [0, 0], C = [0, 0];
        x[s] = v[s], x[o] = v[o], C[s] = v[s], C[o] = v[o] + p.size, u.push({
          type: t,
          pos: x,
          size: 0,
          elementRect: m,
          direction: "",
          elementDirection: "end"
        }), f.push({
          type: t,
          pos: C,
          size: 0,
          elementRect: S,
          direction: "",
          elementDirection: "start"
        });
      }
    }), u.sort((p, g) => g.pos[o] - p.pos[o]), f.sort((p, g) => p.pos[o] - g.pos[o]), {
      total: l,
      start: u,
      end: f,
      inner: d
    };
  });
}
function zl(t, e, n, r, s) {
  const {
    isDisplayInnerSnapDigit: o
  } = t.props, i = [];
  return ["vertical", "horizontal"].forEach((a) => {
    const c = e.filter((v) => v.type === a), l = a === "vertical" ? 1 : 0, u = l ? 0 : 1, f = Bl(a, c, r, o), d = l ? ue : le, p = l ? le : ue, g = r[d.start], h = r[d.end];
    f.forEach(({ total: v, start: m, end: S, inner: x }) => {
      const C = n[u] + v[0].pos[u] - r[p.start];
      let E = r;
      m.forEach((D) => {
        const R = D.elementRect.rect, y = E[d.start] - R[d.end];
        if (y > 0) {
          const M = [0, 0];
          M[l] = n[l] + E[d.start] - g - y, M[u] = C, i.push(Ze(
            t,
            a,
            "dashed",
            i.length,
            y,
            M,
            D.className,
            s
          ));
        }
        E = R;
      }), E = r, S.forEach((D) => {
        const R = D.elementRect.rect, y = R[d.start] - E[d.end];
        if (y > 0) {
          const M = [0, 0];
          M[l] = n[l] + E[d.end] - g, M[u] = C, i.push(Ze(
            t,
            a,
            "dashed",
            i.length,
            y,
            M,
            D.className,
            s
          ));
        }
        E = R;
      }), x.forEach((D) => {
        const R = D.elementRect.rect, y = g - R[d.start], M = R[d.end] - h, P = [0, 0], _ = [0, 0];
        P[l] = n[l] - y, P[u] = C, _[l] = n[l] + h - g, _[u] = C, i.push(Ze(
          t,
          a,
          "dashed",
          i.length,
          y,
          P,
          D.className,
          s
        )), i.push(Ze(
          t,
          a,
          "dashed",
          i.length,
          M,
          _,
          D.className,
          s
        ));
      });
    });
  }), i;
}
function Al(t, e, n, r, s) {
  const o = [];
  return ["horizontal", "vertical"].forEach((i) => {
    const a = e.filter((v) => v.type === i).slice(0, 1), c = i === "vertical" ? 0 : 1, l = c ? 0 : 1, u = c ? ue : le, f = c ? le : ue, d = r[u.start], p = r[u.end], g = r[f.start], h = r[f.end];
    a.forEach(({ gap: v, gapRects: m }) => {
      const S = Math.max(
        g,
        ...m.map(({ rect: E }) => E[f.start])
      ), x = Math.min(
        h,
        ...m.map(({ rect: E }) => E[f.end])
      ), C = (S + x) / 2;
      S === x || C === (g + h) / 2 || m.forEach(({ rect: E, className: D }) => {
        const R = [n[0], n[1]];
        if (E[u.end] < d)
          R[c] += E[u.end] - d;
        else if (p < E[u.start])
          R[c] += E[u.start] - d - v;
        else
          return;
        R[l] += C - g, o.push(Ze(
          t,
          c ? "vertical" : "horizontal",
          "gap",
          o.length,
          v,
          R,
          D,
          s
        ));
      });
    });
  }), o;
}
var Gl = /* @__PURE__ */ function() {
  function t() {
    this.keys = [], this.values = [];
  }
  var e = t.prototype;
  return e.get = function(n) {
    return this.values[this.keys.indexOf(n)];
  }, e.set = function(n, r) {
    var s = this.keys, o = this.values, i = s.indexOf(n), a = i === -1 ? s.length : i;
    s[a] = n, o[a] = r;
  }, t;
}(), kl = /* @__PURE__ */ function() {
  function t() {
    this.object = {};
  }
  var e = t.prototype;
  return e.get = function(n) {
    return this.object[n];
  }, e.set = function(n, r) {
    this.object[n] = r;
  }, t;
}(), $l = typeof Map == "function", Fl = /* @__PURE__ */ function() {
  function t() {
  }
  var e = t.prototype;
  return e.connect = function(n, r) {
    this.prev = n, this.next = r, n && (n.next = this), r && (r.prev = this);
  }, e.disconnect = function() {
    var n = this.prev, r = this.next;
    n && (n.next = r), r && (r.prev = n);
  }, e.getIndex = function() {
    for (var n = this, r = -1; n; )
      n = n.prev, ++r;
    return r;
  }, t;
}();
function Ll(t, e) {
  var n = [], r = [];
  return t.forEach(function(s) {
    var o = s[0], i = s[1], a = new Fl();
    n[o] = a, r[i] = a;
  }), n.forEach(function(s, o) {
    s.connect(n[o - 1]);
  }), t.filter(function(s, o) {
    return !e[o];
  }).map(function(s, o) {
    var i = s[0], a = s[1];
    if (i === a)
      return [0, 0];
    var c = n[i], l = r[a - 1], u = c.getIndex();
    c.disconnect(), l ? c.connect(l, l.next) : c.connect(void 0, n[0]);
    var f = c.getIndex();
    return [u, f];
  });
}
var Nl = /* @__PURE__ */ function() {
  function t(n, r, s, o, i, a, c, l) {
    this.prevList = n, this.list = r, this.added = s, this.removed = o, this.changed = i, this.maintained = a, this.changedBeforeAdded = c, this.fixed = l;
  }
  var e = t.prototype;
  return Object.defineProperty(e, "ordered", {
    get: function() {
      return this.cacheOrdered || this.caculateOrdered(), this.cacheOrdered;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(e, "pureChanged", {
    get: function() {
      return this.cachePureChanged || this.caculateOrdered(), this.cachePureChanged;
    },
    enumerable: !0,
    configurable: !0
  }), e.caculateOrdered = function() {
    var n = Ll(this.changedBeforeAdded, this.fixed), r = this.changed, s = [];
    this.cacheOrdered = n.filter(function(o, i) {
      var a = o[0], c = o[1], l = r[i], u = l[0], f = l[1];
      if (a !== c)
        return s.push([u, f]), !0;
    }), this.cachePureChanged = s;
  }, t;
}();
function ps(t, e, n) {
  var r = $l ? Map : n ? kl : Gl, s = n || function(S) {
    return S;
  }, o = [], i = [], a = [], c = t.map(s), l = e.map(s), u = new r(), f = new r(), d = [], p = [], g = {}, h = [], v = 0, m = 0;
  return c.forEach(function(S, x) {
    u.set(S, x);
  }), l.forEach(function(S, x) {
    f.set(S, x);
  }), c.forEach(function(S, x) {
    var C = f.get(S);
    typeof C > "u" ? (++m, i.push(x)) : g[C] = m;
  }), l.forEach(function(S, x) {
    var C = u.get(S);
    typeof C > "u" ? (o.push(x), ++v) : (a.push([C, x]), m = g[x] || 0, d.push([C - m, x - v]), p.push(x === C), C !== x && h.push([C, x]));
  }), i.reverse(), new Nl(t, e, o, i, h, a, d, p);
}
var Wl = /* @__PURE__ */ function() {
  function t(n, r) {
    n === void 0 && (n = []), this.findKeyCallback = r, this.list = [].slice.call(n);
  }
  var e = t.prototype;
  return e.update = function(n) {
    var r = [].slice.call(n), s = ps(this.list, r, this.findKeyCallback);
    return this.list = r, s;
  }, t;
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var wr = function(t, e) {
  return wr = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var s in r) r.hasOwnProperty(s) && (n[s] = r[s]);
  }, wr(t, e);
};
function Yl(t, e) {
  wr(t, e);
  function n() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());
}
var Pi = typeof Map == "function" ? void 0 : /* @__PURE__ */ function() {
  var t = 0;
  return function(e) {
    return e.__DIFF_KEY__ || (e.__DIFF_KEY__ = ++t);
  };
}(), _i = /* @__PURE__ */ function(t) {
  Yl(e, t);
  function e(n) {
    return n === void 0 && (n = []), t.call(this, n, Pi) || this;
  }
  return e;
}(Wl);
function Vl(t, e) {
  return ps(t, e, Pi);
}
function Ir(t) {
  var P;
  const e = t.state, {
    containerClientRect: n,
    hasFixed: r
  } = e, {
    overflow: s,
    scrollHeight: o,
    scrollWidth: i,
    clientHeight: a,
    clientWidth: c,
    clientLeft: l,
    clientTop: u
  } = n, {
    snapGap: f = !0,
    verticalGuidelines: d,
    horizontalGuidelines: p,
    snapThreshold: g = 5,
    maxSnapElementGuidelineDistance: h = 1 / 0,
    isDisplayGridGuidelines: v
  } = t.props, { top: m, left: S, bottom: x, right: C } = Yt(jt(t.state)), E = { top: m, left: S, bottom: x, right: C, center: (S + C) / 2, middle: (m + x) / 2 };
  let R = [...ql(t)];
  const y = (((P = e.snapThresholdInfo) == null ? void 0 : P.multiples) ?? [1, 1]).map((_) => _ * g);
  f && R.push(...jl(
    t,
    E,
    y
  ));
  const M = {
    ...e.snapOffset || {
      left: 0,
      top: 0,
      bottom: 0,
      right: 0
    }
  };
  if (R.push(...Hl(
    t,
    s ? i : c,
    s ? o : a,
    l,
    u,
    M,
    v
  )), r) {
    const { left: _, top: O } = n;
    M.left += _, M.top += O, M.right += _, M.bottom += O;
  }
  return R.push(...Oi(
    p || !1,
    d || !1,
    s ? i : c,
    s ? o : a,
    l,
    u,
    M
  )), R = R.filter(({ element: _, elementRect: O, type: T }) => {
    if (!_ || !O)
      return !0;
    const w = O.rect;
    return Ti(E, w, T, h);
  }), R;
}
function jl(t, e, n) {
  const {
    maxSnapElementGuidelineDistance: r = 1 / 0,
    maxSnapElementGapDistance: s = 1 / 0
  } = t.props, o = t.state.elementRects, i = [];
  return [
    ["vertical", le, ue],
    ["horizontal", ue, le]
  ].forEach(([a, c, l]) => {
    const u = e[c.start], f = e[c.end], d = e[c.center], p = e[l.start], g = e[l.end], h = {
      left: n[0],
      top: n[1]
    };
    function v(x) {
      const C = x.rect, E = h[c.start];
      return C[c.end] < u + E ? u - C[c.end] : f - E < C[c.start] ? C[c.start] - f : -1;
    }
    const m = o.filter((x) => {
      const C = x.rect;
      return C[l.start] > g || C[l.end] < p ? !1 : v(x) > 0;
    }).sort((x, C) => v(x) - v(C)), S = [];
    m.forEach((x) => {
      m.forEach((C) => {
        if (x === C)
          return;
        const { rect: E } = x, { rect: D } = C, R = E[l.start], y = E[l.end], M = D[l.start], P = D[l.end];
        R > P || M > y || S.push([x, C]);
      });
    }), S.forEach(([x, C]) => {
      const { rect: E } = x, { rect: D } = C, R = E[c.start], y = E[c.end], M = D[c.start], P = D[c.end], _ = h[c.start];
      let O = 0, T = 0, w = !1, k = !1, I = !1;
      if (y <= u && f <= M) {
        if (k = !0, O = (M - y - (f - u)) / 2, T = y + O + (f - u) / 2, B(T - d) > _)
          return;
      } else if (y < M && P < u + _) {
        if (w = !0, O = M - y, T = P + O, B(T - u) > _)
          return;
      } else if (y < M && f - _ < R) {
        if (I = !0, O = M - y, T = R - O, B(T - f) > _)
          return;
      } else
        return;
      O && Ti(e, D, a, r) && (O > s || i.push({
        type: a,
        pos: a === "vertical" ? [T, 0] : [0, T],
        element: C.element,
        size: 0,
        className: C.className,
        isStart: w,
        isCenter: k,
        isEnd: I,
        gap: O,
        hide: !0,
        gapRects: [x, C],
        direction: "",
        elementDirection: ""
      }));
    });
  }), i;
}
function Xl(t, e, n, r) {
  var d, p;
  const s = t.props, o = t.state, {
    snapGridAll: i
  } = s, {
    snapGridWidth: a = 0,
    snapGridHeight: c = 0
  } = s, {
    snapRenderInfo: l
  } = o, u = l && (((d = l.direction) == null ? void 0 : d[0]) || ((p = l.direction) == null ? void 0 : p[1])), f = t.moveables;
  if (i && f && u && (a || c)) {
    if (o.snapThresholdInfo)
      return;
    o.snapThresholdInfo = {
      multiples: [1, 1],
      offset: [0, 0]
    };
    const g = t.getRect(), h = g.children, v = l.direction;
    if (h) {
      const m = v.map((x, C) => {
        const {
          snapSize: E,
          posName: D,
          sizeName: R,
          clientOffset: y
        } = C === 0 ? {
          snapSize: a,
          posName: "left",
          sizeName: "width",
          clientOffset: r.left - e
        } : {
          snapSize: c,
          posName: "top",
          sizeName: "height",
          clientOffset: r.top - n
        };
        if (!E)
          return {
            dir: x,
            multiple: 1,
            snapSize: E,
            snapOffset: 0
          };
        const M = g[R], P = g[D], _ = yc(h.map((G) => [
          G[D] - P,
          G[R],
          M - G[R] - G[D] + P
        ])).filter((G) => G).sort((G, L) => G - L), O = _[0], T = _.map((G) => tt(G / O, 0.1) * E);
        let w = 1;
        const k = tt(M / O, 0.1);
        for (w = 1; w <= 10 && !T.every((G) => G * w % 1 === 0); ++w)
          ;
        const I = (-x + 1) / 2, $ = zn(
          P - y,
          P - y + M,
          I,
          1 - I
        );
        return {
          multiple: k * w,
          dir: x,
          snapSize: E,
          snapOffset: Math.round($ / E)
        };
      }), S = m.map((x) => x.multiple || 1);
      o.snapThresholdInfo.multiples = S, o.snapThresholdInfo.offset = m.map((x) => x.snapOffset), m.forEach((x, C) => {
        x.snapSize;
      });
    }
  } else
    o.snapThresholdInfo = null;
}
function Hl(t, e, n, r = 0, s = 0, o, i) {
  const a = t.props, c = t.state;
  let {
    snapGridWidth: l = 0,
    snapGridHeight: u = 0
  } = a;
  const f = [], {
    left: d,
    top: p
  } = o;
  let g = [0, 0];
  Xl(
    t,
    r,
    s,
    o
  );
  const h = c.snapThresholdInfo, v = l, m = u;
  if (h && (l *= h.multiples[0] || 1, u *= h.multiples[1] || 1, g = h.offset), u) {
    const S = (x) => {
      f.push({
        type: "horizontal",
        pos: [
          d,
          tt(g[1] * m + x - s + p, 0.1)
        ],
        className: U("grid-guideline"),
        size: e,
        hide: !i,
        direction: "",
        grid: !0
      });
    };
    for (let x = 0; x <= n * 2; x += u)
      S(x);
    for (let x = -u; x >= -n; x -= u)
      S(x);
  }
  if (l) {
    const S = (x) => {
      f.push({
        type: "vertical",
        pos: [
          tt(g[0] * v + x - r + d, 0.1),
          p
        ],
        className: U("grid-guideline"),
        size: n,
        hide: !i,
        direction: "",
        grid: !0
      });
    };
    for (let x = 0; x <= e * 2; x += l)
      S(x);
    for (let x = -l; x >= -e; x -= l)
      S(x);
  }
  return f;
}
function Ti(t, e, n, r) {
  return n === "horizontal" ? B(t.right - e.left) <= r || B(t.left - e.right) <= r || t.left <= e.right && e.left <= t.right : n === "vertical" ? B(t.bottom - e.top) <= r || B(t.top - e.bottom) <= r || t.top <= e.bottom && e.top <= t.bottom : !0;
}
function ql(t) {
  const e = t.state, {
    elementGuidelines: n = []
  } = t.props;
  if (!n.length)
    return e.elementRects = [], [];
  const r = (e.elementRects || []).filter((u) => !u.refresh), s = n.map((u) => qt(u) && "element" in u ? {
    ...u,
    element: Zt(u.element, !0)
  } : {
    element: Zt(u, !0)
  }).filter((u) => u.element), {
    maintained: o,
    added: i
  } = Vl(r.map((u) => u.element), s.map((u) => u.element)), a = [];
  o.forEach(([u, f]) => {
    a[f] = r[u];
  }), Ul(t, i.map((u) => s[u])).map((u, f) => {
    a[i[f]] = u;
  }), e.elementRects = a;
  const c = cs(t.props.elementSnapDirections), l = [];
  return a.forEach((u) => {
    const {
      element: f,
      top: d = c.top,
      left: p = c.left,
      right: g = c.right,
      bottom: h = c.bottom,
      center: v = c.center,
      middle: m = c.middle,
      className: S,
      rect: x
    } = u, {
      horizontal: C,
      vertical: E,
      horizontalNames: D,
      verticalNames: R
    } = ls({
      top: d,
      right: g,
      left: p,
      bottom: h,
      center: v,
      middle: m
    }, x), y = x.top, M = x.left, P = x.right - M, _ = x.bottom - y, O = [P, _];
    E.forEach((T, w) => {
      l.push({
        type: "vertical",
        element: f,
        pos: [
          tt(T, 0.1),
          y
        ],
        size: _,
        sizes: O,
        className: S,
        elementRect: u,
        elementDirection: qs[R[w]] || R[w],
        direction: ""
      });
    }), C.forEach((T, w) => {
      l.push({
        type: "horizontal",
        element: f,
        pos: [
          M,
          tt(T, 0.1)
        ],
        size: P,
        sizes: O,
        className: S,
        elementRect: u,
        elementDirection: qs[D[w]] || D[w],
        direction: ""
      });
    });
  }), l;
}
function so(t, e) {
  return t ? t.map((n) => {
    const r = qt(n) ? n : { pos: n }, s = r.pos;
    return an(s) ? r : {
      ...r,
      pos: ft(s, e)
    };
  }) : [];
}
function Oi(t, e, n, r, s = 0, o = 0, i = { left: 0, top: 0, right: 0, bottom: 0 }) {
  const a = [], {
    left: c,
    top: l,
    bottom: u,
    right: f
  } = i, d = n + f - c, p = r + u - l;
  return so(t, p).forEach((g) => {
    a.push({
      type: "horizontal",
      pos: [
        c,
        tt(g.pos - o + l, 0.1)
      ],
      size: d,
      className: g.className,
      direction: ""
    });
  }), so(e, d).forEach((g) => {
    a.push({
      type: "vertical",
      pos: [
        tt(g.pos - s + c, 0.1),
        l
      ],
      size: p,
      className: g.className,
      direction: ""
    });
  }), a;
}
function Ul(t, e) {
  if (!e.length)
    return [];
  const n = t.props.groupable, r = t.state, {
    containerClientRect: s,
    // targetClientRect: {
    //     top: clientTop,
    //     left: clientLeft,
    // },
    rootMatrix: o,
    is3d: i,
    offsetDelta: a
  } = r, c = i ? 4 : 3, [l, u] = ul(o, s, c), f = n ? 0 : a[0], d = n ? 0 : a[1];
  return e.map((p) => {
    const g = p.element.getBoundingClientRect(), h = g.left - l - f, v = g.top - u - d, m = v + g.height, S = h + g.width, [x, C] = We(o, [h, v], c), [E, D] = We(o, [S, m], c);
    return {
      ...p,
      rect: {
        left: x,
        right: E,
        top: C,
        bottom: D,
        center: (x + E) / 2,
        middle: (C + D) / 2
      }
    };
  });
}
function yn(t) {
  const e = t.state, n = e.container, r = t.props.snapContainer || n;
  if (e.snapContainer === r && e.guidelines && e.guidelines.length)
    return !1;
  const s = e.containerClientRect, o = {
    left: 0,
    top: 0,
    bottom: 0,
    right: 0
  };
  if (n !== r) {
    const i = Zt(r, !0);
    if (i) {
      const a = nn(i), c = uo(e, [
        a.left - s.left,
        a.top - s.top
      ]), l = uo(e, [
        a.right - s.right,
        a.bottom - s.bottom
      ]);
      o.left = tt(c[0], 1e-5), o.top = tt(c[1], 1e-5), o.right = tt(l[0], 1e-5), o.bottom = tt(l[1], 1e-5);
    }
  }
  return e.snapContainer = r, e.snapOffset = o, e.guidelines = Ir(t), e.enableSnap = !0, !0;
}
function wi(t, e, n, r, s, o) {
  const i = Me(t, e, n, o ? 4 : 3), a = yt(i, r);
  return hs(i, K(s, a));
}
function oo(t) {
  return t ? t / B(t) : 0;
}
function Kl(t, e, n, r, s, o) {
  const { fixedDirection: i } = o, a = gl(n, i, r), c = fs(t, e, n, r), l = [
    ...Ml(
      t,
      e,
      a,
      r,
      s,
      o
    ),
    ...bi(
      t,
      c,
      o
    )
  ], u = $n(l, 0), f = $n(l, 1);
  return {
    width: {
      isBound: u.isBound,
      offset: u.offset[0]
    },
    height: {
      isBound: f.isBound,
      offset: f.offset[1]
    }
  };
}
function Zl(t, e, n, r, s, o, i, a, c) {
  const l = yt(e, i), {
    horizontal: { offset: u },
    vertical: { offset: f }
  } = Zn(t, a, {
    vertical: [l[0]],
    horizontal: [l[1]]
  });
  if (tt(f, Cr) || tt(u, Cr)) {
    const [d, p] = Qt({
      datas: c,
      distX: -f,
      distY: -u
    }), g = Math.min(
      s || 1 / 0,
      n + i[0] * d
    ), h = Math.min(
      o || 1 / 0,
      r + i[1] * p
    );
    return [g - n, h - r];
  }
  return [0, 0];
}
function Ii(t, e, n, r, s, o, i, a) {
  const c = jt(t.state), l = t.props.keepRatio;
  let u = 0, f = 0;
  for (let d = 0; d < 2; ++d) {
    const p = e(u, f), {
      width: g,
      height: h
    } = Kl(
      t,
      p,
      s,
      l,
      i,
      a
    ), v = g.isBound, m = h.isBound;
    let S = g.offset, x = h.offset;
    if (d === 1 && (v || (S = 0), m || (x = 0)), d === 0 && i && !v && !m)
      return [0, 0];
    if (l) {
      const C = B(S) * (n ? 1 / n : 1), E = B(x) * (r ? 1 / r : 1);
      (v && m ? C < E : m || !v && C < E) ? S = n * x / r : x = r * S / n;
    }
    u += S, f += x;
  }
  if (!l && s[0] && s[1]) {
    const { maxWidth: d, maxHeight: p } = _l(
      t,
      c,
      s,
      o,
      a
    ), [g, h] = Zl(
      t,
      e(u, f).map((v) => v.map((m) => tt(m, Cr))),
      n + u,
      r + f,
      d,
      p,
      s,
      i,
      a
    );
    u += g, f += h;
  }
  return [u, f];
}
function tn(t) {
  return t < 0 && (t = t % 360 + 360), t %= 360, t;
}
function Jl(t, e) {
  e = tn(e);
  const n = Math.floor(t / 360), r = n * 360 + 360 - e, s = n * 360 + e;
  return B(t - r) < B(t - s) ? r : s;
}
function dr(t, e) {
  t = tn(t), e = tn(e);
  const n = tn(t - e);
  return Math.min(n, 360 - n);
}
function Ql(t, e, n, r) {
  const s = t.props, o = s[hi] ?? 5, i = s[vi];
  if (Xe(t, "rotatable")) {
    const { pos1: a, pos2: c, pos3: l, pos4: u, origin: f } = e, d = n * Math.PI / 180, p = [a, c, l, u].map((m) => K(m, f)), g = p.map((m) => gn(m, d)), h = [
      ...il(t, p, g, f, n),
      ...El(
        t,
        p,
        g,
        f,
        n
      )
    ];
    h.sort((m, S) => B(m - n) - B(S - n));
    const v = h.length > 0;
    if (v)
      return {
        isSnap: v,
        dist: v ? h[0] : n
      };
  }
  if (i != null && i.length && o) {
    const c = i.slice().sort((l, u) => dr(l, r) - dr(u, r))[0];
    if (dr(c, r) <= o)
      return {
        isSnap: !0,
        dist: n + Jl(r, c) - r
      };
  }
  return {
    isSnap: !1,
    dist: n
  };
}
function tu(t, e, n, r, s, o, i) {
  if (!Xe(t, "resizable"))
    return [0, 0];
  const { fixedDirection: a, nextAllMatrix: c } = i, { allMatrix: l, is3d: u } = t.state;
  return Ii(
    t,
    (f, d) => wi(
      c || l,
      e + f,
      n + d,
      a,
      s,
      u
    ),
    e,
    n,
    r,
    s,
    o,
    i
  );
}
function eu(t, e, n, r, s) {
  if (!Xe(t, "scalable"))
    return [0, 0];
  const { startOffsetWidth: o, startOffsetHeight: i, fixedPosition: a, fixedDirection: c, is3d: l } = s, u = Ii(
    t,
    (f, d) => wi(
      Yc(
        s,
        at(e, [f / o, d / i])
      ),
      o,
      i,
      c,
      a,
      l
    ),
    o,
    i,
    n,
    a,
    r,
    s
  );
  return [u[0] / o, u[1] / i];
}
function nu(t, e) {
  e.absolutePoses = jt(t.state);
}
function io(t) {
  const e = [];
  return t.forEach((n) => {
    n.guidelineInfos.forEach(({ guideline: r }) => {
      kt(e, (s) => s.guideline === r) || (r.direction = "", e.push({ guideline: r, posInfo: n }));
    });
  }), e.map(({ guideline: n, posInfo: r }) => ({
    ...n,
    direction: r.direction
  }));
}
function ao(t, e, n, r, s, o) {
  const {
    vertical: i,
    horizontal: a
  } = as(
    Un(t, o),
    e,
    n
  ), c = Be();
  i.forEach((d) => {
    d.isBound && (d.direction === "start" && (c.left = !0), d.direction === "end" && (c.right = !0), r.push({
      type: "bounds",
      pos: d.pos
    }));
  }), a.forEach((d) => {
    d.isBound && (d.direction === "start" && (c.top = !0), d.direction === "end" && (c.bottom = !0), s.push({
      type: "bounds",
      pos: d.pos
    }));
  });
  const {
    boundMap: l,
    vertical: u,
    horizontal: f
  } = Cl(t);
  return u.forEach((d) => {
    ne(
      r,
      ({ type: p, pos: g }) => p === "bounds" && g === d
    ) >= 0 || r.push({
      type: "bounds",
      pos: d
    });
  }), f.forEach((d) => {
    ne(
      s,
      ({ type: p, pos: g }) => p === "bounds" && g === d
    ) >= 0 || s.push({
      type: "bounds",
      pos: d
    });
  }), {
    boundMap: c,
    innerBoundMap: l
  };
}
const ru = xs("", ["resizable", "scalable"]), su = {
  name: "snappable",
  dragRelation: "strong",
  props: [
    "snappable",
    "snapContainer",
    "snapDirections",
    "elementSnapDirections",
    "snapGap",
    "snapGridWidth",
    "snapGridHeight",
    "isDisplaySnapDigit",
    "isDisplayInnerSnapDigit",
    "isDisplayGridGuidelines",
    "snapDigit",
    "snapThreshold",
    "snapRenderThreshold",
    "snapGridAll",
    hi,
    vi,
    mi,
    xi,
    "horizontalGuidelines",
    "verticalGuidelines",
    "elementGuidelines",
    "bounds",
    "innerBounds",
    "snapDistFormat",
    "maxSnapElementGuidelineDistance",
    "maxSnapElementGapDistance"
  ],
  events: ["snap", "bound"],
  css: [
    `:host {
--bounds-color: #d66;
}
.guideline {
pointer-events: none;
z-index: 2;
}
.guideline.bounds {
background: #d66;
background: var(--bounds-color);
}
.guideline-group {
position: absolute;
top: 0;
left: 0;
}
.guideline-group .size-value {
position: absolute;
color: #f55;
font-size: 12px;
font-size: calc(12px * var(--zoom));
font-weight: bold;
}
.guideline-group.horizontal .size-value {
transform-origin: 50% 100%;
transform: translateX(-50%);
left: 50%;
bottom: 5px;
bottom: calc(2px + 3px * var(--zoom));
}
.guideline-group.vertical .size-value {
transform-origin: 0% 50%;
top: 50%;
transform: translateY(-50%);
left: 5px;
left: calc(2px + 3px * var(--zoom));
}
.guideline.gap {
background: #f55;
}
.size-value.gap {
color: #f55;
}
`
  ],
  render(t, e) {
    const n = t.state, {
      top: r,
      left: s,
      pos1: o,
      pos2: i,
      pos3: a,
      pos4: c,
      snapRenderInfo: l
    } = n, {
      snapRenderThreshold: u = 1
    } = t.props;
    if (!l || !l.render || !Xe(t, ""))
      return Ae(
        t,
        "boundMap",
        Be(),
        (z) => JSON.stringify(z)
      ), Ae(
        t,
        "innerBoundMap",
        Be(),
        (z) => JSON.stringify(z)
      ), [];
    n.guidelines = Ir(t);
    const f = Math.min(o[0], i[0], a[0], c[0]), d = Math.min(o[1], i[1], a[1], c[1]), p = l.externalPoses || [], g = jt(t.state), h = [], v = [], m = [], S = [], x = [], { width: C, height: E, top: D, left: R, bottom: y, right: M } = Yt(g), P = { left: R, right: M, top: D, bottom: y, center: (R + M) / 2, middle: (D + y) / 2 }, _ = p.length > 0, O = _ ? Yt(p) : {};
    if (!l.request) {
      if (l.direction && x.push(
        pl(
          t,
          g,
          l.direction,
          u,
          u
        )
      ), l.snap) {
        const z = Yt(g);
        l.center && (z.middle = (z.top + z.bottom) / 2, z.center = (z.left + z.right) / 2), x.push(Us(t, z, u, u));
      }
      _ && (l.center && (O.middle = (O.top + O.bottom) / 2, O.center = (O.left + O.right) / 2), x.push(Us(t, O, u, u))), x.forEach((z) => {
        const {
          vertical: { posInfos: N },
          horizontal: { posInfos: Z }
        } = z;
        h.push(
          ...N.filter(({ guidelineInfos: Y }) => Y.some(({ guideline: W }) => !W.hide)).map(
            (Y) => ({
              type: "snap",
              pos: Y.pos
            })
          )
        ), v.push(
          ...Z.filter(({ guidelineInfos: Y }) => Y.some(({ guideline: W }) => !W.hide)).map(
            (Y) => ({
              type: "snap",
              pos: Y.pos
            })
          )
        ), m.push(...io(N)), S.push(...io(Z));
      });
    }
    const {
      boundMap: T,
      innerBoundMap: w
    } = ao(
      t,
      [R, M],
      [D, y],
      h,
      v
    );
    _ && ao(
      t,
      [O.left, O.right],
      [O.top, O.bottom],
      h,
      v,
      l.externalBounds
    );
    const k = [...m, ...S], I = k.filter((z) => z.element && !z.gapRects), $ = k.filter((z) => z.gapRects).sort((z, N) => z.gap - N.gap);
    j(
      t,
      "onSnap",
      {
        guidelines: k.filter(({ element: z }) => !z),
        elements: I,
        gaps: $
      },
      !0
    );
    const G = Ae(
      t,
      "boundMap",
      T,
      (z) => JSON.stringify(z),
      Be()
    ), L = Ae(
      t,
      "innerBoundMap",
      w,
      (z) => JSON.stringify(z),
      Be()
    );
    return (T === G || w === L) && j(
      t,
      "onBound",
      {
        bounds: T,
        innerBounds: w
      },
      !0
    ), [
      ...zl(
        t,
        I,
        [f, d],
        P,
        e
      ),
      ...Al(
        t,
        $,
        [f, d],
        P,
        e
      ),
      ...ro(
        t,
        "horizontal",
        S,
        [s, r],
        P,
        e
      ),
      ...ro(
        t,
        "vertical",
        m,
        [s, r],
        P,
        e
      ),
      ...no(
        t,
        "horizontal",
        v,
        f,
        r,
        C,
        0,
        e
      ),
      ...no(
        t,
        "vertical",
        h,
        d,
        s,
        E,
        1,
        e
      )
    ];
  },
  dragStart(t, e) {
    t.state.snapRenderInfo = {
      request: e.isRequest,
      snap: !0,
      center: !0
    }, yn(t);
  },
  drag(t) {
    const e = t.state;
    yn(t) || (e.guidelines = Ir(t)), e.snapRenderInfo && (e.snapRenderInfo.render = !0);
  },
  pinchStart(t) {
    this.unset(t);
  },
  dragEnd(t) {
    this.unset(t);
  },
  dragControlCondition(t, e) {
    if (ru(t, e) || Or(t, e))
      return !0;
    if (!e.isRequest && e.inputEvent)
      return bt(e.inputEvent.target, U("snap-control"));
  },
  dragControlStart(t) {
    t.state.snapRenderInfo = null, yn(t);
  },
  dragControl(t) {
    this.drag(t);
  },
  dragControlEnd(t) {
    this.unset(t);
  },
  dragGroupStart(t, e) {
    this.dragStart(t, e);
  },
  dragGroup(t) {
    this.drag(t);
  },
  dragGroupEnd(t) {
    this.unset(t);
  },
  dragGroupControlStart(t) {
    t.state.snapRenderInfo = null, yn(t);
  },
  dragGroupControl(t) {
    this.drag(t);
  },
  dragGroupControlEnd(t) {
    this.unset(t);
  },
  unset(t) {
    const e = t.state;
    e.enableSnap = !1, e.guidelines = [], e.snapRenderInfo = null, e.elementRects = [];
  }
};
function ou(t, e) {
  return [t[0] * e[0], t[1] * e[1]];
}
function U(...t) {
  return cc(Hr, ...t);
}
function Bi(t) {
  t();
}
function iu(t) {
  return !t || t === "none" ? [1, 0, 0, 1, 0, 0] : qt(t) ? t : ln(t);
}
function en(t, e, n) {
  return An(
    e,
    Ce(n, e),
    t,
    Ce(
      n.map((r) => -r),
      e
    )
  );
}
function au(t, e, n) {
  return e === "%" ? gs(t.ownerSVGElement)[n ? "width" : "height"] / 100 : 1;
}
function cu(t) {
  return lu(vs(t, ":before")).map((n, r) => {
    const { value: s, unit: o } = pn(n);
    return s * au(t, o, r === 0);
  });
}
function Ln(t) {
  return t ? t.split(" ") : ["0", "0"];
}
function lu(t) {
  return Ln(t.transformOrigin);
}
function zi(t) {
  const n = Gt(t)("transform");
  if (n && n !== "none")
    return n;
  if ("transform" in t) {
    const s = t.transform.baseVal;
    if (!s)
      return "";
    const o = s.length;
    if (!o)
      return "";
    const i = [];
    for (let a = 0; a < o; ++a) {
      const c = s[a].matrix;
      i.push(
        `matrix(${["a", "b", "c", "d", "e", "f"].map((l) => c[l]).join(", ")})`
      );
    }
    return i.join(" ");
  }
  return "";
}
function fn(t, e, n, r, s) {
  var h, v;
  const o = es(t) || fe(t);
  let i = !1, a, c;
  if (!t || n)
    a = t;
  else {
    const m = (h = t == null ? void 0 : t.assignedSlot) == null ? void 0 : h.parentElement, S = t.parentElement;
    m ? (i = !0, c = S, a = m) : a = S;
  }
  let l = !1, u = t === e || a === e, f = "relative", d = 1;
  const p = parseFloat(s == null ? void 0 : s("zoom")) || 1, g = s == null ? void 0 : s("position");
  for (; a && a !== o; ) {
    e === a && (u = !0);
    const m = Gt(a), S = a.tagName.toLowerCase(), x = zi(a), C = m("willChange"), E = parseFloat(m("zoom")) || 1;
    if (f = m("position"), r && E !== 1) {
      d = E;
      break;
    }
    if (
      // offsetParent is the parentElement if the target's zoom is not 1 and not absolute.
      !n && r && p !== 1 && g && g !== "absolute" || S === "svg" || S === "foreignobject" || f !== "static" || x && x !== "none" || C === "transform"
    )
      break;
    const D = (v = t == null ? void 0 : t.assignedSlot) == null ? void 0 : v.parentNode, R = a.parentNode;
    D && (i = !0, c = R);
    const y = R;
    if (y && y.nodeType === 11) {
      a = y.host, l = !0, f = Gt(a)("position");
      break;
    }
    a = y, f = "relative";
  }
  return {
    offsetZoom: d,
    hasSlot: i,
    parentSlotElement: c,
    isCustomElement: l,
    isStatic: f === "static",
    isEnd: u || !a || a === o,
    offsetParent: a || o
  };
}
function uu(t, e) {
  const n = t.tagName.toLowerCase();
  let r = t.offsetLeft, s = t.offsetTop;
  const o = Gt(t), i = Kr(r);
  let a = !i, c, l;
  return !a && (n !== "svg" || t.ownerSVGElement) ? (c = Fo ? cu(t) : Ln(o("transformOrigin")).map(
    (u) => parseFloat(u)
  ), l = c.slice(), a = !0, n === "svg" ? (r = 0, s = 0) : [r, s, c[0], c[1]] = pu(
    t,
    c,
    t === e && e.tagName.toLowerCase() === "g"
  )) : (c = Ln(o("transformOrigin")).map(
    (u) => parseFloat(u)
  ), l = c.slice()), {
    tagName: n,
    isSVG: i,
    hasOffset: a,
    offset: [r || 0, s || 0],
    origin: c,
    targetOrigin: l
  };
}
function Ai(t, e) {
  const n = Gt(t), r = Gt(fe(t)), s = r("position");
  if (!e && (!s || s === "static"))
    return [0, 0];
  let o = parseInt(r("marginLeft"), 10), i = parseInt(r("marginTop"), 10);
  return n("position") === "absolute" && ((n("top") !== "auto" || n("bottom") !== "auto") && (i = 0), (n("left") !== "auto" || n("right") !== "auto") && (o = 0)), [o, i];
}
function Br(t) {
  t.forEach((e) => {
    const n = e.matrix;
    n && (e.matrix = Ut(n, 3, 4));
  });
}
function fu(t) {
  let e = t.parentElement, n = !1;
  const r = fe(t);
  for (; e; ) {
    const s = vs(e).transform;
    if (s && s !== "none") {
      n = !0;
      break;
    }
    if (e === r)
      break;
    e = e.parentElement;
  }
  return {
    fixedContainer: e || r,
    hasTransform: n
  };
}
function Jn(t, e = t.length > 9) {
  return `${e ? "matrix3d" : "matrix"}(${ei(t, !e).join(",")})`;
}
function gs(t) {
  const e = t.clientWidth, n = t.clientHeight;
  if (!t)
    return { x: 0, y: 0, width: 0, height: 0, clientWidth: e, clientHeight: n };
  const r = t.viewBox, s = r && r.baseVal || {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
  return {
    x: s.x,
    y: s.y,
    width: s.width || e,
    height: s.height || n,
    clientWidth: e,
    clientHeight: n
  };
}
function du(t, e) {
  const {
    width: n,
    height: r,
    clientWidth: s,
    clientHeight: o
  } = gs(t), i = s / n, a = o / r, c = t.preserveAspectRatio.baseVal, l = c.align, u = c.meetOrSlice, f = [0, 0], d = [i, a], p = [0, 0];
  if (l !== 1) {
    const h = (l - 2) % 3, v = Math.floor((l - 2) / 3);
    f[0] = n * h / 2, f[1] = r * v / 2;
    const m = u === 2 ? Math.max(a, i) : Math.min(i, a);
    d[0] = m, d[1] = m, p[0] = (s - n) / 2 * h, p[1] = (o - r) / 2 * v;
  }
  const g = rs(d, e);
  return [g[e * (e - 1)], g[e * (e - 1) + 1]] = p, en(g, e, f);
}
function pu(t, e, n) {
  const r = t.tagName.toLowerCase();
  if (!t.getBBox || !n && r === "g")
    return [0, 0, 0, 0];
  const o = Gt(t)("transform-box") === "fill-box", i = t.getBBox(), a = gs(t.ownerSVGElement);
  let c = i.x, l = i.y;
  r === "foreignobject" && !c && !l && (c = parseFloat(t.getAttribute("x")) || 0, l = parseFloat(t.getAttribute("y")) || 0);
  const u = c - a.x, f = l - a.y, d = o ? e[0] : e[0] - u, p = o ? e[1] : e[1] - f;
  return [u, f, d, p];
}
function ht(t, e, n) {
  return _t(t, Ee(e, n), n);
}
function Me(t, e, n, r) {
  return [
    [0, 0],
    [e, 0],
    [0, n],
    [e, n]
  ].map((s) => ht(t, s, r));
}
function Yt(t) {
  const e = t.map((l) => l[0]), n = t.map((l) => l[1]), r = Math.min(...e), s = Math.min(...n), o = Math.max(...e), i = Math.max(...n), a = o - r, c = i - s;
  return {
    left: r,
    top: s,
    right: o,
    bottom: i,
    width: a,
    height: c
  };
}
function co(t, e, n, r) {
  const s = Me(t, e, n, r);
  return Yt(s);
}
function gu(t, e, n, r, s) {
  const o = t.target, i = t.origin, a = e.matrix, { offsetWidth: c, offsetHeight: l } = ki(o), u = n.getBoundingClientRect();
  let f = [0, 0];
  n === fe(n) && (f = Ai(o, !0));
  const d = o.getBoundingClientRect(), p = d.left - u.left + n.scrollLeft - (n.clientLeft || 0) + f[0], g = d.top - u.top + n.scrollTop - (n.clientTop || 0) + f[1], h = d.width, v = d.height, m = An(r, s, a), {
    left: S,
    top: x,
    width: C,
    height: E
  } = co(m, c, l, r), D = ht(m, i, r), R = K(D, [S, x]), y = [
    p + R[0] * h / C,
    g + R[1] * v / E
  ], M = [0, 0];
  let P = 0;
  for (; ++P < 10; ) {
    const _ = Jt(s, r);
    [M[0], M[1]] = K(
      ht(_, y, r),
      ht(_, D, r)
    );
    const O = An(
      r,
      s,
      Ce(M, r),
      a
    ), { left: T, top: w } = co(
      O,
      c,
      l,
      r
    ), k = T - p, I = w - g;
    if (B(k) < 2 && B(I) < 2)
      break;
    y[0] -= k, y[1] -= I;
  }
  return M.map((_) => Math.round(_));
}
function hu(t, e, n) {
  const s = t.length === 16 ? 4 : 3, o = e.map((c) => ht(t, c, s)), { left: i, top: a } = n;
  return o.map((c) => [c[0] + i, c[1] + a]);
}
function Vt(t) {
  return Math.sqrt(t[0] * t[0] + t[1] * t[1]);
}
function Gi(t, e) {
  return Vt([e[0] - t[0], e[1] - t[1]]);
}
function Je(t, e, n = 1, r = xt(t, e)) {
  const s = Gi(t, e);
  return {
    transform: `translateY(-50%) translate(${t[0]}px, ${t[1]}px) rotate(${r}rad) scaleY(${n})`,
    width: `${s}px`
  };
}
function Nn(t, e, ...n) {
  const r = n.length, s = n.reduce((i, a) => i + a[0], 0) / r, o = n.reduce((i, a) => i + a[1], 0) / r;
  return {
    transform: `translateZ(0px) translate(${s}px, ${o}px) rotate(${t}rad) scale(${e})`
  };
}
function De(t, e) {
  const n = t[e];
  return qt(n) ? {
    ...t,
    ...n
  } : t;
}
function ki(t) {
  const e = t && !Kr(t.offsetWidth);
  let n = 0, r = 0, s = 0, o = 0, i = 0, a = 0, c = 0, l = 0, u = 0, f = 0, d = 0, p = 0, g = 1 / 0, h = 1 / 0, v = 1 / 0, m = 1 / 0, S = 0, x = 0, C = !1;
  if (t)
    if (!e && t.ownerSVGElement) {
      const E = t.getBBox();
      C = !0, n = E.width, r = E.height, i = n, a = r, c = n, l = r, s = n, o = r;
    } else {
      const E = Gt(t), D = t.style, R = E("boxSizing") === "border-box", y = parseFloat(E("borderLeftWidth")) || 0, M = parseFloat(E("borderRightWidth")) || 0, P = parseFloat(E("borderTopWidth")) || 0, _ = parseFloat(E("borderBottomWidth")) || 0, O = parseFloat(E("paddingLeft")) || 0, T = parseFloat(E("paddingRight")) || 0, w = parseFloat(E("paddingTop")) || 0, k = parseFloat(E("paddingBottom")) || 0, I = O + T, $ = w + k, G = y + M, L = P + _, z = I + G, N = $ + L, Z = E("position");
      let Y = 0, W = 0;
      if ("clientLeft" in t) {
        let J = null;
        if (Z === "absolute" ? J = fn(t, fe(t)).offsetParent : J = t.parentElement, J) {
          const q = Gt(J);
          Y = parseFloat(q("width")), W = parseFloat(q("height"));
        }
      }
      u = Math.max(
        I,
        ft(E("minWidth"), Y) || 0
      ), f = Math.max(
        $,
        ft(E("minHeight"), W) || 0
      ), g = ft(E("maxWidth"), Y), h = ft(E("maxHeight"), W), isNaN(g) && (g = 1 / 0), isNaN(h) && (h = 1 / 0), S = ft(D.width, 0) || 0, x = ft(D.height, 0) || 0, i = parseFloat(E("width")) || 0, a = parseFloat(E("height")) || 0, c = B(i - S) < 1 ? br(u, S || i, g) : i, l = B(a - x) < 1 ? br(f, x || a, h) : a, n = c, r = l, s = c, o = l, R ? (v = g, m = h, d = u, p = f, c = n - z, l = r - N) : (v = g + z, m = h + N, d = u + z, p = f + N, n = c + z, r = l + N), s = c + I, o = l + $;
    }
  return {
    svg: C,
    offsetWidth: n,
    offsetHeight: r,
    clientWidth: s,
    clientHeight: o,
    contentWidth: c,
    contentHeight: l,
    inlineCSSWidth: S,
    inlineCSSHeight: x,
    cssWidth: i,
    cssHeight: a,
    minWidth: u,
    minHeight: f,
    maxWidth: g,
    maxHeight: h,
    minOffsetWidth: d,
    minOffsetHeight: p,
    maxOffsetWidth: v,
    maxOffsetHeight: m
  };
}
function $i(t, e) {
  return xt(
    e > 0 ? t[0] : t[1],
    e > 0 ? t[1] : t[0]
  );
}
function Rn() {
  return {
    left: 0,
    top: 0,
    width: 0,
    height: 0,
    right: 0,
    bottom: 0,
    clientLeft: 0,
    clientTop: 0,
    clientWidth: 0,
    clientHeight: 0,
    scrollWidth: 0,
    scrollHeight: 0
  };
}
function Fi(t, e) {
  const n = t === fe(t) || t === es(t), r = {
    clientLeft: t.clientLeft,
    clientTop: t.clientTop,
    clientWidth: t.clientWidth,
    clientHeight: t.clientHeight,
    scrollWidth: t.scrollWidth,
    scrollHeight: t.scrollHeight,
    overflow: !1
  };
  return n && (r.clientHeight = Math.max(e.height, r.clientHeight), r.scrollHeight = Math.max(e.height, r.scrollHeight)), r.overflow = Gt(t)("overflow") !== "visible", {
    ...e,
    ...r
  };
}
function pr(t, e, n, r) {
  const { left: s, right: o, top: i, bottom: a } = t, c = e.top, l = e.left, u = {
    left: l + s,
    top: c + i,
    right: l + o,
    bottom: c + a,
    width: o - s,
    height: a - i
  };
  return n && r ? Fi(n, u) : u;
}
function nn(t, e) {
  let n = 0, r = 0, s = 0, o = 0;
  if (t) {
    const a = t.getBoundingClientRect();
    n = a.left, r = a.top, s = a.width, o = a.height;
  }
  const i = {
    left: n,
    top: r,
    width: s,
    height: o,
    right: n + s,
    bottom: r + o
  };
  return t && e ? Fi(t, i) : i;
}
function vu(t) {
  const { groupable: e, svgOrigin: n } = t.props, { offsetWidth: r, offsetHeight: s, svg: o, transformOrigin: i } = t.getState();
  return !e && o && n ? Es(n, r, s) : i;
}
function Li(t, e, n, r) {
  let s;
  if (t)
    s = t;
  else if (e)
    s = [0, 0];
  else {
    const o = n.target;
    s = Ni(o, r);
  }
  return s;
}
function Ni(t, e) {
  if (!t)
    return;
  const n = t.getAttribute("data-rotation") || "", r = t.getAttribute("data-direction");
  if (e.deg = n, !r)
    return;
  const s = [0, 0];
  return r.indexOf("w") > -1 && (s[0] = -1), r.indexOf("e") > -1 && (s[0] = 1), r.indexOf("n") > -1 && (s[1] = -1), r.indexOf("s") > -1 && (s[1] = 1), s;
}
function hs(t, e) {
  return [
    at(e, t[0]),
    at(e, t[1]),
    at(e, t[2]),
    at(e, t[3])
  ];
}
function jt({
  left: t,
  top: e,
  pos1: n,
  pos2: r,
  pos3: s,
  pos4: o
}) {
  return hs([n, r, s, o], [t, e]);
}
function zr(t, e) {
  t[e ? "controlAbles" : "targetAbles"].forEach((n) => {
    n.unset && n.unset(t);
  });
}
function ze(t, e) {
  const n = e ? "controlGesto" : "targetGesto", r = t[n];
  (r == null ? void 0 : r.isIdle()) === !1 && zr(t, e), r == null || r.unset(), t[n] = null;
}
function It(t, e) {
  if (e) {
    const n = je(e);
    n.nextStyle = {
      ...n.nextStyle,
      ...t
    };
  }
  return {
    style: t,
    cssText: Ve(t).map((n) => `${Sc(n, "-")}: ${t[n]};`).join("")
  };
}
function Wi(t, e, n) {
  const r = e.afterTransform || e.transform;
  return {
    ...It(
      {
        ...t.style,
        ...e.style,
        transform: r
      },
      n
    ),
    afterTransform: r,
    transform: t.transform
  };
}
function et(t, e, n, r) {
  const s = e.datas;
  s.datas || (s.datas = {});
  const o = {
    ...n,
    target: t.state.target,
    clientX: e.clientX,
    clientY: e.clientY,
    inputEvent: e.inputEvent,
    currentTarget: t,
    moveable: t,
    datas: s.datas,
    isRequest: e.isRequest,
    isRequestChild: e.isRequestChild,
    isFirstDrag: !!e.isFirstDrag,
    isTrusted: e.isTrusted !== !1,
    stopAble() {
      s.isEventStart = !1;
    },
    stopDrag() {
      var i;
      (i = e.stop) == null || i.call(e);
    }
  };
  return s.isStartEvent ? r || (s.lastEvent = o) : s.isStartEvent = !0, o;
}
function $t(t, e, n) {
  const r = e.datas, s = "isDrag" in n ? n.isDrag : e.isDrag;
  return r.datas || (r.datas = {}), {
    isDrag: s,
    ...n,
    moveable: t,
    target: t.state.target,
    clientX: e.clientX,
    clientY: e.clientY,
    inputEvent: e.inputEvent,
    currentTarget: t,
    lastEvent: r.lastEvent,
    isDouble: e.isDouble,
    datas: r.datas,
    isFirstDrag: !!e.isFirstDrag
  };
}
function Qn(t, e, n) {
  t._emitter.on(e, n);
}
function j(t, e, n, r, s) {
  return t.triggerEvent(e, n, r, s);
}
function vs(t, e) {
  return ae(t).getComputedStyle(t, e);
}
function Mn(t, e, n) {
  const r = {}, s = {};
  return t.filter((o) => {
    const i = o.name;
    if (r[i] || !e.some((a) => o[a]))
      return !1;
    if (!n && o.ableGroup) {
      if (s[o.ableGroup])
        return !1;
      s[o.ableGroup] = !0;
    }
    return r[i] = !0, !0;
  });
}
function Ar(t, e) {
  return t === e || t == null && e == null;
}
function lo(...t) {
  const e = t.length - 1;
  for (let n = 0; n < e; ++n) {
    const r = t[n];
    if (!Kr(r))
      return r;
  }
  return t[e];
}
function Yi(t, e) {
  const n = [], r = [];
  return t.forEach((s, o) => {
    const i = e(s, o, t), a = r.indexOf(i), c = n[a] || [];
    a === -1 && (r.push(i), n.push(c)), c.push(s);
  }), n;
}
function mu(t, e) {
  const n = [], r = {};
  return t.forEach((s, o) => {
    const i = e(s, o, t);
    let a = r[i];
    a || (a = [], r[i] = a, n.push(a)), a.push(s);
  }), n;
}
function Vi(t) {
  return t.reduce((e, n) => e.concat(n), []);
}
function Ne(...t) {
  return t.sort((e, n) => B(n) - B(e)), t[0];
}
function We(t, e, n) {
  return _t(Jt(t, n), Ee(e, n), n);
}
function xu(t, e) {
  const { is3d: n, rootMatrix: r } = t, s = n ? 4 : 3;
  return [e.distX, e.distY] = We(
    r,
    [e.distX, e.distY],
    s
  ), e;
}
function Wt(t, e, n, r) {
  if (!n[0] && !n[1])
    return e;
  const s = ht(t, [oo(n[0] || 1), 0], r), o = ht(t, [0, oo(n[1] || 1)], r), i = ht(
    t,
    [n[0] / Vt(s), n[1] / Vt(o)],
    r
  );
  return at(e, i);
}
function Xt(t, e, n) {
  return n ? `${t / e * 100}%` : `${t}px`;
}
function Wn(t) {
  return B(t) <= Bt ? 0 : t;
}
function ms(t) {
  return (e) => {
    if (!e.isDragging(t))
      return "";
    const r = Kc(e, t).deg;
    return r ? U(`view-control-rotation${r}`) : "";
  };
}
function xs(t, e = [t]) {
  return (n, r) => {
    if (r.isRequest)
      return e.some((o) => r.requestAble === o) ? r.parentDirection : !1;
    const s = r.inputEvent.target;
    return bt(s, U("direction")) && (!t || bt(s, U(t)));
  };
}
function Su(t, e, n) {
  const r = $e(t, {
    "x%": (C) => C / 100 * e.offsetWidth,
    "y%": (C) => C / 100 * e.offsetHeight
  }), s = t.slice(
    0,
    n < 0 ? void 0 : n
  ), o = t.slice(
    0,
    n < 0 ? void 0 : n + 1
  ), i = t[n] || "", a = n < 0 ? [] : t.slice(n), c = n < 0 ? [] : t.slice(n + 1), l = r.slice(0, n < 0 ? void 0 : n), u = r.slice(
    0,
    n < 0 ? void 0 : n + 1
  ), f = r[n] ?? $e([""])[0], d = n < 0 ? [] : r.slice(n), p = n < 0 ? [] : r.slice(n + 1), g = f ? [f] : [], h = we(l), v = we(u), m = we(d), S = we(p), x = dt(
    h,
    m,
    4
  );
  return {
    transforms: t,
    beforeFunctionMatrix: h,
    beforeFunctionMatrix2: v,
    targetFunctionMatrix: we(g),
    afterFunctionMatrix: m,
    afterFunctionMatrix2: S,
    allFunctionMatrix: x,
    beforeFunctions: l,
    beforeFunctions2: u,
    targetFunction: g[0],
    afterFunctions: d,
    afterFunctions2: p,
    beforeFunctionTexts: s,
    beforeFunctionTexts2: o,
    targetFunctionText: i,
    afterFunctionTexts: a,
    afterFunctionTexts2: c
  };
}
function Eu(t) {
  return !t || !qt(t) || ns(t) ? !1 : Rt(t) || "length" in t;
}
function Zt(t, e) {
  return t ? ns(t) ? t : re(t) ? e ? document.querySelector(t) : t : Zr(t) ? t() : Jo(t) ? t : "current" in t ? t.current : t : null;
}
function Ss(t, e) {
  return t ? (Eu(t) ? [].slice.call(t) : [t]).reduce((r, s) => re(s) && e ? [
    ...r,
    ...[].slice.call(document.querySelectorAll(s))
  ] : (Rt(s) ? r.push(Ss(s, e)) : r.push(Zt(s, e)), r), []) : [];
}
function Cu(t, e, n) {
  let r = xt(t, e) / Math.PI * 180;
  return r = n >= 0 ? r : 180 - r, r = r >= 0 ? r : 360 + r, r;
}
function uo(t, e) {
  const { rootMatrix: n, is3d: r } = t;
  let o = Jt(n, r ? 4 : 3);
  return r || (o = Ut(o, 3, 4)), o[12] = 0, o[13] = 0, o[14] = 0, Ac(o, e);
}
function ji(t, e, n, r, s) {
  const [o, i] = t;
  let a = 0, c = 0;
  if (s && o && i) {
    const l = xt([0, 0], e), u = xt([0, 0], r), f = Vt(e), d = Math.cos(l - u) * f;
    if (!r[0])
      c = d, a = c * n;
    else if (!r[1])
      a = d, c = a / n;
    else {
      const p = r[0] * o, g = r[1] * i;
      let h = Math.atan2(
        p + e[0],
        g + e[1]
      ), v = Math.atan2(p, g);
      h < 0 && (h += Math.PI * 2), v < 0 && (v += Math.PI * 2);
      let m = 0;
      B(h - v) < Math.PI / 2 || B(h - v) > Math.PI / 2 * 3 || (v += Math.PI), m = h - v, m > Math.PI * 2 ? m -= Math.PI * 2 : m > Math.PI ? m = 2 * Math.PI - m : m < -Math.PI && (m = -2 * Math.PI - m);
      const S = Vt([p + e[0], g + e[1]]) * Math.cos(m);
      a = S * Math.sin(v) - p, c = S * Math.cos(v) - g, r[0] < 0 && (a *= -1), r[1] < 0 && (c *= -1);
    }
  } else
    a = r[0] * e[0], c = r[1] * e[1];
  return [a, c];
}
function Xi(t, e, n, r) {
  const { ratio: s, startOffsetWidth: o, startOffsetHeight: i } = n;
  let a = 0, c = 0;
  const { distX: l, distY: u, pinchScale: f, parentDistance: d, parentDist: p, parentScale: g } = r, h = n.fixedDirection, v = [0, 1].map((S) => B(t[S] - h[S])), m = [0, 1].map((S) => {
    let x = v[S];
    return x !== 0 && (x = 2 / x), x;
  });
  if (p)
    a = p[0], c = p[1], e && (a ? c || (c = a / s) : a = c * s);
  else if (an(f))
    a = (f - 1) * o, c = (f - 1) * i;
  else if (g)
    a = (g[0] - 1) * o, c = (g[1] - 1) * i;
  else if (d) {
    const S = o * v[0], x = i * v[1], C = Vt([S, x]);
    a = d / C * S * m[0], c = d / C * x * m[1];
  } else {
    let S = Qt({ datas: n, distX: l, distY: u });
    S = m.map((x, C) => S[C] * x), [a, c] = ji(
      [o, i],
      S,
      s,
      t,
      e
    );
  }
  return {
    // direction,
    // sizeDirection,
    distWidth: a,
    distHeight: c
  };
}
function Gr(t, e) {
  if (e) {
    if (t === "left")
      return { x: "0%", y: "50%" };
    if (t === "top")
      return { x: "50%", y: "50%" };
    if (t === "center")
      return { x: "50%", y: "50%" };
    if (t === "right")
      return { x: "100%", y: "50%" };
    if (t === "bottom")
      return { x: "50%", y: "100%" };
    const [n, r] = t.split(" "), s = Gr(n || ""), o = Gr(r || ""), i = {
      ...s,
      ...o
    }, a = {
      x: "50%",
      y: "50%"
    };
    return i.x && (a.x = i.x), i.y && (a.y = i.y), i.value && (i.x && !i.y && (a.y = i.value), !i.x && i.y && (a.x = i.value)), a;
  }
  return t === "left" ? { x: "0%" } : t === "right" ? { x: "100%" } : t === "top" ? { y: "0%" } : t === "bottom" ? { y: "100%" } : t ? t === "center" ? { value: "50%" } : { value: t } : {};
}
function Es(t, e, n) {
  const { x: r, y: s } = Gr(t, !0);
  return [ft(r, e) || 0, ft(s, n) || 0];
}
function Du(t, e, n) {
  const r = t.map((o) => K(o, e)), s = r.map((o) => gn(o, n));
  return {
    prev: r,
    next: s,
    result: s.map((o) => at(o, e))
  };
}
function Hi(t, e) {
  return t.length === e.length && t.every((n, r) => {
    const s = e[r], o = Rt(n), i = Rt(s);
    return o && i ? Hi(n, s) : !o && !i ? n === s : !1;
  });
}
function Ae(t, e, n, r, s) {
  const o = t._store;
  let i = o[e];
  if (!(e in o))
    if (s != null)
      o[e] = s, i = s;
    else
      return o[e] = n, n;
  return i === n || r(i) === r(n) ? i : (o[e] = n, n);
}
function wt(t) {
  return t >= 0 ? 1 : -1;
}
function B(t) {
  return Math.abs(t);
}
function gr(t, e) {
  return bc(t).map((n) => e(n));
}
function qi(t) {
  return an(t) ? {
    top: t,
    left: t,
    right: t,
    bottom: t
  } : {
    left: t.left || 0,
    top: t.top || 0,
    right: t.right || 0,
    bottom: t.bottom || 0
  };
}
const bu = dn("pinchable", {
  props: [
    "pinchable"
  ],
  events: [
    "pinchStart",
    "pinch",
    "pinchEnd",
    "pinchGroupStart",
    "pinchGroup",
    "pinchGroupEnd"
  ],
  dragStart() {
    return !0;
  },
  pinchStart(t, e) {
    const { datas: n, targets: r, angle: s, originalDatas: o } = e, { pinchable: i, ables: a } = t.props;
    if (!i)
      return !1;
    const c = `onPinch${r ? "Group" : ""}Start`, l = `drag${r ? "Group" : ""}ControlStart`, u = (i === !0 ? t.controlAbles : a.filter((g) => i.indexOf(g.name) > -1)).filter((g) => g.canPinch && g[l]), f = et(t, e, {});
    r && (f.targets = r);
    const d = j(t, c, f);
    n.isPinch = d !== !1, n.ables = u;
    const p = n.isPinch;
    return p ? (u.forEach((g) => {
      if (o[g.name] = o[g.name] || {}, !g[l])
        return;
      const h = {
        ...e,
        datas: o[g.name],
        parentRotate: s,
        isPinch: !0
      };
      g[l](t, h);
    }), t.state.snapRenderInfo = {
      request: e.isRequest,
      direction: [0, 0]
    }, p) : !1;
  },
  pinch(t, e) {
    const {
      datas: n,
      scale: r,
      distance: s,
      originalDatas: o,
      inputEvent: i,
      targets: a,
      angle: c
    } = e;
    if (!n.isPinch)
      return;
    const l = s * (1 - 1 / r), u = et(t, e, {});
    a && (u.targets = a), j(t, `onPinch${a ? "Group" : ""}`, u);
    const d = n.ables, p = `drag${a ? "Group" : ""}Control`;
    return d.forEach((g) => {
      g[p] && g[p](t, {
        ...e,
        datas: o[g.name],
        inputEvent: i,
        resolveMatrix: !0,
        pinchScale: r,
        parentDistance: l,
        parentRotate: c,
        isPinch: !0
      });
    }), u;
  },
  pinchEnd(t, e) {
    const { datas: n, isPinch: r, inputEvent: s, targets: o, originalDatas: i } = e;
    if (!n.isPinch)
      return;
    const a = `onPinch${o ? "Group" : ""}End`, c = $t(t, e, { isDrag: r });
    o && (c.targets = o), j(t, a, c);
    const l = n.ables, u = `drag${o ? "Group" : ""}ControlEnd`;
    return l.forEach((f) => {
      f[u] && f[u](t, {
        ...e,
        isDrag: r,
        datas: i[f.name],
        inputEvent: s,
        isPinch: !0
      });
    }), r;
  },
  pinchGroupStart(t, e) {
    return this.pinchStart(t, { ...e, targets: t.props.targets });
  },
  pinchGroup(t, e) {
    return this.pinch(t, { ...e, targets: t.props.targets });
  },
  pinchGroupEnd(t, e) {
    return this.pinchEnd(t, { ...e, targets: t.props.targets });
  }
}), fo = xs("scalable"), yu = {
  name: "scalable",
  ableGroup: "size",
  canPinch: !0,
  props: [
    "scalable",
    "throttleScale",
    "renderDirections",
    "keepRatio",
    "edge",
    "displayAroundControls"
  ],
  events: [
    "scaleStart",
    "beforeScale",
    "scale",
    "scaleEnd",
    "scaleGroupStart",
    "beforeScaleGroup",
    "scaleGroup",
    "scaleGroupEnd"
  ],
  render: di("scalable"),
  dragControlCondition: fo,
  viewClassName: ms("scalable"),
  dragControlStart(t, e) {
    const { datas: n, isPinch: r, inputEvent: s, parentDirection: o } = e, i = Li(
      o,
      r,
      s,
      n
    ), { width: a, height: c, targetTransform: l, target: u, pos1: f, pos2: d, pos4: p } = t.state;
    if (!i || !u)
      return !1;
    r || Re(t, e), n.datas = {}, n.transform = l, n.prevDist = [1, 1], n.direction = i, n.startOffsetWidth = a, n.startOffsetHeight = c, n.startValue = [1, 1];
    const g = !i[0] && !i[1] || i[0] || !i[1];
    qn(t, e, "scale"), n.isWidth = g;
    function h(E) {
      n.ratio = E && isFinite(E) ? E : 0;
    }
    n.startPositions = jt(t.state);
    function v(E) {
      const D = yi(
        n.startPositions,
        E
      );
      n.fixedDirection = D.fixedDirection, n.fixedPosition = D.fixedPosition, n.fixedOffset = D.fixedOffset;
    }
    n.setFixedDirection = v, h(te(f, d) / te(d, p)), v([-i[0], -i[1]]);
    const m = (E) => {
      n.minScaleSize = E;
    }, S = (E) => {
      n.maxScaleSize = E;
    };
    m([-1 / 0, -1 / 0]), S([1 / 0, 1 / 0]);
    const x = et(t, e, {
      direction: i,
      set: (E) => {
        n.startValue = E;
      },
      setRatio: h,
      setFixedDirection: v,
      setMinScaleSize: m,
      setMaxScaleSize: S,
      ...Hn(t, e),
      dragStart: Ot.dragStart(
        t,
        new Fe().dragStart([0, 0], e)
      )
    }), C = j(t, "onScaleStart", x);
    return n.startFixedDirection = n.fixedDirection, C !== !1 && (n.isScale = !0, t.state.snapRenderInfo = {
      request: e.isRequest,
      direction: i
    }), n.isScale ? x : !1;
  },
  dragControl(t, e) {
    jn(t, e, "scale");
    const {
      datas: n,
      parentKeepRatio: r,
      parentFlag: s,
      isPinch: o,
      dragClient: i,
      isRequest: a,
      useSnap: c,
      resolveMatrix: l
    } = e, {
      prevDist: u,
      direction: f,
      startOffsetWidth: d,
      startOffsetHeight: p,
      isScale: g,
      startValue: h,
      isWidth: v,
      ratio: m
    } = n;
    if (!g)
      return !1;
    const S = t.props, { throttleScale: x, parentMoveable: C } = S;
    let E = f;
    !f[0] && !f[1] && (E = [1, 1]);
    const D = m && (r ?? S.keepRatio) || !1, R = t.state, y = [h[0], h[1]];
    function M() {
      const { distWidth: q, distHeight: F } = Xi(
        E,
        D,
        n,
        e
      ), H = d ? (d + q) / d : 1, nt = p ? (p + F) / p : 1;
      h[0] || (y[0] = q / d), h[1] || (y[1] = F / p);
      let lt = (E[0] || D ? H : 1) * y[0], vt = (E[1] || D ? nt : 1) * y[1];
      return lt === 0 && (lt = wt(u[0]) * Sn), vt === 0 && (vt = wt(u[1]) * Sn), [lt, vt];
    }
    let P = M();
    if (!o && t.props.groupable) {
      const F = (R.snapRenderInfo || {}).direction;
      Rt(F) && (F[0] || F[1]) && (R.snapRenderInfo = { direction: f, request: e.isRequest });
    }
    j(
      t,
      "onBeforeScale",
      et(
        t,
        e,
        {
          scale: P,
          setFixedDirection(q) {
            return n.setFixedDirection(q), P = M(), P;
          },
          startFixedDirection: n.startFixedDirection,
          setScale(q) {
            P = q;
          }
        },
        !0
      )
    );
    let _ = [P[0] / y[0], P[1] / y[1]], O = i, T = [0, 0];
    const w = wt(_[0] * _[1]), k = !i && !s && o;
    if (k || l ? O = is(
      t,
      n.targetAllTransform,
      [0, 0],
      [0, 0],
      n
    ) : i || (O = n.fixedPosition), o || (T = eu(
      t,
      _,
      f,
      !c && a,
      n
    )), D) {
      E[0] && E[1] && T[0] && T[1] && (Math.abs(T[0] * d) > Math.abs(T[1] * p) ? T[1] = 0 : T[0] = 0);
      const q = !T[0] && !T[1];
      if (q && (v ? _[0] = tt(_[0] * y[0], x) / y[0] : _[1] = tt(_[1] * y[1], x) / y[1]), E[0] && !E[1] || T[0] && !T[1] || q && v) {
        _[0] += T[0];
        const F = d * _[0] * y[0] / m;
        _[1] = wt(w * _[0]) * B(F / p / y[1]);
      } else if (!E[0] && E[1] || !T[0] && T[1] || q && !v) {
        _[1] += T[1];
        const F = p * _[1] * y[1] * m;
        _[0] = wt(w * _[1]) * B(F / d / y[0]);
      }
    } else
      _[0] += T[0], _[1] += T[1], T[0] || (_[0] = tt(_[0] * y[0], x) / y[0]), T[1] || (_[1] = tt(_[1] * y[1], x) / y[1]);
    _[0] === 0 && (_[0] = wt(u[0]) * Sn), _[1] === 0 && (_[1] = wt(u[1]) * Sn), P = ou(_, [y[0], y[1]]);
    const I = [d, p];
    let $ = [d * P[0], p * P[1]];
    $ = qo(
      $,
      n.minScaleSize,
      n.maxScaleSize,
      D ? m : !1
    ), P = gr(2, (q) => I[q] ? $[q] / I[q] : $[q]), _ = gr(2, (q) => P[q] / y[q]);
    const G = gr(
      2,
      (q) => u[q] ? _[q] / u[q] : _[q]
    ), L = `scale(${_.join(", ")})`, z = `scale(${P.join(", ")})`, N = Xn(n, z, L), Z = !h[0] || !h[1], Y = Vc(
      t,
      Z ? z : L,
      n.fixedDirection,
      O,
      n.fixedOffset,
      n,
      Z
    ), W = k ? Y : K(Y, n.prevInverseDist || [0, 0]);
    if (n.prevDist = _, n.prevInverseDist = Y, P[0] === u[0] && P[1] === u[1] && W.every((q) => !q) && !C && !k)
      return !1;
    const J = et(t, e, {
      offsetWidth: d,
      offsetHeight: p,
      direction: f,
      scale: P,
      dist: _,
      delta: G,
      isPinch: !!o,
      ...ii(t, N, W, o, e)
    });
    return j(t, "onScale", J), J;
  },
  dragControlEnd(t, e) {
    const { datas: n } = e;
    if (!n.isScale)
      return !1;
    n.isScale = !1;
    const r = $t(t, e, {});
    return j(t, "onScaleEnd", r), r;
  },
  dragGroupControlCondition: fo,
  dragGroupControlStart(t, e) {
    const { datas: n } = e, r = this.dragControlStart(t, e);
    if (!r)
      return !1;
    const s = Ht(t, "resizable", e);
    n.moveableScale = t.scale;
    const o = ee(
      t,
      this,
      "dragControlStart",
      e,
      (l, u) => kn(t, l, n, u)
    ), i = (l) => {
      r.setFixedDirection(l), o.forEach((u, f) => {
        u.setFixedDirection(l), kn(t, u.moveable, n, s[f]);
      });
    };
    n.setFixedDirection = i;
    const a = {
      ...r,
      targets: t.props.targets,
      events: o,
      setFixedDirection: i
    }, c = j(t, "onScaleGroupStart", a);
    return n.isScale = c !== !1, n.isScale ? a : !1;
  },
  dragGroupControl(t, e) {
    const { datas: n } = e;
    if (!n.isScale)
      return;
    Qn(t, "onBeforeScale", (u) => {
      j(
        t,
        "onBeforeScaleGroup",
        et(
          t,
          e,
          {
            ...u,
            targets: t.props.targets
          },
          !0
        )
      );
    });
    const r = this.dragControl(t, e);
    if (!r)
      return;
    const { dist: s } = r, o = n.moveableScale;
    t.scale = [s[0] * o[0], s[1] * o[1]];
    const i = t.props.keepRatio, a = n.fixedPosition, c = ee(
      t,
      this,
      "dragControl",
      e,
      (u, f) => {
        const [d, p] = _t(
          hn(t.rotation / 180 * Math.PI, 3),
          [f.datas.originalX * s[0], f.datas.originalY * s[1], 1],
          3
        );
        return {
          ...f,
          parentDist: null,
          parentScale: s,
          parentKeepRatio: i,
          // recalculate child fixed position for parent group's dragging.
          dragClient: at(a, [d, p])
        };
      }
    ), l = {
      targets: t.props.targets,
      events: c,
      ...r
    };
    return j(t, "onScaleGroup", l), l;
  },
  dragGroupControlEnd(t, e) {
    const { isDrag: n, datas: r } = e;
    if (!r.isScale)
      return;
    this.dragControlEnd(t, e);
    const s = ee(t, this, "dragControlEnd", e), o = $t(t, e, {
      targets: t.props.targets,
      events: s
    });
    return j(t, "onScaleGroupEnd", o), n;
  },
  /**
       * @method Moveable.Scalable#request
       * @param {Moveable.Scalable.ScalableRequestParam} e - the Scalable's request parameter
       * @return {Moveable.Requester} Moveable Requester
       * @example
  
       * // Instantly Request (requestStart - request - requestEnd)
       * moveable.request("scalable", { deltaWidth: 10, deltaHeight: 10 }, true);
       *
       * // requestStart
       * const requester = moveable.request("scalable");
       *
       * // request
       * requester.request({ deltaWidth: 10, deltaHeight: 10 });
       * requester.request({ deltaWidth: 10, deltaHeight: 10 });
       * requester.request({ deltaWidth: 10, deltaHeight: 10 });
       *
       * // requestEnd
       * requester.requestEnd();
       */
  request() {
    const t = {};
    let e = 0, n = 0, r = !1;
    return {
      isControl: !0,
      requestStart(s) {
        return r = s.useSnap, {
          datas: t,
          parentDirection: s.direction || [1, 1],
          useSnap: r
        };
      },
      request(s) {
        return e += s.deltaWidth, n += s.deltaHeight, {
          datas: t,
          parentDist: [e, n],
          parentKeepRatio: s.keepRatio,
          useSnap: r
        };
      },
      requestEnd() {
        return { datas: t, isDrag: !0, useSnap: r };
      }
    };
  }
};
function se(t, e) {
  return t.map((n, r) => zn(n, e[r], 1, 2));
}
function po(t, e, n) {
  const r = xt(t, e), o = xt(t, n) - r;
  return o >= 0 ? o : o + 2 * Math.PI;
}
function Ru(t, e) {
  const n = po(t[0], t[1], t[2]), r = po(e[0], e[1], e[2]), s = Math.PI;
  return !(n >= s && r <= s || n <= s && r >= s);
}
const Mu = {
  name: "warpable",
  ableGroup: "size",
  props: [
    "warpable",
    "renderDirections",
    "edge",
    "displayAroundControls"
  ],
  events: ["warpStart", "warp", "warpEnd"],
  viewClassName: ms("warpable"),
  render(t, e) {
    const { resizable: n, scalable: r, warpable: s, zoom: o } = t.props;
    if (n || r || !s)
      return [];
    const { pos1: i, pos2: a, pos3: c, pos4: l } = t.state, u = se(i, a), f = se(a, i), d = se(i, c), p = se(c, i), g = se(c, l), h = se(l, c), v = se(a, l), m = se(l, a);
    return [
      /* @__PURE__ */ it.jsx(
        "div",
        {
          className: U("line"),
          style: Je(u, g, o)
        },
        "middeLine1"
      ),
      /* @__PURE__ */ it.jsx(
        "div",
        {
          className: U("line"),
          style: Je(f, h, o)
        },
        "middeLine2"
      ),
      /* @__PURE__ */ it.jsx(
        "div",
        {
          className: U("line"),
          style: Je(d, v, o)
        },
        "middeLine3"
      ),
      /* @__PURE__ */ it.jsx(
        "div",
        {
          className: U("line"),
          style: Je(p, m, o)
        },
        "middeLine4"
      ),
      ...pi(t, "warpable", e)
    ];
  },
  dragControlCondition(t, e) {
    if (e.isRequest)
      return !1;
    const n = e.inputEvent.target;
    return bt(n, U("direction")) && bt(n, U("warpable"));
  },
  dragControlStart(t, e) {
    const { datas: n, inputEvent: r } = e, { target: s } = t.props, { target: o } = r, i = Ni(o, n);
    if (!i || !s)
      return !1;
    const a = t.state, {
      transformOrigin: c,
      is3d: l,
      targetTransform: u,
      targetMatrix: f,
      width: d,
      height: p,
      left: g,
      top: h
    } = a;
    n.datas = {}, n.targetTransform = u, n.warpTargetMatrix = l ? f : Ut(f, 3, 4), n.targetInverseMatrix = Qo(
      Jt(n.warpTargetMatrix, 4),
      3,
      4
    ), n.direction = i, n.left = g, n.top = h, n.poses = [
      [0, 0],
      [d, 0],
      [0, p],
      [d, p]
    ].map((S) => K(S, c)), n.nextPoses = n.poses.map(
      ([S, x]) => _t(n.warpTargetMatrix, [S, x, 0, 1], 4)
    ), n.startValue = gt(4), n.prevMatrix = gt(4), n.absolutePoses = jt(a), n.posIndexes = oi(i), Re(t, e), qn(t, e, "matrix3d"), a.snapRenderInfo = {
      request: e.isRequest,
      direction: i
    };
    const v = et(t, e, {
      set: (S) => {
        n.startValue = S;
      },
      ...Hn(t, e)
    });
    return j(t, "onWarpStart", v) !== !1 && (n.isWarp = !0), n.isWarp;
  },
  dragControl(t, e) {
    const { datas: n, isRequest: r } = e;
    let { distX: s, distY: o } = e;
    const {
      targetInverseMatrix: i,
      prevMatrix: a,
      isWarp: c,
      startValue: l,
      poses: u,
      posIndexes: f,
      absolutePoses: d
    } = n;
    if (!c)
      return !1;
    if (jn(t, e, "matrix3d"), Xe(t, "warpable")) {
      const E = f.map(
        (y) => d[y]
      );
      E.length > 1 && E.push([
        (E[0][0] + E[1][0]) / 2,
        (E[0][1] + E[1][1]) / 2
      ]);
      const { horizontal: D, vertical: R } = Zn(t, r, {
        horizontal: E.map((y) => y[1] + o),
        vertical: E.map((y) => y[0] + s)
      });
      o -= D.offset, s -= R.offset;
    }
    const p = Qt({ datas: n, distX: s, distY: o }, !0), g = n.nextPoses.slice();
    if (f.forEach((E) => {
      g[E] = at(g[E], p);
    }), !ic.every(
      (E) => Ru(
        E.map((D) => u[D]),
        E.map((D) => g[D])
      )
    ))
      return !1;
    const h = ss(
      u[0],
      u[2],
      u[1],
      u[3],
      g[0],
      g[2],
      g[1],
      g[3]
    );
    if (!h.length)
      return !1;
    const v = dt(i, h, 4), m = ri(n, v, !0), S = dt(Jt(a, 4), m, 4);
    n.prevMatrix = m;
    const x = dt(l, m, 4), C = Xn(
      n,
      `matrix3d(${x.join(", ")})`,
      `matrix3d(${m.join(", ")})`
    );
    return os(e, C), j(
      t,
      "onWarp",
      et(t, e, {
        delta: S,
        matrix: x,
        dist: m,
        multiply: dt,
        transform: C,
        ...It(
          {
            transform: C
          },
          e
        )
      })
    ), !0;
  },
  dragControlEnd(t, e) {
    const { datas: n, isDrag: r } = e;
    return n.isWarp ? (n.isWarp = !1, j(
      t,
      "onWarpEnd",
      $t(t, e, {})
    ), r) : !1;
  }
}, Pu = /* @__PURE__ */ U("area-pieces"), Pn = /* @__PURE__ */ U("area-piece"), Ui = /* @__PURE__ */ U("avoid"), _u = U("view-dragging");
function hr(t) {
  const e = t.areaElement;
  if (!e)
    return;
  const { width: n, height: r } = t.state;
  Zo(e, Ui), e.style.cssText += `left: 0px; top: 0px; width: ${n}px; height: ${r}px`;
}
function go(t) {
  return /* @__PURE__ */ it.jsxs("div", { className: Pu, children: [
    /* @__PURE__ */ it.jsx("div", { className: Pn }),
    /* @__PURE__ */ it.jsx("div", { className: Pn }),
    /* @__PURE__ */ it.jsx("div", { className: Pn }),
    /* @__PURE__ */ it.jsx("div", { className: Pn })
  ] }, "area_pieces");
}
const Ki = {
  name: "dragArea",
  props: ["dragArea", "passDragArea"],
  events: ["click", "clickGroup"],
  render(t, e) {
    const { target: n, dragArea: r, groupable: s, passDragArea: o } = t.props, { width: i, height: a, renderPoses: c } = t.getState(), l = o ? U("area", "pass") : U("area");
    if (s)
      return [
        /* @__PURE__ */ it.jsx(
          "div",
          {
            ref: Se(t, "areaElement"),
            className: l
          },
          "area"
        ),
        go()
      ];
    if (!n || !r)
      return [];
    const u = ss(
      [0, 0],
      [i, 0],
      [0, a],
      [i, a],
      c[0],
      c[1],
      c[2],
      c[3]
    ), f = u.length ? Jn(u, !0) : "none";
    return [
      /* @__PURE__ */ it.jsx(
        "div",
        {
          ref: Se(t, "areaElement"),
          className: l,
          style: {
            top: "0px",
            left: "0px",
            width: `${i}px`,
            height: `${a}px`,
            transformOrigin: "0 0",
            transform: f
          }
        },
        "area"
      ),
      go()
    ];
  },
  dragStart(t, { datas: e, clientX: n, clientY: r, inputEvent: s }) {
    if (!s)
      return !1;
    e.isDragArea = !1;
    const o = t.areaElement, i = t.state, { moveableClientRect: a, renderPoses: c, rootMatrix: l, is3d: u } = i, { left: f, top: d } = a, {
      left: p,
      top: g,
      width: h,
      height: v
    } = Yt(c), m = u ? 4 : 3;
    let [S, x] = We(
      l,
      [n - f, r - d],
      m
    );
    S -= p, x -= g;
    const C = [
      { left: p, top: g, width: h, height: x - 10 },
      { left: p, top: g, width: S - 10, height: v },
      {
        left: p,
        top: g + x + 10,
        width: h,
        height: v - x - 10
      },
      {
        left: p + S + 10,
        top: g,
        width: h - S - 10,
        height: v
      }
    ], E = [].slice.call(
      o.nextElementSibling.children
    );
    C.forEach((D, R) => {
      E[R].style.cssText = `left: ${D.left}px;top: ${D.top}px; width: ${D.width}px; height: ${D.height}px;`;
    }), Ko(o, Ui), i.disableNativeEvent = !0;
  },
  drag(t, { datas: e, inputEvent: n }) {
    if (this.enableNativeEvent(t), !n)
      return !1;
    e.isDragArea || (e.isDragArea = !0, hr(t));
  },
  dragEnd(t, e) {
    this.enableNativeEvent(t);
    const { inputEvent: n, datas: r } = e;
    if (!n)
      return !1;
    r.isDragArea || hr(t);
  },
  dragGroupStart(t, e) {
    return this.dragStart(t, e);
  },
  dragGroup(t, e) {
    return this.drag(t, e);
  },
  dragGroupEnd(t, e) {
    return this.dragEnd(t, e);
  },
  unset(t) {
    hr(t), t.state.disableNativeEvent = !1;
  },
  enableNativeEvent(t) {
    const e = t.state;
    e.disableNativeEvent && Ho(() => {
      e.disableNativeEvent = !1;
    });
  }
}, Tu = dn("origin", {
  props: ["origin", "svgOrigin"],
  render(t, e) {
    const { zoom: n, svgOrigin: r, groupable: s } = t.props, {
      beforeOrigin: o,
      rotation: i,
      svg: a,
      allMatrix: c,
      is3d: l,
      left: u,
      top: f,
      offsetWidth: d,
      offsetHeight: p
    } = t.getState();
    let g;
    if (!s && a && r) {
      const [h, v] = Es(r, d, p), S = ht(
        c,
        [h, v],
        l ? 4 : 3
      );
      g = Nn(i, n, K(S, [u, f]));
    } else
      g = Nn(i, n, o);
    return [
      /* @__PURE__ */ it.jsx("div", { className: U("control", "origin"), style: g }, "beforeOrigin")
    ];
  }
});
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var kr = function() {
  return kr = Object.assign || function(e) {
    for (var n, r = 1, s = arguments.length; r < s; r++) {
      n = arguments[r];
      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, kr.apply(this, arguments);
};
function Ou() {
  for (var t = 0, e = 0, n = arguments.length; e < n; e++) t += arguments[e].length;
  for (var r = Array(t), s = 0, e = 0; e < n; e++) for (var o = arguments[e], i = 0, a = o.length; i < a; i++, s++) r[s] = o[i];
  return r;
}
var Cs = /* @__PURE__ */ function() {
  function t() {
    this._events = {};
  }
  var e = t.prototype;
  return e.on = function(n, r) {
    if (qt(n))
      for (var s in n)
        this.on(s, n[s]);
    else
      this._addEvent(n, r, {});
    return this;
  }, e.off = function(n, r) {
    if (!n)
      this._events = {};
    else if (qt(n))
      for (var s in n)
        this.off(s);
    else if (!r)
      this._events[n] = [];
    else {
      var o = this._events[n];
      if (o) {
        var i = ne(o, function(a) {
          return a.listener === r;
        });
        i > -1 && o.splice(i, 1);
      }
    }
    return this;
  }, e.once = function(n, r) {
    var s = this;
    return r && this._addEvent(n, r, {
      once: !0
    }), new Promise(function(o) {
      s._addEvent(n, o, {
        once: !0
      });
    });
  }, e.emit = function(n, r) {
    var s = this;
    r === void 0 && (r = {});
    var o = this._events[n];
    if (!n || !o)
      return !0;
    var i = !1;
    return r.eventType = n, r.stop = function() {
      i = !0;
    }, r.currentTarget = this, Ou(o).forEach(function(a) {
      a.listener(r), a.once && s.off(n, a.listener);
    }), !i;
  }, e.trigger = function(n, r) {
    return r === void 0 && (r = {}), this.emit(n, r);
  }, e._addEvent = function(n, r, s) {
    var o = this._events;
    o[n] = o[n] || [];
    var i = o[n];
    i.push(kr({
      listener: r
    }, s));
  }, t;
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var $r = function(t, e) {
  return $r = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var s in r) r.hasOwnProperty(s) && (n[s] = r[s]);
  }, $r(t, e);
};
function wu(t, e) {
  $r(t, e);
  function n() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());
}
var Ge = function() {
  return Ge = Object.assign || function(e) {
    for (var n, r = 1, s = arguments.length; r < s; r++) {
      n = arguments[r];
      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, Ge.apply(this, arguments);
};
function Iu(t) {
  var e = t.container;
  return e === document.body ? [e.scrollLeft || document.documentElement.scrollLeft, e.scrollTop || document.documentElement.scrollTop] : [e.scrollLeft, e.scrollTop];
}
function ho(t, e) {
  return t.addEventListener("scroll", e), function() {
    t.removeEventListener("scroll", e);
  };
}
function _n(t) {
  if (t) {
    if (re(t))
      return document.querySelector(t);
  } else return null;
  if (Zr(t))
    return t();
  if (t instanceof Element)
    return t;
  if ("current" in t)
    return t.current;
  if ("value" in t)
    return t.value;
}
var Bu = /* @__PURE__ */ function(t) {
  wu(e, t);
  function e() {
    var r = t !== null && t.apply(this, arguments) || this;
    return r._startRect = null, r._startPos = [], r._prevTime = 0, r._timer = 0, r._prevScrollPos = [0, 0], r._isWait = !1, r._flag = !1, r._currentOptions = null, r._lock = !1, r._unregister = null, r._onScroll = function() {
      var s = r._currentOptions;
      r._lock || !s || r.emit("scrollDrag", {
        next: function(o) {
          r.checkScroll({
            container: s.container,
            inputEvent: o
          });
        }
      });
    }, r;
  }
  var n = e.prototype;
  return n.dragStart = function(r, s) {
    var o = _n(s.container);
    if (!o) {
      this._flag = !1;
      return;
    }
    var i = 0, a = 0, c = 0, l = 0;
    if (o === document.body)
      c = window.innerWidth, l = window.innerHeight;
    else {
      var u = o.getBoundingClientRect();
      i = u.top, a = u.left, c = u.width, l = u.height;
    }
    this._flag = !0, this._startPos = [r.clientX, r.clientY], this._startRect = {
      top: i,
      left: a,
      width: c,
      height: l
    }, this._prevScrollPos = this._getScrollPosition([0, 0], s), this._currentOptions = s, this._registerScrollEvent(s);
  }, n.drag = function(r, s) {
    if (clearTimeout(this._timer), !!this._flag) {
      var o = r.clientX, i = r.clientY, a = s.threshold, c = a === void 0 ? 0 : a, l = this, u = l._startRect, f = l._startPos;
      this._currentOptions = s;
      var d = [0, 0];
      return u.top > i - c ? (f[1] > u.top || i < f[1]) && (d[1] = -1) : u.top + u.height < i + c && (f[1] < u.top + u.height || i > f[1]) && (d[1] = 1), u.left > o - c ? (f[0] > u.left || o < f[0]) && (d[0] = -1) : u.left + u.width < o + c && (f[0] < u.left + u.width || o > f[0]) && (d[0] = 1), !d[0] && !d[1] ? !1 : this._continueDrag(Ge(Ge({}, s), {
        direction: d,
        inputEvent: r,
        isDrag: !0
      }));
    }
  }, n.checkScroll = function(r) {
    var s = this;
    if (this._isWait)
      return !1;
    var o = r.prevScrollPos, i = o === void 0 ? this._prevScrollPos : o, a = r.direction, c = r.throttleTime, l = c === void 0 ? 0 : c, u = r.inputEvent, f = r.isDrag, d = this._getScrollPosition(a || [0, 0], r), p = d[0] - i[0], g = d[1] - i[1], h = a || [p ? Math.abs(p) / p : 0, g ? Math.abs(g) / g : 0];
    return this._prevScrollPos = d, this._lock = !1, !p && !g ? !1 : (this.emit("move", {
      offsetX: h[0] ? p : 0,
      offsetY: h[1] ? g : 0,
      inputEvent: u
    }), l && f && (clearTimeout(this._timer), this._timer = window.setTimeout(function() {
      s._continueDrag(r);
    }, l)), !0);
  }, n.dragEnd = function() {
    this._flag = !1, this._lock = !1, clearTimeout(this._timer), this._unregisterScrollEvent();
  }, n._getScrollPosition = function(r, s) {
    var o = s.container, i = s.getScrollPosition, a = i === void 0 ? Iu : i;
    return a({
      container: _n(o),
      direction: r
    });
  }, n._continueDrag = function(r) {
    var s = this, o, i = r.container, a = r.direction, c = r.throttleTime, l = r.useScroll, u = r.isDrag, f = r.inputEvent;
    if (!(!this._flag || u && this._isWait)) {
      var d = cn(), p = Math.max(c + this._prevTime - d, 0);
      if (p > 0)
        return clearTimeout(this._timer), this._timer = window.setTimeout(function() {
          s._continueDrag(r);
        }, p), !1;
      this._prevTime = d;
      var g = this._getScrollPosition(a, r);
      this._prevScrollPos = g, u && (this._isWait = !0), l || (this._lock = !0);
      var h = {
        container: _n(i),
        direction: a,
        inputEvent: f
      };
      return (o = r.requestScroll) === null || o === void 0 || o.call(r, h), this.emit("scroll", h), this._isWait = !1, l || this.checkScroll(Ge(Ge({}, r), {
        prevScrollPos: g,
        direction: a,
        inputEvent: f
      }));
    }
  }, n._registerScrollEvent = function(r) {
    this._unregisterScrollEvent();
    var s = r.checkScrollEvent;
    if (s) {
      var o = s === !0 ? ho : s, i = _n(r.container);
      s === !0 && (i === document.body || i === document.documentElement) ? this._unregister = ho(window, this._onScroll) : this._unregister = o(i, this._onScroll);
    }
  }, n._unregisterScrollEvent = function() {
    var r;
    (r = this._unregister) === null || r === void 0 || r.call(this), this._unregister = null;
  }, e;
}(Cs);
function zu(t) {
  const e = t.scrollContainer;
  return [
    e.scrollLeft,
    e.scrollTop
  ];
}
const Au = {
  name: "scrollable",
  canPinch: !0,
  props: [
    "scrollable",
    "scrollContainer",
    "scrollThreshold",
    "scrollThrottleTime",
    "getScrollPosition",
    "scrollOptions"
  ],
  events: [
    "scroll",
    "scrollGroup"
  ],
  dragRelation: "strong",
  dragStart(t, e) {
    const n = t.props, {
      scrollContainer: r = t.getContainer(),
      scrollOptions: s
    } = n, o = new Bu(), i = Zt(r, !0);
    e.datas.dragScroll = o, t.state.dragScroll = o;
    const a = e.isControl ? "controlGesto" : "targetGesto", c = e.targets;
    o.on("scroll", ({ container: l, direction: u }) => {
      const f = et(t, e, {
        scrollContainer: l,
        direction: u
      }), d = c ? "onScrollGroup" : "onScroll";
      c && (f.targets = c), j(t, d, f);
    }).on("move", ({ offsetX: l, offsetY: u, inputEvent: f }) => {
      t[a].scrollBy(l, u, f.inputEvent, !1);
    }).on("scrollDrag", ({ next: l }) => {
      l(t[a].getCurrentEvent());
    }), o.dragStart(e, {
      container: i,
      ...s
    });
  },
  checkScroll(t, e) {
    const n = e.datas.dragScroll;
    if (!n)
      return;
    const {
      scrollContainer: r = t.getContainer(),
      scrollThreshold: s = 0,
      scrollThrottleTime: o = 0,
      getScrollPosition: i = zu,
      scrollOptions: a
    } = t.props;
    return n.drag(e, {
      container: r,
      threshold: s,
      throttleTime: o,
      getScrollPosition: (c) => i({ scrollContainer: c.container, direction: c.direction }),
      ...a
    }), !0;
  },
  drag(t, e) {
    return this.checkScroll(t, e);
  },
  dragEnd(t, e) {
    e.datas.dragScroll.dragEnd(), e.datas.dragScroll = null;
  },
  dragControlStart(t, e) {
    return this.dragStart(t, { ...e, isControl: !0 });
  },
  dragControl(t, e) {
    return this.drag(t, e);
  },
  dragControlEnd(t, e) {
    return this.dragEnd(t, e);
  },
  dragGroupStart(t, e) {
    return this.dragStart(t, { ...e, targets: t.props.targets });
  },
  dragGroup(t, e) {
    return this.drag(t, { ...e, targets: t.props.targets });
  },
  dragGroupEnd(t, e) {
    return this.dragEnd(t, { ...e, targets: t.props.targets });
  },
  dragGroupControlStart(t, e) {
    return this.dragStart(t, { ...e, targets: t.props.targets, isControl: !0 });
  },
  dragGroupControl(t, e) {
    return this.drag(t, { ...e, targets: t.props.targets });
  },
  dragGroupControEnd(t, e) {
    return this.dragEnd(t, { ...e, targets: t.props.targets });
  },
  unset(t) {
    var n;
    const e = t.state;
    (n = e.dragScroll) == null || n.dragEnd(), e.dragScroll = null;
  }
}, Zi = {
  name: "",
  props: [
    "target",
    "dragTargetSelf",
    "dragTarget",
    "dragContainer",
    "container",
    "warpSelf",
    "rootContainer",
    "useResizeObserver",
    "useMutationObserver",
    "zoom",
    "dragFocusedInput",
    "transformOrigin",
    "ables",
    "className",
    "pinchThreshold",
    "pinchOutside",
    "triggerAblesSimultaneously",
    "checkInput",
    "cspNonce",
    "translateZ",
    "hideDefaultLines",
    "props",
    "flushSync",
    "stopPropagation",
    "preventClickEventOnDrag",
    "preventClickDefault",
    "viewContainer",
    "persistData",
    "useAccuratePosition",
    "firstRenderState",
    "linePadding",
    "controlPadding",
    "preventDefault",
    "preventRightClick",
    "preventWheelClick",
    "requestStyles"
  ],
  events: [
    "changeTargets"
  ]
}, Gu = dn("padding", {
  props: ["padding"],
  render(t, e) {
    const n = t.props;
    if (n.dragArea)
      return [];
    const {
      left: r,
      top: s,
      right: o,
      bottom: i
    } = qi(n.padding || {}), {
      renderPoses: a,
      pos1: c,
      pos2: l,
      pos3: u,
      pos4: f
    } = t.getState(), d = [c, l, u, f], p = [];
    return r > 0 && p.push([0, 2]), s > 0 && p.push([0, 1]), o > 0 && p.push([1, 3]), i > 0 && p.push([2, 3]), p.map(([g, h], v) => {
      const m = d[g], S = d[h], x = a[g], C = a[h], E = ss(
        [0, 0],
        [100, 0],
        [0, 100],
        [100, 100],
        m,
        S,
        x,
        C
      );
      if (E.length)
        return /* @__PURE__ */ it.jsx("div", { className: U("padding"), style: {
          transform: Jn(E, !0)
        } }, `padding${v}`);
    });
  }
}), vo = ["nw", "ne", "se", "sw"];
function Tn(t, e) {
  const n = t[0] + t[1], r = n > e ? e / n : 1;
  return t[0] *= r, t[1] = e - t[1] * r, t;
}
const ku = [1, 2, 5, 6], $u = [0, 3, 4, 7], ve = [1, -1, -1, 1], me = [1, 1, -1, -1];
function Ds(t, e, n, r, s = 0, o = 0, i = n, a = r) {
  const c = [];
  let l = !1;
  const u = t.filter((d) => !d.virtual), f = u.map((d) => {
    const { horizontal: p, vertical: g, pos: h } = d;
    if (g && !l && (l = !0, c.push("/")), l) {
      const v = Math.max(0, g === 1 ? h[1] - o : a - h[1]);
      return c.push(Xt(v, r, e)), v;
    } else {
      const v = Math.max(0, p === 1 ? h[0] - s : i - h[0]);
      return c.push(Xt(v, n, e)), v;
    }
  });
  return {
    radiusPoses: u,
    styles: c,
    raws: f
  };
}
function Ji(t) {
  const e = [0, 0], n = [0, 0], r = t.length;
  for (let s = 0; s < r; ++s) {
    const o = t[s];
    o.sub && (o.horizontal && (e[1] === 0 && (e[0] = s), e[1] = s - e[0] + 1, n[0] = s + 1), o.vertical && (n[1] === 0 && (n[0] = s), n[1] = s - n[0] + 1));
  }
  return {
    horizontalRange: e,
    verticalRange: n
  };
}
function Fu(t, e, n, r, s, o = [0, 0], i = !1) {
  const a = t.indexOf("/"), c = (a > -1 ? t.slice(0, a) : t).length, l = t.slice(0, c), u = t.slice(c + 1), f = l.length, d = u.length, p = d > 0, [
    g = "0px",
    h = g,
    v = g,
    m = h
  ] = l, [
    S = g,
    x = p ? S : h,
    C = p ? S : v,
    E = p ? x : m
  ] = u, D = [g, h, v, m].map((O) => ft(O, e)), R = [S, x, C, E].map((O) => ft(O, n)), y = D.slice(), M = R.slice();
  [y[0], y[1]] = Tn(
    [y[0], y[1]],
    e
  ), [y[3], y[2]] = Tn(
    [y[3], y[2]],
    e
  ), [M[0], M[3]] = Tn(
    [M[0], M[3]],
    n
  ), [M[1], M[2]] = Tn(
    [M[1], M[2]],
    n
  );
  const P = i ? y : y.slice(0, Math.max(o[0], f)), _ = i ? M : M.slice(0, Math.max(o[1], d));
  return [
    ...P.map((O, T) => {
      const w = vo[T];
      return {
        virtual: T >= f,
        horizontal: ve[T],
        vertical: 0,
        pos: [r + O, s + (me[T] === -1 ? n : 0)],
        sub: !0,
        raw: D[T],
        direction: w
      };
    }),
    ..._.map((O, T) => {
      const w = vo[T];
      return {
        virtual: T >= d,
        horizontal: 0,
        vertical: me[T],
        pos: [r + (ve[T] === -1 ? e : 0), s + O],
        sub: !0,
        raw: R[T],
        direction: w
      };
    })
  ];
}
function Lu(t, e, n, r, s = e.length) {
  const {
    horizontalRange: o,
    verticalRange: i
  } = Ji(t.slice(r)), a = n - r;
  let c = 0;
  if (a === 0)
    c = s;
  else if (a > 0 && a < o[1])
    c = o[1] - a;
  else if (a >= i[0])
    c = i[0] + i[1] - a;
  else
    return;
  t.splice(n, c), e.splice(n, c);
}
function Nu(t, e, n, r, s, o, i, a, c, l = 0, u = 0) {
  const {
    horizontalRange: f,
    verticalRange: d
  } = Ji(t.slice(n));
  if (r > -1) {
    const p = ve[r] === 1 ? o - l : a - o;
    for (let g = f[1]; g <= r; ++g) {
      const h = me[g] === 1 ? u : c;
      let v = 0;
      if (r === g ? v = o : g === 0 ? v = l + p : ve[g] === -1 && (v = a - (e[n][0] - l)), t.splice(n + g, 0, {
        horizontal: ve[g],
        vertical: 0,
        pos: [v, h]
      }), e.splice(n + g, 0, [v, h]), g === 0)
        break;
    }
  } else if (s > -1) {
    const p = me[s] === 1 ? i - u : c - i;
    if (f[1] === 0 && d[1] === 0) {
      const h = [
        l + p,
        u
      ];
      t.push({
        horizontal: ve[0],
        vertical: 0,
        pos: h
      }), e.push(h);
    }
    const g = d[0];
    for (let h = d[1]; h <= s; ++h) {
      const v = ve[h] === 1 ? l : a;
      let m = 0;
      if (s === h ? m = i : h === 0 ? m = u + p : me[h] === 1 ? m = e[n + g][1] : me[h] === -1 && (m = c - (e[n + g][1] - u)), t.push({
        horizontal: 0,
        vertical: me[h],
        pos: [v, m]
      }), e.push([v, m]), h === 0)
        break;
    }
  }
}
function Wu(t, e = t.map((n) => n.raw)) {
  const n = t.map((s, o) => s.horizontal ? e[o] : null).filter((s) => s != null), r = t.map((s, o) => s.vertical ? e[o] : null).filter((s) => s != null);
  return {
    horizontals: n,
    verticals: r
  };
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function Yu() {
  for (var t = 0, e = 0, n = arguments.length; e < n; e++) t += arguments[e].length;
  for (var r = Array(t), s = 0, e = 0; e < n; e++) for (var o = arguments[e], i = 0, a = o.length; i < a; i++, s++) r[s] = o[i];
  return r;
}
function At(t) {
  return tt(t, Dt);
}
function Vu(t, e) {
  return t.every(function(n, r) {
    return At(n - e[r]) === 0;
  });
}
function ju(t, e) {
  return !At(t[0] - e[0]) && !At(t[1] - e[1]);
}
function Qi(t) {
  return t.length < 3 ? 0 : Math.abs(Cc(t.map(function(e, n) {
    var r = t[n + 1] || t[0];
    return e[0] * r[1] - r[0] * e[1];
  }))) / 2;
}
function mo(t, e) {
  var n = e.width, r = e.height, s = e.left, o = e.top, i = be(t), a = i.minX, c = i.minY, l = i.maxX, u = i.maxY, f = n / (l - a), d = r / (u - c);
  return t.map(function(p) {
    return [s + (p[0] - a) * f, o + (p[1] - c) * d];
  });
}
function be(t) {
  var e = t.map(function(r) {
    return r[0];
  }), n = t.map(function(r) {
    return r[1];
  });
  return {
    minX: Math.min.apply(Math, e),
    minY: Math.min.apply(Math, n),
    maxX: Math.max.apply(Math, e),
    maxY: Math.max.apply(Math, n)
  };
}
function Fr(t, e, n) {
  var r = t[0], s = t[1], o = be(e), i = o.minX, a = o.maxX, c = [[i, s], [a, s]], l = Yn(c[0], c[1]), u = Lr(e), f = [];
  if (u.forEach(function(g) {
    var h = Yn(g[0], g[1]), v = g[0];
    if (Vu(l, h))
      f.push({
        pos: t,
        line: g,
        type: "line"
      });
    else {
      var m = ta(bs(l, h), [c, g]);
      m.forEach(function(S) {
        g.some(function(x) {
          return ju(x, S);
        }) ? f.push({
          pos: S,
          line: g,
          type: "point"
        }) : At(v[1] - s) !== 0 && f.push({
          pos: S,
          line: g,
          type: "intersection"
        });
      });
    }
  }), kt(f, function(g) {
    return g[0] === r;
  }))
    return !0;
  var d = 0, p = {};
  return f.forEach(function(g) {
    var h = g.pos, v = g.type, m = g.line;
    if (!(h[0] > r))
      if (v === "intersection")
        ++d;
      else {
        if (v === "line")
          return;
        if (v === "point") {
          var S = kt(m, function(E) {
            return E[1] !== s;
          }), x = p[h[0]], C = S[1] > s ? 1 : -1;
          x ? x !== C && ++d : p[h[0]] = C;
        }
      }
  }), d % 2 === 1;
}
function Yn(t, e) {
  var n = t[0], r = t[1], s = e[0], o = e[1], i = s - n, a = o - r;
  Math.abs(i) < Dt && (i = 0), Math.abs(a) < Dt && (a = 0);
  var c = 0, l = 0, u = 0;
  return i ? a ? (c = -a / i, l = 1, u = -c * n - r) : (l = 1, u = -r) : a && (c = -1, u = n), [c, l, u];
}
function bs(t, e) {
  var n = t[0], r = t[1], s = t[2], o = e[0], i = e[1], a = e[2], c = n === 0 && o === 0, l = r === 0 && i === 0, u = [];
  if (c && l)
    return [];
  if (c) {
    var f = -s / r, d = -a / i;
    return f !== d ? [] : [[-1 / 0, f], [1 / 0, f]];
  } else if (l) {
    var p = -s / n, g = -a / o;
    return p !== g ? [] : [[p, -1 / 0], [p, 1 / 0]];
  } else if (n === 0) {
    var h = -s / r, v = -(i * h + a) / o;
    u = [[v, h]];
  } else if (o === 0) {
    var h = -a / i, v = -(r * h + s) / n;
    u = [[v, h]];
  } else if (r === 0) {
    var v = -s / n, h = -(o * v + a) / i;
    u = [[v, h]];
  } else if (i === 0) {
    var v = -a / o, h = -(n * v + s) / r;
    u = [[v, h]];
  } else {
    var v = (r * a - i * s) / (i * n - r * o), h = -(n * v + s) / r;
    u = [[v, h]];
  }
  return u.map(function(m) {
    return [m[0], m[1]];
  });
}
function ta(t, e) {
  var n = e.map(function(f) {
    return [0, 1].map(function(d) {
      return [Math.min(f[0][d], f[1][d]), Math.max(f[0][d], f[1][d])];
    });
  }), r = [];
  if (t.length === 2) {
    var s = t[0], o = s[0], i = s[1];
    if (At(o - t[1][0])) {
      if (!At(i - t[1][1])) {
        var l = Math.max.apply(Math, n.map(function(f) {
          return f[0][0];
        })), u = Math.min.apply(Math, n.map(function(f) {
          return f[0][1];
        }));
        if (At(l - u) > 0)
          return [];
        r = [[l, i], [u, i]];
      }
    } else {
      var a = Math.max.apply(Math, n.map(function(f) {
        return f[1][0];
      })), c = Math.min.apply(Math, n.map(function(f) {
        return f[1][1];
      }));
      if (At(a - c) > 0)
        return [];
      r = [[o, a], [o, c]];
    }
  }
  return r.length || (r = t.filter(function(f) {
    var d = f[0], p = f[1];
    return n.every(function(g) {
      return 0 <= At(d - g[0][0]) && 0 <= At(g[0][1] - d) && 0 <= At(p - g[1][0]) && 0 <= At(g[1][1] - p);
    });
  })), r.map(function(f) {
    return [At(f[0]), At(f[1])];
  });
}
function Lr(t) {
  return Yu(t.slice(1), [t[0]]).map(function(e, n) {
    return [t[n], e];
  });
}
function Xu(t, e) {
  var n = t.slice(), r = e.slice();
  Ns(n) === -1 && n.reverse(), Ns(r) === -1 && r.reverse();
  var s = Lr(n), o = Lr(r), i = s.map(function(u) {
    return Yn(u[0], u[1]);
  }), a = o.map(function(u) {
    return Yn(u[0], u[1]);
  }), c = [];
  i.forEach(function(u, f) {
    var d = s[f], p = [];
    a.forEach(function(g, h) {
      var v = bs(u, g), m = ta(v, [d, o[h]]);
      p.push.apply(p, m.map(function(S) {
        return {
          index1: f,
          index2: h,
          pos: S,
          type: "intersection"
        };
      }));
    }), p.sort(function(g, h) {
      return te(d[0], g.pos) - te(d[0], h.pos);
    }), c.push.apply(c, p), Fr(d[1], r) && c.push({
      index1: f,
      index2: -1,
      pos: d[1],
      type: "inside"
    });
  }), o.forEach(function(u, f) {
    if (Fr(u[1], n)) {
      var d = !1, p = ne(c, function(g) {
        var h = g.index2;
        return h === f ? (d = !0, !1) : !!d;
      });
      p === -1 && (d = !1, p = ne(c, function(g) {
        var h = g.index1, v = g.index2;
        return h === -1 && v + 1 === f ? (d = !0, !1) : !!d;
      })), p === -1 ? c.push({
        index1: -1,
        index2: f,
        pos: u[1],
        type: "inside"
      }) : c.splice(p, 0, {
        index1: -1,
        index2: f,
        pos: u[1],
        type: "inside"
      });
    }
  });
  var l = {};
  return c.filter(function(u) {
    var f = u.pos, d = f[0] + "x" + f[1];
    return l[d] ? !1 : (l[d] = !0, !0);
  });
}
function Hu(t, e) {
  var n = Xu(t, e);
  return n.map(function(r) {
    var s = r.pos;
    return s;
  });
}
function qu(t, e) {
  var n = Hu(t, e);
  return Qi(n);
}
const Uu = [
  [0, -1, "n"],
  [1, 0, "e"]
], Ku = [
  [-1, -1, "nw"],
  [0, -1, "n"],
  [1, -1, "ne"],
  [1, 0, "e"],
  [1, 1, "se"],
  [0, 1, "s"],
  [-1, 1, "sw"],
  [-1, 0, "w"]
];
function ys(t, e, n) {
  const { clipRelative: r } = t.props, { width: s, height: o } = t.state, { type: i, poses: a } = e, c = i === "rect", l = i === "circle";
  if (i === "polygon")
    return n.map(
      (u) => `${Xt(u[0], s, r)} ${Xt(u[1], o, r)}`
    );
  if (c || i === "inset") {
    const u = n[1][1], f = n[3][0], d = n[7][0], p = n[5][1];
    if (c)
      return [u, f, p, d].map((h) => `${h}px`);
    const g = [u, s - f, o - p, d].map(
      (h, v) => Xt(h, v % 2 ? s : o, r)
    );
    if (n.length > 8) {
      const [h, v] = K(n[4], n[0]);
      g.push(
        "round",
        ...Ds(
          a.slice(8).map((m, S) => ({
            ...m,
            pos: n[S]
          })),
          r,
          h,
          v,
          d,
          u,
          f,
          p
        ).styles
      );
    }
    return g;
  } else if (l || i === "ellipse") {
    const u = n[0], f = Xt(
      B(n[1][1] - u[1]),
      l ? Math.sqrt((s * s + o * o) / 2) : o,
      r
    ), d = l ? [f] : [Xt(B(n[2][0] - u[0]), s, r), f];
    return d.push(
      "at",
      Xt(u[0], s, r),
      Xt(u[1], o, r)
    ), d;
  }
}
function Vn(t, e, n, r) {
  const s = [r, (r + e) / 2, e], o = [t, (t + n) / 2, n];
  return Ku.map(([i, a, c]) => {
    const l = s[i + 1], u = o[a + 1];
    return {
      vertical: B(a),
      horizontal: B(i),
      direction: c,
      pos: [l, u]
    };
  });
}
function ea(t) {
  const e = [1 / 0, -1 / 0], n = [1 / 0, -1 / 0];
  return t.forEach(({ pos: r }) => {
    e[0] = Math.min(e[0], r[0]), e[1] = Math.max(e[1], r[0]), n[0] = Math.min(n[0], r[1]), n[1] = Math.max(n[1], r[1]);
  }), [B(e[1] - e[0]), B(n[1] - n[0])];
}
function xo(t, e, n, r, s) {
  if (!t)
    return;
  let o = s;
  if (!o) {
    const u = Gt(t), f = u("clipPath");
    o = f !== "none" ? f : u("clip");
  }
  if ((!o || o === "none" || o === "auto") && (o = r, !o))
    return;
  const { prefix: i = o, value: a = "" } = Xo(o), c = i === "circle";
  let l = " ";
  if (i === "polygon") {
    const u = xe(a || "0% 0%, 100% 0%, 100% 100%, 0% 100%");
    l = ",";
    const f = u.map((p) => {
      const [g, h] = p.split(" ");
      return {
        vertical: 1,
        horizontal: 1,
        pos: [ft(g, e), ft(h, n)]
      };
    }), d = be(f.map((p) => p.pos));
    return {
      type: i,
      clipText: o,
      poses: f,
      splitter: l,
      left: d.minX,
      right: d.maxX,
      top: d.minY,
      bottom: d.maxY
    };
  } else if (c || i === "ellipse") {
    let u = "", f = "", d = 0, p = 0;
    const g = ce(a);
    if (c) {
      let m = "";
      [m = "50%", , u = "50%", f = "50%"] = g, d = ft(
        m,
        Math.sqrt((e * e + n * n) / 2)
      ), p = d;
    } else {
      let m = "", S = "";
      [m = "50%", S = "50%", , u = "50%", f = "50%"] = g, d = ft(m, e), p = ft(S, n);
    }
    const h = [
      ft(u, e),
      ft(f, n)
    ], v = [
      {
        vertical: 1,
        horizontal: 1,
        pos: h,
        direction: "nesw"
      },
      ...Uu.slice(0, c ? 1 : 2).map((m) => ({
        vertical: B(m[1]),
        horizontal: m[0],
        direction: m[2],
        sub: !0,
        pos: [h[0] + m[0] * d, h[1] + m[1] * p]
      }))
    ];
    return {
      type: i,
      clipText: o,
      radiusX: d,
      radiusY: p,
      left: h[0] - d,
      top: h[1] - p,
      right: h[0] + d,
      bottom: h[1] + p,
      poses: v,
      splitter: l
    };
  } else if (i === "inset") {
    const u = ce(a || "0 0 0 0 round 0px"), f = u.indexOf("round"), d = (f > -1 ? u.slice(0, f) : u).length, p = u.slice(d + 1), [
      g,
      h = g,
      v = g,
      m = h
    ] = u.slice(0, d), [S, x] = [g, v].map(
      (M) => ft(M, n)
    ), [C, E] = [m, h].map(
      (M) => ft(M, e)
    ), D = e - E, R = n - x, y = [
      ...Vn(S, D, R, C)
    ];
    return {
      type: "inset",
      clipText: o,
      poses: y,
      top: S,
      left: C,
      right: D,
      bottom: R,
      radius: p,
      splitter: l
    };
  } else if (i === "rect") {
    const u = xe(a || `0px, ${e}px, ${n}px, 0px`);
    l = ",";
    const [f, d, p, g] = u.map((v) => {
      const { value: m } = pn(v);
      return m;
    }), h = Vn(f, d, p, g);
    return {
      type: "rect",
      clipText: o,
      poses: h,
      top: f,
      right: d,
      bottom: p,
      left: g,
      values: u,
      splitter: l
    };
  }
}
function Zu(t, e, n, r, s) {
  const { direction: o, sub: i } = t[e], a = t.map(() => [0, 0]), c = o ? o.split("") : [];
  if (r && e < 8) {
    const l = c.filter(
      (v) => v === "w" || v === "e"
    ), u = c.filter(
      (v) => v === "n" || v === "s"
    ), f = l[0], d = u[0];
    a[e] = n;
    const [p, g] = ea(t), h = p && g ? p / g : 0;
    if (h && s) {
      const v = (e + 4) % 8, m = t[v].pos, S = [0, 0];
      o.indexOf("w") > -1 ? S[0] = -1 : o.indexOf("e") > -1 && (S[0] = 1), o.indexOf("n") > -1 ? S[1] = -1 : o.indexOf("s") > -1 && (S[1] = 1);
      const x = ji(
        [p, g],
        n,
        h,
        S,
        !0
      ), C = p + x[0], E = g + x[1];
      let D = m[1], R = m[1], y = m[0], M = m[0];
      S[0] === -1 ? y = M - C : S[0] === 1 ? M = y + C : (y = y - C / 2, M = M + C / 2), S[1] === -1 ? D = R - E : (S[1] === 1 || (D = R - E / 2), R = D + E);
      const P = Vn(D, M, R, y);
      t.forEach((_, O) => {
        a[O][0] = P[O].pos[0] - _.pos[0], a[O][1] = P[O].pos[1] - _.pos[1];
      });
    } else
      t.forEach((v, m) => {
        const { direction: S } = v;
        S && (S.indexOf(f) > -1 && (a[m][0] = n[0]), S.indexOf(d) > -1 && (a[m][1] = n[1]));
      }), f && (a[1][0] = n[0] / 2, a[5][0] = n[0] / 2), d && (a[3][1] = n[1] / 2, a[7][1] = n[1] / 2);
  } else o && !i ? c.forEach((l) => {
    const u = l === "n" || l === "s";
    t.forEach((f, d) => {
      const {
        direction: p,
        horizontal: g,
        vertical: h
      } = f;
      !p || p.indexOf(l) === -1 || (a[d] = [
        u || !g ? 0 : n[0],
        !u || !h ? 0 : n[1]
      ]);
    });
  }) : a[e] = n;
  return a;
}
function Ju(t, e) {
  const [n, r] = ni(t, e), { clipPath: s, clipIndex: o } = e.datas, {
    type: i,
    poses: a,
    splitter: c
  } = s, l = a.map((d) => d.pos);
  if (i === "polygon")
    l.splice(o, 0, [n, r]);
  else if (i === "inset") {
    const d = ku.indexOf(o), p = $u.indexOf(o), g = a.length;
    if (Nu(
      a,
      l,
      8,
      d,
      p,
      n,
      r,
      l[4][0],
      l[4][1],
      l[0][0],
      l[0][1]
    ), g === a.length)
      return;
  } else
    return;
  const u = ys(t, s, l), f = `${i}(${u.join(c)})`;
  j(
    t,
    "onClip",
    et(t, e, {
      clipEventType: "added",
      clipType: i,
      poses: l,
      clipStyles: u,
      clipStyle: f,
      distX: 0,
      distY: 0,
      ...It(
        {
          clipPath: f
        },
        e
      )
    })
  );
}
function Qu(t, e) {
  const { clipPath: n, clipIndex: r } = e.datas, {
    type: s,
    poses: o,
    splitter: i
  } = n, a = o.map((f) => f.pos), c = a.length;
  if (s === "polygon")
    o.splice(r, 1), a.splice(r, 1);
  else if (s === "inset") {
    if (r < 8 || (Lu(o, a, r, 8, c), c === o.length))
      return;
  } else
    return;
  const l = ys(t, n, a), u = `${s}(${l.join(i)})`;
  j(
    t,
    "onClip",
    et(t, e, {
      clipEventType: "removed",
      clipType: s,
      poses: a,
      clipStyles: l,
      clipStyle: u,
      distX: 0,
      distY: 0,
      ...It(
        {
          clipPath: u
        },
        e
      )
    })
  );
}
const tf = {
  name: "clippable",
  props: [
    "clippable",
    "defaultClipPath",
    "customClipPath",
    "keepRatio",
    "clipRelative",
    "clipArea",
    "dragWithClip",
    "clipTargetBounds",
    "clipVerticalGuidelines",
    "clipHorizontalGuidelines",
    "clipSnapThreshold"
  ],
  events: ["clipStart", "clip", "clipEnd"],
  css: [
    `.control.clip-control {
background: red;
cursor: pointer;
}
.control.clip-control.clip-radius {
background: #d66;
}
.line.clip-line {
background: #6e6;
cursor: move;
z-index: 1;
}
.clip-area {
position: absolute;
top: 0;
left: 0;
}
.clip-ellipse {
position: absolute;
cursor: move;
border: 1px solid #6d6;
border: var(--zoompx) solid #6d6;
border-radius: 50%;
transform-origin: 0px 0px;
}`,
    `:host {
--bounds-color: #d66;
}`,
    `.guideline {
pointer-events: none;
z-index: 2;
}`,
    `.line.guideline.bounds {
background: #d66;
background: var(--bounds-color);
}`
  ],
  render(t, e) {
    const { customClipPath: n, defaultClipPath: r, clipArea: s, zoom: o, groupable: i } = t.props, {
      target: a,
      width: c,
      height: l,
      allMatrix: u,
      is3d: f,
      left: d,
      top: p,
      pos1: g,
      pos2: h,
      pos3: v,
      pos4: m,
      clipPathState: S,
      snapBoundInfos: x,
      rotation: C
    } = t.getState();
    if (!a || i)
      return [];
    const E = xo(
      a,
      c,
      l,
      r || "inset",
      S || n
    );
    if (!E)
      return [];
    const D = f ? 4 : 3, R = E.type, M = E.poses.map((I) => {
      const $ = ht(u, I.pos, D);
      return [$[0] - d, $[1] - p];
    });
    let P = [], _ = [];
    const O = R === "rect", T = R === "inset", w = R === "polygon";
    if (O || T || w) {
      const I = T ? M.slice(0, 8) : M;
      _ = I.map(($, G) => {
        const L = G === 0 ? I[I.length - 1] : I[G - 1], z = xt(L, $), N = Gi(L, $);
        return /* @__PURE__ */ it.jsx(
          "div",
          {
            className: U("line", "clip-line", "snap-control"),
            "data-clip-index": G,
            style: {
              width: `${N}px`,
              transform: `translate(${L[0]}px, ${L[1]}px) rotate(${z}rad) scaleY(${o})`
            }
          },
          `clipLine${G}`
        );
      });
    }
    const k = ["nw", "n", "ne", "e", "se", "s", "sw", "w"];
    if (P = M.map((I, $) => {
      const G = k[$];
      return /* @__PURE__ */ it.jsx(
        "div",
        {
          className: U(
            "control",
            "clip-control",
            "snap-control",
            `clip-${G}`
          ),
          "data-clip-index": $,
          style: {
            transform: `translate(${I[0]}px, ${I[1]}px) rotate(${C}rad) scale(${o})`,
            backgroundColor: "green"
          }
        },
        `clipControl${$}`
      );
    }), T && P.push(
      ...M.slice(8).map((I, $) => /* @__PURE__ */ it.jsx(
        "div",
        {
          className: U(
            "control",
            "clip-control",
            "clip-radius",
            "snap-control"
          ),
          "data-clip-index": 8 + $,
          style: {
            transform: `translate(${I[0]}px, ${I[1]}px) rotate(${C}rad) scale(${o})`
          }
        },
        `clipRadiusControl${$}`
      ))
    ), R === "circle" || R === "ellipse") {
      const { left: I, top: $, radiusX: G, radiusY: L } = E, [z, N] = K(
        ht(u, [I, $], D),
        ht(u, [0, 0], D)
      );
      let Z = "none";
      if (!s) {
        const Y = Math.max(10, G / 5, L / 5), W = [];
        for (let J = 0; J <= Y; ++J) {
          const q = Math.PI * 2 / Y * J;
          W.push([
            G + (G - o) * Math.cos(q),
            L + (L - o) * Math.sin(q)
          ]);
        }
        W.push([G, -2]), W.push([-2, -2]), W.push([-2, L * 2 + 2]), W.push([G * 2 + 2, L * 2 + 2]), W.push([G * 2 + 2, -2]), W.push([G, -2]), Z = `polygon(${W.map((J) => `${J[0]}px ${J[1]}px`).join(", ")})`;
      }
      P.push(
        /* @__PURE__ */ it.jsx(
          "div",
          {
            className: U("clip-ellipse", "snap-control"),
            style: {
              width: `${G * 2}px`,
              height: `${L * 2}px`,
              clipPath: Z,
              transform: `translate(${-d + z}px, ${-p + N}px) ${Jn(u)}`
            }
          },
          "clipEllipse"
        )
      );
    }
    if (s) {
      const {
        width: I,
        height: $,
        left: G,
        top: L
      } = Yt([g, h, v, m, ...M]);
      if (w || O || T) {
        const z = T ? M.slice(0, 8) : M;
        P.push(
          /* @__PURE__ */ it.jsx(
            "div",
            {
              className: U("clip-area", "snap-control"),
              style: {
                width: `${I}px`,
                height: `${$}px`,
                transform: `translate(${G}px, ${L}px)`,
                clipPath: `polygon(${z.map((N) => `${N[0] - G}px ${N[1] - L}px`).join(", ")})`
              }
            },
            "clipArea"
          )
        );
      }
    }
    return x && ["vertical", "horizontal"].forEach((I) => {
      const $ = x[I], G = I === "horizontal";
      $.isSnap && _.push(
        ...$.snap.posInfos.map(({ pos: L }, z) => {
          const N = K(
            ht(
              u,
              G ? [0, L] : [L, 0],
              D
            ),
            [d, p]
          ), Z = K(
            ht(
              u,
              G ? [c, L] : [L, l],
              D
            ),
            [d, p]
          );
          return un(
            e,
            "",
            N,
            Z,
            o,
            `clip${I}snap${z}`,
            "guideline"
          );
        })
      ), $.isBound && _.push(
        ...$.bounds.map(({ pos: L }, z) => {
          const N = K(
            ht(
              u,
              G ? [0, L] : [L, 0],
              D
            ),
            [d, p]
          ), Z = K(
            ht(
              u,
              G ? [c, L] : [L, l],
              D
            ),
            [d, p]
          );
          return un(
            e,
            "",
            N,
            Z,
            o,
            `clip${I}bounds${z}`,
            "guideline",
            "bounds",
            "bold"
          );
        })
      );
    }), [...P, ..._];
  },
  dragControlCondition(t, e) {
    return e.inputEvent && (e.inputEvent.target.getAttribute("class") || "").indexOf("clip") > -1;
  },
  dragStart(t, e) {
    const n = t.props, { dragWithClip: r = !0 } = n;
    return r ? !1 : this.dragControlStart(t, e);
  },
  drag(t, e) {
    return this.dragControl(t, { ...e, isDragTarget: !0 });
  },
  dragEnd(t, e) {
    return this.dragControlEnd(t, e);
  },
  dragControlStart(t, e) {
    const n = t.state, { defaultClipPath: r, customClipPath: s } = t.props, { target: o, width: i, height: a } = n, c = e.inputEvent ? e.inputEvent.target : null, l = c && c.getAttribute("class") || "", u = e.datas, f = xo(
      o,
      i,
      a,
      r || "inset",
      s
    );
    if (!f)
      return !1;
    const { clipText: d, type: p, poses: g } = f;
    return j(
      t,
      "onClipStart",
      et(t, e, {
        clipType: p,
        clipStyle: d,
        poses: g.map((v) => v.pos)
      })
    ) === !1 ? (u.isClipStart = !1, !1) : (u.isControl = l && l.indexOf("clip-control") > -1, u.isLine = l.indexOf("clip-line") > -1, u.isArea = l.indexOf("clip-area") > -1 || l.indexOf("clip-ellipse") > -1, u.clipIndex = c ? parseInt(c.getAttribute("data-clip-index"), 10) : -1, u.clipPath = f, u.isClipStart = !0, n.clipPathState = d, Re(t, e), !0);
  },
  dragControl(t, e) {
    const { datas: n, originalDatas: r, isDragTarget: s } = e;
    if (!n.isClipStart)
      return !1;
    const { isControl: o, isLine: i, isArea: a, clipIndex: c, clipPath: l } = n;
    if (!l)
      return !1;
    const u = De(t.props, "clippable"), { keepRatio: f } = u;
    let d = 0, p = 0;
    const g = r.draggable, h = Qt(e);
    s && g ? [d, p] = g.prevBeforeDist : [d, p] = h;
    const v = [d, p], m = t.state, { width: S, height: x } = m, C = !a && !o && !i, { type: E, poses: D, splitter: R } = l, y = D.map((F) => F.pos);
    C && (d = -d, p = -p);
    const M = !o || D[c].direction === "nesw", P = E === "inset" || E === "rect";
    let _ = D.map(() => [0, 0]), O = u.defaultClipPath === "inset" ? !1 : f;
    if (o && !M) {
      const { horizontal: F, vertical: H } = D[c], nt = [d * B(F), p * B(H)];
      _ = Zu(
        D,
        c,
        nt,
        P,
        O
      );
    } else M && (_ = y.map(() => [d, p]));
    const T = y.map((F, H) => at(F, _[H])), w = [...T];
    m.snapBoundInfos = null;
    const k = l.type === "circle", I = l.type === "ellipse";
    if (k || I) {
      const F = Yt(T), H = B(F.bottom - F.top), nt = B(I ? F.right - F.left : H), lt = T[0][1] + H, vt = T[0][0] - nt, st = T[0][0] + nt;
      k && (w.push([st, F.bottom]), _.push([1, 0])), w.push([F.left, lt]), _.push([0, 1]), w.push([vt, F.bottom]), _.push([1, 0]);
    }
    const $ = Oi(
      (u.clipHorizontalGuidelines || []).map(
        (F) => ft(`${F}`, x)
      ),
      (u.clipVerticalGuidelines || []).map(
        (F) => ft(`${F}`, S)
      ),
      S,
      x
    );
    let G = [], L = [];
    if (k || I)
      G = [w[4][0], w[2][0]], L = [w[1][1], w[3][1]];
    else if (P) {
      const F = [
        w[0],
        w[2],
        w[4],
        w[6]
      ], H = [_[0], _[2], _[4], _[6]];
      G = F.filter((nt, lt) => H[lt][0]).map((nt) => nt[0]), L = F.filter((nt, lt) => H[lt][1]).map((nt) => nt[1]);
    } else
      G = w.filter((F, H) => _[H][0]).map((F) => F[0]), L = w.filter((F, H) => _[H][1]).map((F) => F[1]);
    const z = [0, 0], { horizontal: N, vertical: Z } = Qs(
      $,
      u.clipTargetBounds && {
        left: 0,
        top: 0,
        right: S,
        bottom: x
      },
      G,
      L,
      5,
      5
    );
    let Y = N.offset, W = Z.offset;
    if (N.isBound && (z[1] += Y), Z.isBound && (z[0] += W), (I || k) && _[0][0] === 0 && _[0][1] === 0) {
      const F = Yt(T);
      let H = F.bottom - F.top, nt = I ? F.right - F.left : H;
      const lt = Z.isBound ? B(W) : Z.snapIndex === 0 ? -W : W, vt = N.isBound ? B(Y) : N.snapIndex === 0 ? -Y : Y;
      nt -= lt, H -= vt, k && (H = Ei(Z, N) > 0 ? H : nt, nt = H);
      const st = w[0];
      w[1][1] = st[1] - H, w[2][0] = st[0] + nt, w[3][1] = st[1] + H, w[4][0] = st[0] - nt;
    } else if (P && O && o) {
      const [F, H] = ea(D), nt = F && H ? F / H : 0, vt = D[c].direction || "";
      let st = w[1][1], Ft = w[5][1], Lt = w[7][0], ut = w[3][0];
      B(Y) <= B(W) ? Y = wt(Y) * B(W) / nt : W = wt(W) * B(Y) * nt, vt.indexOf("w") > -1 ? Lt -= W : vt.indexOf("e") > -1 ? ut -= W : (Lt += W / 2, ut -= W / 2), vt.indexOf("n") > -1 ? st -= Y : vt.indexOf("s") > -1 ? Ft -= Y : (st += Y / 2, Ft -= Y / 2);
      const St = Vn(st, ut, Ft, Lt);
      w.forEach((Kt, de) => {
        [Kt[0], Kt[1]] = St[de].pos;
      });
    } else
      w.forEach((F, H) => {
        const nt = _[H];
        nt[0] && (F[0] -= W), nt[1] && (F[1] -= Y);
      });
    const J = ys(t, l, T), q = `${E}(${J.join(R)} ${l.radius.length ? "round " + l.radius.join(" ") : ""})`;
    if (m.clipPathState = q, k || I)
      G = [w[4][0], w[2][0]], L = [w[1][1], w[3][1]];
    else if (P) {
      const F = [
        w[0],
        w[2],
        w[4],
        w[6]
      ];
      G = F.map((H) => H[0]), L = F.map((H) => H[1]);
    } else
      G = w.map((F) => F[0]), L = w.map((F) => F[1]);
    if (m.snapBoundInfos = Qs(
      $,
      u.clipTargetBounds && {
        left: 0,
        top: 0,
        right: S,
        bottom: x
      },
      G,
      L,
      1,
      1
    ), g) {
      const { is3d: F, allMatrix: H } = m, nt = F ? 4 : 3;
      let lt = z;
      s && (lt = [
        v[0] + z[0] - h[0],
        v[1] + z[1] - h[1]
      ]), g.deltaOffset = dt(
        H,
        [lt[0], lt[1], 0, 0],
        nt
      );
    }
    return j(
      t,
      "onClip",
      et(t, e, {
        clipEventType: "changed",
        clipType: E,
        poses: T,
        clipStyle: q,
        clipStyles: J,
        distX: d,
        distY: p,
        ...It(
          {
            [E === "rect" ? "clip" : "clipPath"]: q
          },
          e
        )
      })
    ), !0;
  },
  dragControlEnd(t, e) {
    this.unset(t);
    const { isDrag: n, datas: r, isDouble: s } = e, { isLine: o, isClipStart: i, isControl: a } = r;
    return i ? (j(
      t,
      "onClipEnd",
      $t(t, e, {})
    ), s && (a ? (console.log("removeClipPath"), Qu(t, e)) : o && (console.log("addClipPath"), Ju(t, e))), s || n) : !1;
  },
  unset(t) {
    t.state.clipPathState = "", t.state.snapBoundInfos = null;
  }
}, ef = {
  name: "originDraggable",
  props: [
    "originDraggable",
    "originRelative"
  ],
  events: [
    "dragOriginStart",
    "dragOrigin",
    "dragOriginEnd"
  ],
  css: [
    `:host[data-able-origindraggable] .control.origin {
pointer-events: auto;
}`
  ],
  dragControlCondition(t, e) {
    return e.isRequest ? e.requestAble === "originDraggable" : bt(e.inputEvent.target, U("origin"));
  },
  dragControlStart(t, e) {
    const { datas: n } = e;
    Re(t, e);
    const r = et(t, e, {
      dragStart: Ot.dragStart(
        t,
        new Fe().dragStart([0, 0], e)
      )
    }), s = j(t, "onDragOriginStart", r);
    return n.startOrigin = t.state.transformOrigin, n.startTargetOrigin = t.state.targetOrigin, n.prevOrigin = [0, 0], n.isDragOrigin = !0, s === !1 ? (n.isDragOrigin = !1, !1) : r;
  },
  dragControl(t, e) {
    const { datas: n, isPinch: r, isRequest: s } = e;
    if (!n.isDragOrigin)
      return !1;
    const [o, i] = Qt(e), a = t.state, {
      width: c,
      height: l,
      offsetMatrix: u,
      targetMatrix: f,
      is3d: d
    } = a, {
      originRelative: p = !0
    } = t.props, g = d ? 4 : 3;
    let h = [o, i];
    if (s) {
      const P = e.distOrigin;
      (P[0] || P[1]) && (h = P);
    }
    const v = at(n.startOrigin, h), m = at(n.startTargetOrigin, h), S = K(h, n.prevOrigin), x = mn(
      u,
      f,
      v,
      g
    ), C = t.getRect(), E = Yt(Me(x, c, l, g)), D = [
      C.left - E.left,
      C.top - E.top
    ];
    n.prevOrigin = h;
    const R = [
      Xt(m[0], c, p),
      Xt(m[1], l, p)
    ].join(" "), y = Ot.drag(
      t,
      vn(e, t.state, D, !!r)
    ), M = et(t, e, {
      width: c,
      height: l,
      origin: v,
      dist: h,
      delta: S,
      transformOrigin: R,
      drag: y,
      ...It({
        transformOrigin: R,
        transform: y.transform
      }, e),
      afterTransform: y.transform
    });
    return j(t, "onDragOrigin", M), M;
  },
  dragControlEnd(t, e) {
    const { datas: n } = e;
    return n.isDragOrigin ? (j(
      t,
      "onDragOriginEnd",
      $t(t, e, {})
    ), !0) : !1;
  },
  dragGroupControlCondition(t, e) {
    return this.dragControlCondition(t, e);
  },
  dragGroupControlStart(t, e) {
    return !!this.dragControlStart(t, e);
  },
  dragGroupControl(t, e) {
    const n = this.dragControl(t, e);
    return n ? (t.transformOrigin = n.transformOrigin, !0) : !1;
  },
  /**
      * @method Moveable.OriginDraggable#request
      * @param {object} e - the OriginDraggable's request parameter
      * @param {number} [e.x] - x position
      * @param {number} [e.y] - y position
      * @param {number} [e.deltaX] - x number to move
      * @param {number} [e.deltaY] - y number to move
      * @param {array} [e.deltaOrigin] - left, top number to move transform-origin
      * @param {array} [e.origin] - transform-origin position
      * @param {number} [e.isInstant] - Whether to execute the request instantly
      * @return {Moveable.Requester} Moveable Requester
      * @example
  
      * // Instantly Request (requestStart - request - requestEnd)
      * // Use Relative Value
      * moveable.request("originDraggable", { deltaX: 10, deltaY: 10 }, true);
      * // Use Absolute Value
      * moveable.request("originDraggable", { x: 200, y: 100 }, true);
      * // Use Transform Value
      * moveable.request("originDraggable", { deltaOrigin: [10, 0] }, true);
      * moveable.request("originDraggable", { origin: [100, 0] }, true);
      * // requestStart
      * const requester = moveable.request("originDraggable");
      *
      * // request
      * // Use Relative Value
      * requester.request({ deltaX: 10, deltaY: 10 });
      * requester.request({ deltaX: 10, deltaY: 10 });
      * requester.request({ deltaX: 10, deltaY: 10 });
      * // Use Absolute Value
      * moveable.request("originDraggable", { x: 200, y: 100 });
      * moveable.request("originDraggable", { x: 220, y: 100 });
      * moveable.request("originDraggable", { x: 240, y: 100 });
      *
      * // requestEnd
      * requester.requestEnd();
      */
  request(t) {
    const e = {}, n = t.getRect();
    let r = 0, s = 0;
    const o = n.transformOrigin, i = [0, 0];
    return {
      isControl: !0,
      requestStart() {
        return { datas: e };
      },
      request(a) {
        return "deltaOrigin" in a ? (i[0] += a.deltaOrigin[0], i[1] += a.deltaOrigin[1]) : "origin" in a ? (i[0] = a.origin[0] - o[0], i[1] = a.origin[1] - o[1]) : ("x" in a ? r = a.x - n.left : "deltaX" in a && (r += a.deltaX), "y" in a ? s = a.y - n.top : "deltaY" in a && (s += a.deltaY)), { datas: e, distX: r, distY: s, distOrigin: i };
      },
      requestEnd() {
        return { datas: e, isDrag: !0 };
      }
    };
  }
};
function nf(t, e, n, r) {
  const s = t.filter(({ virtual: c, horizontal: l }) => l && !c).length, o = t.filter(({ virtual: c, vertical: l }) => l && !c).length;
  let i = -1;
  if (e === 0 && (s === 0 ? i = 0 : s === 1 && (i = 1)), e === 2 && (s <= 2 ? i = 2 : s <= 3 && (i = 3)), e === 3 && (o === 0 ? i = 4 : o < 4 && (i = 7)), e === 1 && (o <= 1 ? i = 5 : o <= 2 && (i = 6)), i === -1 || !t[i].virtual)
    return;
  const a = t[i];
  rf(t, i), i < 4 ? a.pos[0] = n : a.pos[1] = r;
}
function rf(t, e) {
  e < 4 ? t.slice(0, e + 1).forEach((n) => {
    n.virtual = !1;
  }) : (t[0].virtual && (t[0].virtual = !1), t.slice(4, e + 1).forEach((n) => {
    n.virtual = !1;
  }));
}
function sf(t, e) {
  e < 4 ? t.slice(e, 4).forEach((n) => {
    n.virtual = !0;
  }) : t.slice(e).forEach((n) => {
    n.virtual = !0;
  });
}
function So(t, e, n, r = [0, 0], s) {
  let o = [];
  return !t || t === "0px" ? o = [] : o = ce(t), Fu(o, e, n, 0, 0, r, s);
}
function Eo(t, e, n, r, s) {
  const o = t.state, {
    width: i,
    height: a
  } = o, {
    raws: c,
    styles: l,
    radiusPoses: u
  } = Ds(
    s,
    t.props.roundRelative,
    i,
    a
  ), {
    horizontals: f,
    verticals: d
  } = Wu(u, c), p = l.join(" ");
  o.borderRadiusState = p;
  const g = et(t, e, {
    horizontals: f,
    verticals: d,
    borderRadius: p,
    width: i,
    height: a,
    delta: r,
    dist: n,
    ...It({
      borderRadius: p
    }, e)
  });
  return j(t, "onRound", g), g;
}
function Co(t) {
  var r;
  const {
    style: e
  } = t.getState();
  let n = e.borderRadius || "";
  if (!n && t.props.groupable) {
    const s = t.moveables[0], o = t.getTargets()[0];
    o && ((s == null ? void 0 : s.props.target) === o ? (n = ((r = t.moveables[0]) == null ? void 0 : r.state.style.borderRadius) ?? "", e.borderRadius = n) : (n = vs(o).borderRadius, e.borderRadius = n));
  }
  return n;
}
const of = {
  name: "roundable",
  props: [
    "roundable",
    "roundRelative",
    "minRoundControls",
    "maxRoundControls",
    "roundClickable",
    "roundPadding",
    "isDisplayShadowRoundControls"
  ],
  events: [
    "roundStart",
    "round",
    "roundEnd",
    "roundGroupStart",
    "roundGroup",
    "roundGroupEnd"
  ],
  css: [
    `.control.border-radius {
background: #d66;
cursor: pointer;
z-index: 3;
}`,
    `.control.border-radius.vertical {
background: #d6d;
z-index: 2;
}`,
    `.control.border-radius.virtual {
opacity: 0.5;
z-index: 1;
}`,
    `:host.round-line-clickable .line.direction {
cursor: pointer;
}`
  ],
  className(t) {
    const e = t.props.roundClickable;
    return e === !0 || e === "line" ? U("round-line-clickable") : "";
  },
  requestStyle() {
    return ["borderRadius"];
  },
  requestChildStyle() {
    return ["borderRadius"];
  },
  render(t, e) {
    const {
      target: n,
      width: r,
      height: s,
      allMatrix: o,
      is3d: i,
      left: a,
      top: c,
      borderRadiusState: l
    } = t.getState(), {
      minRoundControls: u = [0, 0],
      maxRoundControls: f = [4, 4],
      zoom: d,
      roundPadding: p = 0,
      isDisplayShadowRoundControls: g,
      groupable: h
    } = t.props;
    if (!n)
      return null;
    const v = l || Co(t), m = i ? 4 : 3, S = So(
      v,
      r,
      s,
      u,
      !0
    );
    if (!S)
      return null;
    let x = 0, C = 0;
    const E = h ? [0, 0] : [a, c];
    return S.map((D, R) => {
      const y = D.horizontal, M = D.vertical, P = D.direction || "", _ = [...D.pos];
      C += Math.abs(y), x += Math.abs(M), y && P.indexOf("n") > -1 && (_[1] -= p), M && P.indexOf("w") > -1 && (_[0] -= p), y && P.indexOf("s") > -1 && (_[1] += p), M && P.indexOf("e") > -1 && (_[0] += p);
      const O = K(ht(o, _, m), E), T = g && g !== "horizontal", w = D.vertical ? x <= f[1] && (T || !D.virtual) : C <= f[0] && (g || !D.virtual);
      return /* @__PURE__ */ it.jsx(
        "div",
        {
          className: U(
            "control",
            "border-radius",
            D.vertical ? "vertical" : "",
            D.virtual ? "virtual" : ""
          ),
          "data-radius-index": R,
          style: {
            display: w ? "block" : "none",
            transform: `translate(${O[0]}px, ${O[1]}px) scale(${d})`
          }
        },
        `borderRadiusControl${R}`
      );
    });
  },
  dragControlCondition(t, e) {
    if (!e.inputEvent || e.isRequest)
      return !1;
    const n = e.inputEvent.target.getAttribute("class") || "";
    return n.indexOf("border-radius") > -1 || n.indexOf("moveable-line") > -1 && n.indexOf("moveable-direction") > -1;
  },
  dragGroupControlCondition(t, e) {
    return this.dragControlCondition(t, e);
  },
  dragControlStart(t, e) {
    const { inputEvent: n, datas: r } = e, s = n.target, o = s.getAttribute("class") || "", i = o.indexOf("border-radius") > -1, a = o.indexOf("moveable-line") > -1 && o.indexOf("moveable-direction") > -1, c = i ? parseInt(s.getAttribute("data-radius-index"), 10) : -1;
    let l = -1;
    if (a) {
      const x = s.getAttribute("data-line-key") || "";
      x && (l = parseInt(x.replace(/render-line-/g, ""), 10), isNaN(l) && (l = -1));
    }
    if (!i && !a)
      return !1;
    const u = et(t, e, {});
    if (j(
      t,
      "onRoundStart",
      u
    ) === !1)
      return !1;
    r.lineIndex = l, r.controlIndex = c, r.isControl = i, r.isLine = a, Re(t, e);
    const {
      roundRelative: d,
      minRoundControls: p = [0, 0]
    } = t.props, g = t.state, {
      width: h,
      height: v
    } = g;
    r.isRound = !0, r.prevDist = [0, 0];
    const m = Co(t), S = So(
      m || "",
      h,
      v,
      p,
      !0
    ) || [];
    return r.controlPoses = S, g.borderRadiusState = Ds(
      S,
      d,
      h,
      v
    ).styles.join(" "), u;
  },
  dragControl(t, e) {
    const { datas: n } = e, r = n.controlPoses;
    if (!n.isRound || !n.isControl || !r.length)
      return !1;
    const s = n.controlIndex, [o, i] = Qt(e), a = [o, i], c = K(a, n.prevDist), {
      maxRoundControls: l = [4, 4]
    } = t.props, { width: u, height: f } = t.state, d = r[s], p = d.vertical, g = d.horizontal, h = r.map((m) => {
      const { horizontal: S, vertical: x } = m, C = [
        S * g * a[0],
        x * p * a[1]
      ];
      if (S) {
        if (l[0] === 1)
          return C;
        if (l[0] < 4 && S !== g)
          return C;
      } else {
        if (l[1] === 0)
          return C[1] = x * g * a[0] / u * f, C;
        if (p) {
          if (l[1] === 1)
            return C;
          if (l[1] < 4 && x !== p)
            return C;
        }
      }
      return [0, 0];
    });
    h[s] = a;
    const v = r.map((m, S) => ({
      ...m,
      pos: at(m.pos, h[S])
    }));
    return s < 4 ? v.slice(0, s + 1).forEach((m) => {
      m.virtual = !1;
    }) : v.slice(4, s + 1).forEach((m) => {
      m.virtual = !1;
    }), n.prevDist = [o, i], Eo(
      t,
      e,
      a,
      c,
      v
    );
  },
  dragControlEnd(t, e) {
    const n = t.state;
    n.borderRadiusState = "";
    const { datas: r, isDouble: s } = e;
    if (!r.isRound)
      return !1;
    const {
      isControl: o,
      controlIndex: i,
      isLine: a,
      lineIndex: c
    } = r, l = r.controlPoses, u = l.filter(({ virtual: p }) => p).length, {
      roundClickable: f = !0
    } = t.props;
    if (s && f) {
      if (o && (f === !0 || f === "control"))
        sf(l, i);
      else if (a && (f === !0 || f === "line")) {
        const [p, g] = ni(t, e);
        nf(l, c, p, g);
      }
      u !== l.filter(({ virtual: p }) => p).length && Eo(
        t,
        e,
        [0, 0],
        [0, 0],
        l
      );
    }
    const d = $t(t, e, {});
    return j(t, "onRoundEnd", d), n.borderRadiusState = "", d;
  },
  dragGroupControlStart(t, e) {
    const n = this.dragControlStart(t, e);
    if (!n)
      return !1;
    const r = t.moveables, s = t.props.targets, o = Ht(t, "roundable", e), i = {
      targets: t.props.targets,
      events: o.map((a, c) => ({
        ...a,
        target: s[c],
        moveable: r[c],
        currentTarget: r[c]
      })),
      ...n
    };
    return j(t, "onRoundGroupStart", i), n;
  },
  dragGroupControl(t, e) {
    const n = this.dragControl(t, e);
    if (!n)
      return !1;
    const r = t.moveables, s = t.props.targets, o = Ht(t, "roundable", e), i = {
      targets: t.props.targets,
      events: o.map((a, c) => ({
        ...a,
        target: s[c],
        moveable: r[c],
        currentTarget: r[c],
        ...It({
          borderRadius: n.borderRadius
        }, a)
      })),
      ...n
    };
    return j(t, "onRoundGroup", i), i;
  },
  dragGroupControlEnd(t, e) {
    const n = t.moveables, r = t.props.targets, s = Ht(t, "roundable", e);
    Qn(t, "onRound", (a) => {
      const c = {
        targets: t.props.targets,
        events: s.map((l, u) => ({
          ...l,
          target: r[u],
          moveable: n[u],
          currentTarget: n[u],
          ...It({
            borderRadius: a.borderRadius
          }, l)
        })),
        ...a
      };
      j(t, "onRoundGroup", c);
    });
    const o = this.dragControlEnd(t, e);
    if (!o)
      return !1;
    const i = {
      targets: t.props.targets,
      events: s.map((a, c) => {
        var l;
        return {
          ...a,
          target: r[c],
          moveable: n[c],
          currentTarget: n[c],
          lastEvent: (l = a.datas) == null ? void 0 : l.lastEvent
        };
      }),
      ...o
    };
    return j(t, "onRoundGroupEnd", i), i;
  },
  unset(t) {
    t.state.borderRadiusState = "";
  }
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Nr = function(t, e) {
  return Nr = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var s in r) r.hasOwnProperty(s) && (n[s] = r[s]);
  }, Nr(t, e);
};
function af(t, e) {
  Nr(t, e);
  function n() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n());
}
var Ct = function() {
  return Ct = Object.assign || function(e) {
    for (var n, r = 1, s = arguments.length; r < s; r++) {
      n = arguments[r];
      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, Ct.apply(this, arguments);
};
function cf(t, e) {
  var n = e[0] - t[0], r = e[1] - t[1], s = Math.atan2(r, n);
  return s >= 0 ? s : s + Math.PI * 2;
}
function vr(t) {
  return cf([
    t[0].clientX,
    t[0].clientY
  ], [
    t[1].clientX,
    t[1].clientY
  ]) / Math.PI * 180;
}
function lf(t) {
  return t.touches && t.touches.length >= 2;
}
function On(t) {
  return t ? t.touches ? ff(t.touches) : [na(t)] : [];
}
function uf(t) {
  return t && (t.type.indexOf("mouse") > -1 || "button" in t);
}
function Do(t, e, n) {
  var r = n.length, s = rn(t, r), o = s.clientX, i = s.clientY, a = s.originalClientX, c = s.originalClientY, l = rn(e, r), u = l.clientX, f = l.clientY, d = rn(n, r), p = d.clientX, g = d.clientY, h = o - u, v = i - f, m = o - p, S = i - g;
  return {
    clientX: a,
    clientY: c,
    deltaX: h,
    deltaY: v,
    distX: m,
    distY: S
  };
}
function mr(t) {
  return Math.sqrt(Math.pow(t[0].clientX - t[1].clientX, 2) + Math.pow(t[0].clientY - t[1].clientY, 2));
}
function ff(t) {
  for (var e = Math.min(t.length, 2), n = [], r = 0; r < e; ++r)
    n.push(na(t[r]));
  return n;
}
function na(t) {
  return {
    clientX: t.clientX,
    clientY: t.clientY
  };
}
function rn(t, e) {
  e === void 0 && (e = t.length);
  for (var n = {
    clientX: 0,
    clientY: 0,
    originalClientX: 0,
    originalClientY: 0
  }, r = Math.min(t.length, e), s = 0; s < r; ++s) {
    var o = t[s];
    n.originalClientX += "originalClientX" in o ? o.originalClientX : o.clientX, n.originalClientY += "originalClientY" in o ? o.originalClientY : o.clientY, n.clientX += o.clientX, n.clientY += o.clientY;
  }
  return e ? {
    clientX: n.clientX / e,
    clientY: n.clientY / e,
    originalClientX: n.originalClientX / e,
    originalClientY: n.originalClientY / e
  } : n;
}
var xr = /* @__PURE__ */ function() {
  function t(e) {
    this.prevClients = [], this.startClients = [], this.movement = 0, this.length = 0, this.startClients = e, this.prevClients = e, this.length = e.length;
  }
  return t.prototype.getAngle = function(e) {
    return e === void 0 && (e = this.prevClients), vr(e);
  }, t.prototype.getRotation = function(e) {
    return e === void 0 && (e = this.prevClients), vr(e) - vr(this.startClients);
  }, t.prototype.getPosition = function(e, n) {
    e === void 0 && (e = this.prevClients);
    var r = Do(e || this.prevClients, this.prevClients, this.startClients), s = r.deltaX, o = r.deltaY;
    return this.movement += Math.sqrt(s * s + o * o), this.prevClients = e, r;
  }, t.prototype.getPositions = function(e) {
    e === void 0 && (e = this.prevClients);
    for (var n = this.prevClients, r = this.startClients, s = Math.min(this.length, n.length), o = [], i = 0; i < s; ++i)
      o[i] = Do([e[i]], [n[i]], [r[i]]);
    return o;
  }, t.prototype.getMovement = function(e) {
    var n = this.movement;
    if (!e)
      return n;
    var r = rn(e, this.length), s = rn(this.prevClients, this.length), o = r.clientX - s.clientX, i = r.clientY - s.clientY;
    return Math.sqrt(o * o + i * i) + n;
  }, t.prototype.getDistance = function(e) {
    return e === void 0 && (e = this.prevClients), mr(e);
  }, t.prototype.getScale = function(e) {
    return e === void 0 && (e = this.prevClients), mr(e) / mr(this.startClients);
  }, t.prototype.move = function(e, n) {
    this.startClients.forEach(function(r) {
      r.clientX -= e, r.clientY -= n;
    }), this.prevClients.forEach(function(r) {
      r.clientX -= e, r.clientY -= n;
    });
  }, t;
}(), bo = ["textarea", "input"], df = /* @__PURE__ */ function(t) {
  af(e, t);
  function e(n, r) {
    r === void 0 && (r = {});
    var s = t.call(this) || this;
    s.options = {}, s.flag = !1, s.pinchFlag = !1, s.data = {}, s.isDrag = !1, s.isPinch = !1, s.clientStores = [], s.targets = [], s.prevTime = 0, s.doubleFlag = !1, s._useMouse = !1, s._useTouch = !1, s._useDrag = !1, s._dragFlag = !1, s._isTrusted = !1, s._isMouseEvent = !1, s._isSecondaryButton = !1, s._preventMouseEvent = !1, s._prevInputEvent = null, s._isDragAPI = !1, s._isIdle = !0, s._preventMouseEventId = 0, s._window = window, s.onDragStart = function(d, p) {
      if (p === void 0 && (p = !0), !(!s.flag && d.cancelable === !1)) {
        var g = d.type.indexOf("drag") >= -1;
        if (!(s.flag && g)) {
          s._isDragAPI = !0;
          var h = s.options, v = h.container, m = h.pinchOutside, S = h.preventWheelClick, x = h.preventRightClick, C = h.preventDefault, E = h.checkInput, D = h.dragFocusedInput, R = h.preventClickEventOnDragStart, y = h.preventClickEventOnDrag, M = h.preventClickEventByCondition, P = s._useTouch, _ = !s.flag;
          if (s._isSecondaryButton = d.which === 3 || d.button === 2, S && (d.which === 2 || d.button === 1) || x && (d.which === 3 || d.button === 2))
            return s.stop(), !1;
          if (_) {
            var O = s._window.document.activeElement, T = d.target;
            if (T) {
              var w = T.tagName.toLowerCase(), k = bo.indexOf(w) > -1, I = T.isContentEditable;
              if (k || I) {
                if (E || !D && O === T)
                  return !1;
                if (O && (O === T || I && O.isContentEditable && O.contains(T)))
                  if (D)
                    T.blur();
                  else
                    return !1;
              } else if ((C || d.type === "touchstart") && O) {
                var $ = O.tagName.toLowerCase();
                (O.isContentEditable || bo.indexOf($) > -1) && O.blur();
              }
              (R || y || M) && Pt(s._window, "click", s._onClick, !0);
            }
            s.clientStores = [new xr(On(d))], s._isIdle = !1, s.flag = !0, s.isDrag = !1, s._isTrusted = p, s._dragFlag = !0, s._prevInputEvent = d, s.data = {}, s.doubleFlag = cn() - s.prevTime < 200, s._isMouseEvent = uf(d), !s._isMouseEvent && s._preventMouseEvent && s._allowMouseEvent();
            var G = s._preventMouseEvent || s.emit("dragStart", Ct(Ct({ data: s.data, datas: s.data, inputEvent: d, isMouseEvent: s._isMouseEvent, isSecondaryButton: s._isSecondaryButton, isTrusted: p, isDouble: s.doubleFlag }, s.getCurrentStore().getPosition()), { preventDefault: function() {
              d.preventDefault();
            }, preventDrag: function() {
              s._dragFlag = !1;
            } }));
            G === !1 && s.stop(), s._isMouseEvent && s.flag && C && d.preventDefault();
          }
          if (!s.flag)
            return !1;
          var L = 0;
          if (_ ? (s._attchDragEvent(), P && m && (L = setTimeout(function() {
            Pt(v, "touchstart", s.onDragStart, {
              passive: !1
            });
          }))) : P && m && Mt(v, "touchstart", s.onDragStart), s.flag && lf(d)) {
            if (clearTimeout(L), _ && d.touches.length !== d.changedTouches.length)
              return;
            s.pinchFlag || s.onPinchStart(d);
          }
        }
      }
    }, s.onDrag = function(d, p) {
      if (s.flag) {
        var g = s.options.preventDefault;
        !s._isMouseEvent && g && d.preventDefault(), s._prevInputEvent = d;
        var h = On(d), v = s.moveClients(h, d, !1);
        if (s._dragFlag) {
          if (s.pinchFlag || v.deltaX || v.deltaY) {
            var m = s._preventMouseEvent || s.emit("drag", Ct(Ct({}, v), { isScroll: !!p, inputEvent: d }));
            if (m === !1) {
              s.stop();
              return;
            }
          }
          s.pinchFlag && s.onPinch(d, h);
        }
        s.getCurrentStore().getPosition(h, !0);
      }
    }, s.onDragEnd = function(d) {
      if (s.flag) {
        var p = s.options, g = p.pinchOutside, h = p.container, v = p.preventClickEventOnDrag, m = p.preventClickEventOnDragStart, S = p.preventClickEventByCondition, x = s.isDrag;
        (v || m || S) && requestAnimationFrame(function() {
          s._allowClickEvent();
        }), !S && !m && v && !x && s._allowClickEvent(), s._useTouch && g && Mt(h, "touchstart", s.onDragStart), s.pinchFlag && s.onPinchEnd(d);
        var C = d != null && d.touches ? On(d) : [], E = C.length;
        E === 0 || !s.options.keepDragging ? s.flag = !1 : s._addStore(new xr(C));
        var D = s._getPosition(), R = cn(), y = !x && s.doubleFlag;
        s._prevInputEvent = null, s.prevTime = x || y ? 0 : R, s.flag || (s._dettachDragEvent(), s._preventMouseEvent || s.emit("dragEnd", Ct({ data: s.data, datas: s.data, isDouble: y, isDrag: x, isClick: !x, isMouseEvent: s._isMouseEvent, isSecondaryButton: s._isSecondaryButton, inputEvent: d, isTrusted: s._isTrusted }, D)), s.clientStores = [], s._isMouseEvent || (s._preventMouseEvent = !0, clearTimeout(s._preventMouseEventId), s._preventMouseEventId = setTimeout(function() {
          s._preventMouseEvent = !1;
        }, 200)), s._isIdle = !0);
      }
    }, s.onBlur = function() {
      s.onDragEnd();
    }, s._allowClickEvent = function() {
      Mt(s._window, "click", s._onClick, !0);
    }, s._onClick = function(d) {
      s._allowClickEvent(), s._allowMouseEvent();
      var p = s.options.preventClickEventByCondition;
      p != null && p(d) || (d.stopPropagation(), d.preventDefault());
    }, s._onContextMenu = function(d) {
      var p = s.options;
      p.preventRightClick ? s.onDragEnd(d) : d.preventDefault();
    }, s._passCallback = function() {
    };
    var o = [].concat(n), i = o[0];
    s._window = Jo(i) ? i : ae(i), s.options = Ct({ checkInput: !1, container: i && !("document" in i) ? ae(i) : i, preventRightClick: !0, preventWheelClick: !0, preventClickEventOnDragStart: !1, preventClickEventOnDrag: !1, preventClickEventByCondition: null, preventDefault: !0, checkWindowBlur: !1, keepDragging: !1, pinchThreshold: 0, events: ["touch", "mouse"] }, r);
    var a = s.options, c = a.container, l = a.events, u = a.checkWindowBlur;
    if (s._useDrag = l.indexOf("drag") > -1, s._useTouch = l.indexOf("touch") > -1, s._useMouse = l.indexOf("mouse") > -1, s.targets = o, s._useDrag && o.forEach(function(d) {
      Pt(d, "dragstart", s.onDragStart);
    }), s._useMouse && (o.forEach(function(d) {
      Pt(d, "mousedown", s.onDragStart), Pt(d, "mousemove", s._passCallback);
    }), Pt(c, "contextmenu", s._onContextMenu)), u && Pt(ae(), "blur", s.onBlur), s._useTouch) {
      var f = {
        passive: !1
      };
      o.forEach(function(d) {
        Pt(d, "touchstart", s.onDragStart, f), Pt(d, "touchmove", s._passCallback, f);
      });
    }
    return s;
  }
  return e.prototype.stop = function() {
    this.isDrag = !1, this.data = {}, this.clientStores = [], this.pinchFlag = !1, this.doubleFlag = !1, this.prevTime = 0, this.flag = !1, this._isIdle = !0, this._allowClickEvent(), this._dettachDragEvent(), this._isDragAPI = !1;
  }, e.prototype.getMovement = function(n) {
    return this.getCurrentStore().getMovement(n) + this.clientStores.slice(1).reduce(function(r, s) {
      return r + s.movement;
    }, 0);
  }, e.prototype.isDragging = function() {
    return this.isDrag;
  }, e.prototype.isIdle = function() {
    return this._isIdle;
  }, e.prototype.isFlag = function() {
    return this.flag;
  }, e.prototype.isPinchFlag = function() {
    return this.pinchFlag;
  }, e.prototype.isDoubleFlag = function() {
    return this.doubleFlag;
  }, e.prototype.isPinching = function() {
    return this.isPinch;
  }, e.prototype.scrollBy = function(n, r, s, o) {
    o === void 0 && (o = !0), this.flag && (this.clientStores[0].move(n, r), o && this.onDrag(s, !0));
  }, e.prototype.move = function(n, r) {
    var s = n[0], o = n[1], i = this.getCurrentStore(), a = i.prevClients;
    return this.moveClients(a.map(function(c) {
      var l = c.clientX, u = c.clientY;
      return {
        clientX: l + s,
        clientY: u + o,
        originalClientX: l,
        originalClientY: u
      };
    }), r, !0);
  }, e.prototype.triggerDragStart = function(n) {
    this.onDragStart(n, !1);
  }, e.prototype.setEventData = function(n) {
    var r = this.data;
    for (var s in n)
      r[s] = n[s];
    return this;
  }, e.prototype.setEventDatas = function(n) {
    return this.setEventData(n);
  }, e.prototype.getCurrentEvent = function(n) {
    return n === void 0 && (n = this._prevInputEvent), Ct(Ct({ data: this.data, datas: this.data }, this._getPosition()), { movement: this.getMovement(), isDrag: this.isDrag, isPinch: this.isPinch, isScroll: !1, inputEvent: n });
  }, e.prototype.getEventData = function() {
    return this.data;
  }, e.prototype.getEventDatas = function() {
    return this.data;
  }, e.prototype.unset = function() {
    var n = this, r = this.targets, s = this.options.container;
    this.off(), Mt(this._window, "blur", this.onBlur), this._useDrag && r.forEach(function(o) {
      Mt(o, "dragstart", n.onDragStart);
    }), this._useMouse && (r.forEach(function(o) {
      Mt(o, "mousedown", n.onDragStart);
    }), Mt(s, "contextmenu", this._onContextMenu)), this._useTouch && (r.forEach(function(o) {
      Mt(o, "touchstart", n.onDragStart);
    }), Mt(s, "touchstart", this.onDragStart)), this._prevInputEvent = null, this._allowClickEvent(), this._dettachDragEvent();
  }, e.prototype.onPinchStart = function(n) {
    var r = this, s = this.options.pinchThreshold;
    if (!(this.isDrag && this.getMovement() > s)) {
      var o = new xr(On(n));
      this.pinchFlag = !0, this._addStore(o);
      var i = this.emit("pinchStart", Ct(Ct({ data: this.data, datas: this.data, angle: o.getAngle(), touches: this.getCurrentStore().getPositions() }, o.getPosition()), { inputEvent: n, isTrusted: this._isTrusted, preventDefault: function() {
        n.preventDefault();
      }, preventDrag: function() {
        r._dragFlag = !1;
      } }));
      i === !1 && (this.pinchFlag = !1);
    }
  }, e.prototype.onPinch = function(n, r) {
    if (!(!this.flag || !this.pinchFlag || r.length < 2)) {
      var s = this.getCurrentStore();
      this.isPinch = !0, this.emit("pinch", Ct(Ct({ data: this.data, datas: this.data, movement: this.getMovement(r), angle: s.getAngle(r), rotation: s.getRotation(r), touches: s.getPositions(r), scale: s.getScale(r), distance: s.getDistance(r) }, s.getPosition(r)), { inputEvent: n, isTrusted: this._isTrusted }));
    }
  }, e.prototype.onPinchEnd = function(n) {
    if (this.pinchFlag) {
      var r = this.isPinch;
      this.isPinch = !1, this.pinchFlag = !1;
      var s = this.getCurrentStore();
      this.emit("pinchEnd", Ct(Ct({ data: this.data, datas: this.data, isPinch: r, touches: s.getPositions() }, s.getPosition()), { inputEvent: n }));
    }
  }, e.prototype.getCurrentStore = function() {
    return this.clientStores[0];
  }, e.prototype.moveClients = function(n, r, s) {
    var o = this._getPosition(n, s), i = this.isDrag;
    (o.deltaX || o.deltaY) && (this.isDrag = !0);
    var a = !1;
    return !i && this.isDrag && (a = !0), Ct(Ct({ data: this.data, datas: this.data }, o), { movement: this.getMovement(n), isDrag: this.isDrag, isPinch: this.isPinch, isScroll: !1, isMouseEvent: this._isMouseEvent, isSecondaryButton: this._isSecondaryButton, inputEvent: r, isTrusted: this._isTrusted, isFirstDrag: a });
  }, e.prototype._addStore = function(n) {
    this.clientStores.splice(0, 0, n);
  }, e.prototype._getPosition = function(n, r) {
    var s = this.getCurrentStore(), o = s.getPosition(n, r), i = this.clientStores.slice(1).reduce(function(l, u) {
      var f = u.getPosition();
      return l.distX += f.distX, l.distY += f.distY, l;
    }, o), a = i.distX, c = i.distY;
    return Ct(Ct({}, o), { distX: a, distY: c });
  }, e.prototype._attchDragEvent = function() {
    var n = this._window, r = this.options.container, s = {
      passive: !1
    };
    this._isDragAPI && (Pt(r, "dragover", this.onDrag, s), Pt(n, "dragend", this.onDragEnd)), this._useMouse && (Pt(r, "mousemove", this.onDrag), Pt(n, "mouseup", this.onDragEnd)), this._useTouch && (Pt(r, "touchmove", this.onDrag, s), Pt(n, "touchend", this.onDragEnd, s), Pt(n, "touchcancel", this.onDragEnd, s));
  }, e.prototype._dettachDragEvent = function() {
    var n = this._window, r = this.options.container;
    this._isDragAPI && (Mt(r, "dragover", this.onDrag), Mt(n, "dragend", this.onDragEnd)), this._useMouse && (Mt(r, "mousemove", this.onDrag), Mt(n, "mouseup", this.onDragEnd)), this._useTouch && (Mt(r, "touchstart", this.onDragStart), Mt(r, "touchmove", this.onDrag), Mt(n, "touchend", this.onDragEnd), Mt(n, "touchcancel", this.onDragEnd));
  }, e.prototype._allowMouseEvent = function() {
    this._preventMouseEvent = !1, clearTimeout(this._preventMouseEventId);
  }, e;
}(Cs);
function pf(t, e) {
  const r = gt(e ? 4 : 3), s = `matrix${e ? "3d" : ""}(${r.join(",")})`;
  return t === s || t === "matrix(1,0,0,1,0,0)";
}
const ra = {
  isPinch: !0,
  name: "beforeRenderable",
  props: [],
  events: [
    "beforeRenderStart",
    "beforeRender",
    "beforeRenderEnd",
    "beforeRenderGroupStart",
    "beforeRenderGroup",
    "beforeRenderGroupEnd"
  ],
  dragRelation: "weak",
  setTransform(t, e) {
    const {
      is3d: n,
      targetMatrix: r,
      inlineTransform: s
    } = t.state, o = n ? `matrix3d(${r.join(",")})` : `matrix(${ei(r, !0)})`, i = !s || s === "none" ? o : s;
    e.datas.startTransforms = pf(i, n) ? [] : ce(i);
  },
  resetStyle(t) {
    const e = t.datas;
    e.nextStyle = {}, e.nextTransforms = t.datas.startTransforms, e.nextTransformAppendedIndexes = [];
  },
  fillDragStartParams(t, e) {
    return et(t, e, {
      setTransform: (n) => {
        e.datas.startTransforms = Rt(n) ? n : ce(n);
      },
      isPinch: !!e.isPinch
    });
  },
  fillDragParams(t, e) {
    return et(t, e, {
      isPinch: !!e.isPinch
    });
  },
  dragStart(t, e) {
    this.setTransform(t, e), this.resetStyle(e), j(t, "onBeforeRenderStart", this.fillDragStartParams(t, e));
  },
  drag(t, e) {
    e.datas.startTransforms || this.setTransform(t, e), this.resetStyle(e), j(t, "onBeforeRender", et(t, e, {
      isPinch: !!e.isPinch
    }));
  },
  dragEnd(t, e) {
    e.datas.startTransforms || (this.setTransform(t, e), this.resetStyle(e)), j(t, "onBeforeRenderEnd", et(t, e, {
      isPinch: !!e.isPinch,
      isDrag: e.isDrag
    }));
  },
  dragGroupStart(t, e) {
    this.dragStart(t, e);
    const n = Ht(t, "beforeRenderable", e), r = t.moveables, s = n.map((o, i) => {
      const a = r[i];
      return this.setTransform(a, o), this.resetStyle(o), this.fillDragStartParams(a, o);
    });
    j(t, "onBeforeRenderGroupStart", et(t, e, {
      isPinch: !!e.isPinch,
      targets: t.props.targets,
      setTransform() {
      },
      events: s
    }));
  },
  dragGroup(t, e) {
    this.drag(t, e);
    const n = Ht(t, "beforeRenderable", e), r = t.moveables, s = n.map((o, i) => {
      const a = r[i];
      return this.resetStyle(o), this.fillDragParams(a, o);
    });
    j(t, "onBeforeRenderGroup", et(t, e, {
      isPinch: !!e.isPinch,
      targets: t.props.targets,
      events: s
    }));
  },
  dragGroupEnd(t, e) {
    this.dragEnd(t, e), j(t, "onBeforeRenderGroupEnd", et(t, e, {
      isPinch: !!e.isPinch,
      isDrag: e.isDrag,
      targets: t.props.targets
    }));
  },
  dragControlStart(t, e) {
    return this.dragStart(t, e);
  },
  dragControl(t, e) {
    return this.drag(t, e);
  },
  dragControlEnd(t, e) {
    return this.dragEnd(t, e);
  },
  dragGroupControlStart(t, e) {
    return this.dragGroupStart(t, e);
  },
  dragGroupControl(t, e) {
    return this.dragGroup(t, e);
  },
  dragGroupControlEnd(t, e) {
    return this.dragGroupEnd(t, e);
  }
}, sa = {
  name: "renderable",
  props: [],
  events: [
    "renderStart",
    "render",
    "renderEnd",
    "renderGroupStart",
    "renderGroup",
    "renderGroupEnd"
  ],
  dragRelation: "weak",
  dragStart(t, e) {
    j(t, "onRenderStart", et(t, e, {
      isPinch: !!e.isPinch
    }));
  },
  drag(t, e) {
    j(t, "onRender", this.fillDragParams(t, e));
  },
  dragAfter(t, e) {
    return this.drag(t, e);
  },
  dragEnd(t, e) {
    j(t, "onRenderEnd", this.fillDragEndParams(t, e));
  },
  dragGroupStart(t, e) {
    j(t, "onRenderGroupStart", et(t, e, {
      isPinch: !!e.isPinch,
      targets: t.props.targets
    }));
  },
  dragGroup(t, e) {
    const n = Ht(t, "beforeRenderable", e), r = t.moveables, s = n.map((o, i) => {
      const a = r[i];
      return this.fillDragParams(a, o);
    });
    j(t, "onRenderGroup", et(t, e, {
      isPinch: !!e.isPinch,
      targets: t.props.targets,
      transform: Dn(e),
      transformObject: {},
      ...It(bn(e)),
      events: s
    }));
  },
  dragGroupEnd(t, e) {
    const n = Ht(t, "beforeRenderable", e), r = t.moveables, s = n.map((o, i) => {
      const a = r[i];
      return this.fillDragEndParams(a, o);
    });
    j(t, "onRenderGroupEnd", et(t, e, {
      isPinch: !!e.isPinch,
      isDrag: e.isDrag,
      targets: t.props.targets,
      events: s,
      transformObject: {},
      transform: Dn(e),
      ...It(bn(e))
    }));
  },
  dragControlStart(t, e) {
    return this.dragStart(t, e);
  },
  dragControl(t, e) {
    return this.drag(t, e);
  },
  dragControlAfter(t, e) {
    return this.dragAfter(t, e);
  },
  dragControlEnd(t, e) {
    return this.dragEnd(t, e);
  },
  dragGroupControlStart(t, e) {
    return this.dragGroupStart(t, e);
  },
  dragGroupControl(t, e) {
    return this.dragGroup(t, e);
  },
  dragGroupControlEnd(t, e) {
    return this.dragGroupEnd(t, e);
  },
  fillDragParams(t, e) {
    const n = {};
    return $e(Gn(e) || []).forEach((r) => {
      n[r.name] = r.functionValue;
    }), et(t, e, {
      isPinch: !!e.isPinch,
      transformObject: n,
      transform: Dn(e),
      ...It(bn(e))
    });
  },
  fillDragEndParams(t, e) {
    const n = {};
    return $e(Gn(e) || []).forEach((r) => {
      n[r.name] = r.functionValue;
    }), et(t, e, {
      isPinch: !!e.isPinch,
      isDrag: e.isDrag,
      transformObject: n,
      transform: Dn(e),
      ...It(bn(e))
    });
  }
};
function sn(t, e, n, r, s, o, i) {
  o.clientDistX = o.distX, o.clientDistY = o.distY;
  const a = s === "Start", c = s === "End", l = s === "After", u = t.state.target, f = o.isRequest, d = r.indexOf("Control") > -1;
  if (!u || a && d && !f && t.areaElement === o.inputEvent.target)
    return !1;
  const p = [...e];
  if (f) {
    const P = o.requestAble;
    p.some((_) => _.name === P) || p.push(...t.props.ables.filter((_) => _.name === P));
  }
  if (!p.length || p.every((P) => P.dragRelation))
    return !1;
  const g = o.inputEvent;
  let h;
  c && g && (h = document.elementFromPoint(o.clientX, o.clientY) || g.target);
  let v = !1;
  const m = () => {
    var P;
    v = !0, (P = o.stop) == null || P.call(o);
  }, S = a && (!t.targetGesto || !t.controlGesto || !t.targetGesto.isFlag() || !t.controlGesto.isFlag());
  S && t.updateRect(s, !0, !1);
  const x = o.datas, C = d ? "controlGesto" : "targetGesto", E = t[C], D = (P, _, O) => {
    if (!(_ in P) || E !== t[C])
      return !1;
    const T = P.name, w = x[T] || (x[T] = {});
    if (a && (w.isEventStart = !O || !P[O] || P[O](t, o)), !w.isEventStart)
      return !1;
    const k = P[_](t, {
      ...o,
      stop: m,
      datas: w,
      originalDatas: x,
      inputTarget: h
    });
    return t._emitter.off(), a && k === !1 && (w.isEventStart = !1), k;
  };
  S && p.forEach((P) => {
    P.unset && P.unset(t);
  }), D(ra, `drag${r}${s}`);
  let R = 0, y = 0;
  n.forEach((P) => {
    if (v)
      return !1;
    const _ = `${P}${r}${s}`, O = `${P}${r}Condition`;
    s === "" && !f && xu(t.state, o);
    let T = p.filter((I) => I[_]);
    T = T.filter((I, $) => I.name && T.indexOf(I) === $);
    const k = T.filter((I) => D(I, _, O)).length;
    v && ++R, k && ++y, !v && a && T.length && !k && (R += T.filter((I) => {
      const $ = I.name;
      return x[$].isEventStart ? I.dragRelation !== "strong" : !1;
    }).length ? 1 : 0);
  }), (!l || y) && D(sa, `drag${r}${s}`);
  const M = E !== t[C] || R === n.length;
  return (c || v || M) && (t.state.gestos = {}, t.moveables && t.moveables.forEach((P) => {
    P.state.gestos = {};
  }), p.forEach((P) => {
    P.unset && P.unset(t);
  })), a && !M && !f && y && t.props.preventDefault && (o == null || o.preventDefault()), t.isUnmounted || M ? !1 : ((!a && y && !i || c) && (t.props.flushSync || Bi)(() => {
    t.updateRect(c ? s : "", !0, !1), t.forceUpdate();
  }), !a && !c && !l && y && !i && sn(t, e, n, r, s + "After", o), !0);
}
function Rs(t, e) {
  return (n, r = n.inputEvent.target) => {
    var a;
    const s = r, o = t.areaElement, i = t._dragTarget;
    return !i || !e && ((a = t.controlGesto) != null && a.isFlag()) ? !1 : s === i || i.contains(s) || s === o || !t.isMoveableElement(s) && !t.controlBox.contains(s) || bt(s, "moveable-area") || bt(s, "moveable-padding") || bt(s, "moveable-edgeDraggable");
  };
}
function oa(t, e, n) {
  const r = t.controlBox, s = [], o = t.props, i = o.dragArea, a = t.state.target, c = o.dragTarget;
  s.push(r), (!i || c) && s.push(e), !i && c && a && e !== a && o.dragTargetSelf && s.push(a);
  const l = Rs(t);
  return aa(t, s, "targetAbles", n, {
    dragStart: l,
    pinchStart: l
  });
}
function ia(t, e) {
  const n = t.controlBox, r = [];
  r.push(n);
  const s = Rs(t, !0), o = (i, a = i.inputEvent.target) => a === n ? !0 : !s(i, a);
  return aa(t, r, "controlAbles", e, {
    dragStart: o,
    pinchStart: o
  });
}
function aa(t, e, n, r, s = {}) {
  const o = n === "targetAbles", {
    pinchOutside: i,
    pinchThreshold: a,
    preventClickEventOnDrag: c,
    preventClickDefault: l,
    checkInput: u,
    dragFocusedInput: f,
    preventDefault: d = !0,
    preventRightClick: p = !0,
    preventWheelClick: g = !0,
    dragContainer: h
  } = t.props, v = Zt(h, !0), m = {
    preventDefault: d,
    preventRightClick: p,
    preventWheelClick: g,
    container: v || ae(t.getControlBoxElement()),
    pinchThreshold: a,
    pinchOutside: i,
    preventClickEventOnDrag: o ? c : !1,
    preventClickEventOnDragStart: o ? l : !1,
    preventClickEventByCondition: o ? null : (C) => t.controlBox.contains(C.target),
    checkInput: o ? u : !1,
    dragFocusedInput: f
  }, S = new df(e, m), x = r === "Control";
  return ["drag", "pinch"].forEach((C) => {
    ["Start", "", "End"].forEach((E) => {
      S.on(`${C}${E}`, (D) => {
        var O;
        const R = D.eventType, y = C === "drag" && D.isPinch;
        if (s[R] && !s[R](D)) {
          D.stop();
          return;
        }
        if (y)
          return;
        const M = C === "drag" ? [C] : ["drag", C], P = [...t[n]];
        sn(t, P, M, r, E, D) ? (t.props.stopPropagation || E === "Start" && x) && ((O = D == null ? void 0 : D.inputEvent) == null || O.stopPropagation()) : D.stop();
      });
    });
  }), S;
}
class gf {
  constructor(e, n, r) {
    X(this, "ables", []);
    X(this, "_onEvent", (e) => {
      const n = this.eventName, r = this.moveable;
      r.state.disableNativeEvent || this.ables.forEach((s) => {
        s[n](r, {
          inputEvent: e
        });
      });
    });
    this.target = e, this.moveable = n, this.eventName = r, e.addEventListener(r.toLowerCase(), this._onEvent);
  }
  setAbles(e) {
    this.ables = e;
  }
  destroy() {
    this.target.removeEventListener(
      this.eventName.toLowerCase(),
      this._onEvent
    ), this.target = null, this.moveable = null;
  }
}
function hf(t) {
  for (var e = 5381, n = t.length; n; )
    e = e * 33 ^ t.charCodeAt(--n);
  return e >>> 0;
}
var vf = hf;
function mf(t) {
  return vf(t).toString(36);
}
function xf(t) {
  if (t && t.getRootNode) {
    var e = t.getRootNode();
    if (e.nodeType === 11)
      return e;
  }
}
function Sf(t, e, n) {
  return n.original ? e : e.replace(/([^};{\s}][^};{]*|^\s*){/mg, function(r, s) {
    var o = s.trim();
    return (o ? xe(o) : [""]).map(function(i) {
      var a = i.trim();
      return a.indexOf("@") === 0 ? a : a.indexOf(":global") > -1 ? a.replace(/\:global/g, "") : a.indexOf(":host") > -1 ? "".concat(a.replace(/\:host/g, ".".concat(t))) : a ? ".".concat(t, " ").concat(a) : ".".concat(t);
    }).join(", ") + " {";
  });
}
function Ef(t, e, n, r, s) {
  var o = ts(r), i = o.createElement("style");
  return i.setAttribute("type", "text/css"), i.setAttribute("data-styled-id", t), i.setAttribute("data-styled-count", "1"), n.nonce && i.setAttribute("nonce", n.nonce), i.innerHTML = Sf(t, e, n), (s || o.head || o.body).appendChild(i), i;
}
function Cf(t) {
  var e = "rCS" + mf(t);
  return {
    className: e,
    inject: function(n, r) {
      r === void 0 && (r = {});
      var s = xf(n), o = (s || n.ownerDocument || document).querySelector('style[data-styled-id="'.concat(e, '"]'));
      if (!o)
        o = Ef(e, t, r, n, s);
      else {
        var i = parseFloat(o.getAttribute("data-styled-count")) || 0;
        o.setAttribute("data-styled-count", "".concat(i + 1));
      }
      return {
        destroy: function() {
          var a, c = parseFloat(o.getAttribute("data-styled-count")) || 0;
          c <= 1 ? (o.remove ? o.remove() : (a = o.parentNode) === null || a === void 0 || a.removeChild(o), o = null) : o.setAttribute("data-styled-count", "".concat(c - 1));
        }
      };
    }
  };
}
var Wr = function() {
  return Wr = Object.assign || function(e) {
    for (var n, r = 1, s = arguments.length; r < s; r++) {
      n = arguments[r];
      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, Wr.apply(this, arguments);
};
function Df(t, e) {
  var n = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var s = 0, r = Object.getOwnPropertySymbols(t); s < r.length; s++)
    e.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[s]) && (n[r[s]] = t[r[s]]);
  return n;
}
function ca(t, e) {
  var n = Cf(e), r = n.className;
  return La(function(s, o) {
    var i = s.className, a = i === void 0 ? "" : i;
    s.cspNonce;
    var c = Df(s, ["className", "cspNonce"]), l = Na();
    return Wa(o, function() {
      return l.current;
    }, []), Ya(function() {
      var u = n.inject(l.current, {
        nonce: s.cspNonce
      });
      return function() {
        u.destroy();
      };
    }, []), Bn(t, Wr({
      ref: l,
      "data-styled-id": r,
      className: "".concat(a, " ").concat(r)
    }, c));
  });
}
function bf(t, e, n = e, r) {
  var I;
  const {
    matrixes: s,
    is3d: o,
    targetMatrix: i,
    transformOrigin: a,
    targetOrigin: c,
    offsetContainer: l,
    hasFixed: u,
    zoom: f
  } = ci(t, e), {
    matrixes: d,
    is3d: p,
    offsetContainer: g,
    zoom: h
  } = tl(l, n), v = r, m = 4, S = t.tagName.toLowerCase() !== "svg" && "ownerSVGElement" in t;
  let x = i, C = gt(m), E = gt(m), D = gt(m), R = gt(m);
  const y = s.length, M = d.map(($) => ({
    ...$,
    matrix: $.matrix ? [...$.matrix] : void 0
  })).reverse();
  s.reverse(), !o && v && (x = Ut(x, 3, 4), Br(s)), !p && v && Br(M), M.forEach(($) => {
    E = dt(E, $.matrix, m);
  });
  const P = n || fe(t), _ = ((I = M[0]) == null ? void 0 : I.target) || fn(P, P, !0).offsetParent, O = M.slice(1).reduce(($, G) => dt($, G.matrix, m), gt(m));
  s.forEach(($, G) => {
    if (y - 2 === G && (D = C.slice()), y - 1 === G && (R = C.slice()), !$.matrix) {
      const L = s[G + 1], z = gu(
        $,
        L,
        _,
        m,
        dt(O, C, m)
      );
      $.matrix = Ce(z, m);
    }
    C = dt(C, $.matrix, m);
  });
  const T = !S && o;
  x || (x = gt(T ? 4 : 3));
  const w = Jn(
    S && x.length === 16 ? Ut(x, 4, 3) : x,
    T
  ), k = E;
  return E = Qo(E, m, m), {
    hasZoom: f !== 1 || h !== 1,
    hasFixed: u,
    matrixes: s,
    rootMatrix: E,
    originalRootMatrix: k,
    beforeMatrix: D,
    offsetMatrix: R,
    allMatrix: C,
    targetMatrix: x,
    targetTransform: w,
    inlineTransform: t.style.transform,
    transformOrigin: a,
    targetOrigin: c,
    is3d: v,
    offsetContainer: l,
    offsetRootContainer: g
  };
}
function la(t, e, n = e, r) {
  let s = 0, o = 0, i = 0, a = {};
  const c = ki(t);
  if (t && (s = c.offsetWidth, o = c.offsetHeight), t) {
    const u = bf(
      t,
      e,
      n,
      r
      // prevMatrix, prevRootMatrix, prevN,
    ), f = ke(
      u.allMatrix,
      u.transformOrigin,
      s,
      o
    );
    a = {
      ...u,
      ...f
    };
    const d = ke(
      u.allMatrix,
      [50, 50],
      100,
      100
    );
    i = $i([d.pos1, d.pos2], d.direction);
  }
  const l = 4;
  return {
    hasZoom: !1,
    width: s,
    height: o,
    rotation: i,
    ...c,
    originalRootMatrix: gt(l),
    rootMatrix: gt(l),
    beforeMatrix: gt(l),
    offsetMatrix: gt(l),
    allMatrix: gt(l),
    targetMatrix: gt(l),
    targetTransform: "",
    inlineTransform: "",
    transformOrigin: [0, 0],
    targetOrigin: [0, 0],
    is3d: !!r,
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
    origin: [0, 0],
    pos1: [0, 0],
    pos2: [0, 0],
    pos3: [0, 0],
    pos4: [0, 0],
    direction: 1,
    hasFixed: !1,
    offsetContainer: null,
    offsetRootContainer: null,
    matrixes: [],
    ...a
  };
}
function If(t, e, n = e) {
  return la(t, e, n, !0);
}
function Yr(t, e, n, r, s, o = []) {
  let i = 1, a = [0, 0], c = Rn(), l = Rn(), u = Rn(), f = Rn(), d = [0, 0];
  const p = {}, g = la(
    e,
    n,
    s,
    !0
  );
  if (e) {
    const h = Gt(e);
    o.forEach((x) => {
      p[x] = h(x);
    });
    const v = g.is3d ? 4 : 3, m = ke(
      g.offsetMatrix,
      at(g.transformOrigin, ti(g.targetMatrix, v)),
      g.width,
      g.height
    );
    i = m.direction, a = at(
      m.origin,
      [m.left - g.left, m.top - g.top]
    ), f = nn(g.offsetRootContainer);
    const S = fn(r, r, !0).offsetParent || g.offsetRootContainer;
    if (g.hasZoom) {
      const x = ke(
        dt(g.originalRootMatrix, g.allMatrix),
        g.transformOrigin,
        g.width,
        g.height
      ), C = ke(
        g.originalRootMatrix,
        Ln(Gt(S)("transformOrigin")).map((E) => parseFloat(E)),
        S.offsetWidth,
        S.offsetHeight
      );
      if (c = pr(x, f), u = pr(
        C,
        f,
        S,
        !0
      ), t) {
        const E = x.left, D = x.top;
        l = pr({
          left: E,
          top: D,
          bottom: D,
          right: D
        }, f);
      }
    } else {
      c = nn(e), u = Qc(S), t && (l = nn(t));
      const {
        left: x,
        top: C,
        clientLeft: E,
        clientTop: D
      } = u, R = [
        c.left - x,
        c.top - C
      ];
      d = K(
        We(g.rootMatrix, R, 4),
        [E + g.left, D + g.top]
      );
    }
  }
  return {
    targetClientRect: c,
    containerClientRect: u,
    moveableClientRect: l,
    rootContainerClientRect: f,
    beforeDirection: i,
    beforeOrigin: a,
    originalBeforeOrigin: a,
    target: e,
    style: p,
    offsetDelta: d,
    ...g
  };
}
function yo(t) {
  let {
    pos1: e,
    pos2: n,
    pos3: r,
    pos4: s
  } = t;
  if (!e || !n || !r || !s)
    return null;
  const o = be([e, n, r, s]), i = [o.minX, o.minY], a = K(t.origin, i);
  return e = K(e, i), n = K(n, i), r = K(r, i), s = K(s, i), {
    ...t,
    left: t.left,
    top: t.top,
    posDelta: i,
    pos1: e,
    pos2: n,
    pos3: r,
    pos4: s,
    origin: a,
    beforeOrigin: a,
    // originalBeforeOrigin: origin,
    isPersisted: !0
  };
}
class ye extends _o.PureComponent {
  constructor() {
    super(...arguments);
    X(this, "state", {
      container: null,
      gestos: {},
      renderLines: [
        [
          [0, 0],
          [0, 0]
        ],
        [
          [0, 0],
          [0, 0]
        ],
        [
          [0, 0],
          [0, 0]
        ],
        [
          [0, 0],
          [0, 0]
        ]
      ],
      renderPoses: [
        [0, 0],
        [0, 0],
        [0, 0],
        [0, 0]
      ],
      disableNativeEvent: !1,
      posDelta: [0, 0],
      ...Yr(null)
    });
    X(this, "renderState", {});
    X(this, "enabledAbles", []);
    X(this, "targetAbles", []);
    X(this, "controlAbles", []);
    X(this, "controlBox");
    X(this, "areaElement");
    X(this, "targetGesto");
    X(this, "controlGesto");
    X(this, "rotation", 0);
    X(this, "scale", [1, 1]);
    X(this, "isMoveableMounted", !1);
    X(this, "isUnmounted", !1);
    X(this, "events", {
      mouseEnter: null,
      mouseLeave: null
    });
    X(this, "_emitter", new Cs());
    X(this, "_prevOriginalDragTarget", null);
    X(this, "_originalDragTarget", null);
    X(this, "_prevDragTarget", null);
    X(this, "_dragTarget", null);
    X(this, "_prevPropTarget", null);
    X(this, "_propTarget", null);
    X(this, "_prevDragArea", !1);
    X(this, "_isPropTargetChanged", !1);
    X(this, "_hasFirstTarget", !1);
    X(this, "_reiszeObserver", null);
    X(this, "_observerId", 0);
    X(this, "_mutationObserver", null);
    X(this, "_rootContainer", null);
    X(this, "_viewContainer", null);
    X(this, "_viewClassNames", []);
    X(this, "_store", {});
    X(this, "checkUpdateRect", () => {
      if (this.isDragging())
        return;
      const n = this.props.parentMoveable;
      if (n) {
        n.checkUpdateRect();
        return;
      }
      Ec(this._observerId), this._observerId = Ho(() => {
        this.isDragging() || this.updateRect();
      });
    });
    X(this, "_onPreventClick", (n) => {
      n.stopPropagation(), n.preventDefault();
    });
  }
  render() {
    const n = this.props, r = this.getState(), {
      parentPosition: s,
      className: o,
      target: i,
      zoom: a,
      cspNonce: c,
      translateZ: l,
      cssStyled: u,
      groupable: f,
      linePadding: d,
      controlPadding: p
    } = n;
    this._checkUpdateRootContainer(), this.checkUpdate(), this.updateRenderPoses();
    const [g, h] = s || [0, 0], {
      left: v,
      top: m,
      target: S,
      direction: x,
      hasFixed: C,
      offsetDelta: E
    } = r, D = n.targets, R = this.isDragging(), y = {};
    this.getEnabledAbles().forEach((w) => {
      y[`data-able-${w.name.toLowerCase()}`] = !0;
    });
    const M = this._getAbleClassName(), P = D && D.length && (S || f) || i || !this._hasFirstTarget && this.state.isPersisted, _ = this.controlBox || this.props.firstRenderState || this.props.persistData, O = [v - g, m - h];
    !f && n.useAccuratePosition && (O[0] += E[0], O[1] += E[1]);
    const T = {
      position: C ? "fixed" : "absolute",
      display: P ? "block" : "none",
      visibility: _ ? "visible" : "hidden",
      transform: `translate3d(${O[0]}px, ${O[1]}px, ${l})`,
      "--zoom": a,
      "--zoompx": `${a}px`
    };
    return d && (T["--moveable-line-padding"] = d), p && (T["--moveable-control-padding"] = p), /* @__PURE__ */ it.jsxs(
      u,
      {
        cspNonce: c,
        ref: Se(this, "controlBox"),
        className: `${U("control-box", x === -1 ? "reverse" : "", R ? "dragging" : "")} ${M} ${o}`,
        ...y,
        onClick: this._onPreventClick,
        style: T,
        children: [
          this.renderAbles(),
          this._renderLines()
        ]
      }
    );
  }
  componentDidMount() {
    this.isMoveableMounted = !0, this.isUnmounted = !1;
    const n = this.props, { parentMoveable: r, container: s } = n;
    this._checkUpdateRootContainer(), this._checkUpdateViewContainer(), this._updateTargets(), this._updateNativeEvents(), this._updateEvents(), this.updateCheckInput(), this._updateObserver(this.props), !s && !r && !this.state.isPersisted && (this.updateRect("", !1, !1), this.forceUpdate());
  }
  componentDidUpdate(n) {
    this._checkUpdateRootContainer(), this._checkUpdateViewContainer(), this._updateNativeEvents(), this._updateTargets(), this._updateEvents(), this.updateCheckInput(), this._updateObserver(n);
  }
  componentWillUnmount() {
    var s, o;
    this.isMoveableMounted = !1, this.isUnmounted = !0, this._emitter.off(), (s = this._reiszeObserver) == null || s.disconnect(), (o = this._mutationObserver) == null || o.disconnect(), this._viewContainer && this._changeAbleViewClassNames([]), ze(this, !1), ze(this, !0);
    const r = this.events;
    for (const i in r) {
      const a = r[i];
      a && a.destroy();
    }
  }
  getTargets() {
    const n = this.props.target;
    return n ? [n] : [];
  }
  /**
   * Get the able used in MoveableManager.
   * @method Moveable#getAble
   * @param - able name
   */
  getAble(n) {
    const r = this.props.ables || [];
    return kt(r, (s) => s.name === n);
  }
  getContainer() {
    const { parentMoveable: n, wrapperMoveable: r, container: s } = this.props;
    return s || r && r.getContainer() || n && n.getContainer() || this.controlBox.parentElement;
  }
  /**
   * Returns the element of the control box.
   * @method Moveable#getControlBoxElement
   */
  getControlBoxElement() {
    return this.controlBox;
  }
  /**
   * Target element to be dragged in moveable
   * @method Moveable#getDragElement
   */
  getDragElement() {
    return this._dragTarget;
  }
  /**
   * Check if the target is an element included in the moveable.
   * @method Moveable#isMoveableElement
   * @param - the target
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * window.addEventListener("click", e => {
   *     if (!moveable.isMoveableElement(e.target)) {
   *         moveable.target = e.target;
   *     }
   * });
   */
  isMoveableElement(n) {
    var r;
    return n && (((r = n.getAttribute) == null ? void 0 : r.call(n, "class")) || "").indexOf(Hr) > -1;
  }
  /**
   * You can drag start the Moveable through the external `MouseEvent`or `TouchEvent`. (Angular: ngDragStart)
   * @method Moveable#dragStart
   * @param - external `MouseEvent`or `TouchEvent`
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * document.body.addEventListener("mousedown", e => {
   *     if (!moveable.isMoveableElement(e.target)) {
   *          moveable.dragStart(e);
   *     }
   * });
   */
  dragStart(n, r = n.target) {
    const s = this.targetGesto, o = this.controlGesto;
    return s && Rs(this)({ inputEvent: n }, r) ? s.isFlag() || s.triggerDragStart(n) : o && this.isMoveableElement(r) && (o.isFlag() || o.triggerDragStart(n)), this;
  }
  /**
   * Hit test an element or rect on a moveable target.
   * (100% = 100)
   * @method Moveable#hitTest
   * @param - element or rect to test
   * @return - Get hit test rate (rate > 0 is hitted)
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * document.body.addEventListener("mousedown", e => {
   *     if (moveable.hitTest(e.target) > 0) {
   *          console.log("hiited");
   *     }
   * });
   */
  hitTest(n) {
    const { target: r, pos1: s, pos2: o, pos3: i, pos4: a, targetClientRect: c } = this.state;
    if (!r)
      return 0;
    let l;
    if (ns(n)) {
      const m = n.getBoundingClientRect();
      l = {
        left: m.left,
        top: m.top,
        width: m.width,
        height: m.height
      };
    } else
      l = { width: 0, height: 0, ...n };
    const {
      left: u,
      top: f,
      width: d,
      height: p
    } = l, g = mo([s, o, a, i], c), h = qu(g, [
      [u, f],
      [u + d, f],
      [u + d, f + p],
      [u, f + p]
    ]), v = Qi(g);
    return !h || !v ? 0 : Math.min(100, h / v * 100);
  }
  /**
   * Whether the coordinates are inside Moveable
   * @method Moveable#isInside
   * @param - x coordinate
   * @param - y coordinate
   * @return - True if the coordinate is in moveable or false
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * document.body.addEventListener("mousedown", e => {
   *     if (moveable.isInside(e.clientX, e.clientY)) {
   *          console.log("inside");
   *     }
   * });
   */
  isInside(n, r) {
    const { target: s, pos1: o, pos2: i, pos3: a, pos4: c, targetClientRect: l } = this.state;
    return s ? Fr(
      [n, r],
      mo([o, i, c, a], l)
    ) : !1;
  }
  /**
   * If the width, height, left, and top of all elements change, update the shape of the moveable.
   * @method Moveable#updateRect
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * window.addEventListener("resize", e => {
   *     moveable.updateRect();
   * });
   */
  updateRect(n, r, s = !0) {
    const o = this.props, i = !o.parentPosition && !o.wrapperMoveable;
    i && Le(!0);
    const a = o.parentMoveable, l = this.state.target || o.target, u = this.getContainer(), f = a ? a._rootContainer : this._rootContainer, d = Yr(
      this.controlBox,
      l,
      u,
      u,
      f || u,
      this._getRequestStyles()
    );
    if (!l && this._hasFirstTarget && o.persistData) {
      const p = yo(o.persistData);
      for (const g in p)
        d[g] = p[g];
    }
    i && Le(), this.updateState(d, a ? !1 : s);
  }
  /**
   * Check if the moveable state is being dragged.
   * @method Moveable#isDragging
   * @param - If you want to check if able is dragging, specify ableName.
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * // false
   * console.log(moveable.isDragging());
   *
   * moveable.on("drag", () => {
   *   // true
   *   console.log(moveable.isDragging());
   * });
   */
  isDragging(n) {
    var o, i;
    const r = this.targetGesto, s = this.controlGesto;
    return r != null && r.isFlag() ? n ? !!((o = r.getEventData()[n]) != null && o.isEventStart) : !0 : s != null && s.isFlag() ? n ? !!((i = s.getEventData()[n]) != null && i.isEventStart) : !0 : !1;
  }
  /**
   * If the width, height, left, and top of the only target change, update the shape of the moveable.
   * Use `.updateRect()` method
   * @method Moveable#updateTarget
   * @deprecated
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * moveable.updateTarget();
   */
  updateTarget(n) {
    this.updateRect(n, !0);
  }
  /**
   * You can get the vertex information, position and offset size information of the target based on the container.
   * @method Moveable#getRect
   * @return - The Rect Info
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * const rectInfo = moveable.getRect();
   */
  getRect() {
    const n = this.state, r = jt(this.state), [s, o, i, a] = r, c = Yt(r), { width: l, height: u } = n, { width: f, height: d, left: p, top: g } = c, h = [n.left, n.top], v = at(h, n.origin), m = at(h, n.beforeOrigin), S = n.transformOrigin;
    return {
      width: f,
      height: d,
      left: p,
      top: g,
      pos1: s,
      pos2: o,
      pos3: i,
      pos4: a,
      offsetWidth: l,
      offsetHeight: u,
      beforeOrigin: m,
      origin: v,
      transformOrigin: S,
      rotation: this.getRotation()
    };
  }
  /**
   * Get a manager that manages the moveable's state and props.
   * @method Moveable#getManager
   * @return - The Rect Info
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * const manager = moveable.getManager(); // real moveable class instance
   */
  getManager() {
    return this;
  }
  /**
   * You can stop the dragging currently in progress through a method from outside.
   * @method Moveable#stopDrag
   * @return - The Rect Info
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * moveable.stopDrag();
   */
  stopDrag(n) {
    if (!n || n === "target") {
      const r = this.targetGesto;
      (r == null ? void 0 : r.isIdle()) === !1 && zr(this, !1), r == null || r.stop();
    }
    if (!n || n === "control") {
      const r = this.controlGesto;
      (r == null ? void 0 : r.isIdle()) === !1 && zr(this, !0), r == null || r.stop();
    }
  }
  getRotation() {
    const { pos1: n, pos2: r, direction: s } = this.state;
    return Cu(n, r, s);
  }
  /**
   * Request able through a method rather than an event.
   * At the moment of execution, requestStart is executed,
   * and then request and requestEnd can be executed through Requester.
   * @method Moveable#request
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Draggable.html#request|Draggable Requester}
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Resizable.html#request|Resizable Requester}
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Scalable.html#request|Scalable Requester}
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Rotatable.html#request|Rotatable Requester}
   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.OriginDraggable.html#request|OriginDraggable Requester}
   * @param - ableName
   * @param - request to be able params.
   * @param - If isInstant is true, request and requestEnd are executed immediately.
   * @return - Able Requester. If there is no request in able, nothing will work.
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * // Instantly Request (requestStart - request - requestEnd)
   * moveable.request("draggable", { deltaX: 10, deltaY: 10 }, true);
   *
   * // Start move
   * const requester = moveable.request("draggable");
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.request({ deltaX: 10, deltaY: 10 });
   * requester.requestEnd();
   */
  request(n, r = {}, s) {
    const o = this, i = o.props, a = i.parentMoveable || i.wrapperMoveable || o, c = a.props.ables, l = i.groupable, u = kt(c, (m) => m.name === n);
    if (this.isDragging() || !u || !u.request)
      return {
        request() {
          return this;
        },
        requestEnd() {
          return this;
        }
      };
    const f = u.request(o), d = s || r.isInstant, p = f.isControl ? "controlAbles" : "targetAbles", g = `${l ? "Group" : ""}${f.isControl ? "Control" : ""}`, h = [...a[p]], v = {
      request(m) {
        return sn(
          o,
          h,
          ["drag"],
          g,
          "",
          {
            ...f.request(m),
            requestAble: n,
            isRequest: !0
          },
          d
        ), v;
      },
      requestEnd() {
        return sn(
          o,
          h,
          ["drag"],
          g,
          "End",
          {
            ...f.requestEnd(),
            requestAble: n,
            isRequest: !0
          },
          d
        ), v;
      }
    };
    return sn(
      o,
      h,
      ["drag"],
      g,
      "Start",
      {
        ...f.requestStart(r),
        requestAble: n,
        isRequest: !0
      },
      d
    ), d ? v.request(r).requestEnd() : v;
  }
  /**
   * moveable is the top level that manages targets
   * `Single`: MoveableManager instance
   * `Group`: MoveableGroup instance
   * `IndividualGroup`: MoveableIndividaulGroup instance
   * Returns leaf target MoveableManagers.
   */
  getMoveables() {
    return [this];
  }
  /**
   * Remove the Moveable object and the events.
   * @method Moveable#destroy
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body);
   *
   * moveable.destroy();
   */
  destroy() {
    this.componentWillUnmount();
  }
  updateRenderPoses() {
    const n = this.getState(), r = this.props, s = r.padding, {
      originalBeforeOrigin: o,
      transformOrigin: i,
      allMatrix: a,
      is3d: c,
      pos1: l,
      pos2: u,
      pos3: f,
      pos4: d,
      left: p,
      top: g,
      isPersisted: h
    } = n, v = r.zoom || 1;
    if (!s && v <= 1) {
      n.renderPoses = [l, u, f, d], n.renderLines = [
        [l, u],
        [u, d],
        [d, f],
        [f, l]
      ];
      return;
    }
    const { left: m, top: S, bottom: x, right: C } = qi(s || {}), E = c ? 4 : 3;
    let D = [];
    h ? D = i : this.controlBox && r.groupable ? D = o : D = at(o, [p, g]);
    const R = An(
      E,
      Ce(
        D.map((O) => -O),
        E
      ),
      a,
      Ce(i, E)
    ), y = Wt(R, l, [-m, -S], E), M = Wt(R, u, [C, -S], E), P = Wt(R, f, [-m, x], E), _ = Wt(R, d, [C, x], E);
    if (n.renderPoses = [y, M, P, _], n.renderLines = [
      [y, M],
      [M, _],
      [_, P],
      [P, y]
    ], v) {
      const O = v / 2;
      n.renderLines = [
        [
          Wt(R, l, [-m - O, -S], E),
          Wt(R, u, [C + O, -S], E)
        ],
        [
          Wt(R, u, [C, -S - O], E),
          Wt(R, d, [C, x + O], E)
        ],
        [
          Wt(R, d, [C + O, x], E),
          Wt(R, f, [-m - O, x], E)
        ],
        [
          Wt(R, f, [-m, x + O], E),
          Wt(R, l, [-m, -S - O], E)
        ]
      ];
    }
  }
  checkUpdate() {
    this._isPropTargetChanged = !1;
    const { target: n, container: r, parentMoveable: s } = this.props, { target: o, container: i } = this.state;
    if (!o && !n)
      return;
    this.updateAbles();
    const a = !Ar(o, n);
    if (!(a || !Ar(i, r)))
      return;
    const l = r || this.controlBox;
    l && this.unsetAbles(), this.updateState({ target: n, container: r }), !s && l && this.updateRect("End", !1, !1), this._isPropTargetChanged = a;
  }
  waitToChangeTarget() {
    return new Promise(() => {
    });
  }
  triggerEvent(n, r) {
    const s = this.props;
    if (this._emitter.trigger(n, r), s.parentMoveable && r.isRequest && !r.isRequestChild)
      return s.parentMoveable.triggerEvent(n, r, !0);
    const o = s[n];
    return o && o(r);
  }
  useCSS(n, r) {
    const s = this.props.customStyledMap, o = n + r;
    return s[o] || (s[o] = ca(n, r)), s[o];
  }
  getState() {
    var i;
    const n = this.props;
    (n.target || (i = n.targets) != null && i.length) && (this._hasFirstTarget = !0);
    const r = this.controlBox, s = n.persistData, o = n.firstRenderState;
    if (o && !r)
      return o;
    if (!this._hasFirstTarget && s) {
      const a = yo(s);
      if (a)
        return this.updateState(a, !1), this.state;
    }
    return this.state.isPersisted = !1, this.state;
  }
  updateSelectors() {
  }
  unsetAbles() {
    this.targetAbles.forEach((n) => {
      n.unset && n.unset(this);
    });
  }
  updateAbles(n = this.props.ables, r = "") {
    const o = this.props.triggerAblesSimultaneously, i = this.getEnabledAbles(n), a = `drag${r}Start`, c = `pinch${r}Start`, l = `drag${r}ControlStart`, u = Mn(
      i,
      [a, c],
      o
    ), f = Mn(
      i,
      [l],
      o
    );
    this.enabledAbles = i, this.targetAbles = u, this.controlAbles = f;
  }
  updateState(n, r) {
    if (r) {
      if (this.isUnmounted)
        return;
      this.setState(n);
    } else {
      const s = this.state;
      for (const o in n)
        s[o] = n[o];
    }
  }
  getEnabledAbles(n = this.props.ables) {
    const r = this.props;
    return n.filter(
      (s) => s && (s.always && r[s.name] !== !1 || r[s.name])
    );
  }
  renderAbles() {
    const r = this.props.triggerAblesSimultaneously, s = {
      createElement: Bn
    };
    return this.renderState = {}, mu(
      Vi(
        Mn(
          this.getEnabledAbles(),
          ["render"],
          r
        ).map(({ render: o }) => o(this, s) || [])
      ).filter((o) => o),
      ({ key: o }) => o
    ).map((o) => o[0]);
  }
  updateCheckInput() {
    this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput);
  }
  _getRequestStyles() {
    return this.getEnabledAbles().reduce(
      (r, s) => {
        var i;
        const o = ((i = s.requestStyle) == null ? void 0 : i.call(s)) ?? [];
        return [...r, ...o];
      },
      [...this.props.requestStyles || []]
    );
  }
  _updateObserver(n) {
    this._updateResizeObserver(n), this._updateMutationObserver(n);
  }
  _updateEvents() {
    const n = this.targetAbles.length, r = this.controlAbles.length, s = this._dragTarget;
    (!n && this.targetGesto || this._isTargetChanged(!0)) && (ze(this, !1), this.updateState({ gestos: {} })), r || ze(this, !0), s && n && !this.targetGesto && (this.targetGesto = oa(this, s, "")), !this.controlGesto && r && (this.controlGesto = ia(this, "Control"));
  }
  _updateTargets() {
    const n = this.props;
    this._prevPropTarget = this._propTarget, this._prevDragTarget = this._dragTarget, this._prevOriginalDragTarget = this._originalDragTarget, this._prevDragArea = n.dragArea, this._propTarget = n.target, this._originalDragTarget = n.dragTarget || n.target, this._dragTarget = Zt(this._originalDragTarget, !0);
  }
  _renderLines() {
    const n = this.props, {
      zoom: r,
      hideDefaultLines: s,
      hideChildMoveableDefaultLines: o,
      parentMoveable: i
    } = n;
    if (s || i && o)
      return [];
    const a = this.getState(), c = {
      createElement: Bn
    };
    return a.renderLines.map((l, u) => un(
      c,
      "",
      l[0],
      l[1],
      r,
      `render-line-${u}`
    ));
  }
  _isTargetChanged(n) {
    const r = this.props, s = r.dragTarget || r.target, o = this._prevOriginalDragTarget, i = this._prevDragArea, a = r.dragArea;
    return !a && o !== s || (n || a) && i !== a || this._prevPropTarget != this._propTarget;
  }
  _updateNativeEvents() {
    const r = this.props.dragArea ? this.areaElement : this.state.target, s = this.events, o = Ve(s);
    if (this._isTargetChanged())
      for (const a in s) {
        const c = s[a];
        c && c.destroy(), s[a] = null;
      }
    if (!r)
      return;
    const i = this.enabledAbles;
    o.forEach((a) => {
      const c = Mn(i, [a]), l = c.length > 0;
      let u = s[a];
      if (!l) {
        u && (u.destroy(), s[a] = null);
        return;
      }
      u || (u = new gf(r, this, a), s[a] = u), u.setAbles(c);
    });
  }
  _checkUpdateRootContainer() {
    const n = this.props.rootContainer;
    !this._rootContainer && n && (this._rootContainer = Zt(n, !0));
  }
  _checkUpdateViewContainer() {
    const n = this.props.viewContainer;
    !this._viewContainer && n && (this._viewContainer = Zt(n, !0)), this._viewContainer && this._changeAbleViewClassNames([
      ...this._getAbleViewClassNames(),
      this.isDragging() ? _u : ""
    ]);
  }
  _changeAbleViewClassNames(n) {
    const r = this._viewContainer, s = Yi(n.filter(Boolean), (c) => c).map(
      ([c]) => c
    ), o = this._viewClassNames, { removed: i, added: a } = ps(o, s);
    i.forEach((c) => {
      Zo(r, o[c]);
    }), a.forEach((c) => {
      Ko(r, s[c]);
    }), this._viewClassNames = s;
  }
  _getAbleViewClassNames() {
    return (this.getEnabledAbles().map((n) => {
      var r;
      return ((r = n.viewClassName) == null ? void 0 : r.call(n, this)) || "";
    }).join(" ") + ` ${this._getAbleClassName("-view")}`).split(/\s+/g);
  }
  _getAbleClassName(n = "") {
    const r = this.getEnabledAbles(), s = this.targetGesto, o = this.controlGesto, i = s != null && s.isFlag() ? s.getEventData() : {}, a = o != null && o.isFlag() ? o.getEventData() : {};
    return r.map((c) => {
      var f, d, p;
      const l = c.name;
      let u = ((f = c.className) == null ? void 0 : f.call(c, this)) || "";
      return ((d = i[l]) != null && d.isEventStart || (p = a[l]) != null && p.isEventStart) && (u += ` ${U(`${l}${n}-dragging`)}`), u.trim();
    }).filter(Boolean).join(" ");
  }
  _updateResizeObserver(n) {
    var a;
    const r = this.props, s = r.target, o = ae(this.getControlBoxElement());
    if (!o.ResizeObserver || !s || !r.useResizeObserver) {
      (a = this._reiszeObserver) == null || a.disconnect();
      return;
    }
    if (n.target === s && this._reiszeObserver)
      return;
    const i = new o.ResizeObserver(this.checkUpdateRect);
    i.observe(s, {
      box: "border-box"
    }), this._reiszeObserver = i;
  }
  _updateMutationObserver(n) {
    var a;
    const r = this.props, s = r.target, o = ae(this.getControlBoxElement());
    if (!o.MutationObserver || !s || !r.useMutationObserver) {
      (a = this._mutationObserver) == null || a.disconnect();
      return;
    }
    if (n.target === s && this._mutationObserver)
      return;
    const i = new o.MutationObserver((c) => {
      for (const l of c)
        l.type === "attributes" && l.attributeName === "style" && this.checkUpdateRect();
    });
    i.observe(s, {
      attributes: !0
    }), this._mutationObserver = i;
  }
}
X(ye, "defaultProps", {
  dragTargetSelf: !1,
  target: null,
  dragTarget: null,
  container: null,
  rootContainer: null,
  origin: !0,
  parentMoveable: null,
  wrapperMoveable: null,
  isWrapperMounted: !1,
  parentPosition: null,
  warpSelf: !1,
  svgOrigin: "",
  dragContainer: null,
  useResizeObserver: !1,
  useMutationObserver: !1,
  preventDefault: !0,
  preventRightClick: !0,
  preventWheelClick: !0,
  linePadding: 0,
  controlPadding: 0,
  ables: [],
  pinchThreshold: 20,
  dragArea: !1,
  passDragArea: !1,
  transformOrigin: "",
  className: "",
  zoom: 1,
  triggerAblesSimultaneously: !1,
  padding: {},
  pinchOutside: !0,
  checkInput: !1,
  dragFocusedInput: !1,
  groupable: !1,
  hideDefaultLines: !1,
  cspNonce: "",
  translateZ: 0,
  cssStyled: null,
  customStyledMap: {},
  props: {},
  stopPropagation: !1,
  preventClickDefault: !1,
  preventClickEventOnDrag: !0,
  flushSync: Bi,
  firstRenderState: null,
  persistData: null,
  viewContainer: null,
  requestStyles: [],
  useAccuratePosition: !1
});
const Ms = {
  name: "groupable",
  props: [
    "defaultGroupRotate",
    "useDefaultGroupRotate",
    "defaultGroupOrigin",
    "groupable",
    "groupableProps",
    "targetGroups",
    "hideChildMoveableDefaultLines"
  ],
  events: [],
  render(t, e) {
    var d;
    const n = t.props;
    let r = n.targets || [];
    const { left: s, top: o, isPersisted: i } = t.getState(), a = n.zoom || 1, c = t.renderGroupRects;
    let l = ((d = n.persistData) == null ? void 0 : d.children) || [];
    i ? r = l.map(() => null) : l = [];
    const u = Ae(
      t,
      "parentPosition",
      [s, o],
      (p) => p.join(",")
    ), f = Ae(
      t,
      "requestStyles",
      t.getRequestChildStyles(),
      (p) => p.join(",")
    );
    return t.moveables = t.moveables.slice(0, r.length), [
      ...r.map((p, g) => /* @__PURE__ */ it.jsx(
        ye,
        {
          ref: Yo(t, "moveables", g),
          target: p,
          origin: !1,
          requestStyles: f,
          cssStyled: n.cssStyled,
          customStyledMap: n.customStyledMap,
          useResizeObserver: n.useResizeObserver,
          useMutationObserver: n.useMutationObserver,
          hideChildMoveableDefaultLines: n.hideChildMoveableDefaultLines,
          parentMoveable: t,
          parentPosition: [s, o],
          persistData: l[g],
          zoom: a
        },
        "moveable" + g
      )),
      ...Vi(
        c.map(({ pos1: p, pos2: g, pos3: h, pos4: v }, m) => {
          const S = [p, g, h, v];
          return [
            [0, 1],
            [1, 3],
            [3, 2],
            [2, 0]
          ].map(([x, C], E) => un(
            e,
            "",
            K(S[x], u),
            K(S[C], u),
            a,
            `group-rect-${m}-${E}`
          ));
        })
      )
    ];
  }
}, yf = dn("clickable", {
  props: [
    "clickable"
  ],
  events: [
    "click",
    "clickGroup"
  ],
  always: !0,
  dragRelation: "weak",
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  dragStart() {
  },
  dragControlStart() {
  },
  dragGroupStart(t, e) {
    e.datas.inputTarget = e.inputEvent && e.inputEvent.target;
  },
  dragEnd(t, e) {
    const n = t.props.target, r = e.inputEvent, s = e.inputTarget, i = !t.isMoveableElement(s) && t.controlBox.contains(s);
    if (!r || !s || e.isDrag || t.isMoveableElement(s) || i)
      return;
    const a = n.contains(s);
    j(t, "onClick", et(t, e, {
      isDouble: e.isDouble,
      inputTarget: s,
      isTarget: n === s,
      moveableTarget: t.props.target,
      containsTarget: a
    }));
  },
  dragGroupEnd(t, e) {
    const n = e.inputEvent, r = e.inputTarget;
    if (!n || !r || e.isDrag || t.isMoveableElement(r) || e.datas.inputTarget === r)
      return;
    const s = t.props.targets;
    let o = s.indexOf(r);
    const i = o > -1;
    let a = !1;
    o === -1 && (o = ne(s, (c) => c.contains(r)), a = o > -1), j(t, "onClickGroup", et(t, e, {
      isDouble: e.isDouble,
      targets: s,
      inputTarget: r,
      targetIndex: o,
      isTarget: i,
      containsTarget: a,
      moveableTarget: s[o]
    }));
  },
  dragControlEnd(t, e) {
    this.dragEnd(t, e);
  },
  dragGroupControlEnd(t, e) {
    this.dragEnd(t, e);
  }
});
function Oe(t) {
  let e = t.originalDatas.draggable;
  return e || (t.originalDatas.draggable = {}, e = t.originalDatas.draggable), { ...t, datas: e };
}
const Rf = dn("edgeDraggable", {
  css: [
    `.edge.edgeDraggable.line {
cursor: move;
}`
  ],
  render(t, e) {
    const n = t.props, r = n.edgeDraggable;
    return r ? fi(
      e,
      "edgeDraggable",
      r,
      t.getState().renderPoses,
      n.zoom
    ) : [];
  },
  dragCondition(t, e) {
    var s;
    const n = t.props, r = (s = e.inputEvent) == null ? void 0 : s.target;
    return !n.edgeDraggable || !r ? !1 : !n.draggable && bt(r, U("direction")) && bt(r, U("edge")) && bt(r, U("edgeDraggable"));
  },
  dragStart(t, e) {
    return Ot.dragStart(t, Oe(e));
  },
  drag(t, e) {
    return Ot.drag(t, Oe(e));
  },
  dragEnd(t, e) {
    return Ot.dragEnd(t, Oe(e));
  },
  dragGroupCondition(t, e) {
    var s;
    const n = t.props, r = (s = e.inputEvent) == null ? void 0 : s.target;
    return !n.edgeDraggable || !r ? !1 : !n.draggable && bt(r, U("direction")) && bt(r, U("line"));
  },
  dragGroupStart(t, e) {
    return Ot.dragGroupStart(t, Oe(e));
  },
  dragGroup(t, e) {
    return Ot.dragGroup(t, Oe(e));
  },
  dragGroupEnd(t, e) {
    return Ot.dragGroupEnd(t, Oe(e));
  },
  unset(t) {
    return Ot.unset(t);
  }
}), ua = {
  name: "individualGroupable",
  props: [
    "individualGroupable",
    "individualGroupableProps"
  ],
  events: []
}, Ps = [
  ra,
  Zi,
  su,
  bu,
  Ot,
  Rf,
  Tr,
  yu,
  Mu,
  wl,
  Au,
  Gu,
  Tu,
  ef,
  tf,
  of,
  Ms,
  ua,
  yf,
  Ki,
  sa
], Bf = /* @__PURE__ */ Ps.reduce((t, e) => ((e.events || []).forEach((n) => {
  Uo(t, n);
}), t), []), zf = /* @__PURE__ */ Ps.reduce((t, e) => ((e.props || []).forEach((n) => {
  Uo(t, n);
}), t), []);
function Ro([t, e, n], r) {
  return (t * r[0] + e * r[1] + n) / Math.sqrt(t * t + e * e);
}
function wn([t, e], n) {
  return -t * n[0] - e * n[1];
}
function Mo(t, e) {
  return Math.max(
    ...t.map(([n, r, s, o]) => Math.max(n[e], r[e], s[e], o[e]))
  );
}
function Po(t, e) {
  return Math.min(
    ...t.map(([n, r, s, o]) => Math.min(n[e], r[e], s[e], o[e]))
  );
}
function Mf(t, e) {
  let n = [0, 0], r = [0, 0], s = [0, 0], o = [0, 0], i = 0, a = 0;
  if (!t.length)
    return {
      pos1: n,
      pos2: r,
      pos3: s,
      pos4: o,
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0,
      width: i,
      height: a,
      rotation: e
    };
  const c = tt(e, Bt);
  if (c % 90) {
    const p = c / 180 * Math.PI, g = Math.tan(p), h = -1 / g, v = [Dr, Fs], m = [
      [0, 0],
      [0, 0]
    ], S = [Dr, Fs], x = [
      [0, 0],
      [0, 0]
    ];
    t.forEach((O) => {
      O.forEach((T) => {
        const w = Ro([-g, 1, 0], T), k = Ro([-h, 1, 0], T);
        v[0] > w && (m[0] = T, v[0] = w), v[1] < w && (m[1] = T, v[1] = w), S[0] > k && (x[0] = T, S[0] = k), S[1] < k && (x[1] = T, S[1] = k);
      });
    });
    const [C, E] = m, [D, R] = x, y = [-g, 1, wn([-g, 1], C)], M = [-g, 1, wn([-g, 1], E)], P = [-h, 1, wn([-h, 1], D)], _ = [-h, 1, wn([-h, 1], R)];
    [n, r, s, o] = [
      [y, P],
      [y, _],
      [M, P],
      [M, _]
    ].map(
      ([O, T]) => bs(O, T)[0]
    ), i = S[1] - S[0], a = v[1] - v[0];
  } else {
    const p = Po(t, 0), g = Po(t, 1), h = Mo(t, 0), v = Mo(t, 1);
    n = [p, g], r = [h, g], s = [p, v], o = [h, v], i = h - p, a = v - g, c % 180 && ([n, r, s, o] = [s, n, o, r], i = v - g, a = h - p);
  }
  c % 360 > 180 && ([n, r, s, o] = [o, s, r, n]);
  const { minX: l, minY: u, maxX: f, maxY: d } = be([n, r, s, o]);
  return {
    pos1: n,
    pos2: r,
    pos3: s,
    pos4: o,
    width: i,
    height: a,
    minX: l,
    minY: u,
    maxX: f,
    maxY: d,
    rotation: e
  };
}
function fa(t, e) {
  const n = e.map((r) => {
    if (Rt(r)) {
      const s = fa(t, r), o = s.length;
      return o > 1 ? s : o === 1 ? s[0] : null;
    } else {
      const s = kt(
        t,
        ({ manager: o }) => o.props.target === r
      );
      return s ? (s.finded = !0, s.manager) : null;
    }
  }).filter(Boolean);
  return n.length === 1 && Rt(n[0]) ? n[0] : n;
}
class da extends ye {
  constructor() {
    super(...arguments);
    X(this, "differ", new _i());
    X(this, "moveables", []);
    X(this, "transformOrigin", "50% 50%");
    X(this, "renderGroupRects", []);
    X(this, "_targetGroups", []);
    X(this, "_hasFirstTargets", !1);
  }
  componentDidMount() {
    super.componentDidMount();
  }
  checkUpdate() {
    this._isPropTargetChanged = !1, this.updateAbles();
  }
  getTargets() {
    return this.props.targets;
  }
  updateRect(n, r, s = !0) {
    var W;
    const o = this.state;
    if (!this.controlBox || o.isPersisted)
      return;
    Le(!0), this.moveables.forEach((J) => {
      J.updateRect(n, !1, !1);
    });
    const i = this.props, a = this.moveables, c = o.target || i.target, l = a.map((J) => ({
      finded: !1,
      manager: J
    })), u = this.props.targetGroups || [], f = fa(l, u), d = i.useDefaultGroupRotate;
    f.push(
      ...l.filter(({ finded: J }) => !J).map(({ manager: J }) => J)
    );
    const p = [], g = !r || n !== "" && i.updateGroup;
    let h = i.defaultGroupRotate || 0;
    if (!this._hasFirstTargets) {
      const J = (W = i.persistData) == null ? void 0 : W.rotation;
      J != null && (h = J);
    }
    function v(J, q, F) {
      const H = J.map((ut) => {
        if (Rt(ut)) {
          const St = v(ut, q), Kt = [St.pos1, St.pos2, St.pos3, St.pos4];
          return p.push(St), { poses: Kt, rotation: St.rotation };
        } else
          return {
            poses: jt(ut.state),
            rotation: ut.getRotation()
          };
      }), nt = H.map(({ rotation: ut }) => ut);
      let lt = 0;
      const vt = nt[0], st = nt.every((ut) => Math.abs(vt - ut) < 0.1);
      g ? lt = !d && st ? vt : h : lt = !d && !F && st ? vt : q;
      const Ft = H.map(({ poses: ut }) => ut);
      return Mf(Ft, lt);
    }
    const m = v(
      f,
      this.rotation,
      !0
    );
    g && (this.rotation = m.rotation, this.transformOrigin = i.defaultGroupOrigin || "50% 50%", this.scale = [1, 1]), this._targetGroups = u, this.renderGroupRects = p;
    const S = this.transformOrigin, x = this.rotation, C = this.scale, { width: E, height: D, minX: R, minY: y } = m, M = Du(
      [
        [0, 0],
        [E, 0],
        [0, D],
        [E, D]
      ],
      Es(S, E, D),
      this.rotation / 180 * Math.PI
    ), { minX: P, minY: _ } = be(M.result), O = ` rotate(${x}deg) scale(${wt(C[0])}, ${wt(C[1])})`, T = `translate(${-P}px, ${-_}px)${O}`;
    this.controlBox.style.transform = `translate3d(${R}px, ${y}px, ${this.props.translateZ || 0})`, c.style.cssText += `left:0px;top:0px;transform-origin:${S};width:${E}px;height:${D}px;transform: ${T}`, o.width = E, o.height = D;
    const w = this.getContainer(), k = Yr(
      this.controlBox,
      c,
      this.controlBox,
      this.getContainer(),
      this._rootContainer || w,
      []
    ), I = [k.left, k.top], [$, G, L, z] = jt(k), N = be([$, G, L, z]), Z = [N.minX, N.minY], Y = wt(C[0] * C[1]);
    k.pos1 = K($, Z), k.pos2 = K(G, Z), k.pos3 = K(L, Z), k.pos4 = K(z, Z), k.left = R - k.left + Z[0], k.top = y - k.top + Z[1], k.origin = K(at(I, k.origin), Z), k.beforeOrigin = K(at(I, k.beforeOrigin), Z), k.originalBeforeOrigin = at(I, k.originalBeforeOrigin), k.transformOrigin = K(at(I, k.transformOrigin), Z), c.style.transform = `translate(${-P - Z[0]}px, ${-_ - Z[1]}px)` + O, Le(), this.updateState(
      {
        ...k,
        posDelta: Z,
        direction: Y,
        beforeDirection: Y
      },
      s
    );
  }
  getRect() {
    return {
      ...super.getRect(),
      children: this.moveables.map((n) => n.getRect())
    };
  }
  triggerEvent(n, r, s) {
    if (s || n.indexOf("Group") > -1)
      return super.triggerEvent(n, r);
    this._emitter.trigger(n, r);
  }
  getRequestChildStyles() {
    return this.getEnabledAbles().reduce(
      (r, s) => {
        var i;
        const o = ((i = s.requestChildStyle) == null ? void 0 : i.call(s)) ?? [];
        return [...r, ...o];
      },
      []
    );
  }
  getMoveables() {
    return [...this.moveables];
  }
  updateAbles() {
    super.updateAbles([...this.props.ables, Ms], "Group");
  }
  _updateTargets() {
    super._updateTargets(), this._originalDragTarget = this.props.dragTarget || this.areaElement, this._dragTarget = Zt(this._originalDragTarget, !0);
  }
  _updateEvents() {
    const n = this.state, r = this.props, s = this._prevDragTarget, o = r.dragTarget || this.areaElement, i = r.targets, { added: a, changed: c, removed: l } = this.differ.update(i), u = a.length || l.length;
    (u || this._prevOriginalDragTarget !== this._originalDragTarget) && (ze(this, !1), ze(this, !0), this.updateState({ gestos: {} })), s !== o && (n.target = null), n.target || (n.target = this.areaElement, this.controlBox.style.display = "block"), n.target && (this.targetGesto || (this.targetGesto = oa(this, this._dragTarget, "Group")), this.controlGesto || (this.controlGesto = ia(this, "GroupControl")));
    const f = !Ar(n.container, r.container);
    f && (n.container = r.container), (f || u || this.transformOrigin !== (r.defaultGroupOrigin || "50% 50%") || c.length || i.length && !Hi(this._targetGroups, r.targetGroups || [])) && (this.updateRect(), this._hasFirstTargets = !0), this._isPropTargetChanged = !!u;
  }
  _updateObserver() {
  }
}
X(da, "defaultProps", {
  ...ye.defaultProps,
  transformOrigin: ["50%", "50%"],
  groupable: !0,
  dragArea: !0,
  keepRatio: !0,
  targets: [],
  defaultGroupRotate: 0,
  defaultGroupOrigin: "50% 50%"
});
class Pf extends ye {
  constructor() {
    super(...arguments);
    X(this, "moveables", []);
  }
  render() {
    const n = this.props, { cspNonce: r, cssStyled: s, persistData: o } = n;
    let i = n.targets || [];
    const a = i.length, c = this.isUnmounted || !a;
    let l = (o == null ? void 0 : o.children) ?? [];
    return c && !a && l.length ? i = l.map(() => null) : c || (l = []), /* @__PURE__ */ it.jsx(
      s,
      {
        cspNonce: r,
        ref: Se(this, "controlBox"),
        className: U("control-box"),
        children: i.map((u, f) => {
          var p;
          const d = ((p = n.individualGroupableProps) == null ? void 0 : p.call(n, u, f)) ?? {};
          return /* @__PURE__ */ it.jsx(
            ye,
            {
              ref: Yo(this, "moveables", f),
              ...n,
              ...d,
              target: u,
              wrapperMoveable: this,
              isWrapperMounted: this.isMoveableMounted,
              persistData: l[f]
            },
            "moveable" + f
          );
        })
      }
    );
  }
  componentDidMount() {
  }
  componentDidUpdate() {
  }
  getTargets() {
    return this.props.targets;
  }
  updateRect(n, r, s = !0) {
    Le(!0), this.moveables.forEach((o) => {
      o.updateRect(n, r, s);
    }), Le();
  }
  getRect() {
    return {
      ...super.getRect(),
      children: this.moveables.map((n) => n.getRect())
    };
  }
  request(n, r = {}, s) {
    const o = this.moveables.map(
      (c) => c.request(n, { ...r, isInstant: !1 }, !1)
    ), i = s || r.isInstant, a = {
      request(c) {
        return o.forEach((l) => l.request(c)), this;
      },
      requestEnd() {
        return o.forEach((c) => c.requestEnd()), this;
      }
    };
    return i ? a.request(r).requestEnd() : a;
  }
  dragStart(n, r = n.target) {
    const s = r, o = kt(this.moveables, (i) => {
      const a = i.getTargets()[0], c = i.getControlBoxElement(), l = i.getDragElement();
      return !a || !l ? !1 : l === s || l.contains(s) || l !== a && a === s || a.contains(s) || c === s || c.contains(s);
    });
    return o && o.dragStart(n, r), this;
  }
  hitTest() {
    return 0;
  }
  isInside() {
    return !1;
  }
  isDragging() {
    return !1;
  }
  getDragElement() {
    return null;
  }
  getMoveables() {
    return [...this.moveables];
  }
  updateRenderPoses() {
  }
  checkUpdate() {
  }
  triggerEvent() {
  }
  updateAbles() {
  }
  _updateEvents() {
  }
  _updateObserver() {
  }
}
function pa(t, e) {
  const n = [];
  return t.forEach((r) => {
    if (r) {
      if (re(r)) {
        e[r] && n.push(...e[r]);
        return;
      }
      Rt(r) ? n.push(...pa(r, e)) : n.push(r);
    }
  }), n;
}
function ga(t, e) {
  const n = [];
  return t.forEach((r) => {
    if (r) {
      if (re(r)) {
        e[r] && n.push(...e[r]);
        return;
      }
      Rt(r) ? n.push(ga(r, e)) : n.push(r);
    }
  }), n;
}
function ha(t, e) {
  return t.length !== e.length || t.some((n, r) => {
    const s = e[r];
    return !n && !s ? !1 : n != s ? Rt(n) && Rt(s) ? ha(n, s) : !0 : !1;
  });
}
class on extends _o.PureComponent {
  constructor() {
    super(...arguments);
    // @withMethods(MOVEABLE_METHODS)
    X(this, "moveable");
    X(this, "refTargets", []);
    X(this, "selectorMap", {});
    X(this, "_differ", new _i());
    X(this, "_elementTargets", []);
    X(this, "_tmpRefTargets", []);
    X(this, "_tmpSelectorMap", {});
    X(this, "_onChangeTargets", null);
  }
  static makeStyled() {
    const n = {};
    this.getTotalAbles().forEach(({ css: o }) => {
      o && o.forEach((i) => {
        n[i] = !0;
      });
    });
    const s = Ve(n).join(`
`);
    this.defaultStyled = ca("div", lc(Hr, oc + s));
  }
  static getTotalAbles() {
    return [
      Zi,
      Ms,
      ua,
      Ki,
      ...this.defaultAbles
    ];
  }
  render() {
    const n = this.constructor;
    n.defaultStyled || n.makeStyled();
    const { ables: r, props: s, ...o } = this.props, [i, a] = this._updateRefs(!0), c = pa(i, a);
    let l = c.length > 1;
    const f = [...n.getTotalAbles(), ...r || []], d = {
      ...o,
      ...s || {},
      ables: f,
      cssStyled: n.defaultStyled,
      customStyledMap: n.customStyledMap
    };
    this._elementTargets = c;
    let p = null;
    const g = this.moveable, h = o.persistData;
    if (h != null && h.children && (l = !0), o.individualGroupable)
      return /* @__PURE__ */ it.jsx(
        Pf,
        {
          ref: Se(this, "moveable"),
          ...d,
          target: null,
          targets: c
        },
        "individual-group"
      );
    if (l) {
      const v = ga(i, a);
      if (g && !g.props.groupable && !g.props.individualGroupable) {
        const m = g.props.target;
        m && c.indexOf(m) > -1 && (p = { ...g.state });
      }
      return /* @__PURE__ */ it.jsx(
        da,
        {
          ref: Se(this, "moveable"),
          ...d,
          ...o.groupableProps ?? {},
          target: null,
          targets: c,
          targetGroups: v,
          firstRenderState: p
        },
        "group"
      );
    } else {
      const v = c[0];
      if (g && (g.props.groupable || g.props.individualGroupable)) {
        const m = g.moveables || [], S = kt(
          m,
          (x) => x.props.target === v
        );
        S && (p = { ...S.state });
      }
      return /* @__PURE__ */ it.jsx(
        ye,
        {
          ref: Se(this, "moveable"),
          ...d,
          target: v,
          firstRenderState: p
        },
        "single"
      );
    }
  }
  componentDidMount() {
    this._checkChangeTargets();
  }
  componentDidUpdate() {
    this._checkChangeTargets();
  }
  componentWillUnmount() {
    this.selectorMap = {}, this.refTargets = [];
  }
  /**
   * Get targets set in moveable through target or targets of props.
   * @method Moveable#getTargets
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body, {
   *    target: [targetRef, ".target", document.querySelectorAll(".target")],
   * });
   *
   * console.log(moveable.getTargets());
   */
  getTargets() {
    var n;
    return ((n = this.moveable) == null ? void 0 : n.getTargets()) ?? [];
  }
  /**
   * If the element list corresponding to the selector among the targets is changed, it is updated.
   * @method Moveable#updateSelectors
   * @example
   * import Moveable from "moveable";
   *
   * const moveable = new Moveable(document.body, {
   *    target: ".target",
   * });
   *
   * moveable.updateSelectors();
   */
  updateSelectors() {
    this.selectorMap = {}, this._updateRefs(), this.forceUpdate();
  }
  /**
   * User changes target and waits for target to change.
   * @method Moveable#waitToChangeTarget
   * @story combination-with-other-components--components-selecto
   * @example
   * document.querySelector(".target").addEventListener("mousedown", e => {
   *   moveable.waitToChangeTarget().then(() => {
   *      moveable.dragStart(e, e.currentTarget);
   *   });
   *   moveable.target = e.currentTarget;
   * });
   */
  waitToChangeTarget() {
    let n;
    return this._onChangeTargets = () => {
      this._onChangeTargets = null, n();
    }, new Promise((r) => {
      n = r;
    });
  }
  waitToChangeTargets() {
    return this.waitToChangeTarget();
  }
  getManager() {
    return this.moveable;
  }
  getMoveables() {
    return this.moveable.getMoveables();
  }
  getDragElement() {
    return this.moveable.getDragElement();
  }
  _updateRefs(n) {
    const r = this.refTargets, s = Ss(
      this.props.target || this.props.targets
    ), o = typeof document < "u";
    let i = ha(r, s);
    const a = this.selectorMap, c = {};
    return this.refTargets.forEach(function l(u) {
      re(u) ? a[u] ? c[u] = a[u] : o && (i = !0, c[u] = [].slice.call(
        document.querySelectorAll(u)
      )) : Rt(u) && u.forEach(l);
    }), this._tmpRefTargets = s, this._tmpSelectorMap = c, [s, c, !n && i];
  }
  _checkChangeTargets() {
    var c, l, u;
    this.refTargets = this._tmpRefTargets, this.selectorMap = this._tmpSelectorMap;
    const { added: n, removed: r } = this._differ.update(this._elementTargets);
    (n.length || r.length) && ((l = (c = this.props).onChangeTargets) == null || l.call(c, {
      moveable: this.moveable,
      targets: this._elementTargets
    }), (u = this._onChangeTargets) == null || u.call(this));
    const [o, i, a] = this._updateRefs();
    this.refTargets = o, this.selectorMap = i, a && this.forceUpdate();
  }
}
X(on, "defaultAbles", []), X(on, "customStyledMap", {}), X(on, "defaultStyled", null);
class _f extends on {
}
X(_f, "defaultAbles", Ps);
function Gf(t) {
  var e;
  return e = class extends on {
  }, X(e, "defaultAbles", t), e;
}
export {
  tf as Clippable,
  Xr as DIRECTIONS,
  Ot as Draggable,
  Rf as EdgeDraggable,
  on as InitialMoveable,
  Ps as MOVEABLE_ABLES,
  Bf as MOVEABLE_EVENTS,
  wf as MOVEABLE_METHODS,
  zf as MOVEABLE_PROPS,
  bu as Pinchable,
  Tr as Resizable,
  wl as Rotatable,
  of as Roundable,
  yu as Scalable,
  su as Snappable,
  Mu as Warpable,
  ke as calculateElementPosition,
  _f as default,
  If as getElementInfo,
  dn as makeAble,
  Gf as makeMoveable
};
//# sourceMappingURL=index.es.js.map

import { GroupChild, TargetGroupsObject, TargetGroupsType } from "./types";
export declare class Child {
    parent?: GroupArrayChild | undefined;
    type: "group" | "root" | "single";
    depth: number;
    protected _scope: string[];
    constructor(parent?: GroupArrayChild | undefined);
    get scope(): string[];
}
export declare class GroupSingleChild extends Child {
    value: HTMLElement | SVGElement;
    type: "single";
    constructor(parent: GroupArrayChild, value: HTMLElement | SVGElement);
}
export declare class GroupArrayChild extends Child {
    type: "group" | "root";
    value: GroupChild[];
    id: string;
    map: Map<HTMLElement | SVGElement, GroupSingleChild>;
    compare(groups: TargetGroupsType, checker?: -1 | 0 | 1): boolean;
    has(target: HTMLElement | SVGElement): boolean;
    contains(element: HTMLElement | SVGElement): boolean;
    findContainedChild(element: HTMLElement | SVGElement): GroupChild | undefined;
    /**
     * Exact group containing targets
     */
    findExactChild(target: TargetGroupsType[0]): GroupChild | undefined;
    findCommonParent(targets: TargetGroupsType): GroupArrayChild;
    findNextChild(target: HTMLElement | SVGElement, range?: TargetGroupsType, isExact?: boolean): GroupArrayChild | null;
    findNextExactChild(target: HTMLElement | SVGElement, selected: Array<HTMLElement | SVGElement>, range?: TargetGroupsType): GroupArrayChild | null;
    /**
     * Finds a group that does not overlap within the range and includes the target.
     */
    findPureChild(target: HTMLElement | SVGElement, range: Array<HTMLElement | SVGElement>): GroupArrayChild | null;
    findNextPureChild(target: HTMLElement | SVGElement, range: Array<HTMLElement | SVGElement>): GroupArrayChild | null;
    toTargetGroups(): TargetGroupsType;
    findArrayChild(targets: TargetGroupsType): GroupArrayChild | null;
    groupByPerfect(selected: Array<HTMLElement | SVGElement>): GroupChild[];
    add(targets: TargetGroupsObject): Window;
}

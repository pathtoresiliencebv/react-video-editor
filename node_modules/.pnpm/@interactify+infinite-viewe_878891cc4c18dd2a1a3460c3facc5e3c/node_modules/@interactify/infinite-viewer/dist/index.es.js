var Tr = Object.defineProperty;
var zr = (i, n, t) => n in i ? Tr(i, n, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[n] = t;
var _ = (i, n, t) => zr(i, typeof n != "symbol" ? n + "" : n, t);
import * as Rr from "react";
import xe from "react";
var Lt = { exports: {} }, ht = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var pe;
function Dr() {
  if (pe) return ht;
  pe = 1;
  var i = xe, n = Symbol.for("react.element"), t = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, e = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(l, h, u) {
    var d, v = {}, c = null, m = null;
    u !== void 0 && (c = "" + u), h.key !== void 0 && (c = "" + h.key), h.ref !== void 0 && (m = h.ref);
    for (d in h) r.call(h, d) && !o.hasOwnProperty(d) && (v[d] = h[d]);
    if (l && l.defaultProps) for (d in h = l.defaultProps, h) v[d] === void 0 && (v[d] = h[d]);
    return { $$typeof: n, type: l, key: c, ref: m, props: v, _owner: e.current };
  }
  return ht.Fragment = t, ht.jsx = a, ht.jsxs = a, ht;
}
var ft = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ge;
function Yr() {
  return ge || (ge = 1, process.env.NODE_ENV !== "production" && function() {
    var i = xe, n = Symbol.for("react.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), l = Symbol.for("react.context"), h = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), v = Symbol.for("react.memo"), c = Symbol.for("react.lazy"), m = Symbol.for("react.offscreen"), p = Symbol.iterator, S = "@@iterator";
    function T(s) {
      if (s === null || typeof s != "object")
        return null;
      var f = p && s[p] || s[S];
      return typeof f == "function" ? f : null;
    }
    var z = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function b(s) {
      {
        for (var f = arguments.length, g = new Array(f > 1 ? f - 1 : 0), E = 1; E < f; E++)
          g[E - 1] = arguments[E];
        W("error", s, g);
      }
    }
    function W(s, f, g) {
      {
        var E = z.ReactDebugCurrentFrame, R = E.getStackAddendum();
        R !== "" && (f += "%s", g = g.concat([R]));
        var D = g.map(function(y) {
          return String(y);
        });
        D.unshift("Warning: " + f), Function.prototype.apply.call(console[s], console, D);
      }
    }
    var k = !1, H = !1, V = !1, C = !1, P = !1, L;
    L = Symbol.for("react.module.reference");
    function q(s) {
      return !!(typeof s == "string" || typeof s == "function" || s === r || s === o || P || s === e || s === u || s === d || C || s === m || k || H || V || typeof s == "object" && s !== null && (s.$$typeof === c || s.$$typeof === v || s.$$typeof === a || s.$$typeof === l || s.$$typeof === h || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      s.$$typeof === L || s.getModuleId !== void 0));
    }
    function Z(s, f, g) {
      var E = s.displayName;
      if (E)
        return E;
      var R = f.displayName || f.name || "";
      return R !== "" ? g + "(" + R + ")" : g;
    }
    function F(s) {
      return s.displayName || "Context";
    }
    function x(s) {
      if (s == null)
        return null;
      if (typeof s.tag == "number" && b("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof s == "function")
        return s.displayName || s.name || null;
      if (typeof s == "string")
        return s;
      switch (s) {
        case r:
          return "Fragment";
        case t:
          return "Portal";
        case o:
          return "Profiler";
        case e:
          return "StrictMode";
        case u:
          return "Suspense";
        case d:
          return "SuspenseList";
      }
      if (typeof s == "object")
        switch (s.$$typeof) {
          case l:
            var f = s;
            return F(f) + ".Consumer";
          case a:
            var g = s;
            return F(g._context) + ".Provider";
          case h:
            return Z(s, s.render, "ForwardRef");
          case v:
            var E = s.displayName || null;
            return E !== null ? E : x(s.type) || "Memo";
          case c: {
            var R = s, D = R._payload, y = R._init;
            try {
              return x(y(D));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var B = Object.assign, K = 0, at, mt, _t, lt, Kt, Jt, Qt;
    function te() {
    }
    te.__reactDisabledLog = !0;
    function Je() {
      {
        if (K === 0) {
          at = console.log, mt = console.info, _t = console.warn, lt = console.error, Kt = console.group, Jt = console.groupCollapsed, Qt = console.groupEnd;
          var s = {
            configurable: !0,
            enumerable: !0,
            value: te,
            writable: !0
          };
          Object.defineProperties(console, {
            info: s,
            log: s,
            warn: s,
            error: s,
            group: s,
            groupCollapsed: s,
            groupEnd: s
          });
        }
        K++;
      }
    }
    function Qe() {
      {
        if (K--, K === 0) {
          var s = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: B({}, s, {
              value: at
            }),
            info: B({}, s, {
              value: mt
            }),
            warn: B({}, s, {
              value: _t
            }),
            error: B({}, s, {
              value: lt
            }),
            group: B({}, s, {
              value: Kt
            }),
            groupCollapsed: B({}, s, {
              value: Jt
            }),
            groupEnd: B({}, s, {
              value: Qt
            })
          });
        }
        K < 0 && b("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var zt = z.ReactCurrentDispatcher, Rt;
    function St(s, f, g) {
      {
        if (Rt === void 0)
          try {
            throw Error();
          } catch (R) {
            var E = R.stack.trim().match(/\n( *(at )?)/);
            Rt = E && E[1] || "";
          }
        return `
` + Rt + s;
      }
    }
    var Dt = !1, Et;
    {
      var tr = typeof WeakMap == "function" ? WeakMap : Map;
      Et = new tr();
    }
    function ee(s, f) {
      if (!s || Dt)
        return "";
      {
        var g = Et.get(s);
        if (g !== void 0)
          return g;
      }
      var E;
      Dt = !0;
      var R = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var D;
      D = zt.current, zt.current = null, Je();
      try {
        if (f) {
          var y = function() {
            throw Error();
          };
          if (Object.defineProperty(y.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(y, []);
            } catch ($) {
              E = $;
            }
            Reflect.construct(s, [], y);
          } else {
            try {
              y.call();
            } catch ($) {
              E = $;
            }
            s.call(y.prototype);
          }
        } else {
          try {
            throw Error();
          } catch ($) {
            E = $;
          }
          s();
        }
      } catch ($) {
        if ($ && E && typeof $.stack == "string") {
          for (var w = $.stack.split(`
`), j = E.stack.split(`
`), X = w.length - 1, A = j.length - 1; X >= 1 && A >= 0 && w[X] !== j[A]; )
            A--;
          for (; X >= 1 && A >= 0; X--, A--)
            if (w[X] !== j[A]) {
              if (X !== 1 || A !== 1)
                do
                  if (X--, A--, A < 0 || w[X] !== j[A]) {
                    var N = `
` + w[X].replace(" at new ", " at ");
                    return s.displayName && N.includes("<anonymous>") && (N = N.replace("<anonymous>", s.displayName)), typeof s == "function" && Et.set(s, N), N;
                  }
                while (X >= 1 && A >= 0);
              break;
            }
        }
      } finally {
        Dt = !1, zt.current = D, Qe(), Error.prepareStackTrace = R;
      }
      var nt = s ? s.displayName || s.name : "", J = nt ? St(nt) : "";
      return typeof s == "function" && Et.set(s, J), J;
    }
    function er(s, f, g) {
      return ee(s, !1);
    }
    function rr(s) {
      var f = s.prototype;
      return !!(f && f.isReactComponent);
    }
    function wt(s, f, g) {
      if (s == null)
        return "";
      if (typeof s == "function")
        return ee(s, rr(s));
      if (typeof s == "string")
        return St(s);
      switch (s) {
        case u:
          return St("Suspense");
        case d:
          return St("SuspenseList");
      }
      if (typeof s == "object")
        switch (s.$$typeof) {
          case h:
            return er(s.render);
          case v:
            return wt(s.type, f, g);
          case c: {
            var E = s, R = E._payload, D = E._init;
            try {
              return wt(D(R), f, g);
            } catch {
            }
          }
        }
      return "";
    }
    var ct = Object.prototype.hasOwnProperty, re = {}, ne = z.ReactDebugCurrentFrame;
    function bt(s) {
      if (s) {
        var f = s._owner, g = wt(s.type, s._source, f ? f.type : null);
        ne.setExtraStackFrame(g);
      } else
        ne.setExtraStackFrame(null);
    }
    function nr(s, f, g, E, R) {
      {
        var D = Function.call.bind(ct);
        for (var y in s)
          if (D(s, y)) {
            var w = void 0;
            try {
              if (typeof s[y] != "function") {
                var j = Error((E || "React class") + ": " + g + " type `" + y + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof s[y] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw j.name = "Invariant Violation", j;
              }
              w = s[y](f, y, E, g, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (X) {
              w = X;
            }
            w && !(w instanceof Error) && (bt(R), b("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", E || "React class", g, y, typeof w), bt(null)), w instanceof Error && !(w.message in re) && (re[w.message] = !0, bt(R), b("Failed %s type: %s", g, w.message), bt(null));
          }
      }
    }
    var ir = Array.isArray;
    function Yt(s) {
      return ir(s);
    }
    function or(s) {
      {
        var f = typeof Symbol == "function" && Symbol.toStringTag, g = f && s[Symbol.toStringTag] || s.constructor.name || "Object";
        return g;
      }
    }
    function sr(s) {
      try {
        return ie(s), !1;
      } catch {
        return !0;
      }
    }
    function ie(s) {
      return "" + s;
    }
    function oe(s) {
      if (sr(s))
        return b("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", or(s)), ie(s);
    }
    var ut = z.ReactCurrentOwner, ar = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, se, ae, xt;
    xt = {};
    function lr(s) {
      if (ct.call(s, "ref")) {
        var f = Object.getOwnPropertyDescriptor(s, "ref").get;
        if (f && f.isReactWarning)
          return !1;
      }
      return s.ref !== void 0;
    }
    function cr(s) {
      if (ct.call(s, "key")) {
        var f = Object.getOwnPropertyDescriptor(s, "key").get;
        if (f && f.isReactWarning)
          return !1;
      }
      return s.key !== void 0;
    }
    function ur(s, f) {
      if (typeof s.ref == "string" && ut.current && f && ut.current.stateNode !== f) {
        var g = x(ut.current.type);
        xt[g] || (b('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', x(ut.current.type), s.ref), xt[g] = !0);
      }
    }
    function hr(s, f) {
      {
        var g = function() {
          se || (se = !0, b("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", f));
        };
        g.isReactWarning = !0, Object.defineProperty(s, "key", {
          get: g,
          configurable: !0
        });
      }
    }
    function fr(s, f) {
      {
        var g = function() {
          ae || (ae = !0, b("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", f));
        };
        g.isReactWarning = !0, Object.defineProperty(s, "ref", {
          get: g,
          configurable: !0
        });
      }
    }
    var vr = function(s, f, g, E, R, D, y) {
      var w = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: n,
        // Built-in properties that belong on the element
        type: s,
        key: f,
        ref: g,
        props: y,
        // Record the component responsible for creating this element.
        _owner: D
      };
      return w._store = {}, Object.defineProperty(w._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(w, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: E
      }), Object.defineProperty(w, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: R
      }), Object.freeze && (Object.freeze(w.props), Object.freeze(w)), w;
    };
    function dr(s, f, g, E, R) {
      {
        var D, y = {}, w = null, j = null;
        g !== void 0 && (oe(g), w = "" + g), cr(f) && (oe(f.key), w = "" + f.key), lr(f) && (j = f.ref, ur(f, R));
        for (D in f)
          ct.call(f, D) && !ar.hasOwnProperty(D) && (y[D] = f[D]);
        if (s && s.defaultProps) {
          var X = s.defaultProps;
          for (D in X)
            y[D] === void 0 && (y[D] = X[D]);
        }
        if (w || j) {
          var A = typeof s == "function" ? s.displayName || s.name || "Unknown" : s;
          w && hr(y, A), j && fr(y, A);
        }
        return vr(s, w, j, R, E, ut.current, y);
      }
    }
    var Ot = z.ReactCurrentOwner, le = z.ReactDebugCurrentFrame;
    function rt(s) {
      if (s) {
        var f = s._owner, g = wt(s.type, s._source, f ? f.type : null);
        le.setExtraStackFrame(g);
      } else
        le.setExtraStackFrame(null);
    }
    var Xt;
    Xt = !1;
    function Pt(s) {
      return typeof s == "object" && s !== null && s.$$typeof === n;
    }
    function ce() {
      {
        if (Ot.current) {
          var s = x(Ot.current.type);
          if (s)
            return `

Check the render method of \`` + s + "`.";
        }
        return "";
      }
    }
    function pr(s) {
      return "";
    }
    var ue = {};
    function gr(s) {
      {
        var f = ce();
        if (!f) {
          var g = typeof s == "string" ? s : s.displayName || s.name;
          g && (f = `

Check the top-level render call using <` + g + ">.");
        }
        return f;
      }
    }
    function he(s, f) {
      {
        if (!s._store || s._store.validated || s.key != null)
          return;
        s._store.validated = !0;
        var g = gr(f);
        if (ue[g])
          return;
        ue[g] = !0;
        var E = "";
        s && s._owner && s._owner !== Ot.current && (E = " It was passed a child from " + x(s._owner.type) + "."), rt(s), b('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', g, E), rt(null);
      }
    }
    function fe(s, f) {
      {
        if (typeof s != "object")
          return;
        if (Yt(s))
          for (var g = 0; g < s.length; g++) {
            var E = s[g];
            Pt(E) && he(E, f);
          }
        else if (Pt(s))
          s._store && (s._store.validated = !0);
        else if (s) {
          var R = T(s);
          if (typeof R == "function" && R !== s.entries)
            for (var D = R.call(s), y; !(y = D.next()).done; )
              Pt(y.value) && he(y.value, f);
        }
      }
    }
    function mr(s) {
      {
        var f = s.type;
        if (f == null || typeof f == "string")
          return;
        var g;
        if (typeof f == "function")
          g = f.propTypes;
        else if (typeof f == "object" && (f.$$typeof === h || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        f.$$typeof === v))
          g = f.propTypes;
        else
          return;
        if (g) {
          var E = x(f);
          nr(g, s.props, "prop", E, s);
        } else if (f.PropTypes !== void 0 && !Xt) {
          Xt = !0;
          var R = x(f);
          b("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", R || "Unknown");
        }
        typeof f.getDefaultProps == "function" && !f.getDefaultProps.isReactClassApproved && b("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function _r(s) {
      {
        for (var f = Object.keys(s.props), g = 0; g < f.length; g++) {
          var E = f[g];
          if (E !== "children" && E !== "key") {
            rt(s), b("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", E), rt(null);
            break;
          }
        }
        s.ref !== null && (rt(s), b("Invalid attribute `ref` supplied to `React.Fragment`."), rt(null));
      }
    }
    var ve = {};
    function de(s, f, g, E, R, D) {
      {
        var y = q(s);
        if (!y) {
          var w = "";
          (s === void 0 || typeof s == "object" && s !== null && Object.keys(s).length === 0) && (w += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var j = pr();
          j ? w += j : w += ce();
          var X;
          s === null ? X = "null" : Yt(s) ? X = "array" : s !== void 0 && s.$$typeof === n ? (X = "<" + (x(s.type) || "Unknown") + " />", w = " Did you accidentally export a JSX literal instead of a component?") : X = typeof s, b("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", X, w);
        }
        var A = dr(s, f, g, R, D);
        if (A == null)
          return A;
        if (y) {
          var N = f.children;
          if (N !== void 0)
            if (E)
              if (Yt(N)) {
                for (var nt = 0; nt < N.length; nt++)
                  fe(N[nt], s);
                Object.freeze && Object.freeze(N);
              } else
                b("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              fe(N, s);
        }
        if (ct.call(f, "key")) {
          var J = x(s), $ = Object.keys(f).filter(function(Cr) {
            return Cr !== "key";
          }), At = $.length > 0 ? "{key: someKey, " + $.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!ve[J + At]) {
            var yr = $.length > 0 ? "{" + $.join(": ..., ") + ": ...}" : "{}";
            b(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, At, J, yr, J), ve[J + At] = !0;
          }
        }
        return s === r ? _r(A) : mr(A), A;
      }
    }
    function Sr(s, f, g) {
      return de(s, f, g, !0);
    }
    function Er(s, f, g) {
      return de(s, f, g, !1);
    }
    var wr = Er, br = Sr;
    ft.Fragment = r, ft.jsx = wr, ft.jsxs = br;
  }()), ft;
}
process.env.NODE_ENV === "production" ? Lt.exports = Dr() : Lt.exports = Yr();
var Q = Lt.exports, xr = "function", Or = "object", Xr = "string", Pr = "undefined", Ar = typeof document !== Pr && document, Mr = [{
  open: "(",
  close: ")"
}, {
  open: '"',
  close: '"'
}, {
  open: "'",
  close: "'"
}, {
  open: '\\"',
  close: '\\"'
}, {
  open: "\\'",
  close: "\\'"
}], yt = {
  cm: function(i) {
    return i * 96 / 2.54;
  },
  mm: function(i) {
    return i * 96 / 254;
  },
  in: function(i) {
    return i * 96;
  },
  pt: function(i) {
    return i * 96 / 72;
  },
  pc: function(i) {
    return i * 96 / 6;
  },
  "%": function(i, n) {
    return i * n / 100;
  },
  vw: function(i, n) {
    return n === void 0 && (n = window.innerWidth), i / 100 * n;
  },
  vh: function(i, n) {
    return n === void 0 && (n = window.innerHeight), i / 100 * n;
  },
  vmax: function(i, n) {
    return n === void 0 && (n = Math.max(window.innerWidth, window.innerHeight)), i / 100 * n;
  },
  vmin: function(i, n) {
    return n === void 0 && (n = Math.min(window.innerWidth, window.innerHeight)), i / 100 * n;
  }
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function kr() {
  for (var i = 0, n = 0, t = arguments.length; n < t; n++) i += arguments[n].length;
  for (var r = Array(i), e = 0, n = 0; n < t; n++) for (var o = arguments[n], a = 0, l = o.length; a < l; a++, e++) r[e] = o[a];
  return r;
}
function st(i) {
  return i && typeof i === Or;
}
function vt(i) {
  return Array.isArray(i);
}
function Oe(i) {
  return typeof i === Xr;
}
function Wr(i) {
  return typeof i === xr;
}
function Lr(i, n) {
  var t = i === "" || i == " ", r = n === "" || n == " ";
  return r && t || i === n;
}
function Xe(i, n, t, r, e) {
  var o = Vt(i, n, t);
  return o ? t : Fr(i, n, t + 1, r, e);
}
function Vt(i, n, t) {
  if (!i.ignore)
    return null;
  var r = n.slice(Math.max(t - 3, 0), t + 3).join("");
  return new RegExp(i.ignore).exec(r);
}
function Fr(i, n, t, r, e) {
  for (var o = function(u) {
    var d = n[u].trim();
    if (d === i.close && !Vt(i, n, u))
      return {
        value: u
      };
    var v = u, c = Ft(e, function(m) {
      var p = m.open;
      return p === d;
    });
    if (c && (v = Xe(c, n, u, r, e)), v === -1)
      return a = u, "break";
    u = v, a = u;
  }, a, l = t; l < r; ++l) {
    var h = o(l);
    if (l = a, typeof h == "object") return h.value;
    if (h === "break") break;
  }
  return -1;
}
function Pe(i, n) {
  var t = Oe(n) ? {
    separator: n
  } : n, r = t.separator, e = r === void 0 ? "," : r, o = t.isSeparateFirst, a = t.isSeparateOnlyOpenClose, l = t.isSeparateOpenClose, h = l === void 0 ? a : l, u = t.openCloseCharacters, d = u === void 0 ? Mr : u, v = d.map(function(C) {
    var P = C.open, L = C.close;
    return P === L ? P : P + "|" + L;
  }).join("|"), c = "(\\s*" + e + "\\s*|" + v + "|\\s+)", m = new RegExp(c, "g"), p = i.split(m).filter(function(C) {
    return C && C !== "undefined";
  }), S = p.length, T = [], z = [];
  function b() {
    return z.length ? (T.push(z.join("")), z = [], !0) : !1;
  }
  for (var W = function(C) {
    var P = p[C].trim(), L = C, q = Ft(d, function(x) {
      var B = x.open;
      return B === P;
    }), Z = Ft(d, function(x) {
      var B = x.close;
      return B === P;
    });
    if (q) {
      if (L = Xe(q, p, C, S, d), L !== -1 && h)
        return b() && o || (T.push(p.slice(C, L + 1).join("")), C = L, o) ? (k = C, "break") : (k = C, "continue");
    } else if (Z && !Vt(Z, p, C)) {
      var F = kr(d);
      return F.splice(d.indexOf(Z), 1), {
        value: Pe(i, {
          separator: e,
          isSeparateFirst: o,
          isSeparateOnlyOpenClose: a,
          isSeparateOpenClose: h,
          openCloseCharacters: F
        })
      };
    } else if (Lr(P, e) && !a)
      return b(), o ? (k = C, "break") : (k = C, "continue");
    L === -1 && (L = S - 1), z.push(p.slice(C, L + 1).join("")), C = L, k = C;
  }, k, H = 0; H < S; ++H) {
    var V = W(H);
    if (H = k, typeof V == "object") return V.value;
    if (V === "break") break;
  }
  return z.length && T.push(z.join("")), T;
}
function jr(i) {
  return Pe(i, ",");
}
function Ir(i) {
  var n = /^([^\d|e|\-|\+]*)((?:\d|\.|-|e-|e\+)+)(\S*)$/g.exec(i);
  if (!n)
    return {
      prefix: "",
      unit: "",
      value: NaN
    };
  var t = n[1], r = n[2], e = n[3];
  return {
    prefix: t,
    unit: e,
    value: parseFloat(r)
  };
}
function Ae(i) {
  return i.replace(/[\s-_]+([^\s-_])/g, function(n, t) {
    return t.toUpperCase();
  });
}
function me() {
  return Date.now ? Date.now() : (/* @__PURE__ */ new Date()).getTime();
}
function Me(i, n, t) {
  t === void 0 && (t = -1);
  for (var r = i.length, e = 0; e < r; ++e)
    if (n(i[e], e, i))
      return e;
  return t;
}
function Ft(i, n, t) {
  var r = Me(i, n);
  return r > -1 ? i[r] : t;
}
function G(i, n) {
  var t = Ir(i), r = t.value, e = t.unit;
  if (st(n)) {
    var o = n[e];
    if (o) {
      if (Wr(o))
        return o(r);
      if (yt[e])
        return yt[e](r, o);
    }
  } else if (e === "%")
    return r * n / 100;
  return yt[e] ? yt[e](r) : r;
}
function tt(i, n, t) {
  return Math.max(n, Math.min(i, t));
}
function $r(i, n) {
  var t = 1 / n;
  return Math.round(i / n) / t;
}
function it(i, n) {
  i.classList ? i.classList.add(n) : i.className += " " + n;
}
function O(i, n, t, r) {
  i.addEventListener(n, t, r);
}
function Y(i, n, t, r) {
  i.removeEventListener(n, t, r);
}
function Nt(i) {
  return (i == null ? void 0 : i.ownerDocument) || Ar;
}
function ot(i) {
  var n;
  return ((n = i == null ? void 0 : i.ownerDocument) === null || n === void 0 ? void 0 : n.defaultView) || window;
}
function Br(i) {
  return i && "postMessage" in i && "blur" in i && "self" in i;
}
function _e(i) {
  return st(i) && i.nodeName && i.nodeType && "ownerDocument" in i;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var jt = function() {
  return jt = Object.assign || function(n) {
    for (var t, r = 1, e = arguments.length; r < e; r++) {
      t = arguments[r];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (n[o] = t[o]);
    }
    return n;
  }, jt.apply(this, arguments);
};
function Hr() {
  for (var i = 0, n = 0, t = arguments.length; n < t; n++) i += arguments[n].length;
  for (var r = Array(i), e = 0, n = 0; n < t; n++) for (var o = arguments[n], a = 0, l = o.length; a < l; a++, e++) r[e] = o[a];
  return r;
}
var Zt = /* @__PURE__ */ function() {
  function i() {
    this._events = {};
  }
  var n = i.prototype;
  return n.on = function(t, r) {
    if (st(t))
      for (var e in t)
        this.on(e, t[e]);
    else
      this._addEvent(t, r, {});
    return this;
  }, n.off = function(t, r) {
    if (!t)
      this._events = {};
    else if (st(t))
      for (var e in t)
        this.off(e);
    else if (!r)
      this._events[t] = [];
    else {
      var o = this._events[t];
      if (o) {
        var a = Me(o, function(l) {
          return l.listener === r;
        });
        a > -1 && o.splice(a, 1);
      }
    }
    return this;
  }, n.once = function(t, r) {
    var e = this;
    return r && this._addEvent(t, r, {
      once: !0
    }), new Promise(function(o) {
      e._addEvent(t, o, {
        once: !0
      });
    });
  }, n.emit = function(t, r) {
    var e = this;
    r === void 0 && (r = {});
    var o = this._events[t];
    if (!t || !o)
      return !0;
    var a = !1;
    return r.eventType = t, r.stop = function() {
      a = !0;
    }, r.currentTarget = this, Hr(o).forEach(function(l) {
      l.listener(r), l.once && e.off(t, l.listener);
    }), !a;
  }, n.trigger = function(t, r) {
    return r === void 0 && (r = {}), this.emit(t, r);
  }, n._addEvent = function(t, r, e) {
    var o = this._events;
    o[t] = o[t] || [];
    var a = o[t];
    a.push(jt({
      listener: r
    }, e));
  }, i;
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var It = function(i, n) {
  return It = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, r) {
    t.__proto__ = r;
  } || function(t, r) {
    for (var e in r) r.hasOwnProperty(e) && (t[e] = r[e]);
  }, It(i, n);
};
function Vr(i, n) {
  It(i, n);
  function t() {
    this.constructor = i;
  }
  i.prototype = n === null ? Object.create(n) : (t.prototype = n.prototype, new t());
}
var M = function() {
  return M = Object.assign || function(n) {
    for (var t, r = 1, e = arguments.length; r < e; r++) {
      t = arguments[r];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (n[o] = t[o]);
    }
    return n;
  }, M.apply(this, arguments);
};
function Nr(i, n) {
  var t = n[0] - i[0], r = n[1] - i[1], e = Math.atan2(r, t);
  return e >= 0 ? e : e + Math.PI * 2;
}
function Mt(i) {
  return Nr([
    i[0].clientX,
    i[0].clientY
  ], [
    i[1].clientX,
    i[1].clientY
  ]) / Math.PI * 180;
}
function Zr(i) {
  return i.touches && i.touches.length >= 2;
}
function Ct(i) {
  return i ? i.touches ? qr(i.touches) : [ke(i)] : [];
}
function Ur(i) {
  return i && (i.type.indexOf("mouse") > -1 || "button" in i);
}
function Se(i, n, t) {
  var r = t.length, e = gt(i, r), o = e.clientX, a = e.clientY, l = e.originalClientX, h = e.originalClientY, u = gt(n, r), d = u.clientX, v = u.clientY, c = gt(t, r), m = c.clientX, p = c.clientY, S = o - d, T = a - v, z = o - m, b = a - p;
  return {
    clientX: l,
    clientY: h,
    deltaX: S,
    deltaY: T,
    distX: z,
    distY: b
  };
}
function kt(i) {
  return Math.sqrt(Math.pow(i[0].clientX - i[1].clientX, 2) + Math.pow(i[0].clientY - i[1].clientY, 2));
}
function qr(i) {
  for (var n = Math.min(i.length, 2), t = [], r = 0; r < n; ++r)
    t.push(ke(i[r]));
  return t;
}
function ke(i) {
  return {
    clientX: i.clientX,
    clientY: i.clientY
  };
}
function gt(i, n) {
  n === void 0 && (n = i.length);
  for (var t = {
    clientX: 0,
    clientY: 0,
    originalClientX: 0,
    originalClientY: 0
  }, r = Math.min(i.length, n), e = 0; e < r; ++e) {
    var o = i[e];
    t.originalClientX += "originalClientX" in o ? o.originalClientX : o.clientX, t.originalClientY += "originalClientY" in o ? o.originalClientY : o.clientY, t.clientX += o.clientX, t.clientY += o.clientY;
  }
  return n ? {
    clientX: t.clientX / n,
    clientY: t.clientY / n,
    originalClientX: t.originalClientX / n,
    originalClientY: t.originalClientY / n
  } : t;
}
var Wt = /* @__PURE__ */ function() {
  function i(n) {
    this.prevClients = [], this.startClients = [], this.movement = 0, this.length = 0, this.startClients = n, this.prevClients = n, this.length = n.length;
  }
  return i.prototype.getAngle = function(n) {
    return n === void 0 && (n = this.prevClients), Mt(n);
  }, i.prototype.getRotation = function(n) {
    return n === void 0 && (n = this.prevClients), Mt(n) - Mt(this.startClients);
  }, i.prototype.getPosition = function(n, t) {
    n === void 0 && (n = this.prevClients);
    var r = Se(n || this.prevClients, this.prevClients, this.startClients), e = r.deltaX, o = r.deltaY;
    return this.movement += Math.sqrt(e * e + o * o), this.prevClients = n, r;
  }, i.prototype.getPositions = function(n) {
    n === void 0 && (n = this.prevClients);
    for (var t = this.prevClients, r = this.startClients, e = Math.min(this.length, t.length), o = [], a = 0; a < e; ++a)
      o[a] = Se([n[a]], [t[a]], [r[a]]);
    return o;
  }, i.prototype.getMovement = function(n) {
    var t = this.movement;
    if (!n)
      return t;
    var r = gt(n, this.length), e = gt(this.prevClients, this.length), o = r.clientX - e.clientX, a = r.clientY - e.clientY;
    return Math.sqrt(o * o + a * a) + t;
  }, i.prototype.getDistance = function(n) {
    return n === void 0 && (n = this.prevClients), kt(n);
  }, i.prototype.getScale = function(n) {
    return n === void 0 && (n = this.prevClients), kt(n) / kt(this.startClients);
  }, i.prototype.move = function(n, t) {
    this.startClients.forEach(function(r) {
      r.clientX -= n, r.clientY -= t;
    }), this.prevClients.forEach(function(r) {
      r.clientX -= n, r.clientY -= t;
    });
  }, i;
}(), Ee = ["textarea", "input"], We = /* @__PURE__ */ function(i) {
  Vr(n, i);
  function n(t, r) {
    r === void 0 && (r = {});
    var e = i.call(this) || this;
    e.options = {}, e.flag = !1, e.pinchFlag = !1, e.data = {}, e.isDrag = !1, e.isPinch = !1, e.clientStores = [], e.targets = [], e.prevTime = 0, e.doubleFlag = !1, e._useMouse = !1, e._useTouch = !1, e._useDrag = !1, e._dragFlag = !1, e._isTrusted = !1, e._isMouseEvent = !1, e._isSecondaryButton = !1, e._preventMouseEvent = !1, e._prevInputEvent = null, e._isDragAPI = !1, e._isIdle = !0, e._preventMouseEventId = 0, e._window = window, e.onDragStart = function(c, m) {
      if (m === void 0 && (m = !0), !(!e.flag && c.cancelable === !1)) {
        var p = c.type.indexOf("drag") >= -1;
        if (!(e.flag && p)) {
          e._isDragAPI = !0;
          var S = e.options, T = S.container, z = S.pinchOutside, b = S.preventWheelClick, W = S.preventRightClick, k = S.preventDefault, H = S.checkInput, V = S.dragFocusedInput, C = S.preventClickEventOnDragStart, P = S.preventClickEventOnDrag, L = S.preventClickEventByCondition, q = e._useTouch, Z = !e.flag;
          if (e._isSecondaryButton = c.which === 3 || c.button === 2, b && (c.which === 2 || c.button === 1) || W && (c.which === 3 || c.button === 2))
            return e.stop(), !1;
          if (Z) {
            var F = e._window.document.activeElement, x = c.target;
            if (x) {
              var B = x.tagName.toLowerCase(), K = Ee.indexOf(B) > -1, at = x.isContentEditable;
              if (K || at) {
                if (H || !V && F === x)
                  return !1;
                if (F && (F === x || at && F.isContentEditable && F.contains(x)))
                  if (V)
                    x.blur();
                  else
                    return !1;
              } else if ((k || c.type === "touchstart") && F) {
                var mt = F.tagName.toLowerCase();
                (F.isContentEditable || Ee.indexOf(mt) > -1) && F.blur();
              }
              (C || P || L) && O(e._window, "click", e._onClick, !0);
            }
            e.clientStores = [new Wt(Ct(c))], e._isIdle = !1, e.flag = !0, e.isDrag = !1, e._isTrusted = m, e._dragFlag = !0, e._prevInputEvent = c, e.data = {}, e.doubleFlag = me() - e.prevTime < 200, e._isMouseEvent = Ur(c), !e._isMouseEvent && e._preventMouseEvent && e._allowMouseEvent();
            var _t = e._preventMouseEvent || e.emit("dragStart", M(M({ data: e.data, datas: e.data, inputEvent: c, isMouseEvent: e._isMouseEvent, isSecondaryButton: e._isSecondaryButton, isTrusted: m, isDouble: e.doubleFlag }, e.getCurrentStore().getPosition()), { preventDefault: function() {
              c.preventDefault();
            }, preventDrag: function() {
              e._dragFlag = !1;
            } }));
            _t === !1 && e.stop(), e._isMouseEvent && e.flag && k && c.preventDefault();
          }
          if (!e.flag)
            return !1;
          var lt = 0;
          if (Z ? (e._attchDragEvent(), q && z && (lt = setTimeout(function() {
            O(T, "touchstart", e.onDragStart, {
              passive: !1
            });
          }))) : q && z && Y(T, "touchstart", e.onDragStart), e.flag && Zr(c)) {
            if (clearTimeout(lt), Z && c.touches.length !== c.changedTouches.length)
              return;
            e.pinchFlag || e.onPinchStart(c);
          }
        }
      }
    }, e.onDrag = function(c, m) {
      if (e.flag) {
        var p = e.options.preventDefault;
        !e._isMouseEvent && p && c.preventDefault(), e._prevInputEvent = c;
        var S = Ct(c), T = e.moveClients(S, c, !1);
        if (e._dragFlag) {
          if (e.pinchFlag || T.deltaX || T.deltaY) {
            var z = e._preventMouseEvent || e.emit("drag", M(M({}, T), { isScroll: !!m, inputEvent: c }));
            if (z === !1) {
              e.stop();
              return;
            }
          }
          e.pinchFlag && e.onPinch(c, S);
        }
        e.getCurrentStore().getPosition(S, !0);
      }
    }, e.onDragEnd = function(c) {
      if (e.flag) {
        var m = e.options, p = m.pinchOutside, S = m.container, T = m.preventClickEventOnDrag, z = m.preventClickEventOnDragStart, b = m.preventClickEventByCondition, W = e.isDrag;
        (T || z || b) && requestAnimationFrame(function() {
          e._allowClickEvent();
        }), !b && !z && T && !W && e._allowClickEvent(), e._useTouch && p && Y(S, "touchstart", e.onDragStart), e.pinchFlag && e.onPinchEnd(c);
        var k = c != null && c.touches ? Ct(c) : [], H = k.length;
        H === 0 || !e.options.keepDragging ? e.flag = !1 : e._addStore(new Wt(k));
        var V = e._getPosition(), C = me(), P = !W && e.doubleFlag;
        e._prevInputEvent = null, e.prevTime = W || P ? 0 : C, e.flag || (e._dettachDragEvent(), e._preventMouseEvent || e.emit("dragEnd", M({ data: e.data, datas: e.data, isDouble: P, isDrag: W, isClick: !W, isMouseEvent: e._isMouseEvent, isSecondaryButton: e._isSecondaryButton, inputEvent: c, isTrusted: e._isTrusted }, V)), e.clientStores = [], e._isMouseEvent || (e._preventMouseEvent = !0, clearTimeout(e._preventMouseEventId), e._preventMouseEventId = setTimeout(function() {
          e._preventMouseEvent = !1;
        }, 200)), e._isIdle = !0);
      }
    }, e.onBlur = function() {
      e.onDragEnd();
    }, e._allowClickEvent = function() {
      Y(e._window, "click", e._onClick, !0);
    }, e._onClick = function(c) {
      e._allowClickEvent(), e._allowMouseEvent();
      var m = e.options.preventClickEventByCondition;
      m != null && m(c) || (c.stopPropagation(), c.preventDefault());
    }, e._onContextMenu = function(c) {
      var m = e.options;
      m.preventRightClick ? e.onDragEnd(c) : c.preventDefault();
    }, e._passCallback = function() {
    };
    var o = [].concat(t), a = o[0];
    e._window = Br(a) ? a : ot(a), e.options = M({ checkInput: !1, container: a && !("document" in a) ? ot(a) : a, preventRightClick: !0, preventWheelClick: !0, preventClickEventOnDragStart: !1, preventClickEventOnDrag: !1, preventClickEventByCondition: null, preventDefault: !0, checkWindowBlur: !1, keepDragging: !1, pinchThreshold: 0, events: ["touch", "mouse"] }, r);
    var l = e.options, h = l.container, u = l.events, d = l.checkWindowBlur;
    if (e._useDrag = u.indexOf("drag") > -1, e._useTouch = u.indexOf("touch") > -1, e._useMouse = u.indexOf("mouse") > -1, e.targets = o, e._useDrag && o.forEach(function(c) {
      O(c, "dragstart", e.onDragStart);
    }), e._useMouse && (o.forEach(function(c) {
      O(c, "mousedown", e.onDragStart), O(c, "mousemove", e._passCallback);
    }), O(h, "contextmenu", e._onContextMenu)), d && O(ot(), "blur", e.onBlur), e._useTouch) {
      var v = {
        passive: !1
      };
      o.forEach(function(c) {
        O(c, "touchstart", e.onDragStart, v), O(c, "touchmove", e._passCallback, v);
      });
    }
    return e;
  }
  return n.prototype.stop = function() {
    this.isDrag = !1, this.data = {}, this.clientStores = [], this.pinchFlag = !1, this.doubleFlag = !1, this.prevTime = 0, this.flag = !1, this._isIdle = !0, this._allowClickEvent(), this._dettachDragEvent(), this._isDragAPI = !1;
  }, n.prototype.getMovement = function(t) {
    return this.getCurrentStore().getMovement(t) + this.clientStores.slice(1).reduce(function(r, e) {
      return r + e.movement;
    }, 0);
  }, n.prototype.isDragging = function() {
    return this.isDrag;
  }, n.prototype.isIdle = function() {
    return this._isIdle;
  }, n.prototype.isFlag = function() {
    return this.flag;
  }, n.prototype.isPinchFlag = function() {
    return this.pinchFlag;
  }, n.prototype.isDoubleFlag = function() {
    return this.doubleFlag;
  }, n.prototype.isPinching = function() {
    return this.isPinch;
  }, n.prototype.scrollBy = function(t, r, e, o) {
    o === void 0 && (o = !0), this.flag && (this.clientStores[0].move(t, r), o && this.onDrag(e, !0));
  }, n.prototype.move = function(t, r) {
    var e = t[0], o = t[1], a = this.getCurrentStore(), l = a.prevClients;
    return this.moveClients(l.map(function(h) {
      var u = h.clientX, d = h.clientY;
      return {
        clientX: u + e,
        clientY: d + o,
        originalClientX: u,
        originalClientY: d
      };
    }), r, !0);
  }, n.prototype.triggerDragStart = function(t) {
    this.onDragStart(t, !1);
  }, n.prototype.setEventData = function(t) {
    var r = this.data;
    for (var e in t)
      r[e] = t[e];
    return this;
  }, n.prototype.setEventDatas = function(t) {
    return this.setEventData(t);
  }, n.prototype.getCurrentEvent = function(t) {
    return t === void 0 && (t = this._prevInputEvent), M(M({ data: this.data, datas: this.data }, this._getPosition()), { movement: this.getMovement(), isDrag: this.isDrag, isPinch: this.isPinch, isScroll: !1, inputEvent: t });
  }, n.prototype.getEventData = function() {
    return this.data;
  }, n.prototype.getEventDatas = function() {
    return this.data;
  }, n.prototype.unset = function() {
    var t = this, r = this.targets, e = this.options.container;
    this.off(), Y(this._window, "blur", this.onBlur), this._useDrag && r.forEach(function(o) {
      Y(o, "dragstart", t.onDragStart);
    }), this._useMouse && (r.forEach(function(o) {
      Y(o, "mousedown", t.onDragStart);
    }), Y(e, "contextmenu", this._onContextMenu)), this._useTouch && (r.forEach(function(o) {
      Y(o, "touchstart", t.onDragStart);
    }), Y(e, "touchstart", this.onDragStart)), this._prevInputEvent = null, this._allowClickEvent(), this._dettachDragEvent();
  }, n.prototype.onPinchStart = function(t) {
    var r = this, e = this.options.pinchThreshold;
    if (!(this.isDrag && this.getMovement() > e)) {
      var o = new Wt(Ct(t));
      this.pinchFlag = !0, this._addStore(o);
      var a = this.emit("pinchStart", M(M({ data: this.data, datas: this.data, angle: o.getAngle(), touches: this.getCurrentStore().getPositions() }, o.getPosition()), { inputEvent: t, isTrusted: this._isTrusted, preventDefault: function() {
        t.preventDefault();
      }, preventDrag: function() {
        r._dragFlag = !1;
      } }));
      a === !1 && (this.pinchFlag = !1);
    }
  }, n.prototype.onPinch = function(t, r) {
    if (!(!this.flag || !this.pinchFlag || r.length < 2)) {
      var e = this.getCurrentStore();
      this.isPinch = !0, this.emit("pinch", M(M({ data: this.data, datas: this.data, movement: this.getMovement(r), angle: e.getAngle(r), rotation: e.getRotation(r), touches: e.getPositions(r), scale: e.getScale(r), distance: e.getDistance(r) }, e.getPosition(r)), { inputEvent: t, isTrusted: this._isTrusted }));
    }
  }, n.prototype.onPinchEnd = function(t) {
    if (this.pinchFlag) {
      var r = this.isPinch;
      this.isPinch = !1, this.pinchFlag = !1;
      var e = this.getCurrentStore();
      this.emit("pinchEnd", M(M({ data: this.data, datas: this.data, isPinch: r, touches: e.getPositions() }, e.getPosition()), { inputEvent: t }));
    }
  }, n.prototype.getCurrentStore = function() {
    return this.clientStores[0];
  }, n.prototype.moveClients = function(t, r, e) {
    var o = this._getPosition(t, e), a = this.isDrag;
    (o.deltaX || o.deltaY) && (this.isDrag = !0);
    var l = !1;
    return !a && this.isDrag && (l = !0), M(M({ data: this.data, datas: this.data }, o), { movement: this.getMovement(t), isDrag: this.isDrag, isPinch: this.isPinch, isScroll: !1, isMouseEvent: this._isMouseEvent, isSecondaryButton: this._isSecondaryButton, inputEvent: r, isTrusted: this._isTrusted, isFirstDrag: l });
  }, n.prototype._addStore = function(t) {
    this.clientStores.splice(0, 0, t);
  }, n.prototype._getPosition = function(t, r) {
    var e = this.getCurrentStore(), o = e.getPosition(t, r), a = this.clientStores.slice(1).reduce(function(u, d) {
      var v = d.getPosition();
      return u.distX += v.distX, u.distY += v.distY, u;
    }, o), l = a.distX, h = a.distY;
    return M(M({}, o), { distX: l, distY: h });
  }, n.prototype._attchDragEvent = function() {
    var t = this._window, r = this.options.container, e = {
      passive: !1
    };
    this._isDragAPI && (O(r, "dragover", this.onDrag, e), O(t, "dragend", this.onDragEnd)), this._useMouse && (O(r, "mousemove", this.onDrag), O(t, "mouseup", this.onDragEnd)), this._useTouch && (O(r, "touchmove", this.onDrag, e), O(t, "touchend", this.onDragEnd, e), O(t, "touchcancel", this.onDragEnd, e));
  }, n.prototype._dettachDragEvent = function() {
    var t = this._window, r = this.options.container;
    this._isDragAPI && (Y(r, "dragover", this.onDrag), Y(t, "dragend", this.onDragEnd)), this._useMouse && (Y(r, "mousemove", this.onDrag), Y(t, "mouseup", this.onDragEnd)), this._useTouch && (Y(r, "touchstart", this.onDragStart), Y(r, "touchmove", this.onDrag), Y(t, "touchend", this.onDragEnd), Y(t, "touchcancel", this.onDragEnd));
  }, n.prototype._allowMouseEvent = function() {
    this._preventMouseEvent = !1, clearTimeout(this._preventMouseEventId);
  }, n;
}(Zt);
function Gr(i) {
  for (var n = 5381, t = i.length; t; )
    n = n * 33 ^ i.charCodeAt(--t);
  return n >>> 0;
}
var Kr = Gr;
function Jr(i) {
  return Kr(i).toString(36);
}
function Qr(i) {
  if (i && i.getRootNode) {
    var n = i.getRootNode();
    if (n.nodeType === 11)
      return n;
  }
}
function tn(i, n, t) {
  return t.original ? n : n.replace(/([^};{\s}][^};{]*|^\s*){/mg, function(r, e) {
    var o = e.trim();
    return (o ? jr(o) : [""]).map(function(a) {
      var l = a.trim();
      return l.indexOf("@") === 0 ? l : l.indexOf(":global") > -1 ? l.replace(/\:global/g, "") : l.indexOf(":host") > -1 ? "".concat(l.replace(/\:host/g, ".".concat(i))) : l ? ".".concat(i, " ").concat(l) : ".".concat(i);
    }).join(", ") + " {";
  });
}
function en(i, n, t, r, e) {
  var o = Nt(r), a = o.createElement("style");
  return a.setAttribute("type", "text/css"), a.setAttribute("data-styled-id", i), a.setAttribute("data-styled-count", "1"), t.nonce && a.setAttribute("nonce", t.nonce), a.innerHTML = tn(i, n, t), (e || o.head || o.body).appendChild(a), a;
}
function rn(i) {
  var n = "rCS" + Jr(i);
  return {
    className: n,
    inject: function(t, r) {
      r === void 0 && (r = {});
      var e = Qr(t), o = (e || t.ownerDocument || document).querySelector('style[data-styled-id="'.concat(n, '"]'));
      if (!o)
        o = en(n, i, r, t, e);
      else {
        var a = parseFloat(o.getAttribute("data-styled-count")) || 0;
        o.setAttribute("data-styled-count", "".concat(a + 1));
      }
      return {
        destroy: function() {
          var l, h = parseFloat(o.getAttribute("data-styled-count")) || 0;
          h <= 1 ? (o.remove ? o.remove() : (l = o.parentNode) === null || l === void 0 || l.removeChild(o), o = null) : o.setAttribute("data-styled-count", "".concat(h - 1));
        }
      };
    }
  };
}
function Ut(i, n) {
  for (var t = i.length, r = 0; r < t; ++r)
    if (n(i[r], r))
      return !0;
  return !1;
}
function Le(i, n) {
  for (var t = i.length, r = 0; r < t; ++r)
    if (n(i[r], r))
      return i[r];
  return null;
}
function Fe(i) {
  var n = i;
  if (typeof n > "u") {
    if (typeof navigator > "u" || !navigator)
      return "";
    n = navigator.userAgent || "";
  }
  return n.toLowerCase();
}
function qt(i, n) {
  try {
    return new RegExp(i, "g").exec(n);
  } catch {
    return null;
  }
}
function nn() {
  if (typeof navigator > "u" || !navigator || !navigator.userAgentData)
    return !1;
  var i = navigator.userAgentData, n = i.brands || i.uaList;
  return !!(n && n.length);
}
function on(i, n) {
  var t = qt("(" + i + ")((?:\\/|\\s|:)([0-9|\\.|_]+))", n);
  return t ? t[3] : "";
}
function $t(i) {
  return i.replace(/_/g, ".");
}
function pt(i, n) {
  var t = null, r = "-1";
  return Ut(i, function(e) {
    var o = qt("(" + e.test + ")((?:\\/|\\s|:)([0-9|\\.|_]+))?", n);
    return !o || e.brand ? !1 : (t = e, r = o[3] || "-1", e.versionAlias ? r = e.versionAlias : e.versionTest && (r = on(e.versionTest.toLowerCase(), n) || r), r = $t(r), !0);
  }), {
    preset: t,
    version: r
  };
}
function Tt(i, n) {
  var t = {
    brand: "",
    version: "-1"
  };
  return Ut(i, function(r) {
    var e = je(n, r);
    return e ? (t.brand = r.id, t.version = r.versionAlias || e.version, t.version !== "-1") : !1;
  }), t;
}
function je(i, n) {
  return Le(i, function(t) {
    var r = t.brand;
    return qt("" + n.test, r.toLowerCase());
  });
}
var Ie = [{
  test: "phantomjs",
  id: "phantomjs"
}, {
  test: "whale",
  id: "whale"
}, {
  test: "edgios|edge|edg",
  id: "edge"
}, {
  test: "msie|trident|windows phone",
  id: "ie",
  versionTest: "iemobile|msie|rv"
}, {
  test: "miuibrowser",
  id: "miui browser"
}, {
  test: "samsungbrowser",
  id: "samsung internet"
}, {
  test: "samsung",
  id: "samsung internet",
  versionTest: "version"
}, {
  test: "chrome|crios",
  id: "chrome"
}, {
  test: "firefox|fxios",
  id: "firefox"
}, {
  test: "android",
  id: "android browser",
  versionTest: "version"
}, {
  test: "safari|iphone|ipad|ipod",
  id: "safari",
  versionTest: "version"
}], $e = [{
  test: "(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\schrome)",
  id: "chrome",
  versionTest: "chrome"
}, {
  test: "chromium",
  id: "chrome"
}, {
  test: "whale",
  id: "chrome",
  versionAlias: "-1",
  brand: !0
}], Bt = [{
  test: "applewebkit",
  id: "webkit",
  versionTest: "applewebkit|safari"
}], Be = [{
  test: "(?=(iphone|ipad))(?!(.*version))",
  id: "webview"
}, {
  test: "(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))",
  id: "webview"
}, {
  // test webview
  test: "webview",
  id: "webview"
}], He = [{
  test: "windows phone",
  id: "windows phone"
}, {
  test: "windows 2000",
  id: "window",
  versionAlias: "5.0"
}, {
  test: "windows nt",
  id: "window"
}, {
  test: "win32|windows",
  id: "window"
}, {
  test: "iphone|ipad|ipod",
  id: "ios",
  versionTest: "iphone os|cpu os"
}, {
  test: "macos|macintel|mac os x",
  id: "mac"
}, {
  test: "android|linux armv81",
  id: "android"
}, {
  test: "tizen",
  id: "tizen"
}, {
  test: "webos|web0s",
  id: "webos"
}];
function Ve(i) {
  return !!pt(Be, i).preset;
}
function sn(i) {
  var n = Fe(i), t = !!/mobi/g.exec(n), r = {
    name: "unknown",
    version: "-1",
    majorVersion: -1,
    webview: Ve(n),
    chromium: !1,
    chromiumVersion: "-1",
    webkit: !1,
    webkitVersion: "-1"
  }, e = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  }, o = pt(Ie, n), a = o.preset, l = o.version, h = pt(He, n), u = h.preset, d = h.version, v = pt($e, n);
  if (r.chromium = !!v.preset, r.chromiumVersion = v.version, !r.chromium) {
    var c = pt(Bt, n);
    r.webkit = !!c.preset, r.webkitVersion = c.version;
  }
  return u && (e.name = u.id, e.version = d, e.majorVersion = parseInt(d, 10)), a && (r.name = a.id, r.version = l, r.webview && e.name === "ios" && r.name !== "safari" && (r.webview = !1)), r.majorVersion = parseInt(r.version, 10), {
    browser: r,
    os: e,
    isMobile: t,
    isHints: !1
  };
}
function an(i) {
  var n = navigator.userAgentData, t = (n.uaList || n.brands).slice(), r = n.mobile || !1, e = t[0], o = (n.platform || navigator.platform).toLowerCase(), a = {
    name: e.brand,
    version: e.version,
    majorVersion: -1,
    webkit: !1,
    webkitVersion: "-1",
    chromium: !1,
    chromiumVersion: "-1",
    webview: !!Tt(Be, t).brand || Ve(Fe())
  }, l = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  };
  a.webkit = !a.chromium && Ut(Bt, function(c) {
    return je(t, c);
  });
  var h = Tt($e, t);
  if (a.chromium = !!h.brand, a.chromiumVersion = h.version || "-1", !a.chromium) {
    var u = Tt(Bt, t);
    a.webkit = !!u.brand, a.webkitVersion = u.version || "-1";
  }
  var d = Le(He, function(c) {
    return new RegExp("" + c.test, "g").exec(o);
  });
  l.name = d ? d.id : "";
  {
    var v = Tt(Ie, t);
    a.name = v.brand || a.name, a.version = v.brand && i ? i.uaFullVersion : v.version;
  }
  return a.webkit && (l.name = r ? "ios" : "mac"), l.name === "ios" && a.webview && (a.version = "-1"), l.version = $t(l.version), a.version = $t(a.version), l.majorVersion = parseInt(l.version, 10), a.majorVersion = parseInt(a.version, 10), {
    browser: a,
    os: l,
    isMobile: r,
    isHints: !0
  };
}
function ln(i) {
  return nn() ? an() : sn(i);
}
function cn(i, n) {
  return n.replace(/([^}{]*){/gm, (t, r) => `${r.replace(/\.([^{,\s\d.]+)/g, `.${i}$1`)}{`);
}
function dt(i, n) {
  return (t) => {
    t && (i[n] = t);
  };
}
const un = ln(), hn = un.browser.name === "safari", et = "infinite-viewer-", we = `${et}wrapper`, be = `${et}scroll-area`, fn = `${et}scroll-bar`, Ne = `${et}horizontal-scroll-bar`, Ze = `${et}vertical-scroll-bar`, ye = `${et}scroll-thumb`, Ue = rn(
  cn(
    et,
    `
{
    position: relative;
    overscroll-behavior: none;
}
.wrapper {
    position: absolute;
    width: 100%;
    height: 100%;
    overflow: auto;
    scrollbar-width: none;
    top: 0;
    left: 0;
    will-change: scroll-position;
}
.restrict-wrapper {
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
}
.wrapper::-webkit-scrollbar {
    display: none;
}
.scroll-area {
    position:absolute;
    top:0;
    left:0;
    transform-origin: 0 0;
}
.scroll-bar {
    position:absolute;
    width: 10px;
    height: 10px;
    box-sizing: border-box;
    right: 0;
    bottom: 0;
    overflow: hidden;
}
.horizontal-scroll-bar {
    width: calc(100% - 20px);
    right: 10px;
    height: 14px;
}
.vertical-scroll-bar {
    height: calc(100% - 20px);
    bottom: 10px;
    width: 14px;
}
.scroll-thumb {
    position:relative;
    opacity: 0.7;
    background: #333;
    border-radius: 3px;
    left: 0px;
    top: 0px;
    z-index: 10;
    width: 6px;
    height: 6px;
    transition: all ease 0.2s;
    opacity: 0;
}
.scroll-bar:hover .scroll-thumb {
    border-radius: 5px;
    opacity: 1;
}
.horizontal-scroll-bar .scroll-thumb {
    margin: 4px 0px;
    transition-property: opacity, margin, height, border-radius;
}
.vertical-scroll-bar .scroll-thumb {
    margin: 0px 4px;
    transition-property: opacity, margin, width, border-radius;
}
.horizontal-scroll-bar:hover .scroll-thumb {
    height: 10px;
    margin: 2px 0px;
}
.vertical-scroll-bar:hover .scroll-thumb {
    width: 10px;
    margin: 0px 2px;
}
`
  )
), I = {
  margin: 500,
  threshold: 100,
  zoom: 1,
  zoomX: 1,
  zoomY: 1,
  rangeX: [-1 / 0, 1 / 0],
  rangeY: [-1 / 0, 1 / 0],
  rangeOffsetX: [0, 0],
  rangeOffsetY: [0, 0],
  wrapperElement: null,
  scrollAreaElement: null,
  horizontalScrollElement: null,
  verticalScrollElement: null,
  usePinch: !1,
  useAutoZoom: !1,
  useMouseDrag: !1,
  pinchThreshold: 30,
  cspNonce: "",
  maxPinchWheel: 1 / 0,
  wheelScale: 0.01,
  displayHorizontalScroll: !0,
  displayVerticalScroll: !0,
  useTransform: !0,
  useWheelPinch: !0,
  zoomRange: [1e-3, 1 / 0],
  wheelPinchKey: "ctrl",
  useWheelScroll: hn,
  zoomOffsetX: "50%",
  zoomOffsetY: "50%",
  translateZ: 0,
  useGesture: !0,
  useResizeObserver: !1,
  pinchDirection: "all",
  preventWheelClick: !0,
  useBounceScrollBar: !1,
  useOverflowScroll: !1
}, Ce = (i) => 1 - Math.pow(1 - i, 3), Te = {
  horizontal: {
    pos: "Left",
    coord: "X",
    size: "Width"
  },
  vertical: {
    pos: "Top",
    coord: "Y",
    size: "Height"
  }
}, qe = Ue.className, Gt = [
  "margin",
  "threshold",
  "zoomOffsetX",
  "zoomOffsetY",
  "zoom",
  "zoomX",
  "zoomY",
  "rangeX",
  "rangeY",
  "rangeOffsetX",
  "rangeOffsetY",
  "usePinch",
  "useMouseDrag",
  "pinchThreshold",
  "maxPinchWheel",
  "wheelScale",
  "displayVerticalScroll",
  "displayHorizontalScroll",
  "translateZ",
  "useAutoZoom",
  "wheelPinchKey",
  "zoomRange",
  "zoomRangeX",
  "zoomRangeY",
  "pinchDirection",
  "useOverflowScroll"
], vn = [
  // ignore target, container,
  ...Gt,
  "preventWheelClick",
  "useWheelPinch",
  "useWheelScroll",
  "useGesture",
  "cspNonce",
  "wrapperElement",
  "scrollAreaElement",
  "verticalScrollElement",
  "horizontalScrollElement",
  "useResizeObserver",
  "wheelContainer",
  "useBounceScrollBar"
], Ge = [
  "scroll",
  "abortPinch",
  "dragStart",
  "dragEnd",
  "pinchStart",
  "pinch"
], wn = [
  "getScrollLeft",
  "getScrollTop",
  "getScrollWidth",
  "getScrollHeight",
  "getContainerWidth",
  "getContainerHeight",
  "getViewportWidth",
  "getViewportHeight",
  "getViewportScrollWidth",
  "getViewportScrollHeight",
  "scrollTo",
  "scrollBy",
  "zoomBy",
  "scrollCenter",
  "getContainer",
  "getViewport",
  "getWrapper",
  "setZoom",
  "getRangeX",
  "getRangeY",
  "resize",
  "getZoom",
  "getZoomX",
  "getZoomY",
  "getWheelContainer",
  "setTo",
  "setBy"
], dn = 1e-6;
function pn(i) {
  const { deltaX: n, deltaY: t, datas: r } = i, e = Date.now(), o = r.speed;
  if (!o) {
    r.speed = [0, 0], r.time = e;
    return;
  }
  const a = e - r.time;
  r.speed = [o[0] / 2 + n / a, o[1] / 2 + t / a];
}
function Ke(i, n) {
  const t = Math.sqrt(i[0] * i[0] + i[1] * i[1]);
  return Math.abs(t / n);
}
function gn(i, n) {
  const t = Ke(i, n);
  return [
    -i[0] / 2 * t,
    -i[1] / 2 * t
  ];
}
function U(i) {
  return Math.abs(i);
}
function mn(i, n, t, r, e) {
  const o = e || isFinite(t[0]) ? t[0] : Math.min(-1, Math.floor(i / n)) * n - r, a = e || isFinite(t[1]) ? t[1] : Math.max(1, Math.ceil(i / n)) * n + r;
  return [o, a];
}
function ze(i, n) {
  return i ?? n;
}
function Re(i, n, t) {
  const r = t.duration, e = t.easing || ((h) => 1 - Math.pow(1 - h, 3)), o = Date.now();
  let a = o;
  const l = () => {
    const h = Date.now();
    let u = h - o;
    r < u && (u = r);
    const d = e(u / r), v = e((a - o) / r);
    a = h, i(d - v), !(u >= r) && n(l);
  };
  n(l);
}
class De extends Zt {
  constructor(t, r, e) {
    super();
    _(this, "isAppend", !1);
    _(this, "thumbElement");
    _(this, "barElement");
    _(this, "gesto");
    _(this, "size", 0);
    _(this, "scrollSize", 0);
    _(this, "isHorizontal", !1);
    _(this, "_onDragStart", (t) => {
      const r = this.isHorizontal, e = t.inputEvent.target, o = t.datas, a = this.thumbElement === e;
      a || setTimeout(() => {
        requestAnimationFrame(() => {
          const l = this.thumbElement.getBoundingClientRect(), h = l[r ? "left" : "top"], u = l[r ? "width" : "height"], d = h + u, v = t[r ? "clientX" : "clientY"];
          if (h <= v && v <= d)
            return;
          const c = this.size, m = c * c / this.scrollSize;
          this.scrollBy(h < v ? m : -m);
        });
      }, 100), o.isThumb = a, t.inputEvent.stopPropagation(), t.inputEvent.preventDefault();
    });
    _(this, "_onDrag", (t) => {
      t.datas.isThumb && this.scrollBy(this.isHorizontal ? t.deltaX : t.deltaY);
    });
    _(this, "_onWheel", (t) => {
      const r = this.isHorizontal ? t.deltaX : t.deltaY;
      r && t.preventDefault(), this.trigger("scroll", {
        delta: r
      });
    });
    this.type = r;
    const o = r === "horizontal", a = Nt(t);
    let l, h = e;
    e ? l = e.querySelector(`.${ye}`) : (h = a.createElement("div"), l = a.createElement("div"), h.insertBefore(l, null), this.isAppend = !0), it(
      h,
      o ? Ne : Ze
    ), it(h, fn), it(l, ye), this.thumbElement = l, this.barElement = h, this.isHorizontal = o, this.gesto = new We(h, {
      container: ot(a)
    }).on("dragStart", (u) => this._onDragStart(u)).on("drag", (u) => this._onDrag(u)), O(this.barElement, "wheel", this._onWheel, {
      passive: !1
    });
  }
  scrollBy(t, r) {
    const e = t / this.size;
    this.trigger("scroll", {
      delta: r ? t : this.scrollSize * e
    });
  }
  render(t, r, e, o) {
    this.size = e, this.scrollSize = o;
    const a = t && $r(o - e, 1e-3) > 0 ? 1 : 0, [l, h] = this.isHorizontal ? ["X", "width"] : ["Y", "height"], u = e / o * 100, d = Math.max(0, r) / o * 100;
    this.thumbElement.style.cssText += `${h}: ${u}%;opacity: ${a};transform: translate${l}(${100 / u * d}%)`;
  }
  destroy() {
    Y(this.barElement, "wheel", this._onWheel), this.gesto.off(), this.off();
  }
}
let Ht = class extends Zt {
  /**
   * @sort 1
   */
  constructor(t, r = {}, e = {}) {
    super();
    _(this, "options");
    _(this, "injectResult");
    _(this, "wrapperElement");
    _(this, "scrollAreaElement");
    _(this, "horizontalScrollbar");
    _(this, "verticalScrollbar");
    _(this, "gesto");
    _(this, "offsetX", 0);
    _(this, "offsetY", 0);
    _(this, "containerWidth", 0);
    _(this, "containerHeight", 0);
    _(this, "viewportWidth", 0);
    _(this, "viewportHeight", 0);
    _(this, "viewportScrollWidth", 0);
    _(this, "viewportScrollHeight", 0);
    _(this, "scrollLeft", 0);
    _(this, "scrollTop", 0);
    _(this, "_scrollTimer", 0);
    _(this, "_zoomTimer", 0);
    _(this, "_viewportElement", null);
    _(this, "_wheelContainerElement", null);
    _(this, "dragFlag", !1);
    _(this, "isLoop", !1);
    _(this, "_tempScale", [1, 1]);
    _(this, "_tempRect", null);
    _(this, "_tempRectTimer", null);
    _(this, "_onDestroys", []);
    _(this, "_asLeft", 0);
    _(this, "_asTop", 0);
    /**
     * Update Viewer Sizes
     * @method
     */
    _(this, "resize", () => {
      const { offsetWidth: t, offsetHeight: r } = this._containerElement, {
        offsetWidth: e,
        offsetHeight: o,
        scrollWidth: a,
        scrollHeight: l
      } = this._viewportElement;
      this.containerWidth = t, this.containerHeight = r, this.viewportWidth = e, this.viewportHeight = o, this.viewportScrollWidth = Math.max(e, a), this.viewportScrollHeight = Math.max(o, l), this.render(), this._scrollBy(0, 0);
    });
    _(this, "_onScroll", () => {
      const { scrollLeft: t, scrollTop: r } = this.wrapperElement, { zoom: e = I.zoom } = this, o = t - this.scrollLeft, a = r - this.scrollTop, l = this.getScrollLeft(), h = this.getScrollTop();
      this.isLoop && (this.isLoop = !1), this.scrollLeft = t, this.scrollTop = r, this.scrollTo(
        l + o / e,
        h + a / e
      );
    });
    _(this, "onWheel", (t) => {
      const r = this.options, e = r.pinchDirection, o = r.maxPinchWheel || 1 / 0, a = t[`${this.wheelPinchKey}Key`] || t.ctrlKey;
      if (r.useWheelPinch && a) {
        let l = t.deltaY;
        const h = l >= 0 ? 1 : -1, u = Math.min(o, Math.abs(l));
        l = h * u;
        const d = -l, v = Math.max(
          1 + d * (r.wheelScale || 0.01),
          dn
        );
        clearTimeout(this._tempRectTimer), this._tempRectTimer = window.setTimeout(() => {
          this._tempRect = null;
        }, 100), this._triggerPinch({
          distance: u,
          scale: v,
          rotation: 0,
          zoom: this.zoom * v,
          zoomX: this.zoomX * (e === "vertical" ? 1 : v),
          zoomY: this.zoomY * (e === "horizontal" ? 1 : v),
          inputEvent: t,
          isWheel: !0,
          clientX: t.clientX,
          clientY: t.clientY,
          ratioX: 0,
          ratioY: 0
        });
      } else if (r.useWheelScroll) {
        let l = t.deltaX, h = t.deltaY;
        t.shiftKey && !l && (l = h, h = 0), this.scrollBy(l / this.zoomX, h / this.zoomY);
      } else
        return;
      t.preventDefault();
    });
    _(this, "onGestureStart", (t) => {
      this._tempScale = [this.zoomX, this.zoomY], this._setClientRect(), t.preventDefault();
    });
    _(this, "onGestureChange", (t) => {
      if (t.preventDefault(), this.gesto.isFlag() || !this._tempScale) {
        this._tempScale = [1, 1];
        return;
      }
      const r = t.scale, e = this._tempScale[0], o = this._tempScale[1], a = this.options.pinchDirection;
      this._triggerPinch({
        distance: 0,
        scale: r,
        rotation: t.rotation,
        inputEvent: t,
        isWheel: !0,
        zoom: (e + o) * r / 2,
        zoomX: e * (a === "vertical" ? 1 : r),
        zoomY: o * (a === "horizontal" ? 1 : r),
        clientX: t.clientX,
        clientY: t.clientY,
        ratioX: 0,
        ratioY: 0
      });
    });
    _(this, "onGestureEnd", () => {
    });
    this._containerElement = t, _e(r) ? (this._viewportElement = r, this.options = {
      ...I,
      ...e
    }) : (this._viewportElement = t.children[0], this.options = {
      ...I,
      ...r
    }), this.init();
  }
  static addProperties(t, r) {
    t.forEach((e) => {
      const o = {
        enumerable: !0,
        configurable: !0,
        get() {
          return this.options[e];
        }
      }, a = Ae(`set ${e}`);
      r[a] ? o.set = function(l) {
        this[a](l);
      } : o.set = function(l) {
        this.options[e] = l;
      }, Object.defineProperty(r, e, o);
    });
  }
  /**
   * Get Container Element
   */
  getContainer() {
    return this._containerElement;
  }
  /**
   * Get Wheel Container Element
   */
  getWheelContainer() {
    return this._wheelContainerElement;
  }
  /**
   * Get Viewport Element
   */
  getViewport() {
    return this._viewportElement;
  }
  /**
   * Get Wrapper Element
   */
  getWrapper() {
    return this.wrapperElement;
  }
  /**
   * Get Scroll Area Element
   */
  geScrollArea() {
    return this.scrollAreaElement;
  }
  /**
   * Destroy elements, properties, and events.
   */
  destroy() {
    this.off(), this.gesto.unset(), this.verticalScrollbar.destroy(), this.horizontalScrollbar.destroy(), this.injectResult.destroy();
    const t = this._containerElement;
    this._onDestroys.forEach((r) => {
      r();
    }), Y(this.wrapperElement, "scroll", this._onScroll), Y(this._wheelContainerElement, "wheel", this.onWheel), Y(t, "gesturestart", this.onGestureStart), Y(t, "gesturechange", this.onGestureChange), Y(t, "gesturesend", this.onGestureEnd), this.gesto = null, this.injectResult = null, this._containerElement = null, this._viewportElement = null, this.options = null;
  }
  /**
   * Gets the number of pixels that an element's content is scrolled vertically.
   */
  getScrollTop(t = {}) {
    let r = !1, e = !1;
    st(t) ? (r = t.range, e = t.absolute) : r = t;
    const o = this.zoomY, a = this.scrollTop / o + this.offsetY + (r ? U(this.getRangeY()[0]) : 0);
    return e ? a * o : a;
  }
  /**
   * Gets the number of pixels that an element's content is scrolled vertically.
   */
  getScrollLeft(t = {}) {
    let r = !1, e = !1;
    st(t) ? (r = t.range, e = t.absolute) : r = t;
    const o = this.zoomX, a = this.scrollLeft / o + this.offsetX + (r ? U(this.getRangeX()[0]) : 0);
    return e ? a * o : a;
  }
  /**
   * Gets measurement of the width of an element's content with overflow
   */
  getScrollWidth(t) {
    const r = this._getScrollRangeX(), e = this.zoomX, o = this.containerWidth / e + U(r[0]) + r[1];
    return t ? o : o * e;
  }
  /**
   * Gets measurement of the height of an element's content with overflow
   */
  getScrollHeight(t) {
    const r = this._getScrollRangeY(), e = this.zoomY, o = this.containerHeight / e + U(r[0]) + r[1];
    return t ? o : o * e;
  }
  /**
   * Scroll the element to the center
   */
  scrollCenter(t = {}) {
    this.resize();
    const r = this.zoomX, e = this.zoomY;
    let o = -(this.containerWidth / r - this.viewportWidth) / 2, a = -(this.containerHeight / e - this.viewportHeight) / 2;
    return t.absolute && (o *= r, a *= e), t.horizontal === !1 && (o = this.getScrollLeft()), t.vertical === !1 && (a = this.getScrollTop()), this.scrollTo(o, a, t);
  }
  /**
   * Move to that position or zoom.
   * @since 0.25.0
   */
  setTo(t) {
    const {
      x: r = this.getScrollLeft(),
      y: e = this.getScrollTop(),
      zoom: o = [this.getZoomX(), this.getZoomY()],
      duration: a
    } = t, { zoomX: l, zoomY: h, zoomRange: u } = this;
    let {
      zoomOffsetX: d = I.zoomOffsetX,
      zoomOffsetY: v = I.zoomOffsetY
    } = this;
    "zoomOffsetX" in t && (d = t.zoomOffsetX), "zoomOffsetY" in t && (v = t.zoomOffsetY);
    const [c, m] = vt(o) ? o : [o, o], p = this.zoomRangeX || u, S = this.zoomRangeY || u, T = tt(c, p[0], p[1]), z = tt(m, S[0], S[1]), b = G(`${d}`, this.viewportWidth) * (1 / l - 1 / T), W = G(`${v}`, this.viewportHeight) * (1 / h - 1 / z);
    this.scrollTo(r - b, e - W, {
      duration: a
    }), this.setZoom(o, {
      zoomOffsetX: d,
      zoomOffsetY: v,
      duration: a,
      zoomBase: "fixed"
    });
  }
  /**
   * Move by the position or zoom delta value.
   * @since 0.25.0
   */
  setBy(t) {
    const { x: r = 0, y: e = 0, zoom: o = [0, 0] } = t, [a, l] = vt(o) ? o : [o, o];
    this.setTo({
      ...t,
      x: this.getScrollLeft() + r,
      y: this.getScrollTop() + e,
      zoom: [this.zoomX + a, this.zoomY + l]
    });
  }
  /**
   * Scrolls the container by the given amount.
   */
  scrollBy(t, r, e) {
    if (this._pauseScrollAnimation(), !e || !e.duration) {
      let o = this.getScrollLeft(), a = this.getScrollTop();
      return e != null && e.absolute && (o *= this.zoomX, a *= this.zoomY), this._scrollTo(o + t, a + r, e);
    } else
      return this._startScrollAnimation([t, r], e), !0;
  }
  /**
   * Scrolls the container to set of coordinates.
   * @param scrollLeft
   * @param scrollTop
   */
  scrollTo(t, r, e) {
    if (this._pauseScrollAnimation(), !e || !e.duration)
      return this._scrollTo(t, r, e);
    {
      let o = this.getScrollLeft(), a = this.getScrollTop();
      return e != null && e.absolute && (o *= this.zoomX, a *= this.zoomY), this.scrollBy(t - o, r - a, e);
    }
  }
  /**
   * Set viewer zoom by the given amount
   */
  zoomBy(t, r) {
    this._pauseZoomAnimation();
    const [e, o] = vt(t) ? t : [t, t];
    !r || !r.duration ? this._setZoom([this.zoomX + e, this.zoomY + o], r) : this._startZoomAnimation([e, o], r);
  }
  /**
   * Set viewer zoom
   */
  setZoom(t, r) {
    if (this._pauseZoomAnimation(), !r || !r.duration)
      this._setZoom(t, r);
    else {
      const [e, o] = vt(t) ? t : [t, t];
      this._startZoomAnimation(
        [e - this.zoomX, o - this.zoomY],
        r
      );
    }
  }
  getViewportWidth() {
    return this.viewportWidth;
  }
  getViewportHeight() {
    return this.viewportWidth;
  }
  getViewportScrollWidth() {
    return this.viewportScrollWidth;
  }
  getViewportScrollHeight() {
    return this.viewportScrollHeight;
  }
  getContainerWidth() {
    return this.containerWidth;
  }
  getContainerHeight() {
    return this.containerHeight;
  }
  /**
   * Get viewer zoom
   */
  getZoom() {
    return (this.zoomX + this.zoomY) / 2;
  }
  /**
   * Get viewer zoomX
   * @since 0.20.0
   */
  getZoomX() {
    return this.zoomX;
  }
  /**
   * Get viewer zoom
   * @since 0.20.0
   */
  getZoomY() {
    return this.zoomY;
  }
  /**
   * get x ranges
   */
  getRangeX(t, r) {
    return this._getRangeCoord("horizontal", t, r);
  }
  /**
   * get y ranges
   */
  getRangeY(t, r) {
    return this._getRangeCoord("vertical", t, r);
  }
  init() {
    const t = this._containerElement, r = this.options, e = Nt(t), o = ot(t);
    let a = r.wrapperElement || t.querySelector(`.${we}`), l = r.scrollAreaElement || t.querySelector(`.${be}`);
    const h = r.horizontalScrollElement || t.querySelector(`.${Ne}`), u = r.verticalScrollElement || t.querySelector(`.${Ze}`);
    a || (a = e.createElement("div"), a.insertBefore(this._viewportElement, null), t.insertBefore(a, null)), this.wrapperElement = a, l || (l = e.createElement("div"), a.insertBefore(l, a.firstChild)), this.scrollAreaElement = l, it(t, qe), it(a, we), it(l, be);
    const d = new De(
      t,
      "horizontal",
      h
    ), v = new De(
      t,
      "vertical",
      u
    );
    this.horizontalScrollbar = d, this.verticalScrollbar = v, d.on("scroll", (p) => {
      this.scrollBy(p.delta / this.zoomX, 0);
    }), v.on("scroll", (p) => {
      this.scrollBy(0, p.delta / this.zoomY);
    }), d.isAppend && t.insertBefore(d.barElement, null), v.isAppend && t.insertBefore(v.barElement, null), this.injectResult = Ue.inject(t, {
      nonce: this.options.cspNonce
    });
    const c = r.wheelContainer;
    let m = null;
    if (c && (Oe(c) ? m = e.querySelector(c) : _e(c) ? m = c : ("value" in c || "current" in c) && (m = c.current || c.value)), m || (m = t), this._wheelContainerElement = m, this.gesto = new We(t, {
      container: ot(t),
      events: ["touch", "mouse"],
      preventWheelClick: this.options.preventWheelClick ?? !0
    }).on("dragStart", (p) => {
      const { inputEvent: S, stop: T, datas: z } = p;
      if (!this.useMouseDrag && p.isMouseEvent) {
        T();
        return;
      }
      if (this._pauseScrollAnimation(), this.dragFlag = !1, this.trigger("dragStart", p) === !1) {
        T();
        return;
      }
      S.preventDefault(), z.startEvent = S;
    }).on("drag", (p) => {
      !this.options.usePinch || p.isPinch || this.useMouseDrag && p.isMouseEvent ? (this.trigger("drag", {
        ...p,
        inputEvent: p.inputEvent
      }), pn(p), this.scrollBy(-p.deltaX / this.zoomX, -p.deltaY / this.zoomY)) : !this.dragFlag && p.movement > r.pinchThreshold && (this.dragFlag = !0, this.trigger("abortPinch", {
        inputEvent: p.datas.startEvent || p.inputEvent
      }));
    }).on("dragEnd", (p) => {
      this.trigger("dragEnd", {
        isDrag: p.isDrag,
        isDouble: p.isDouble,
        inputEvent: p.inputEvent
      }), this._startScrollAnimationBySpeed(p.datas.speed);
    }).on("pinchStart", ({ inputEvent: p, datas: S, stop: T }) => {
      p.preventDefault(), this._pauseScrollAnimation(), S.startZoom = [this.zoomX, this.zoomY], this.trigger("pinchStart", {
        inputEvent: p
      }) === !1 && T(), this._setClientRect();
    }).on("pinch", (p) => {
      const S = p.scale, T = this.options.pinchDirection;
      this._triggerPinch({
        rotation: p.rotation,
        distance: p.distance,
        scale: p.scale,
        inputEvent: p.inputEvent,
        isWheel: !1,
        zoom: p.datas.startZoom * S,
        zoomX: this.zoomX * (T === "vertical" ? 1 : S),
        zoomY: this.zoomY * (T === "horizontal" ? 1 : S),
        clientX: p.clientX,
        clientY: p.clientY,
        ratioX: 0,
        ratioY: 0
      });
    }).on("pinchEnd", () => {
      this._tempRect = null;
    }), O(a, "scroll", this._onScroll), r.useResizeObserver) {
      const p = new o.ResizeObserver(() => {
        this.resize();
      });
      p.observe(this._viewportElement), p.observe(this._containerElement), this._onDestroys.push(() => {
        p.disconnect();
      });
    } else
      O(o, "resize", this.resize), this._onDestroys.push(() => {
        Y(o, "resize", this.resize);
      });
    (r.useWheelPinch || r.useWheelScroll) && O(m, "wheel", this.onWheel, {
      passive: !1
    }), r.useGesture && (O(t, "gesturestart", this.onGestureStart, {
      passive: !1
    }), O(t, "gesturechange", this.onGestureChange, {
      passive: !1
    })), this.resize();
  }
  render() {
    const {
      offsetX: t,
      offsetY: r,
      zoomX: e = I.zoomX,
      zoomY: o = I.zoomY,
      translateZ: a = 0,
      rangeX: l,
      rangeY: h,
      containerWidth: u,
      containerHeight: d
    } = this, { useTransform: v = I.useTransform } = this.options;
    let c = -t * e, m = -r * o;
    this.scrollAreaElement.style.cssText = `width:calc(100% + ${this.getScrollAreaWidth()}px);height:calc(100% + ${this.getScrollAreaHeight()}px);`;
    const p = this._viewportElement.style;
    v === !1 ? p.cssText += `position: relative; left: ${c}px; top: ${m}px; ` : p.cssText += `transform-origin: 0 0;transform:translate3d(${c}px, ${m}px, ${a}px) scale(${e}, ${o});`, this.renderScroll();
  }
  renderScroll() {
    const { zoomX: t, zoomY: r, containerWidth: e, containerHeight: o } = this, a = this.horizontalScrollbar, l = this.verticalScrollbar;
    if (this.options.useBounceScrollBar) {
      const h = this.getScrollLeft(!0) * t, u = this.getRangeX(!0), d = e + U(u[0]) + U(u[1]), v = this.getScrollTop(!0) * r, c = this.getRangeY(!0), m = o + U(c[0]) + U(c[1]);
      a.render(
        this.displayHorizontalScroll,
        h,
        e,
        d
      ), l.render(
        this.displayVerticalScroll,
        v,
        o,
        m
      );
    } else {
      const h = this._getScrollRangeX(), u = this._getScrollRangeY(), d = this.getScrollLeft(), v = this.getScrollTop(), c = this.containerWidth + U(h[0]) + h[1], m = this.containerHeight + U(u[0]) + u[1];
      a.render(
        this.displayHorizontalScroll,
        d - h[0],
        e,
        c
      ), l.render(
        this.displayVerticalScroll,
        v - u[0],
        o,
        m
      );
    }
  }
  move(t, r) {
    const e = this.wrapperElement;
    e.scrollLeft = t, e.scrollTop = r;
  }
  setDisplayVerticalScroll(t) {
    this.options.displayVerticalScroll = t, this.renderScroll();
  }
  setDisplayHorizontalScroll(t) {
    this.options.displayHorizontalScroll = t, this.renderScroll();
  }
  _startZoomAnimation(t, r) {
    if (!t)
      return;
    const e = r.duration, o = r.easing || Ce;
    Re(
      (a) => this._setZoom(
        [this.zoomX + t[0] * a, this.zoomY + t[1] * a],
        r
      ),
      (a) => {
        this._zoomTimer = requestAnimationFrame(a);
      },
      {
        easing: o,
        duration: e
      }
    );
  }
  _startScrollAnimation(t, r) {
    if (!t[0] && !t[1])
      return;
    const e = r.duration, o = r.easing || Ce;
    Re(
      (a) => this._scrollBy(t[0] * a, t[1] * a, r),
      (a) => {
        this._scrollTimer = requestAnimationFrame(a);
      },
      {
        easing: o,
        duration: e
      }
    );
  }
  _startScrollAnimationBySpeed(t) {
    if (!t || !t[0] && !t[1])
      return;
    const r = -6e-4, e = Ke(t, r), o = gn(t, r);
    return this._startScrollAnimation(o, {
      duration: e
    });
  }
  _pauseScrollAnimation() {
    cancelAnimationFrame(this._scrollTimer), this._scrollTimer = 0;
  }
  _pauseZoomAnimation() {
    cancelAnimationFrame(this._zoomTimer), this._zoomTimer = 0;
  }
  getScrollAreaWidth() {
    const [t, r] = this.getRangeX(!0);
    return t || r ? this.margin * 2 : 0;
  }
  getScrollAreaHeight() {
    const [t, r] = this.getRangeY(!0);
    return t || r ? this.margin * 2 : 0;
  }
  _triggerPinch(t) {
    const { clientX: r, clientY: e, zoomX: o, zoomY: a } = t;
    this.useAutoZoom && this._zoomByClient([o, a], r, e), this._tempRect || this._setClientRect();
    const l = this.zoomRange, h = this.zoomRangeX || l, u = this.zoomRangeY || l, { left: d, top: v, width: c, height: m } = this._tempRect, p = (r - d) / c * 100, S = (e - v) / m * 100;
    this.trigger("pinch", {
      ...t,
      zoom: tt((o + a) / 2, l[0], l[1]),
      zoomX: tt(o, h[0], h[1]),
      zoomY: tt(a, u[0], u[1]),
      ratioX: p,
      ratioY: S
    });
  }
  _setClientRect() {
    const t = this.getContainer().getBoundingClientRect();
    this._tempRect = {
      left: t.left,
      top: t.top,
      width: t.width,
      height: t.height
    };
  }
  _zoomByClient(t, r, e) {
    this._tempRect || this._setClientRect();
    const { left: o, top: a, width: l, height: h } = this._tempRect, u = this.options, d = u.zoomOffsetX, v = u.zoomOffsetY;
    u.zoomOffsetX = `${(r - o) / l * 100}%`, u.zoomOffsetY = `${(e - a) / h * 100}%`, this._setZoom(t, {
      zoomBase: "screen"
    }), u.zoomOffsetX = d, u.zoomOffsetY = v;
  }
  _setZoom(t, r = {}) {
    const e = r.zoomBase, {
      containerWidth: o,
      containerHeight: a,
      zoomX: l,
      zoomY: h,
      zoomRange: u
    } = this;
    let {
      zoomOffsetX: d = I.zoomOffsetX,
      zoomOffsetY: v = I.zoomOffsetY
    } = this;
    "zoomOffsetX" in r && (d = r.zoomOffsetX), "zoomOffsetY" in r && (v = r.zoomOffsetY);
    const c = this.getScrollLeft(), m = this.getScrollTop(), [p, S] = vt(t) ? t : [t, t], T = this.zoomRangeX || u, z = this.zoomRangeY || u, b = tt(p, T[0], T[1]), W = tt(S, z[0], z[1]), k = this.options;
    k.zoomX = b, k.zoomY = W, k.zoom = (b + W) / 2;
    const H = this.getScrollLeft(), V = this.getScrollTop();
    let C = 0, P = 0;
    e === "fixed" ? (C = G(`${d}`, this.viewportWidth), P = G(`${v}`, this.viewportHeight)) : e === "viewport" ? (C = (-c + G(`${d}`, this.viewportWidth)) * l, P = (-m + G(`${v}`, this.viewportHeight)) * h) : (C = G(`${d}`, o), P = G(`${v}`, a));
    const L = c + C / l, q = m + P / h, Z = H + C / b, F = V + P / W;
    this._scrollBy(L - Z, q - F, {
      zoom: !!(b - l || W - h)
    }), this.render();
  }
  _scrollBy(t, r, e) {
    let o = this.getScrollLeft(), a = this.getScrollTop();
    return e != null && e.absolute && (o *= this.zoomX, a *= this.zoomY), this._scrollTo(o + t, a + r, e);
  }
  _scrollTo(t, r, e) {
    const { scrollLeft: o, scrollTop: a } = this, l = e == null ? void 0 : e.absolute;
    this._scrollToType("horizontal", t, l), this._scrollToType("vertical", r, l);
    const h = this.scrollLeft, u = this.scrollTop;
    this.render();
    const d = this.getScrollLeft(), v = this.getScrollTop();
    return this._emitScrollEvent(
      d,
      v,
      e == null ? void 0 : e.zoom
    ), Math.round(o) !== h || Math.round(a) !== u ? (this.isLoop = !0, this.move(h, u), requestAnimationFrame(() => {
      if (!this.isLoop)
        return;
      this.isLoop = !1;
      const { scrollLeft: c, scrollTop: m } = this.wrapperElement;
      this.scrollLeft = c, this.scrollTop = m, (h !== Math.round(c) || u !== Math.round(m)) && this._scrollTo(d, v);
    }), !1) : !0;
  }
  _scrollToType(t, r, e) {
    const o = Te[t], {
      margin: a = I.margin,
      threshold: l = I.threshold
    } = this, h = this[`scroll${o.pos}`], [u, d] = this[`getRange${o.coord}`](!0, !0);
    let v = Math.round(h);
    const c = this[`getScrollArea${o.size}`](), m = this[`zoom${o.coord}`];
    e && (r = r / m);
    const p = r * m;
    if (u === d)
      v = u, r = u / m;
    else if (p - l <= u) {
      const S = Math.max(0, p - u);
      v = S, r = (u + S) / m;
    } else if (p + l >= d) {
      const S = Math.max(0, d - p);
      v = c - S, r = (d - S) / m;
    } else v < l ? v += a : v > c - l && (v -= a);
    v = Math.round(v), this[`scroll${o.pos}`] = v, this[`offset${o.coord}`] = r - v / m;
  }
  _getRangeCoord(t, r, e) {
    const { margin: o = I.margin, threshold: a } = this, l = Te[t], h = ze(
      this[`range${l.coord}`],
      I[`range${l.coord}`]
    ), u = ze(
      this[`rangeOffset${l.coord}`],
      I[`rangeOffset${l.coord}`]
    ), d = this[`zoom${l.coord}`], v = mn(
      this[`getScroll${l.pos}`](),
      o,
      h,
      a,
      e
    );
    return r ? [
      v[0] * d + u[0],
      this.options.useOverflowScroll ? Math.max(
        this[`viewport${l.size}`] * d - this[`container${l.size}`],
        v[1] * d + u[1]
      ) : v[1] * d + u[1]
    ] : [v[0] + u[0], v[1] + u[1]];
  }
  _emitScrollEvent(t, r, e) {
    const o = this._asLeft, a = this._asTop;
    !e && o === t && a === r || (this._asLeft = t, this._asTop = r, this.trigger("scroll", {
      scrollLeft: t,
      scrollTop: r,
      zoomX: this.zoomX,
      zoomY: this.zoomY
    }));
  }
  _getScrollRangeX() {
    const t = this.getScrollLeft(), r = this.rangeX, e = r[0];
    let o = r[1];
    this.useOverflowScroll && isFinite(o) && (o = Math.max(
      o,
      this.viewportWidth - this.containerWidth / this.zoomX
    ));
    const a = Math.min(
      0,
      isFinite(e) ? Math.min(e, t) : t
    ), l = Math.max(
      0,
      isFinite(o) ? Math.max(o, t) : t
    ), h = this.viewportScrollWidth, u = Math.max(this.containerWidth / this.zoomX, h) - h;
    return [Math.min(0, u + a), l];
  }
  _getScrollRangeY() {
    const t = this.getScrollTop(), r = this.rangeY, e = r[0];
    let o = r[1];
    this.useOverflowScroll && isFinite(o) && (o = Math.max(
      o,
      this.viewportHeight - this.containerHeight / this.zoomY
    ));
    const a = Math.min(
      0,
      isFinite(e) ? Math.min(e, t) : t
    ), l = Math.max(
      0,
      isFinite(o) ? Math.max(o, t) : t
    ), h = this.viewportScrollHeight, u = Math.max(this.containerHeight / this.zoomY, h) - h;
    return [Math.min(0, u + a), l];
  }
};
Ht.addProperties(Gt, Ht.prototype);
let _n = class extends Ht {
};
const Ye = Ge.map((i) => Ae(`on ${i}`));
class Cn extends Rr.PureComponent {
  constructor() {
    super(...arguments);
    _(this, "infiniteViewer");
    _(this, "containerElement");
    _(this, "wrapperElement");
    _(this, "scrollAreaElement");
    _(this, "horizontalScrollElement");
    _(this, "verticalScrollElement");
  }
  render() {
    const t = this.props.className;
    return /* @__PURE__ */ Q.jsxs(
      "div",
      {
        className: `${t || ""} ${qe}`,
        ref: dt(this, "containerElement"),
        children: [
          /* @__PURE__ */ Q.jsxs(
            "div",
            {
              className: "infinite-viewer-wrapper",
              ref: dt(this, "wrapperElement"),
              children: [
                /* @__PURE__ */ Q.jsx(
                  "div",
                  {
                    className: "infinite-viewer-scroll-area",
                    ref: dt(this, "scrollAreaElement")
                  }
                ),
                this.props.children
              ]
            }
          ),
          /* @__PURE__ */ Q.jsx(
            "div",
            {
              className: "infinite-viewer-scroll-bar infinite-viewer-horizontal-scroll-bar",
              ref: dt(this, "horizontalScrollElement"),
              children: /* @__PURE__ */ Q.jsx("div", { className: "infinite-viewer-scroll-thumb" })
            }
          ),
          /* @__PURE__ */ Q.jsx(
            "div",
            {
              className: "infinite-viewer-scroll-bar infinite-viewer-vertical-scroll-bar",
              ref: dt(this, "verticalScrollElement"),
              children: /* @__PURE__ */ Q.jsx("div", { className: "infinite-viewer-scroll-thumb" })
            }
          )
        ]
      }
    );
  }
  componentDidMount() {
    const t = this.props, r = {};
    vn.forEach((e) => {
      e in t && typeof t[e] < "u" && (r[e] = t[e]);
    }), this.infiniteViewer = new _n(
      this.containerElement,
      this.scrollAreaElement.nextElementSibling,
      {
        ...r,
        wrapperElement: this.wrapperElement,
        scrollAreaElement: this.scrollAreaElement,
        horizontalScrollElement: this.horizontalScrollElement,
        verticalScrollElement: this.verticalScrollElement
      }
    ), Ge.forEach((e, o) => {
      this.infiniteViewer.on(e, (a) => {
        const l = this.props;
        (l[Ye[o]] && l[Ye[o]](a)) === !1 && a.stop();
      });
    });
  }
  componentDidUpdate() {
    const t = this.props, r = this.infiniteViewer;
    Gt.forEach((e) => {
      e in t && r[e] !== t[e] && (r[e] = t[e]);
    });
  }
  componentWillUnmount() {
    this.infiniteViewer.destroy();
  }
  getElement() {
    return this.containerElement;
  }
}
export {
  qe as CLASS_NAME,
  Ge as EVENTS,
  wn as METHODS,
  vn as OPTIONS,
  Gt as PROPERTIES,
  Cn as default
};
//# sourceMappingURL=index.es.js.map

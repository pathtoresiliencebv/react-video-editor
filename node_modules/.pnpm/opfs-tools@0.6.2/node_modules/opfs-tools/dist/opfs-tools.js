var O = (t) => {
  throw TypeError(t);
};
var E = (t, e, r) => e.has(t) || O("Cannot " + r);
var s = (t, e, r) => (E(t, e, "read from private field"), r ? r.call(t) : e.get(t)), o = (t, e, r) => e.has(t) ? O("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, r), l = (t, e, r, a) => (E(t, e, "write to private field"), a ? a.call(t, r) : e.set(t, r), r);
const z = "KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIHUobil7aWYobj09PSIvIilyZXR1cm57cGFyZW50Om51bGwsbmFtZToiIn07Y29uc3QgZT1uLnNwbGl0KCIvIikuZmlsdGVyKGk9PmkubGVuZ3RoPjApO2lmKGUubGVuZ3RoPT09MCl0aHJvdyBFcnJvcigiSW52YWxpZCBwYXRoIik7Y29uc3QgYT1lW2UubGVuZ3RoLTFdLHI9Ii8iK2Uuc2xpY2UoMCwtMSkuam9pbigiLyIpO3JldHVybntuYW1lOmEscGFyZW50OnJ9fWFzeW5jIGZ1bmN0aW9uIHcobixlKXtjb25zdHtwYXJlbnQ6YSxuYW1lOnJ9PXUobik7aWYoYT09bnVsbClyZXR1cm4gYXdhaXQgbmF2aWdhdG9yLnN0b3JhZ2UuZ2V0RGlyZWN0b3J5KCk7Y29uc3QgaT1hLnNwbGl0KCIvIikuZmlsdGVyKHQ9PnQubGVuZ3RoPjApO3RyeXtsZXQgdD1hd2FpdCBuYXZpZ2F0b3Iuc3RvcmFnZS5nZXREaXJlY3RvcnkoKTtmb3IoY29uc3QgcyBvZiBpKXQ9YXdhaXQgdC5nZXREaXJlY3RvcnlIYW5kbGUocyx7Y3JlYXRlOmUuY3JlYXRlfSk7aWYoZS5pc0ZpbGUpcmV0dXJuIGF3YWl0IHQuZ2V0RmlsZUhhbmRsZShyLHtjcmVhdGU6ZS5jcmVhdGV9KX1jYXRjaCh0KXtpZih0Lm5hbWU9PT0iTm90Rm91bmRFcnJvciIpcmV0dXJuIG51bGw7dGhyb3cgdH19Y29uc3QgZj17fTtzZWxmLm9ubWVzc2FnZT1hc3luYyBuPT57dmFyIGk7Y29uc3R7ZXZ0VHlwZTplLGFyZ3M6YX09bi5kYXRhO2xldCByPWZbYS5maWxlSWRdO3RyeXtsZXQgdDtjb25zdCBzPVtdO2lmKGU9PT0icmVnaXN0ZXIiKXtjb25zdCBsPWF3YWl0IHcoYS5maWxlUGF0aCx7Y3JlYXRlOiEwLGlzRmlsZTohMH0pO2lmKGw9PW51bGwpdGhyb3cgRXJyb3IoYG5vdCBmb3VuZCBmaWxlOiAke2EuZmlsZUlkfWApO3I9YXdhaXQgbC5jcmVhdGVTeW5jQWNjZXNzSGFuZGxlKHttb2RlOmEubW9kZX0pLGZbYS5maWxlSWRdPXJ9ZWxzZSBpZihlPT09ImNsb3NlIilhd2FpdCByLmNsb3NlKCksZGVsZXRlIGZbYS5maWxlSWRdO2Vsc2UgaWYoZT09PSJ0cnVuY2F0ZSIpYXdhaXQgci50cnVuY2F0ZShhLm5ld1NpemUpO2Vsc2UgaWYoZT09PSJ3cml0ZSIpe2NvbnN0e2RhdGE6bCxvcHRzOm99PW4uZGF0YS5hcmdzO3Q9YXdhaXQgci53cml0ZShsLG8pfWVsc2UgaWYoZT09PSJyZWFkIil7Y29uc3R7b2Zmc2V0Omwsc2l6ZTpvfT1uLmRhdGEuYXJncyxnPW5ldyBVaW50OEFycmF5KG8pLGQ9YXdhaXQgci5yZWFkKGcse2F0Omx9KSxjPWcuYnVmZmVyO3Q9ZD09PW8/YzooKGk9Yy50cmFuc2Zlcik9PW51bGw/dm9pZCAwOmkuY2FsbChjLGQpKT8/Yy5zbGljZSgwLGQpLHMucHVzaCh0KX1lbHNlIGU9PT0iZ2V0U2l6ZSI/dD1hd2FpdCByLmdldFNpemUoKTplPT09ImZsdXNoIiYmYXdhaXQgci5mbHVzaCgpO3NlbGYucG9zdE1lc3NhZ2Uoe2V2dFR5cGU6ImNhbGxiYWNrIixjYklkOm4uZGF0YS5jYklkLHJldHVyblZhbDp0fSxzKX1jYXRjaCh0KXtjb25zdCBzPXQ7c2VsZi5wb3N0TWVzc2FnZSh7ZXZ0VHlwZToidGhyb3dFcnJvciIsY2JJZDpuLmRhdGEuY2JJZCxlcnJNc2c6cy5uYW1lKyI6ICIrcy5tZXNzYWdlK2AKYCtKU09OLnN0cmluZ2lmeShuLmRhdGEpfSl9fX0pKCk7Ci8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wZnMtd29ya2VyLUY0UldscWNfLmpzLm1hcAo=", B = (t) => Uint8Array.from(atob(t), (e) => e.charCodeAt(0)), U = typeof self < "u" && self.Blob && new Blob([B(z)], { type: "text/javascript;charset=utf-8" });
function Q(t) {
  let e;
  try {
    if (e = U && (self.URL || self.webkitURL).createObjectURL(U), !e) throw "";
    const r = new Worker(e, {
      name: t == null ? void 0 : t.name
    });
    return r.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(e);
    }), r;
  } catch {
    return new Worker(
      "data:text/javascript;base64," + z,
      {
        name: t == null ? void 0 : t.name
      }
    );
  } finally {
    e && (self.URL || self.webkitURL).revokeObjectURL(e);
  }
}
async function D(t, e, r) {
  const a = M();
  return await a("register", { fileId: t, filePath: e, mode: r }), {
    read: async (i, n) => await a("read", {
      fileId: t,
      offset: i,
      size: n
    }),
    write: async (i, n) => await a(
      "write",
      {
        fileId: t,
        data: i,
        opts: n
      },
      [ArrayBuffer.isView(i) ? i.buffer : i]
    ),
    close: async () => await a("close", {
      fileId: t
    }),
    truncate: async (i) => await a("truncate", {
      fileId: t,
      newSize: i
    }),
    getSize: async () => await a("getSize", {
      fileId: t
    }),
    flush: async () => await a("flush", {
      fileId: t
    })
  };
}
const I = [];
let V = 0;
function M() {
  if (I.length < 3) {
    const e = t();
    return I.push(e), e;
  } else {
    const e = I[V];
    return V = (V + 1) % I.length, e;
  }
  function t() {
    const e = new Q();
    let r = 0, a = {};
    return e.onmessage = ({
      data: i
    }) => {
      var n, c;
      i.evtType === "callback" ? (n = a[i.cbId]) == null || n.resolve(i.returnVal) : i.evtType === "throwError" && ((c = a[i.cbId]) == null || c.reject(Error(i.errMsg))), delete a[i.cbId];
    }, async function(n, c, u = []) {
      r += 1;
      const h = new Promise((b, T) => {
        a[r] = { resolve: b, reject: T };
      });
      return e.postMessage(
        {
          cbId: r,
          evtType: n,
          args: c
        },
        u
      ), h;
    };
  }
}
function v(t) {
  if (t === "/") return { parent: null, name: "" };
  const e = t.split("/").filter((i) => i.length > 0);
  if (e.length === 0) throw Error("Invalid path");
  const r = e[e.length - 1], a = "/" + e.slice(0, -1).join("/");
  return { name: r, parent: a };
}
async function d(t, e) {
  const { parent: r, name: a } = v(t);
  if (r == null) return await navigator.storage.getDirectory();
  const i = r.split("/").filter((n) => n.length > 0);
  try {
    let n = await navigator.storage.getDirectory();
    for (const c of i)
      n = await n.getDirectoryHandle(c, {
        create: e.create
      });
    return e.isFile ? await n.getFileHandle(a, {
      create: e.create
    }) : await n.getDirectoryHandle(a, {
      create: e.create
    });
  } catch (n) {
    if (n.name === "NotFoundError")
      return null;
    throw n;
  }
}
async function j(t) {
  const { parent: e, name: r } = v(t);
  if (e == null) {
    const i = await navigator.storage.getDirectory();
    for await (const n of i.keys())
      await i.removeEntry(n, { recursive: !0 });
    return;
  }
  const a = await d(e, {
    create: !1,
    isFile: !1
  });
  a != null && await a.removeEntry(r, { recursive: !0 });
}
function k(t, e) {
  return `${t}/${e}`.replace("//", "/");
}
function g(t) {
  return new K(t);
}
var w, S, p;
class K {
  constructor(e) {
    o(this, w);
    o(this, S);
    o(this, p);
    l(this, w, e);
    const { parent: r, name: a } = v(e);
    l(this, S, a), l(this, p, r);
  }
  get kind() {
    return "dir";
  }
  get name() {
    return s(this, S);
  }
  get path() {
    return s(this, w);
  }
  get parent() {
    return s(this, p) == null ? null : g(s(this, p));
  }
  /**
   * Creates the directory.
   * return A promise that resolves when the directory is created.
   */
  async create() {
    return await d(s(this, w), {
      create: !0,
      isFile: !1
    }), g(s(this, w));
  }
  /**
   * Checks if the directory exists.
   * return A promise that resolves to true if the directory exists, otherwise false.
   */
  async exists() {
    return await d(s(this, w), {
      create: !1,
      isFile: !1
    }) instanceof FileSystemDirectoryHandle;
  }
  /**
   * Removes the directory.
   * return A promise that resolves when the directory is removed.
   */
  async remove() {
    for (const e of await this.children())
      try {
        await e.remove();
      } catch (r) {
        console.warn(r);
      }
    try {
      await j(s(this, w));
    } catch (e) {
      console.warn(e);
    }
  }
  /**
   * Retrieves the children of the directory.
   * return A promise that resolves to an array of objects representing the children.
   */
  async children() {
    const e = await d(s(this, w), {
      create: !1,
      isFile: !1
    });
    if (e == null) return [];
    const r = [];
    for await (const a of e.values())
      r.push((a.kind === "file" ? y : g)(k(s(this, w), a.name)));
    return r;
  }
  /**
   * If the dest folder exists, copy the current directory into the dest folder;
   * if the dest folder does not exist, rename the current directory to dest name.
   */
  async copyTo(e) {
    if (!await this.exists())
      throw Error(`dir ${this.path} not exists`);
    const r = await e.exists() ? g(k(e.path, this.name)) : e;
    return await r.create(), await Promise.all((await this.children()).map((a) => a.copyTo(r))), r;
  }
  /**
   * move directory, copy then remove current
   */
  async moveTo(e) {
    const r = await this.copyTo(e);
    return await this.remove(), r;
  }
}
w = new WeakMap(), S = new WeakMap(), p = new WeakMap();
const C = /* @__PURE__ */ new Map();
function y(t, e = "rw") {
  if (e === "rw") {
    const r = C.get(t) ?? new F(t, e);
    return C.set(t, r), r;
  }
  return new F(t, e);
}
async function J(t, e, r = { overwrite: !0 }) {
  if (e instanceof F) {
    await J(t, await e.stream(), r);
    return;
  }
  const a = await (t instanceof F ? t : y(t, "rw")).createWriter();
  try {
    if (r.overwrite && await a.truncate(0), e instanceof ReadableStream) {
      const i = e.getReader();
      for (; ; ) {
        const { done: n, value: c } = await i.read();
        if (n) break;
        await a.write(c);
      }
    } else
      await a.write(e);
  } catch (i) {
    throw i;
  } finally {
    await a.close();
  }
}
let _ = 0;
const A = () => ++_;
var f, Z, G, Y, X, m, R, W;
const P = class P {
  constructor(e, r) {
    o(this, f);
    o(this, Z);
    o(this, G);
    o(this, Y);
    o(this, X);
    o(this, m, 0);
    o(this, R, /* @__PURE__ */ (() => {
      let e = null;
      return () => (l(this, m, s(this, m) + 1), e ?? (e = new Promise(async (r, a) => {
        try {
          const i = await D(
            s(this, X),
            s(this, f),
            s(this, Y)
          );
          r([
            i,
            async () => {
              l(this, m, s(this, m) - 1), !(s(this, m) > 0) && (e = null, await i.close());
            }
          ]);
        } catch (i) {
          a(i);
        }
      })));
    })());
    o(this, W, !1);
    l(this, X, A()), l(this, f, e), l(this, Y, {
      r: "read-only",
      rw: "readwrite",
      "rw-unsafe": "readwrite-unsafe"
    }[r]);
    const { parent: a, name: i } = v(e);
    l(this, G, i), l(this, Z, a);
  }
  get kind() {
    return "file";
  }
  get path() {
    return s(this, f);
  }
  get name() {
    return s(this, G);
  }
  get parent() {
    return s(this, Z) == null ? null : g(s(this, Z));
  }
  /**
   * Random write to file
   */
  async createWriter() {
    if (s(this, Y) === "read-only") throw Error("file is read-only");
    if (s(this, W)) throw Error("Other writer have not been closed");
    l(this, W, !0);
    const e = new TextEncoder(), [r, a] = await s(this, R).call(this);
    let i = await r.getSize(), n = !1;
    return {
      write: async (c, u = {}) => {
        if (n) throw Error("Writer is closed");
        const h = typeof c == "string" ? e.encode(c) : c, b = u.at ?? i, T = h.byteLength;
        return i = b + T, await r.write(h, { at: b });
      },
      truncate: async (c) => {
        if (n) throw Error("Writer is closed");
        await r.truncate(c), i > c && (i = c);
      },
      flush: async () => {
        if (n) throw Error("Writer is closed");
        await r.flush();
      },
      close: async () => {
        if (n) throw Error("Writer is closed");
        n = !0, l(this, W, !1), await a();
      }
    };
  }
  /**
   * Random access to file
   */
  async createReader() {
    const [e, r] = await s(this, R).call(this);
    let a = !1, i = 0;
    return {
      read: async (n, c = {}) => {
        if (a) throw Error("Reader is closed");
        const u = c.at ?? i, h = await e.read(u, n);
        return i = u + h.byteLength, h;
      },
      getSize: async () => {
        if (a) throw Error("Reader is closed");
        return await e.getSize();
      },
      close: async () => {
        a || (a = !0, await r());
      }
    };
  }
  async text() {
    return new TextDecoder().decode(await this.arrayBuffer());
  }
  async arrayBuffer() {
    const e = await d(s(this, f), { create: !1, isFile: !0 });
    return e == null ? new ArrayBuffer(0) : (await e.getFile()).arrayBuffer();
  }
  async stream() {
    const e = await this.getOriginFile();
    return e == null ? new ReadableStream({
      pull: (r) => {
        r.close();
      }
    }) : e.stream();
  }
  async getOriginFile() {
    var e;
    return (e = await d(s(this, f), { create: !1, isFile: !0 })) == null ? void 0 : e.getFile();
  }
  async getSize() {
    const e = await d(s(this, f), { create: !1, isFile: !0 });
    return e == null ? 0 : (await e.getFile()).size;
  }
  async exists() {
    return await d(s(this, f), {
      create: !1,
      isFile: !0
    }) instanceof FileSystemFileHandle;
  }
  async remove() {
    if (s(this, m)) throw Error("exists unclosed reader/writer");
    await j(s(this, f));
  }
  /**
   * If the target is a file, use current overwrite the target;
   * if the target is a folder, copy the current file into that folder.
   */
  async copyTo(e) {
    if (e instanceof P)
      return e.path === this.path ? this : (await J(e.path, this), y(e.path));
    if (e instanceof K) {
      if (!await this.exists())
        throw Error(`file ${this.path} not exists`);
      return await this.copyTo(y(k(e.path, this.name)));
    }
    throw Error("Illegal target type");
  }
  /**
   * move file, copy then remove current
   */
  async moveTo(e) {
    const r = await this.copyTo(e);
    return await this.remove(), r;
  }
};
f = new WeakMap(), Z = new WeakMap(), G = new WeakMap(), Y = new WeakMap(), X = new WeakMap(), m = new WeakMap(), R = new WeakMap(), W = new WeakMap();
let F = P;
const L = "/.opfs-tools-temp-dir";
async function N(t) {
  try {
    if (t.kind === "file") {
      if (!await t.exists()) return !0;
      const e = await t.createWriter();
      await e.truncate(0), await e.close(), await t.remove();
    } else
      await t.remove();
    return !0;
  } catch (e) {
    return console.warn(e), !1;
  }
}
function $() {
  setInterval(async () => {
    for (const e of await g(L).children()) {
      const r = /^\d+-(\d+)$/.exec(e.name);
      (r == null || Date.now() - Number(r[1]) > 2592e5) && await N(e);
    }
  }, 60 * 1e3);
}
const x = [];
let H = !1;
async function q() {
  if (globalThis.localStorage == null) return;
  const t = "OPFS_TOOLS_EXPIRES_TMP_FILES";
  H || (H = !0, globalThis.addEventListener("unload", () => {
    x.length !== 0 && localStorage.setItem(
      t,
      `${localStorage.getItem(t) ?? ""},${x.join(",")}`
    );
  }));
  let e = localStorage.getItem(t) ?? "";
  for (const r of e.split(","))
    r.length !== 0 && await N(y(`${L}/${r}`)) && (e = e.replace(r, ""));
  localStorage.setItem(t, e.replace(/,{2,}/g, ","));
}
(async function() {
  var e;
  globalThis.__opfs_tools_tmpfile_init__ !== !0 && (globalThis.__opfs_tools_tmpfile_init__ = !0, !(globalThis.FileSystemDirectoryHandle == null || globalThis.FileSystemFileHandle == null || ((e = globalThis.navigator) == null ? void 0 : e.storage.getDirectory) == null) && ($(), await q()));
})();
function te() {
  const t = `${Math.random().toString().slice(2)}-${Date.now()}`;
  return x.push(t), y(`${L}/${t}`);
}
function re(t, e) {
  let r = y(t), a = 0, i = r.createWriter(), n = r.createReader();
  const c = async (u) => {
    const b = await (await n).read(a, { at: Math.round(a * 0.3) });
    a = await u.write(b, { at: 0 }), await u.truncate(a);
  };
  return {
    append: async (u) => {
      const h = await i;
      a += await h.write(u), a >= e && await c(h);
    },
    text: r.text.bind(r),
    remove: async () => {
      await (await n).close(), await (await i).close(), await r.remove();
    },
    getSize: async () => a
  };
}
export {
  g as dir,
  y as file,
  re as rollfile,
  te as tmpfile,
  J as write
};
//# sourceMappingURL=opfs-tools.js.map

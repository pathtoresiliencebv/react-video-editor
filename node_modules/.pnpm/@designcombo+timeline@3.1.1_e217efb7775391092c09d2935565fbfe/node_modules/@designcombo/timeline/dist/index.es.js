var Fh = Object.defineProperty;
var Rh = (i, t, e) => t in i ? Fh(i, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[t] = e;
var T = (i, t, e) => Rh(i, typeof t != "symbol" ? t + "" : t, e);
import { dispatch as ie } from "@designcombo/events";
function y(i, t, e) {
  return (t = function(s) {
    var r = function(n, o) {
      if (typeof n != "object" || !n) return n;
      var a = n[Symbol.toPrimitive];
      if (a !== void 0) {
        var c = a.call(n, o);
        if (typeof c != "object") return c;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (o === "string" ? String : Number)(n);
    }(s, "string");
    return typeof r == "symbol" ? r : r + "";
  }(t)) in i ? Object.defineProperty(i, t, { value: e, enumerable: !0, configurable: !0, writable: !0 }) : i[t] = e, i;
}
function fo(i, t) {
  var e = Object.keys(i);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(i);
    t && (s = s.filter(function(r) {
      return Object.getOwnPropertyDescriptor(i, r).enumerable;
    })), e.push.apply(e, s);
  }
  return e;
}
function v(i) {
  for (var t = 1; t < arguments.length; t++) {
    var e = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fo(Object(e), !0).forEach(function(s) {
      y(i, s, e[s]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(e)) : fo(Object(e)).forEach(function(s) {
      Object.defineProperty(i, s, Object.getOwnPropertyDescriptor(e, s));
    });
  }
  return i;
}
function G(i, t) {
  if (i == null) return {};
  var e, s, r = function(o, a) {
    if (o == null) return {};
    var c = {};
    for (var l in o) if ({}.hasOwnProperty.call(o, l)) {
      if (a.indexOf(l) >= 0) continue;
      c[l] = o[l];
    }
    return c;
  }(i, t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(i);
    for (s = 0; s < n.length; s++) e = n[s], t.indexOf(e) >= 0 || {}.propertyIsEnumerable.call(i, e) && (r[e] = i[e]);
  }
  return r;
}
function Me(i, t) {
  return t || (t = i.slice(0)), Object.freeze(Object.defineProperties(i, { raw: { value: Object.freeze(t) } }));
}
class go {
  constructor() {
    y(this, "browserShadowBlurConstant", 1), y(this, "DPI", 96), y(this, "devicePixelRatio", typeof window < "u" ? window.devicePixelRatio : 1), y(this, "perfLimitSizeTotal", 2097152), y(this, "maxCacheSideLimit", 4096), y(this, "minCacheSideLimit", 256), y(this, "disableStyleCopyPaste", !1), y(this, "enableGLFiltering", !0), y(this, "textureSize", 4096), y(this, "forceGLPutImageData", !1), y(this, "cachesBoundsOfCurve", !1), y(this, "fontPaths", {}), y(this, "NUM_FRACTION_DIGITS", 4);
  }
}
const A = new class extends go {
  constructor(i) {
    super(), this.configure(i);
  }
  configure() {
    let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Object.assign(this, i);
  }
  addFonts() {
    let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.fontPaths = v(v({}, this.fontPaths), i);
  }
  removeFonts() {
    (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).forEach((i) => {
      delete this.fontPaths[i];
    });
  }
  clearFonts() {
    this.fontPaths = {};
  }
  restoreDefaults(i) {
    const t = new go(), e = (i == null ? void 0 : i.reduce((s, r) => (s[r] = t[r], s), {})) || t;
    this.configure(e);
  }
}(), Te = function(i) {
  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++) e[s - 1] = arguments[s];
  return console[i]("fabric", ...e);
};
class Yt extends Error {
  constructor(t, e) {
    super("fabric: ".concat(t), e);
  }
}
class Fa extends Yt {
  constructor(t) {
    super("".concat(t, " 'options.signal' is in 'aborted' state"));
  }
}
class Lh {
}
class Bh extends Lh {
  testPrecision(t, e) {
    const s = "precision ".concat(e, ` float;
void main(){}`), r = t.createShader(t.FRAGMENT_SHADER);
    return !!r && (t.shaderSource(r, s), t.compileShader(r), !!t.getShaderParameter(r, t.COMPILE_STATUS));
  }
  queryWebGL(t) {
    const e = t.getContext("webgl");
    e && (this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), this.GLPrecision = ["highp", "mediump", "lowp"].find((s) => this.testPrecision(e, s)), e.getExtension("WEBGL_lose_context").loseContext(), Te("log", "WebGL: max texture size ".concat(this.maxTextureSize)));
  }
  isSupported(t) {
    return !!this.maxTextureSize && this.maxTextureSize >= t;
  }
}
const Wh = {};
let po;
const $t = () => po || (po = { document, window, isTouchSupported: "ontouchstart" in window || "ontouchstart" in document || window && window.navigator && window.navigator.maxTouchPoints > 0, WebGLProbe: new Bh(), dispose() {
}, copyPasteData: Wh }), Cs = () => $t().document, fi = () => $t().window, Ra = () => {
  var i;
  return Math.max((i = A.devicePixelRatio) !== null && i !== void 0 ? i : fi().devicePixelRatio, 1);
}, zs = new class {
  constructor() {
    y(this, "charWidthsCache", {}), y(this, "boundsOfCurveCache", {});
  }
  getFontCache(i) {
    let { fontFamily: t, fontStyle: e, fontWeight: s } = i;
    t = t.toLowerCase(), this.charWidthsCache[t] || (this.charWidthsCache[t] = {});
    const r = this.charWidthsCache[t], n = "".concat(e.toLowerCase(), "_").concat((s + "").toLowerCase());
    return r[n] || (r[n] = {}), r[n];
  }
  clearFontCache(i) {
    (i = (i || "").toLowerCase()) ? this.charWidthsCache[i] && delete this.charWidthsCache[i] : this.charWidthsCache = {};
  }
  limitDimsByArea(i) {
    const { perfLimitSizeTotal: t } = A, e = Math.sqrt(t * i);
    return [Math.floor(e), Math.floor(t / e)];
  }
}(), sn = "6.6.1";
function Be() {
}
const xe = Math.PI / 2, he = 2 * Math.PI, jn = Math.PI / 180, ht = Object.freeze([1, 0, 0, 1, 0, 0]), En = 16, ye = 0.4477152502, j = "center", L = "left", gt = "top", rn = "bottom", Z = "right", pt = "none", Pn = /\r?\n/, La = "moving", gi = "scaling", Ba = "rotating", An = "rotate", Wa = "skewing", $s = "resizing", Xa = "modifyPoly", Xh = "modifyPath", Ur = "changed", pi = "scale", ut = "scaleX", Tt = "scaleY", Os = "skewX", ks = "skewY", rt = "fill", mt = "stroke", $r = "modified", qe = "json", Ri = "svg", C = new class {
  constructor() {
    this[qe] = /* @__PURE__ */ new Map(), this[Ri] = /* @__PURE__ */ new Map();
  }
  has(i) {
    return this[qe].has(i);
  }
  getClass(i) {
    const t = this[qe].get(i);
    if (!t) throw new Yt("No class registered for ".concat(i));
    return t;
  }
  setClass(i, t) {
    t ? this[qe].set(t, i) : (this[qe].set(i.type, i), this[qe].set(i.type.toLowerCase(), i));
  }
  getSVGClass(i) {
    return this[Ri].get(i);
  }
  setSVGClass(i, t) {
    this[Ri].set(t ?? i.type.toLowerCase(), i);
  }
}(), qr = new class extends Array {
  remove(i) {
    const t = this.indexOf(i);
    t > -1 && this.splice(t, 1);
  }
  cancelAll() {
    const i = this.splice(0);
    return i.forEach((t) => t.abort()), i;
  }
  cancelByCanvas(i) {
    if (!i) return [];
    const t = this.filter((e) => {
      var s;
      return e.target === i || typeof e.target == "object" && ((s = e.target) === null || s === void 0 ? void 0 : s.canvas) === i;
    });
    return t.forEach((e) => e.abort()), t;
  }
  cancelByTarget(i) {
    if (!i) return [];
    const t = this.filter((e) => e.target === i);
    return t.forEach((e) => e.abort()), t;
  }
}();
class zh {
  constructor() {
    y(this, "__eventListeners", {});
  }
  on(t, e) {
    if (this.__eventListeners || (this.__eventListeners = {}), typeof t == "object") return Object.entries(t).forEach((s) => {
      let [r, n] = s;
      this.on(r, n);
    }), () => this.off(t);
    if (e) {
      const s = t;
      return this.__eventListeners[s] || (this.__eventListeners[s] = []), this.__eventListeners[s].push(e), () => this.off(s, e);
    }
    return () => !1;
  }
  once(t, e) {
    if (typeof t == "object") {
      const s = [];
      return Object.entries(t).forEach((r) => {
        let [n, o] = r;
        s.push(this.once(n, o));
      }), () => s.forEach((r) => r());
    }
    if (e) {
      const s = this.on(t, function() {
        for (var r = arguments.length, n = new Array(r), o = 0; o < r; o++) n[o] = arguments[o];
        e.call(this, ...n), s();
      });
      return s;
    }
    return () => !1;
  }
  _removeEventListener(t, e) {
    if (this.__eventListeners[t]) if (e) {
      const s = this.__eventListeners[t], r = s.indexOf(e);
      r > -1 && s.splice(r, 1);
    } else this.__eventListeners[t] = [];
  }
  off(t, e) {
    if (this.__eventListeners) if (t === void 0) for (const s in this.__eventListeners) this._removeEventListener(s);
    else typeof t == "object" ? Object.entries(t).forEach((s) => {
      let [r, n] = s;
      this._removeEventListener(r, n);
    }) : this._removeEventListener(t, e);
  }
  fire(t, e) {
    var s;
    if (!this.__eventListeners) return;
    const r = (s = this.__eventListeners[t]) === null || s === void 0 ? void 0 : s.concat();
    if (r) for (let n = 0; n < r.length; n++) r[n].call(this, e || {});
  }
}
const Ee = (i, t) => {
  const e = i.indexOf(t);
  return e !== -1 && i.splice(e, 1), i;
}, Lt = (i) => {
  if (i === 0) return 1;
  switch (Math.abs(i) / xe) {
    case 1:
    case 3:
      return 0;
    case 2:
      return -1;
  }
  return Math.cos(i);
}, Bt = (i) => {
  if (i === 0) return 0;
  const t = i / xe, e = Math.sign(i);
  switch (t) {
    case 1:
      return e;
    case 2:
      return 0;
    case 3:
      return -e;
  }
  return Math.sin(i);
};
class _ {
  constructor() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    typeof t == "object" ? (this.x = t.x, this.y = t.y) : (this.x = t, this.y = e);
  }
  add(t) {
    return new _(this.x + t.x, this.y + t.y);
  }
  addEquals(t) {
    return this.x += t.x, this.y += t.y, this;
  }
  scalarAdd(t) {
    return new _(this.x + t, this.y + t);
  }
  scalarAddEquals(t) {
    return this.x += t, this.y += t, this;
  }
  subtract(t) {
    return new _(this.x - t.x, this.y - t.y);
  }
  subtractEquals(t) {
    return this.x -= t.x, this.y -= t.y, this;
  }
  scalarSubtract(t) {
    return new _(this.x - t, this.y - t);
  }
  scalarSubtractEquals(t) {
    return this.x -= t, this.y -= t, this;
  }
  multiply(t) {
    return new _(this.x * t.x, this.y * t.y);
  }
  scalarMultiply(t) {
    return new _(this.x * t, this.y * t);
  }
  scalarMultiplyEquals(t) {
    return this.x *= t, this.y *= t, this;
  }
  divide(t) {
    return new _(this.x / t.x, this.y / t.y);
  }
  scalarDivide(t) {
    return new _(this.x / t, this.y / t);
  }
  scalarDivideEquals(t) {
    return this.x /= t, this.y /= t, this;
  }
  eq(t) {
    return this.x === t.x && this.y === t.y;
  }
  lt(t) {
    return this.x < t.x && this.y < t.y;
  }
  lte(t) {
    return this.x <= t.x && this.y <= t.y;
  }
  gt(t) {
    return this.x > t.x && this.y > t.y;
  }
  gte(t) {
    return this.x >= t.x && this.y >= t.y;
  }
  lerp(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.5;
    return e = Math.max(Math.min(1, e), 0), new _(this.x + (t.x - this.x) * e, this.y + (t.y - this.y) * e);
  }
  distanceFrom(t) {
    const e = this.x - t.x, s = this.y - t.y;
    return Math.sqrt(e * e + s * s);
  }
  midPointFrom(t) {
    return this.lerp(t);
  }
  min(t) {
    return new _(Math.min(this.x, t.x), Math.min(this.y, t.y));
  }
  max(t) {
    return new _(Math.max(this.x, t.x), Math.max(this.y, t.y));
  }
  toString() {
    return "".concat(this.x, ",").concat(this.y);
  }
  setXY(t, e) {
    return this.x = t, this.y = e, this;
  }
  setX(t) {
    return this.x = t, this;
  }
  setY(t) {
    return this.y = t, this;
  }
  setFromPoint(t) {
    return this.x = t.x, this.y = t.y, this;
  }
  swap(t) {
    const e = this.x, s = this.y;
    this.x = t.x, this.y = t.y, t.x = e, t.y = s;
  }
  clone() {
    return new _(this.x, this.y);
  }
  rotate(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Fn;
    const s = Bt(t), r = Lt(t), n = this.subtract(e);
    return new _(n.x * r - n.y * s, n.x * s + n.y * r).add(e);
  }
  transform(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
    return new _(t[0] * this.x + t[2] * this.y + (e ? 0 : t[4]), t[1] * this.x + t[3] * this.y + (e ? 0 : t[5]));
  }
}
const Fn = new _(0, 0), Vr = (i) => !!i && Array.isArray(i._objects);
function za(i) {
  class t extends i {
    constructor() {
      super(...arguments), y(this, "_objects", []);
    }
    _onObjectAdded(s) {
    }
    _onObjectRemoved(s) {
    }
    _onStackOrderChanged(s) {
    }
    add() {
      for (var s = arguments.length, r = new Array(s), n = 0; n < s; n++) r[n] = arguments[n];
      const o = this._objects.push(...r);
      return r.forEach((a) => this._onObjectAdded(a)), o;
    }
    insertAt(s) {
      for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++) n[o - 1] = arguments[o];
      return this._objects.splice(s, 0, ...n), n.forEach((a) => this._onObjectAdded(a)), this._objects.length;
    }
    remove() {
      const s = this._objects, r = [];
      for (var n = arguments.length, o = new Array(n), a = 0; a < n; a++) o[a] = arguments[a];
      return o.forEach((c) => {
        const l = s.indexOf(c);
        l !== -1 && (s.splice(l, 1), r.push(c), this._onObjectRemoved(c));
      }), r;
    }
    forEachObject(s) {
      this.getObjects().forEach((r, n, o) => s(r, n, o));
    }
    getObjects() {
      for (var s = arguments.length, r = new Array(s), n = 0; n < s; n++) r[n] = arguments[n];
      return r.length === 0 ? [...this._objects] : this._objects.filter((o) => o.isType(...r));
    }
    item(s) {
      return this._objects[s];
    }
    isEmpty() {
      return this._objects.length === 0;
    }
    size() {
      return this._objects.length;
    }
    contains(s, r) {
      return !!this._objects.includes(s) || !!r && this._objects.some((n) => n instanceof t && n.contains(s, !0));
    }
    complexity() {
      return this._objects.reduce((s, r) => s += r.complexity ? r.complexity() : 0, 0);
    }
    sendObjectToBack(s) {
      return !(!s || s === this._objects[0]) && (Ee(this._objects, s), this._objects.unshift(s), this._onStackOrderChanged(s), !0);
    }
    bringObjectToFront(s) {
      return !(!s || s === this._objects[this._objects.length - 1]) && (Ee(this._objects, s), this._objects.push(s), this._onStackOrderChanged(s), !0);
    }
    sendObjectBackwards(s, r) {
      if (!s) return !1;
      const n = this._objects.indexOf(s);
      if (n !== 0) {
        const o = this.findNewLowerIndex(s, n, r);
        return Ee(this._objects, s), this._objects.splice(o, 0, s), this._onStackOrderChanged(s), !0;
      }
      return !1;
    }
    bringObjectForward(s, r) {
      if (!s) return !1;
      const n = this._objects.indexOf(s);
      if (n !== this._objects.length - 1) {
        const o = this.findNewUpperIndex(s, n, r);
        return Ee(this._objects, s), this._objects.splice(o, 0, s), this._onStackOrderChanged(s), !0;
      }
      return !1;
    }
    moveObjectTo(s, r) {
      return s !== this._objects[r] && (Ee(this._objects, s), this._objects.splice(r, 0, s), this._onStackOrderChanged(s), !0);
    }
    findNewLowerIndex(s, r, n) {
      let o;
      if (n) {
        o = r;
        for (let a = r - 1; a >= 0; --a) if (s.isOverlapping(this._objects[a])) {
          o = a;
          break;
        }
      } else o = r - 1;
      return o;
    }
    findNewUpperIndex(s, r, n) {
      let o;
      if (n) {
        o = r;
        for (let a = r + 1; a < this._objects.length; ++a) if (s.isOverlapping(this._objects[a])) {
          o = a;
          break;
        }
      } else o = r + 1;
      return o;
    }
    collectObjects(s) {
      let { left: r, top: n, width: o, height: a } = s, { includeIntersecting: c = !0 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const l = [], h = new _(r, n), u = h.add(new _(o, a));
      for (let d = this._objects.length - 1; d >= 0; d--) {
        const f = this._objects[d];
        f.selectable && f.visible && (c && f.intersectsWithRect(h, u) || f.isContainedWithinRect(h, u) || c && f.containsPoint(h) || c && f.containsPoint(u)) && l.push(f);
      }
      return l;
    }
  }
  return t;
}
class Ha extends zh {
  _setOptions() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    for (const e in t) this.set(e, t[e]);
  }
  _setObject(t) {
    for (const e in t) this._set(e, t[e]);
  }
  set(t, e) {
    return typeof t == "object" ? this._setObject(t) : this._set(t, e), this;
  }
  _set(t, e) {
    this[t] = e;
  }
  toggle(t) {
    const e = this.get(t);
    return typeof e == "boolean" && this.set(t, !e), this;
  }
  get(t) {
    return this[t];
  }
}
function Hs(i) {
  return fi().requestAnimationFrame(i);
}
function Ya(i) {
  return fi().cancelAnimationFrame(i);
}
let Hh = 0;
const we = () => Hh++, kt = () => {
  const i = Cs().createElement("canvas");
  if (!i || i.getContext === void 0) throw new Yt("Failed to create `canvas` element");
  return i;
}, Va = () => Cs().createElement("img"), Wt = (i) => {
  const t = kt();
  return t.width = i.width, t.height = i.height, t;
}, Rn = (i, t, e) => i.toDataURL("image/".concat(t), e), Ln = (i, t, e) => new Promise((s, r) => {
  i.toBlob(s, "image/".concat(t), e);
}), K = (i) => i * jn, Ce = (i) => i / jn, Ga = (i) => i.every((t, e) => t === ht[e]), ot = (i, t, e) => new _(i).transform(t, e), St = (i) => {
  const t = 1 / (i[0] * i[3] - i[1] * i[2]), e = [t * i[3], -t * i[1], -t * i[2], t * i[0], 0, 0], { x: s, y: r } = new _(i[4], i[5]).transform(e, !0);
  return e[4] = -s, e[5] = -r, e;
}, J = (i, t, e) => [i[0] * t[0] + i[2] * t[1], i[1] * t[0] + i[3] * t[1], i[0] * t[2] + i[2] * t[3], i[1] * t[2] + i[3] * t[3], e ? 0 : i[0] * t[4] + i[2] * t[5] + i[4], e ? 0 : i[1] * t[4] + i[3] * t[5] + i[5]], mi = (i, t) => i.reduceRight((e, s) => s && e ? J(s, e, t) : s || e, void 0) || ht.concat(), Na = (i) => {
  let [t, e] = i;
  return Math.atan2(e, t);
}, ys = (i) => {
  const t = Na(i), e = Math.pow(i[0], 2) + Math.pow(i[1], 2), s = Math.sqrt(e), r = (i[0] * i[3] - i[2] * i[1]) / s, n = Math.atan2(i[0] * i[2] + i[1] * i[3], e);
  return { angle: Ce(t), scaleX: s, scaleY: r, skewX: Ce(n), skewY: 0, translateX: i[4] || 0, translateY: i[5] || 0 };
}, Ms = function(i) {
  return [1, 0, 0, 1, i, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0];
};
function Is() {
  let { angle: i = 0 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, { x: t = 0, y: e = 0 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const s = K(i), r = Lt(s), n = Bt(s);
  return [r, n, -n, r, t ? t - (r * t - n * e) : 0, e ? e - (n * t + r * e) : 0];
}
const vi = function(i) {
  return [i, 0, 0, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : i, 0, 0];
}, Ua = (i) => Math.tan(K(i)), Bn = (i) => [1, 0, Ua(i), 1, 0, 0], Wn = (i) => [1, Ua(i), 0, 1, 0, 0], ar = (i) => {
  let { scaleX: t = 1, scaleY: e = 1, flipX: s = !1, flipY: r = !1, skewX: n = 0, skewY: o = 0 } = i, a = vi(s ? -t : t, r ? -e : e);
  return n && (a = J(a, Bn(n), !0)), o && (a = J(a, Wn(o), !0)), a;
}, $a = (i) => {
  const { translateX: t = 0, translateY: e = 0, angle: s = 0 } = i;
  let r = Ms(t, e);
  s && (r = J(r, Is({ angle: s })));
  const n = ar(i);
  return Ga(n) || (r = J(r, n)), r;
}, Ys = function(i) {
  let { signal: t, crossOrigin: e = null } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Promise(function(s, r) {
    if (t && t.aborted) return r(new Fa("loadImage"));
    const n = Va();
    let o;
    t && (o = function(c) {
      n.src = "", r(c);
    }, t.addEventListener("abort", o, { once: !0 }));
    const a = function() {
      n.onload = n.onerror = null, o && (t == null || t.removeEventListener("abort", o)), s(n);
    };
    i ? (n.onload = a, n.onerror = function() {
      o && (t == null || t.removeEventListener("abort", o)), r(new Yt("Error loading ".concat(n.src)));
    }, e && (n.crossOrigin = e), n.src = i) : a();
  });
}, bs = function(i) {
  let { signal: t, reviver: e = Be } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Promise((s, r) => {
    const n = [];
    t && t.addEventListener("abort", r, { once: !0 }), Promise.all(i.map((o) => C.getClass(o.type).fromObject(o, { signal: t }).then((a) => (e(o, a), n.push(a), a)))).then(s).catch((o) => {
      n.forEach((a) => {
        a.dispose && a.dispose();
      }), r(o);
    }).finally(() => {
      t && t.removeEventListener("abort", r);
    });
  });
}, cr = function(i) {
  let { signal: t } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Promise((e, s) => {
    const r = [];
    t && t.addEventListener("abort", s, { once: !0 });
    const n = Object.values(i).map((a) => a && a.type && C.has(a.type) ? bs([a], { signal: t }).then((c) => {
      let [l] = c;
      return r.push(l), l;
    }) : a), o = Object.keys(i);
    Promise.all(n).then((a) => a.reduce((c, l, h) => (c[o[h]] = l, c), {})).then(e).catch((a) => {
      r.forEach((c) => {
        c.dispose && c.dispose();
      }), s(a);
    }).finally(() => {
      t && t.removeEventListener("abort", s);
    });
  });
}, Ve = function(i) {
  return (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : []).reduce((t, e) => (e in i && (t[e] = i[e]), t), {});
}, Xn = (i, t) => Object.keys(i).reduce((e, s) => (t(i[s], s, i) && (e[s] = i[s]), e), {}), mo = { aliceblue: "#F0F8FF", antiquewhite: "#FAEBD7", aqua: "#0FF", aquamarine: "#7FFFD4", azure: "#F0FFFF", beige: "#F5F5DC", bisque: "#FFE4C4", black: "#000", blanchedalmond: "#FFEBCD", blue: "#00F", blueviolet: "#8A2BE2", brown: "#A52A2A", burlywood: "#DEB887", cadetblue: "#5F9EA0", chartreuse: "#7FFF00", chocolate: "#D2691E", coral: "#FF7F50", cornflowerblue: "#6495ED", cornsilk: "#FFF8DC", crimson: "#DC143C", cyan: "#0FF", darkblue: "#00008B", darkcyan: "#008B8B", darkgoldenrod: "#B8860B", darkgray: "#A9A9A9", darkgrey: "#A9A9A9", darkgreen: "#006400", darkkhaki: "#BDB76B", darkmagenta: "#8B008B", darkolivegreen: "#556B2F", darkorange: "#FF8C00", darkorchid: "#9932CC", darkred: "#8B0000", darksalmon: "#E9967A", darkseagreen: "#8FBC8F", darkslateblue: "#483D8B", darkslategray: "#2F4F4F", darkslategrey: "#2F4F4F", darkturquoise: "#00CED1", darkviolet: "#9400D3", deeppink: "#FF1493", deepskyblue: "#00BFFF", dimgray: "#696969", dimgrey: "#696969", dodgerblue: "#1E90FF", firebrick: "#B22222", floralwhite: "#FFFAF0", forestgreen: "#228B22", fuchsia: "#F0F", gainsboro: "#DCDCDC", ghostwhite: "#F8F8FF", gold: "#FFD700", goldenrod: "#DAA520", gray: "#808080", grey: "#808080", green: "#008000", greenyellow: "#ADFF2F", honeydew: "#F0FFF0", hotpink: "#FF69B4", indianred: "#CD5C5C", indigo: "#4B0082", ivory: "#FFFFF0", khaki: "#F0E68C", lavender: "#E6E6FA", lavenderblush: "#FFF0F5", lawngreen: "#7CFC00", lemonchiffon: "#FFFACD", lightblue: "#ADD8E6", lightcoral: "#F08080", lightcyan: "#E0FFFF", lightgoldenrodyellow: "#FAFAD2", lightgray: "#D3D3D3", lightgrey: "#D3D3D3", lightgreen: "#90EE90", lightpink: "#FFB6C1", lightsalmon: "#FFA07A", lightseagreen: "#20B2AA", lightskyblue: "#87CEFA", lightslategray: "#789", lightslategrey: "#789", lightsteelblue: "#B0C4DE", lightyellow: "#FFFFE0", lime: "#0F0", limegreen: "#32CD32", linen: "#FAF0E6", magenta: "#F0F", maroon: "#800000", mediumaquamarine: "#66CDAA", mediumblue: "#0000CD", mediumorchid: "#BA55D3", mediumpurple: "#9370DB", mediumseagreen: "#3CB371", mediumslateblue: "#7B68EE", mediumspringgreen: "#00FA9A", mediumturquoise: "#48D1CC", mediumvioletred: "#C71585", midnightblue: "#191970", mintcream: "#F5FFFA", mistyrose: "#FFE4E1", moccasin: "#FFE4B5", navajowhite: "#FFDEAD", navy: "#000080", oldlace: "#FDF5E6", olive: "#808000", olivedrab: "#6B8E23", orange: "#FFA500", orangered: "#FF4500", orchid: "#DA70D6", palegoldenrod: "#EEE8AA", palegreen: "#98FB98", paleturquoise: "#AFEEEE", palevioletred: "#DB7093", papayawhip: "#FFEFD5", peachpuff: "#FFDAB9", peru: "#CD853F", pink: "#FFC0CB", plum: "#DDA0DD", powderblue: "#B0E0E6", purple: "#800080", rebeccapurple: "#639", red: "#F00", rosybrown: "#BC8F8F", royalblue: "#4169E1", saddlebrown: "#8B4513", salmon: "#FA8072", sandybrown: "#F4A460", seagreen: "#2E8B57", seashell: "#FFF5EE", sienna: "#A0522D", silver: "#C0C0C0", skyblue: "#87CEEB", slateblue: "#6A5ACD", slategray: "#708090", slategrey: "#708090", snow: "#FFFAFA", springgreen: "#00FF7F", steelblue: "#4682B4", tan: "#D2B48C", teal: "#008080", thistle: "#D8BFD8", tomato: "#FF6347", turquoise: "#40E0D0", violet: "#EE82EE", wheat: "#F5DEB3", white: "#FFF", whitesmoke: "#F5F5F5", yellow: "#FF0", yellowgreen: "#9ACD32" }, Li = (i, t, e) => (e < 0 && (e += 1), e > 1 && (e -= 1), e < 1 / 6 ? i + 6 * (t - i) * e : e < 0.5 ? t : e < 2 / 3 ? i + (t - i) * (2 / 3 - e) * 6 : i), vo = (i, t, e, s) => {
  i /= 255, t /= 255, e /= 255;
  const r = Math.max(i, t, e), n = Math.min(i, t, e);
  let o, a;
  const c = (r + n) / 2;
  if (r === n) o = a = 0;
  else {
    const l = r - n;
    switch (a = c > 0.5 ? l / (2 - r - n) : l / (r + n), r) {
      case i:
        o = (t - e) / l + (t < e ? 6 : 0);
        break;
      case t:
        o = (e - i) / l + 2;
        break;
      case e:
        o = (i - t) / l + 4;
    }
    o /= 6;
  }
  return [Math.round(360 * o), Math.round(100 * a), Math.round(100 * c), s];
}, yo = function() {
  let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "1";
  return parseFloat(i) / (i.endsWith("%") ? 100 : 1);
}, vr = (i) => Math.min(Math.round(i), 255).toString(16).toUpperCase().padStart(2, "0"), bo = (i) => {
  let [t, e, s, r = 1] = i;
  const n = Math.round(0.3 * t + 0.59 * e + 0.11 * s);
  return [n, n, n, r];
};
class W {
  constructor(t) {
    if (y(this, "isUnrecognised", !1), t) if (t instanceof W) this.setSource([...t._source]);
    else if (Array.isArray(t)) {
      const [e, s, r, n = 1] = t;
      this.setSource([e, s, r, n]);
    } else this.setSource(this._tryParsingColor(t));
    else this.setSource([0, 0, 0, 1]);
  }
  _tryParsingColor(t) {
    return (t = t.toLowerCase()) in mo && (t = mo[t]), t === "transparent" ? [255, 255, 255, 0] : W.sourceFromHex(t) || W.sourceFromRgb(t) || W.sourceFromHsl(t) || (this.isUnrecognised = !0) && [0, 0, 0, 1];
  }
  getSource() {
    return this._source;
  }
  setSource(t) {
    this._source = t;
  }
  toRgb() {
    const [t, e, s] = this.getSource();
    return "rgb(".concat(t, ",").concat(e, ",").concat(s, ")");
  }
  toRgba() {
    return "rgba(".concat(this.getSource().join(","), ")");
  }
  toHsl() {
    const [t, e, s] = vo(...this.getSource());
    return "hsl(".concat(t, ",").concat(e, "%,").concat(s, "%)");
  }
  toHsla() {
    const [t, e, s, r] = vo(...this.getSource());
    return "hsla(".concat(t, ",").concat(e, "%,").concat(s, "%,").concat(r, ")");
  }
  toHex() {
    return this.toHexa().slice(0, 6);
  }
  toHexa() {
    const [t, e, s, r] = this.getSource();
    return "".concat(vr(t)).concat(vr(e)).concat(vr(s)).concat(vr(Math.round(255 * r)));
  }
  getAlpha() {
    return this.getSource()[3];
  }
  setAlpha(t) {
    return this._source[3] = t, this;
  }
  toGrayscale() {
    return this.setSource(bo(this.getSource())), this;
  }
  toBlackWhite(t) {
    const [e, , , s] = bo(this.getSource()), r = e < (t || 127) ? 0 : 255;
    return this.setSource([r, r, r, s]), this;
  }
  overlayWith(t) {
    t instanceof W || (t = new W(t));
    const e = this.getSource(), s = t.getSource(), [r, n, o] = e.map((a, c) => Math.round(0.5 * a + 0.5 * s[c]));
    return this.setSource([r, n, o, e[3]]), this;
  }
  static fromRgb(t) {
    return W.fromRgba(t);
  }
  static fromRgba(t) {
    return new W(W.sourceFromRgb(t));
  }
  static sourceFromRgb(t) {
    const e = t.match(/^rgba?\(\s*(\d{0,3}(?:\.\d+)?%?)\s*[\s|,]\s*(\d{0,3}(?:\.\d+)?%?)\s*[\s|,]\s*(\d{0,3}(?:\.\d+)?%?)\s*(?:\s*[,/]\s*(\d{0,3}(?:\.\d+)?%?)\s*)?\)$/i);
    if (e) {
      const [s, r, n] = e.slice(1, 4).map((o) => {
        const a = parseFloat(o);
        return o.endsWith("%") ? Math.round(2.55 * a) : a;
      });
      return [s, r, n, yo(e[4])];
    }
  }
  static fromHsl(t) {
    return W.fromHsla(t);
  }
  static fromHsla(t) {
    return new W(W.sourceFromHsl(t));
  }
  static sourceFromHsl(t) {
    const e = t.match(/^hsla?\(\s*([+-]?\d{0,3}(?:\.\d+)?(?:deg|turn|rad)?)\s*[\s|,]\s*(\d{0,3}(?:\.\d+)?%?)\s*[\s|,]\s*(\d{0,3}(?:\.\d+)?%?)\s*(?:\s*[,/]\s*(\d*(?:\.\d+)?%?)\s*)?\)$/i);
    if (!e) return;
    const s = (W.parseAngletoDegrees(e[1]) % 360 + 360) % 360 / 360, r = parseFloat(e[2]) / 100, n = parseFloat(e[3]) / 100;
    let o, a, c;
    if (r === 0) o = a = c = n;
    else {
      const l = n <= 0.5 ? n * (r + 1) : n + r - n * r, h = 2 * n - l;
      o = Li(h, l, s + 1 / 3), a = Li(h, l, s), c = Li(h, l, s - 1 / 3);
    }
    return [Math.round(255 * o), Math.round(255 * a), Math.round(255 * c), yo(e[4])];
  }
  static fromHex(t) {
    return new W(W.sourceFromHex(t));
  }
  static sourceFromHex(t) {
    if (t.match(/^#?(([0-9a-f]){3,4}|([0-9a-f]{2}){3,4})$/i)) {
      const e = t.slice(t.indexOf("#") + 1);
      let s;
      s = e.length <= 4 ? e.split("").map((c) => c + c) : e.match(/.{2}/g);
      const [r, n, o, a = 255] = s.map((c) => parseInt(c, 16));
      return [r, n, o, a / 255];
    }
  }
  static parseAngletoDegrees(t) {
    const e = t.toLowerCase(), s = parseFloat(e);
    return e.includes("rad") ? Ce(s) : e.includes("turn") ? 360 * s : s;
  }
}
const V = (i, t) => parseFloat(Number(i).toFixed(t)), We = function(i) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : En;
  const e = /\D{0,2}$/.exec(i), s = parseFloat(i), r = A.DPI;
  switch (e == null ? void 0 : e[0]) {
    case "mm":
      return s * r / 25.4;
    case "cm":
      return s * r / 2.54;
    case "in":
      return s * r;
    case "pt":
      return s * r / 72;
    case "pc":
      return s * r / 72 * 12;
    case "em":
      return s * t;
    default:
      return s;
  }
}, qa = (i) => {
  const [t, e] = i.trim().split(" "), [s, r] = (n = t) && n !== pt ? [n.slice(1, 4), n.slice(5, 8)] : n === pt ? [n, n] : ["Mid", "Mid"];
  var n;
  return { meetOrSlice: e || "meet", alignX: s, alignY: r };
}, qs = (i) => "matrix(" + i.map((t) => V(t, A.NUM_FRACTION_DIGITS)).join(" ") + ")", Ks = function(i, t) {
  let e, s, r = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2];
  if (t) if (t.toLive) e = "url(#SVGID_".concat(t.id, ")");
  else {
    const n = new W(t), o = n.getAlpha();
    e = n.toRgb(), o !== 1 && (s = o.toString());
  }
  else e = "none";
  return r ? "".concat(i, ": ").concat(e, "; ").concat(s ? "".concat(i, "-opacity: ").concat(s, "; ") : "") : "".concat(i, '="').concat(e, '" ').concat(s ? "".concat(i, '-opacity="').concat(s, '" ') : "");
}, Ct = (i) => !!i && i.toLive !== void 0, _o = (i) => !!i && typeof i.toObject == "function", So = (i) => !!i && i.offsetX !== void 0 && "source" in i, Pe = (i) => !!i && "multiSelectionStacking" in i;
function Ka(i) {
  const t = i && At(i);
  let e = 0, s = 0;
  if (!i || !t) return { left: e, top: s };
  let r = i;
  const n = t.documentElement, o = t.body || { scrollLeft: 0, scrollTop: 0 };
  for (; r && (r.parentNode || r.host) && (r = r.parentNode || r.host, r === t ? (e = o.scrollLeft || n.scrollLeft || 0, s = o.scrollTop || n.scrollTop || 0) : (e += r.scrollLeft || 0, s += r.scrollTop || 0), r.nodeType !== 1 || r.style.position !== "fixed"); ) ;
  return { left: e, top: s };
}
const At = (i) => i.ownerDocument || null, Ja = (i) => {
  var t;
  return ((t = i.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView) || null;
}, Za = function(i, t, e) {
  let { width: s, height: r } = e, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
  i.width = s, i.height = r, n > 1 && (i.setAttribute("width", (s * n).toString()), i.setAttribute("height", (r * n).toString()), t.scale(n, n));
}, nn = (i, t) => {
  let { width: e, height: s } = t;
  e && (i.style.width = typeof e == "number" ? "".concat(e, "px") : e), s && (i.style.height = typeof s == "number" ? "".concat(s, "px") : s);
};
function To(i) {
  return i.onselectstart !== void 0 && (i.onselectstart = () => !1), i.style.userSelect = pt, i;
}
class Qa {
  constructor(t) {
    y(this, "_originalCanvasStyle", void 0), y(this, "lower", void 0);
    const e = this.createLowerCanvas(t);
    this.lower = { el: e, ctx: e.getContext("2d") };
  }
  createLowerCanvas(t) {
    const e = (s = t) && s.getContext !== void 0 ? t : t && Cs().getElementById(t) || kt();
    var s;
    if (e.hasAttribute("data-fabric")) throw new Yt("Trying to initialize a canvas that has already been initialized. Did you forget to dispose the canvas?");
    return this._originalCanvasStyle = e.style.cssText, e.setAttribute("data-fabric", "main"), e.classList.add("lower-canvas"), e;
  }
  cleanupDOM(t) {
    let { width: e, height: s } = t;
    const { el: r } = this.lower;
    r.classList.remove("lower-canvas"), r.removeAttribute("data-fabric"), r.setAttribute("width", "".concat(e)), r.setAttribute("height", "".concat(s)), r.style.cssText = this._originalCanvasStyle || "", this._originalCanvasStyle = void 0;
  }
  setDimensions(t, e) {
    const { el: s, ctx: r } = this.lower;
    Za(s, r, t, e);
  }
  setCSSDimensions(t) {
    nn(this.lower.el, t);
  }
  calcOffset() {
    return function(t) {
      var e;
      const s = t && At(t), r = { left: 0, top: 0 };
      if (!s) return r;
      const n = ((e = Ja(t)) === null || e === void 0 ? void 0 : e.getComputedStyle(t, null)) || {};
      r.left += parseInt(n.borderLeftWidth, 10) || 0, r.top += parseInt(n.borderTopWidth, 10) || 0, r.left += parseInt(n.paddingLeft, 10) || 0, r.top += parseInt(n.paddingTop, 10) || 0;
      let o = { left: 0, top: 0 };
      const a = s.documentElement;
      t.getBoundingClientRect !== void 0 && (o = t.getBoundingClientRect());
      const c = Ka(t);
      return { left: o.left + c.left - (a.clientLeft || 0) + r.left, top: o.top + c.top - (a.clientTop || 0) + r.top };
    }(this.lower.el);
  }
  dispose() {
    $t().dispose(this.lower.el), delete this.lower;
  }
}
const Yh = { backgroundVpt: !0, backgroundColor: "", overlayVpt: !0, overlayColor: "", includeDefaultValues: !0, svgViewportTransformation: !0, renderOnAddRemove: !0, skipOffscreen: !0, enableRetinaScaling: !0, imageSmoothingEnabled: !0, controlsAboveOverlay: !1, allowTouchScrolling: !1, viewportTransform: [...ht] };
class lr extends za(Ha) {
  get lowerCanvasEl() {
    var t;
    return (t = this.elements.lower) === null || t === void 0 ? void 0 : t.el;
  }
  get contextContainer() {
    var t;
    return (t = this.elements.lower) === null || t === void 0 ? void 0 : t.ctx;
  }
  static getDefaults() {
    return lr.ownDefaults;
  }
  constructor(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), Object.assign(this, this.constructor.getDefaults()), this.set(e), this.initElements(t), this._setDimensionsImpl({ width: this.width || this.elements.lower.el.width || 0, height: this.height || this.elements.lower.el.height || 0 }), this.skipControlsDrawing = !1, this.viewportTransform = [...this.viewportTransform], this.calcViewportBoundaries();
  }
  initElements(t) {
    this.elements = new Qa(t);
  }
  add() {
    const t = super.add(...arguments);
    return arguments.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), t;
  }
  insertAt(t) {
    for (var e = arguments.length, s = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) s[r - 1] = arguments[r];
    const n = super.insertAt(t, ...s);
    return s.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), n;
  }
  remove() {
    const t = super.remove(...arguments);
    return t.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), t;
  }
  _onObjectAdded(t) {
    t.canvas && t.canvas !== this && (Te("warn", `Canvas is trying to add an object that belongs to a different canvas.
Resulting to default behavior: removing object from previous canvas and adding to new canvas`), t.canvas.remove(t)), t._set("canvas", this), t.setCoords(), this.fire("object:added", { target: t }), t.fire("added", { target: this });
  }
  _onObjectRemoved(t) {
    t._set("canvas", void 0), this.fire("object:removed", { target: t }), t.fire("removed", { target: this });
  }
  _onStackOrderChanged() {
    this.renderOnAddRemove && this.requestRenderAll();
  }
  getRetinaScaling() {
    return this.enableRetinaScaling ? Ra() : 1;
  }
  calcOffset() {
    return this._offset = this.elements.calcOffset();
  }
  getWidth() {
    return this.width;
  }
  getHeight() {
    return this.height;
  }
  setWidth(t, e) {
    return this.setDimensions({ width: t }, e);
  }
  setHeight(t, e) {
    return this.setDimensions({ height: t }, e);
  }
  _setDimensionsImpl(t) {
    let { cssOnly: e = !1, backstoreOnly: s = !1 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!e) {
      const r = v({ width: this.width, height: this.height }, t);
      this.elements.setDimensions(r, this.getRetinaScaling()), this.hasLostContext = !0, this.width = r.width, this.height = r.height;
    }
    s || this.elements.setCSSDimensions(t), this.calcOffset();
  }
  setDimensions(t, e) {
    this._setDimensionsImpl(t, e), e && e.cssOnly || this.requestRenderAll();
  }
  getZoom() {
    return this.viewportTransform[0];
  }
  setViewportTransform(t) {
    this.viewportTransform = t, this.calcViewportBoundaries(), this.renderOnAddRemove && this.requestRenderAll();
  }
  zoomToPoint(t, e) {
    const s = t, r = [...this.viewportTransform], n = ot(t, St(r));
    r[0] = e, r[3] = e;
    const o = ot(n, r);
    r[4] += s.x - o.x, r[5] += s.y - o.y, this.setViewportTransform(r);
  }
  setZoom(t) {
    this.zoomToPoint(new _(0, 0), t);
  }
  absolutePan(t) {
    const e = [...this.viewportTransform];
    return e[4] = -t.x, e[5] = -t.y, this.setViewportTransform(e);
  }
  relativePan(t) {
    return this.absolutePan(new _(-t.x - this.viewportTransform[4], -t.y - this.viewportTransform[5]));
  }
  getElement() {
    return this.elements.lower.el;
  }
  clearContext(t) {
    t.clearRect(0, 0, this.width, this.height);
  }
  getContext() {
    return this.elements.lower.ctx;
  }
  clear() {
    this.remove(...this.getObjects()), this.backgroundImage = void 0, this.overlayImage = void 0, this.backgroundColor = "", this.overlayColor = "", this.clearContext(this.getContext()), this.fire("canvas:cleared"), this.renderOnAddRemove && this.requestRenderAll();
  }
  renderAll() {
    this.cancelRequestedRender(), this.destroyed || this.renderCanvas(this.getContext(), this._objects);
  }
  renderAndReset() {
    this.nextRenderHandle = 0, this.renderAll();
  }
  requestRenderAll() {
    this.nextRenderHandle || this.disposed || this.destroyed || (this.nextRenderHandle = Hs(() => this.renderAndReset()));
  }
  calcViewportBoundaries() {
    const t = this.width, e = this.height, s = St(this.viewportTransform), r = ot({ x: 0, y: 0 }, s), n = ot({ x: t, y: e }, s), o = r.min(n), a = r.max(n);
    return this.vptCoords = { tl: o, tr: new _(a.x, o.y), bl: new _(o.x, a.y), br: a };
  }
  cancelRequestedRender() {
    this.nextRenderHandle && (Ya(this.nextRenderHandle), this.nextRenderHandle = 0);
  }
  drawControls(t) {
  }
  renderCanvas(t, e) {
    if (this.destroyed) return;
    const s = this.viewportTransform, r = this.clipPath;
    this.calcViewportBoundaries(), this.clearContext(t), t.imageSmoothingEnabled = this.imageSmoothingEnabled, t.patternQuality = "best", this.fire("before:render", { ctx: t }), this._renderBackground(t), t.save(), t.transform(s[0], s[1], s[2], s[3], s[4], s[5]), this._renderObjects(t, e), t.restore(), this.controlsAboveOverlay || this.skipControlsDrawing || this.drawControls(t), r && (r._set("canvas", this), r.shouldCache(), r._transformDone = !0, r.renderCache({ forClipping: !0 }), this.drawClipPathOnCanvas(t, r)), this._renderOverlay(t), this.controlsAboveOverlay && !this.skipControlsDrawing && this.drawControls(t), this.fire("after:render", { ctx: t }), this.__cleanupTask && (this.__cleanupTask(), this.__cleanupTask = void 0);
  }
  drawClipPathOnCanvas(t, e) {
    const s = this.viewportTransform;
    t.save(), t.transform(...s), t.globalCompositeOperation = "destination-in", e.transform(t), t.scale(1 / e.zoomX, 1 / e.zoomY), t.drawImage(e._cacheCanvas, -e.cacheTranslationX, -e.cacheTranslationY), t.restore();
  }
  _renderObjects(t, e) {
    for (let s = 0, r = e.length; s < r; ++s) e[s] && e[s].render(t);
  }
  _renderBackgroundOrOverlay(t, e) {
    const s = this["".concat(e, "Color")], r = this["".concat(e, "Image")], n = this.viewportTransform, o = this["".concat(e, "Vpt")];
    if (!s && !r) return;
    const a = Ct(s);
    if (s) {
      if (t.save(), t.beginPath(), t.moveTo(0, 0), t.lineTo(this.width, 0), t.lineTo(this.width, this.height), t.lineTo(0, this.height), t.closePath(), t.fillStyle = a ? s.toLive(t) : s, o && t.transform(...n), a) {
        t.transform(1, 0, 0, 1, s.offsetX || 0, s.offsetY || 0);
        const c = s.gradientTransform || s.patternTransform;
        c && t.transform(...c);
      }
      t.fill(), t.restore();
    }
    if (r) {
      t.save();
      const { skipOffscreen: c } = this;
      this.skipOffscreen = o, o && t.transform(...n), r.render(t), this.skipOffscreen = c, t.restore();
    }
  }
  _renderBackground(t) {
    this._renderBackgroundOrOverlay(t, "background");
  }
  _renderOverlay(t) {
    this._renderBackgroundOrOverlay(t, "overlay");
  }
  getCenter() {
    return { top: this.height / 2, left: this.width / 2 };
  }
  getCenterPoint() {
    return new _(this.width / 2, this.height / 2);
  }
  centerObjectH(t) {
    return this._centerObject(t, new _(this.getCenterPoint().x, t.getCenterPoint().y));
  }
  centerObjectV(t) {
    return this._centerObject(t, new _(t.getCenterPoint().x, this.getCenterPoint().y));
  }
  centerObject(t) {
    return this._centerObject(t, this.getCenterPoint());
  }
  viewportCenterObject(t) {
    return this._centerObject(t, this.getVpCenter());
  }
  viewportCenterObjectH(t) {
    return this._centerObject(t, new _(this.getVpCenter().x, t.getCenterPoint().y));
  }
  viewportCenterObjectV(t) {
    return this._centerObject(t, new _(t.getCenterPoint().x, this.getVpCenter().y));
  }
  getVpCenter() {
    return ot(this.getCenterPoint(), St(this.viewportTransform));
  }
  _centerObject(t, e) {
    t.setXY(e, j, j), t.setCoords(), this.renderOnAddRemove && this.requestRenderAll();
  }
  toDatalessJSON(t) {
    return this.toDatalessObject(t);
  }
  toObject(t) {
    return this._toObjectMethod("toObject", t);
  }
  toJSON() {
    return this.toObject();
  }
  toDatalessObject(t) {
    return this._toObjectMethod("toDatalessObject", t);
  }
  _toObjectMethod(t, e) {
    const s = this.clipPath, r = s && !s.excludeFromExport ? this._toObject(s, t, e) : null;
    return v(v(v({ version: sn }, Ve(this, e)), {}, { objects: this._objects.filter((n) => !n.excludeFromExport).map((n) => this._toObject(n, t, e)) }, this.__serializeBgOverlay(t, e)), r ? { clipPath: r } : null);
  }
  _toObject(t, e, s) {
    let r;
    this.includeDefaultValues || (r = t.includeDefaultValues, t.includeDefaultValues = !1);
    const n = t[e](s);
    return this.includeDefaultValues || (t.includeDefaultValues = !!r), n;
  }
  __serializeBgOverlay(t, e) {
    const s = {}, r = this.backgroundImage, n = this.overlayImage, o = this.backgroundColor, a = this.overlayColor;
    return Ct(o) ? o.excludeFromExport || (s.background = o.toObject(e)) : o && (s.background = o), Ct(a) ? a.excludeFromExport || (s.overlay = a.toObject(e)) : a && (s.overlay = a), r && !r.excludeFromExport && (s.backgroundImage = this._toObject(r, t, e)), n && !n.excludeFromExport && (s.overlayImage = this._toObject(n, t, e)), s;
  }
  toSVG() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = arguments.length > 1 ? arguments[1] : void 0;
    t.reviver = e;
    const s = [];
    return this._setSVGPreamble(s, t), this._setSVGHeader(s, t), this.clipPath && s.push('<g clip-path="url(#'.concat(this.clipPath.clipPathId, `)" >
`)), this._setSVGBgOverlayColor(s, "background"), this._setSVGBgOverlayImage(s, "backgroundImage", e), this._setSVGObjects(s, e), this.clipPath && s.push(`</g>
`), this._setSVGBgOverlayColor(s, "overlay"), this._setSVGBgOverlayImage(s, "overlayImage", e), s.push("</svg>"), s.join("");
  }
  _setSVGPreamble(t, e) {
    e.suppressPreamble || t.push('<?xml version="1.0" encoding="', e.encoding || "UTF-8", `" standalone="no" ?>
`, '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ', `"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
`);
  }
  _setSVGHeader(t, e) {
    const s = e.width || "".concat(this.width), r = e.height || "".concat(this.height), n = A.NUM_FRACTION_DIGITS, o = e.viewBox;
    let a;
    if (o) a = 'viewBox="'.concat(o.x, " ").concat(o.y, " ").concat(o.width, " ").concat(o.height, '" ');
    else if (this.svgViewportTransformation) {
      const c = this.viewportTransform;
      a = 'viewBox="'.concat(V(-c[4] / c[0], n), " ").concat(V(-c[5] / c[3], n), " ").concat(V(this.width / c[0], n), " ").concat(V(this.height / c[3], n), '" ');
    } else a = 'viewBox="0 0 '.concat(this.width, " ").concat(this.height, '" ');
    t.push("<svg ", 'xmlns="http://www.w3.org/2000/svg" ', 'xmlns:xlink="http://www.w3.org/1999/xlink" ', 'version="1.1" ', 'width="', s, '" ', 'height="', r, '" ', a, `xml:space="preserve">
`, "<desc>Created with Fabric.js ", sn, `</desc>
`, `<defs>
`, this.createSVGFontFacesMarkup(), this.createSVGRefElementsMarkup(), this.createSVGClipPathMarkup(e), `</defs>
`);
  }
  createSVGClipPathMarkup(t) {
    const e = this.clipPath;
    return e ? (e.clipPathId = "CLIPPATH_".concat(we()), '<clipPath id="'.concat(e.clipPathId, `" >
`).concat(e.toClipPathSVG(t.reviver), `</clipPath>
`)) : "";
  }
  createSVGRefElementsMarkup() {
    return ["background", "overlay"].map((t) => {
      const e = this["".concat(t, "Color")];
      if (Ct(e)) {
        const s = this["".concat(t, "Vpt")], r = this.viewportTransform, n = { isType: () => !1, width: this.width / (s ? r[0] : 1), height: this.height / (s ? r[3] : 1) };
        return e.toSVG(n, { additionalTransform: s ? qs(r) : "" });
      }
    }).join("");
  }
  createSVGFontFacesMarkup() {
    const t = [], e = {}, s = A.fontPaths;
    this._objects.forEach(function n(o) {
      t.push(o), Vr(o) && o._objects.forEach(n);
    }), t.forEach((n) => {
      if (!(o = n) || typeof o._renderText != "function") return;
      var o;
      const { styles: a, fontFamily: c } = n;
      !e[c] && s[c] && (e[c] = !0, a && Object.values(a).forEach((l) => {
        Object.values(l).forEach((h) => {
          let { fontFamily: u = "" } = h;
          !e[u] && s[u] && (e[u] = !0);
        });
      }));
    });
    const r = Object.keys(e).map((n) => `		@font-face {
			font-family: '`.concat(n, `';
			src: url('`).concat(s[n], `');
		}
`)).join("");
    return r ? `	<style type="text/css"><![CDATA[
`.concat(r, `]]></style>
`) : "";
  }
  _setSVGObjects(t, e) {
    this.forEachObject((s) => {
      s.excludeFromExport || this._setSVGObject(t, s, e);
    });
  }
  _setSVGObject(t, e, s) {
    t.push(e.toSVG(s));
  }
  _setSVGBgOverlayImage(t, e, s) {
    const r = this[e];
    r && !r.excludeFromExport && r.toSVG && t.push(r.toSVG(s));
  }
  _setSVGBgOverlayColor(t, e) {
    const s = this["".concat(e, "Color")];
    if (s) if (Ct(s)) {
      const r = s.repeat || "", n = this.width, o = this.height, a = this["".concat(e, "Vpt")] ? qs(St(this.viewportTransform)) : "";
      t.push('<rect transform="'.concat(a, " translate(").concat(n / 2, ",").concat(o / 2, ')" x="').concat(s.offsetX - n / 2, '" y="').concat(s.offsetY - o / 2, '" width="').concat(r !== "repeat-y" && r !== "no-repeat" || !So(s) ? n : s.source.width, '" height="').concat(r !== "repeat-x" && r !== "no-repeat" || !So(s) ? o : s.source.height, '" fill="url(#SVGID_').concat(s.id, `)"></rect>
`));
    } else t.push('<rect x="0" y="0" width="100%" height="100%" ', 'fill="', s, '"', `></rect>
`);
  }
  loadFromJSON(t, e) {
    let { signal: s } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!t) return Promise.reject(new Yt("`json` is undefined"));
    const r = typeof t == "string" ? JSON.parse(t) : t, { objects: n = [], backgroundImage: o, background: a, overlayImage: c, overlay: l, clipPath: h } = r, u = this.renderOnAddRemove;
    return this.renderOnAddRemove = !1, Promise.all([bs(n, { reviver: e, signal: s }), cr({ backgroundImage: o, backgroundColor: a, overlayImage: c, overlayColor: l, clipPath: h }, { signal: s })]).then((d) => {
      let [f, g] = d;
      return this.clear(), this.add(...f), this.set(r), this.set(g), this.renderOnAddRemove = u, this;
    });
  }
  clone(t) {
    const e = this.toObject(t);
    return this.cloneWithoutData().loadFromJSON(e);
  }
  cloneWithoutData() {
    const t = Wt(this);
    return new this.constructor(t);
  }
  toDataURL() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const { format: e = "png", quality: s = 1, multiplier: r = 1, enableRetinaScaling: n = !1 } = t, o = r * (n ? this.getRetinaScaling() : 1);
    return Rn(this.toCanvasElement(o, t), e, s);
  }
  toBlob() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const { format: e = "png", quality: s = 1, multiplier: r = 1, enableRetinaScaling: n = !1 } = t, o = r * (n ? this.getRetinaScaling() : 1);
    return Ln(this.toCanvasElement(o, t), e, s);
  }
  toCanvasElement() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, { width: e, height: s, left: r, top: n, filter: o } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const a = (e || this.width) * t, c = (s || this.height) * t, l = this.getZoom(), h = this.width, u = this.height, d = this.skipControlsDrawing, f = l * t, g = this.viewportTransform, p = [f, 0, 0, f, (g[4] - (r || 0)) * t, (g[5] - (n || 0)) * t], m = this.enableRetinaScaling, b = Wt({ width: a, height: c }), S = o ? this._objects.filter((w) => o(w)) : this._objects;
    return this.enableRetinaScaling = !1, this.viewportTransform = p, this.width = a, this.height = c, this.skipControlsDrawing = !0, this.calcViewportBoundaries(), this.renderCanvas(b.getContext("2d"), S), this.viewportTransform = g, this.width = h, this.height = u, this.calcViewportBoundaries(), this.enableRetinaScaling = m, this.skipControlsDrawing = d, b;
  }
  dispose() {
    return !this.disposed && this.elements.cleanupDOM({ width: this.width, height: this.height }), qr.cancelByCanvas(this), this.disposed = !0, new Promise((t, e) => {
      const s = () => {
        this.destroy(), t(!0);
      };
      s.kill = e, this.__cleanupTask && this.__cleanupTask.kill("aborted"), this.destroyed ? t(!1) : this.nextRenderHandle ? this.__cleanupTask = s : s();
    });
  }
  destroy() {
    this.destroyed = !0, this.cancelRequestedRender(), this.forEachObject((t) => t.dispose()), this._objects = [], this.backgroundImage && this.backgroundImage.dispose(), this.backgroundImage = void 0, this.overlayImage && this.overlayImage.dispose(), this.overlayImage = void 0, this.elements.dispose();
  }
  toString() {
    return "#<Canvas (".concat(this.complexity(), "): { objects: ").concat(this._objects.length, " }>");
  }
}
y(lr, "ownDefaults", Yh);
const Vh = ["touchstart", "touchmove", "touchend"], tc = (i) => {
  const t = Ka(i.target), e = function(s) {
    const r = s.changedTouches;
    return r && r[0] ? r[0] : s;
  }(i);
  return new _(e.clientX + t.left, e.clientY + t.top);
}, Kr = (i) => Vh.includes(i.type) || i.pointerType === "touch", on = (i) => {
  i.preventDefault(), i.stopPropagation();
}, Gt = (i) => {
  let t = 0, e = 0, s = 0, r = 0;
  for (let n = 0, o = i.length; n < o; n++) {
    const { x: a, y: c } = i[n];
    (a > s || !n) && (s = a), (a < t || !n) && (t = a), (c > r || !n) && (r = c), (c < e || !n) && (e = c);
  }
  return { left: t, top: e, width: s - t, height: r - e };
}, Gh = ["translateX", "translateY", "scaleX", "scaleY"], ec = (i, t) => _s(i, J(t, i.calcOwnMatrix())), _s = (i, t) => {
  const e = ys(t), { translateX: s, translateY: r, scaleX: n, scaleY: o } = e, a = G(e, Gh), c = new _(s, r);
  i.flipX = !1, i.flipY = !1, Object.assign(i, a), i.set({ scaleX: n, scaleY: o }), i.setPositionByOrigin(c, j, j);
}, sc = (i) => {
  i.scaleX = 1, i.scaleY = 1, i.skewX = 0, i.skewY = 0, i.flipX = !1, i.flipY = !1, i.rotate(0);
}, zn = (i) => ({ scaleX: i.scaleX, scaleY: i.scaleY, skewX: i.skewX, skewY: i.skewY, angle: i.angle, left: i.left, flipX: i.flipX, flipY: i.flipY, top: i.top }), yi = (i, t, e) => {
  const s = i / 2, r = t / 2, n = [new _(-s, -r), new _(s, -r), new _(-s, r), new _(s, r)].map((a) => a.transform(e)), o = Gt(n);
  return new _(o.width, o.height);
}, hr = function() {
  let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ht;
  return J(St(arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ht), i);
}, ae = function(i) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ht, e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ht;
  return i.transform(hr(t, e));
}, rc = function(i) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ht, e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ht;
  return i.transform(hr(t, e), !0);
}, an = (i, t, e) => {
  const s = hr(t, e);
  return _s(i, J(s, i.calcOwnMatrix())), s;
}, Hn = (i, t) => {
  var e;
  const { transform: { target: s } } = t;
  (e = s.canvas) === null || e === void 0 || e.fire("object:".concat(i), v(v({}, t), {}, { target: s })), s.fire(i, t);
}, Nh = { left: -0.5, top: -0.5, center: 0, bottom: 0.5, right: 0.5 }, st = (i) => typeof i == "string" ? Nh[i] : i - 0.5, Jr = "not-allowed";
function ic(i) {
  return st(i.originX) === st(j) && st(i.originY) === st(j);
}
function xo(i) {
  return 0.5 - st(i);
}
const Rt = (i, t) => i[t], Yn = (i, t, e, s) => ({ e: i, transform: t, pointer: new _(e, s) });
function nc(i, t) {
  const e = i.getTotalAngle() + Ce(Math.atan2(t.y, t.x)) + 360;
  return Math.round(e % 360 / 45);
}
function bi(i, t, e, s, r) {
  var n;
  let { target: o, corner: a } = i;
  const c = o.controls[a], l = ((n = o.canvas) === null || n === void 0 ? void 0 : n.getZoom()) || 1, h = o.padding / l, u = function(d, f, g, p) {
    const m = d.getRelativeCenterPoint(), b = g !== void 0 && p !== void 0 ? d.translateToGivenOrigin(m, j, j, g, p) : new _(d.left, d.top);
    return (d.angle ? f.rotate(-K(d.angle), m) : f).subtract(b);
  }(o, new _(s, r), t, e);
  return u.x >= h && (u.x -= h), u.x <= -h && (u.x += h), u.y >= h && (u.y -= h), u.y <= h && (u.y += h), u.x -= c.offsetX, u.y -= c.offsetY, u;
}
const oc = (i, t, e, s) => {
  const { target: r, offsetX: n, offsetY: o } = t, a = e - n, c = s - o, l = !Rt(r, "lockMovementX") && r.left !== a, h = !Rt(r, "lockMovementY") && r.top !== c;
  return l && r.set(L, a), h && r.set(gt, c), (l || h) && Hn(La, Yn(i, t, e, s)), l || h;
};
class ac {
  getSvgStyles(t) {
    const e = this.fillRule ? this.fillRule : "nonzero", s = this.strokeWidth ? this.strokeWidth : "0", r = this.strokeDashArray ? this.strokeDashArray.join(" ") : pt, n = this.strokeDashOffset ? this.strokeDashOffset : "0", o = this.strokeLineCap ? this.strokeLineCap : "butt", a = this.strokeLineJoin ? this.strokeLineJoin : "miter", c = this.strokeMiterLimit ? this.strokeMiterLimit : "4", l = this.opacity !== void 0 ? this.opacity : "1", h = this.visible ? "" : " visibility: hidden;", u = t ? "" : this.getSvgFilter(), d = Ks(rt, this.fill);
    return [Ks(mt, this.stroke), "stroke-width: ", s, "; ", "stroke-dasharray: ", r, "; ", "stroke-linecap: ", o, "; ", "stroke-dashoffset: ", n, "; ", "stroke-linejoin: ", a, "; ", "stroke-miterlimit: ", c, "; ", d, "fill-rule: ", e, "; ", "opacity: ", l, ";", u, h].join("");
  }
  getSvgFilter() {
    return this.shadow ? "filter: url(#SVGID_".concat(this.shadow.id, ");") : "";
  }
  getSvgCommons() {
    return [this.id ? 'id="'.concat(this.id, '" ') : "", this.clipPath ? 'clip-path="url(#'.concat(this.clipPath.clipPathId, ')" ') : ""].join("");
  }
  getSvgTransform(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const s = t ? this.calcTransformMatrix() : this.calcOwnMatrix(), r = 'transform="'.concat(qs(s));
    return "".concat(r).concat(e, '" ');
  }
  _toSVG(t) {
    return [""];
  }
  toSVG(t) {
    return this._createBaseSVGMarkup(this._toSVG(t), { reviver: t });
  }
  toClipPathSVG(t) {
    return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(t), { reviver: t });
  }
  _createBaseClipPathSVGMarkup(t) {
    let { reviver: e, additionalTransform: s = "" } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const r = [this.getSvgTransform(!0, s), this.getSvgCommons()].join(""), n = t.indexOf("COMMON_PARTS");
    return t[n] = r, e ? e(t.join("")) : t.join("");
  }
  _createBaseSVGMarkup(t) {
    let { noStyle: e, reviver: s, withShadow: r, additionalTransform: n } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const o = e ? "" : 'style="'.concat(this.getSvgStyles(), '" '), a = r ? 'style="'.concat(this.getSvgFilter(), '" ') : "", c = this.clipPath, l = this.strokeUniform ? 'vector-effect="non-scaling-stroke" ' : "", h = c && c.absolutePositioned, u = this.stroke, d = this.fill, f = this.shadow, g = [], p = t.indexOf("COMMON_PARTS");
    let m;
    c && (c.clipPathId = "CLIPPATH_".concat(we()), m = '<clipPath id="'.concat(c.clipPathId, `" >
`).concat(c.toClipPathSVG(s), `</clipPath>
`)), h && g.push("<g ", a, this.getSvgCommons(), ` >
`), g.push("<g ", this.getSvgTransform(!1), h ? "" : a + this.getSvgCommons(), ` >
`);
    const b = [o, l, e ? "" : this.addPaintOrder(), " ", n ? 'transform="'.concat(n, '" ') : ""].join("");
    return t[p] = b, Ct(d) && g.push(d.toSVG(this)), Ct(u) && g.push(u.toSVG(this)), f && g.push(f.toSVG(this)), c && g.push(m), g.push(t.join("")), g.push(`</g>
`), h && g.push(`</g>
`), s ? s(g.join("")) : g.join("");
  }
  addPaintOrder() {
    return this.paintFirst !== rt ? ' paint-order="'.concat(this.paintFirst, '" ') : "";
  }
}
function _i(i) {
  return new RegExp("^(" + i.join("|") + ")\\b", "i");
}
var wo;
const Xe = String.raw(wo || (wo = Me(["(?:[-+]?(?:d*.d+|d+.?)(?:[eE][-+]?d+)?)"], ["(?:[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?)"]))), Uh = new RegExp("(normal|italic)?\\s*(normal|small-caps)?\\s*(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(" + Xe + "(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|" + Xe + "))?\\s+(.*)"), $h = { cx: L, x: L, r: "radius", cy: gt, y: gt, display: "visible", visibility: "visible", transform: "transformMatrix", "fill-opacity": "fillOpacity", "fill-rule": "fillRule", "font-family": "fontFamily", "font-size": "fontSize", "font-style": "fontStyle", "font-weight": "fontWeight", "letter-spacing": "charSpacing", "paint-order": "paintFirst", "stroke-dasharray": "strokeDashArray", "stroke-dashoffset": "strokeDashOffset", "stroke-linecap": "strokeLineCap", "stroke-linejoin": "strokeLineJoin", "stroke-miterlimit": "strokeMiterLimit", "stroke-opacity": "strokeOpacity", "stroke-width": "strokeWidth", "text-decoration": "textDecoration", "text-anchor": "textAnchor", opacity: "opacity", "clip-path": "clipPath", "clip-rule": "clipRule", "vector-effect": "strokeUniform", "image-rendering": "imageSmoothing" }, Bi = "font-size", Wi = "clip-path";
_i(["path", "circle", "polygon", "polyline", "ellipse", "rect", "line", "image", "text"]);
_i(["symbol", "image", "marker", "pattern", "view", "svg"]);
const Co = _i(["symbol", "g", "a", "svg", "clipPath", "defs"]), qh = new _(1, 0), cc = new _(), Vn = (i, t) => i.rotate(t), Zr = (i, t) => new _(t).subtract(i), Qr = (i) => i.distanceFrom(cc), ti = (i, t) => Math.atan2(ps(i, t), hc(i, t)), lc = (i) => ti(qh, i), Si = (i) => i.eq(cc) ? i : i.scalarDivide(Qr(i)), Gn = function(i) {
  let t = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
  return Si(new _(-i.y, i.x).scalarMultiply(t ? 1 : -1));
}, ps = (i, t) => i.x * t.y - i.y * t.x, hc = (i, t) => i.x * t.x + i.y * t.y, cn = (i, t, e) => {
  if (i.eq(t) || i.eq(e)) return !0;
  const s = ps(t, e), r = ps(t, i), n = ps(e, i);
  return s >= 0 ? r >= 0 && n <= 0 : !(r <= 0 && n >= 0);
}, Oo = "(-?\\d+(?:\\.\\d*)?(?:px)?(?:\\s?|$))?", ko = new RegExp("(?:\\s|^)" + Oo + Oo + "(" + Xe + "?(?:px)?)?(?:\\s?|$)(?:$|\\s)");
class ce {
  constructor(t) {
    const e = typeof t == "string" ? ce.parseShadow(t) : t;
    Object.assign(this, ce.ownDefaults, e), this.id = we();
  }
  static parseShadow(t) {
    const e = t.trim(), [, s = 0, r = 0, n = 0] = (ko.exec(e) || []).map((o) => parseFloat(o) || 0);
    return { color: (e.replace(ko, "") || "rgb(0,0,0)").trim(), offsetX: s, offsetY: r, blur: n };
  }
  toString() {
    return [this.offsetX, this.offsetY, this.blur, this.color].join("px ");
  }
  toSVG(t) {
    const e = Vn(new _(this.offsetX, this.offsetY), K(-t.angle)), s = new W(this.color);
    let r = 40, n = 40;
    return t.width && t.height && (r = 100 * V((Math.abs(e.x) + this.blur) / t.width, A.NUM_FRACTION_DIGITS) + 20, n = 100 * V((Math.abs(e.y) + this.blur) / t.height, A.NUM_FRACTION_DIGITS) + 20), t.flipX && (e.x *= -1), t.flipY && (e.y *= -1), '<filter id="SVGID_'.concat(this.id, '" y="-').concat(n, '%" height="').concat(100 + 2 * n, '%" x="-').concat(r, '%" width="').concat(100 + 2 * r, `%" >
	<feGaussianBlur in="SourceAlpha" stdDeviation="`).concat(V(this.blur ? this.blur / 2 : 0, A.NUM_FRACTION_DIGITS), `"></feGaussianBlur>
	<feOffset dx="`).concat(V(e.x, A.NUM_FRACTION_DIGITS), '" dy="').concat(V(e.y, A.NUM_FRACTION_DIGITS), `" result="oBlur" ></feOffset>
	<feFlood flood-color="`).concat(s.toRgb(), '" flood-opacity="').concat(s.getAlpha(), `"/>
	<feComposite in2="oBlur" operator="in" />
	<feMerge>
		<feMergeNode></feMergeNode>
		<feMergeNode in="SourceGraphic"></feMergeNode>
	</feMerge>
</filter>
`);
  }
  toObject() {
    const t = { color: this.color, blur: this.blur, offsetX: this.offsetX, offsetY: this.offsetY, affectStroke: this.affectStroke, nonScaling: this.nonScaling, type: this.constructor.type }, e = ce.ownDefaults;
    return this.includeDefaultValues ? t : Xn(t, (s, r) => s !== e[r]);
  }
  static async fromObject(t) {
    return new this(t);
  }
}
y(ce, "ownDefaults", { color: "rgb(0,0,0)", blur: 0, offsetX: 0, offsetY: 0, affectStroke: !1, includeDefaultValues: !0, nonScaling: !1 }), y(ce, "type", "shadow"), C.setClass(ce, "shadow");
const ze = (i, t, e) => Math.max(i, Math.min(t, e)), Kh = [gt, L, ut, Tt, "flipX", "flipY", "originX", "originY", "angle", "opacity", "globalCompositeOperation", "shadow", "visible", Os, ks], de = [rt, mt, "strokeWidth", "strokeDashArray", "width", "height", "paintFirst", "strokeUniform", "strokeLineCap", "strokeDashOffset", "strokeLineJoin", "strokeMiterLimit", "backgroundColor", "clipPath"], Jh = { top: 0, left: 0, width: 0, height: 0, angle: 0, flipX: !1, flipY: !1, scaleX: 1, scaleY: 1, minScaleLimit: 0, skewX: 0, skewY: 0, originX: L, originY: gt, strokeWidth: 1, strokeUniform: !1, padding: 0, opacity: 1, paintFirst: rt, fill: "rgb(0,0,0)", fillRule: "nonzero", stroke: null, strokeDashArray: null, strokeDashOffset: 0, strokeLineCap: "butt", strokeLineJoin: "miter", strokeMiterLimit: 4, globalCompositeOperation: "source-over", backgroundColor: "", shadow: null, visible: !0, includeDefaultValues: !0, excludeFromExport: !1, objectCaching: !0, clipPath: void 0, inverted: !1, absolutePositioned: !1, centeredRotation: !0, centeredScaling: !1, dirty: !0 }, Xi = (i, t, e, s) => (i < Math.abs(t) ? (i = t, s = e / 4) : s = t === 0 && i === 0 ? e / he * Math.asin(1) : e / he * Math.asin(t / i), { a: i, c: t, p: e, s }), Mo = (i, t, e, s, r) => i * Math.pow(2, 10 * (s -= 1)) * Math.sin((s * r - t) * he / e), uc = (i, t, e, s) => -e * Math.cos(i / s * xe) + e + t, ln = (i, t, e, s) => (i /= s) < 1 / 2.75 ? e * (7.5625 * i * i) + t : i < 2 / 2.75 ? e * (7.5625 * (i -= 1.5 / 2.75) * i + 0.75) + t : i < 2.5 / 2.75 ? e * (7.5625 * (i -= 2.25 / 2.75) * i + 0.9375) + t : e * (7.5625 * (i -= 2.625 / 2.75) * i + 0.984375) + t, Io = (i, t, e, s) => e - ln(s - i, 0, e, s) + t;
var Zh = Object.freeze({ __proto__: null, defaultEasing: uc, easeInBack: function(i, t, e, s) {
  let r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1.70158;
  return e * (i /= s) * i * ((r + 1) * i - r) + t;
}, easeInBounce: Io, easeInCirc: (i, t, e, s) => -e * (Math.sqrt(1 - (i /= s) * i) - 1) + t, easeInCubic: (i, t, e, s) => e * (i / s) ** 3 + t, easeInElastic: (i, t, e, s) => {
  const r = e;
  let n = 0;
  if (i === 0) return t;
  if ((i /= s) === 1) return t + e;
  n || (n = 0.3 * s);
  const { a: o, s: a, p: c } = Xi(r, e, n, 1.70158);
  return -Mo(o, a, c, i, s) + t;
}, easeInExpo: (i, t, e, s) => i === 0 ? t : e * 2 ** (10 * (i / s - 1)) + t, easeInOutBack: function(i, t, e, s) {
  let r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1.70158;
  return (i /= s / 2) < 1 ? e / 2 * (i * i * ((1 + (r *= 1.525)) * i - r)) + t : e / 2 * ((i -= 2) * i * ((1 + (r *= 1.525)) * i + r) + 2) + t;
}, easeInOutBounce: (i, t, e, s) => i < s / 2 ? 0.5 * Io(2 * i, 0, e, s) + t : 0.5 * ln(2 * i - s, 0, e, s) + 0.5 * e + t, easeInOutCirc: (i, t, e, s) => (i /= s / 2) < 1 ? -e / 2 * (Math.sqrt(1 - i ** 2) - 1) + t : e / 2 * (Math.sqrt(1 - (i -= 2) * i) + 1) + t, easeInOutCubic: (i, t, e, s) => (i /= s / 2) < 1 ? e / 2 * i ** 3 + t : e / 2 * ((i - 2) ** 3 + 2) + t, easeInOutElastic: (i, t, e, s) => {
  const r = e;
  let n = 0;
  if (i === 0) return t;
  if ((i /= s / 2) === 2) return t + e;
  n || (n = s * (0.3 * 1.5));
  const { a: o, s: a, p: c, c: l } = Xi(r, e, n, 1.70158);
  return i < 1 ? -0.5 * Mo(o, a, c, i, s) + t : o * Math.pow(2, -10 * (i -= 1)) * Math.sin((i * s - a) * he / c) * 0.5 + l + t;
}, easeInOutExpo: (i, t, e, s) => i === 0 ? t : i === s ? t + e : (i /= s / 2) < 1 ? e / 2 * 2 ** (10 * (i - 1)) + t : e / 2 * -(2 ** (-10 * --i) + 2) + t, easeInOutQuad: (i, t, e, s) => (i /= s / 2) < 1 ? e / 2 * i ** 2 + t : -e / 2 * (--i * (i - 2) - 1) + t, easeInOutQuart: (i, t, e, s) => (i /= s / 2) < 1 ? e / 2 * i ** 4 + t : -e / 2 * ((i -= 2) * i ** 3 - 2) + t, easeInOutQuint: (i, t, e, s) => (i /= s / 2) < 1 ? e / 2 * i ** 5 + t : e / 2 * ((i - 2) ** 5 + 2) + t, easeInOutSine: (i, t, e, s) => -e / 2 * (Math.cos(Math.PI * i / s) - 1) + t, easeInQuad: (i, t, e, s) => e * (i /= s) * i + t, easeInQuart: (i, t, e, s) => e * (i /= s) * i ** 3 + t, easeInQuint: (i, t, e, s) => e * (i / s) ** 5 + t, easeInSine: (i, t, e, s) => -e * Math.cos(i / s * xe) + e + t, easeOutBack: function(i, t, e, s) {
  let r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1.70158;
  return e * ((i = i / s - 1) * i * ((r + 1) * i + r) + 1) + t;
}, easeOutBounce: ln, easeOutCirc: (i, t, e, s) => e * Math.sqrt(1 - (i = i / s - 1) * i) + t, easeOutCubic: (i, t, e, s) => e * ((i / s - 1) ** 3 + 1) + t, easeOutElastic: (i, t, e, s) => {
  const r = e;
  let n = 0;
  if (i === 0) return t;
  if ((i /= s) === 1) return t + e;
  n || (n = 0.3 * s);
  const { a: o, s: a, p: c, c: l } = Xi(r, e, n, 1.70158);
  return o * 2 ** (-10 * i) * Math.sin((i * s - a) * he / c) + l + t;
}, easeOutExpo: (i, t, e, s) => i === s ? t + e : e * -(2 ** (-10 * i / s) + 1) + t, easeOutQuad: (i, t, e, s) => -e * (i /= s) * (i - 2) + t, easeOutQuart: (i, t, e, s) => -e * ((i = i / s - 1) * i ** 3 - 1) + t, easeOutQuint: (i, t, e, s) => e * ((i / s - 1) ** 5 + 1) + t, easeOutSine: (i, t, e, s) => e * Math.sin(i / s * xe) + t });
const Qh = () => !1;
class Nn {
  constructor(t) {
    let { startValue: e, byValue: s, duration: r = 500, delay: n = 0, easing: o = uc, onStart: a = Be, onChange: c = Be, onComplete: l = Be, abort: h = Qh, target: u } = t;
    y(this, "_state", "pending"), y(this, "durationProgress", 0), y(this, "valueProgress", 0), this.tick = this.tick.bind(this), this.duration = r, this.delay = n, this.easing = o, this._onStart = a, this._onChange = c, this._onComplete = l, this._abort = h, this.target = u, this.startValue = e, this.byValue = s, this.value = this.startValue, this.endValue = Object.freeze(this.calculate(this.duration).value);
  }
  get state() {
    return this._state;
  }
  isDone() {
    return this._state === "aborted" || this._state === "completed";
  }
  start() {
    const t = (e) => {
      this._state === "pending" && (this.startTime = e || +/* @__PURE__ */ new Date(), this._state = "running", this._onStart(), this.tick(this.startTime));
    };
    this.register(), this.delay > 0 ? setTimeout(() => Hs(t), this.delay) : Hs(t);
  }
  tick(t) {
    const e = (t || +/* @__PURE__ */ new Date()) - this.startTime, s = Math.min(e, this.duration);
    this.durationProgress = s / this.duration;
    const { value: r, valueProgress: n } = this.calculate(s);
    this.value = Object.freeze(r), this.valueProgress = n, this._state !== "aborted" && (this._abort(this.value, this.valueProgress, this.durationProgress) ? (this._state = "aborted", this.unregister()) : e >= this.duration ? (this.durationProgress = this.valueProgress = 1, this._onChange(this.endValue, this.valueProgress, this.durationProgress), this._state = "completed", this._onComplete(this.endValue, this.valueProgress, this.durationProgress), this.unregister()) : (this._onChange(this.value, this.valueProgress, this.durationProgress), Hs(this.tick)));
  }
  register() {
    qr.push(this);
  }
  unregister() {
    qr.remove(this);
  }
  abort() {
    this._state = "aborted", this.unregister();
  }
}
const tu = ["startValue", "endValue"];
class eu extends Nn {
  constructor(t) {
    let { startValue: e = 0, endValue: s = 100 } = t;
    super(v(v({}, G(t, tu)), {}, { startValue: e, byValue: s - e }));
  }
  calculate(t) {
    const e = this.easing(t, this.startValue, this.byValue, this.duration);
    return { value: e, valueProgress: Math.abs((e - this.startValue) / this.byValue) };
  }
}
const su = ["startValue", "endValue"];
class ru extends Nn {
  constructor(t) {
    let { startValue: e = [0], endValue: s = [100] } = t;
    super(v(v({}, G(t, su)), {}, { startValue: e, byValue: s.map((r, n) => r - e[n]) }));
  }
  calculate(t) {
    const e = this.startValue.map((s, r) => this.easing(t, s, this.byValue[r], this.duration, r));
    return { value: e, valueProgress: Math.abs((e[0] - this.startValue[0]) / this.byValue[0]) };
  }
}
const iu = ["startValue", "endValue", "easing", "onChange", "onComplete", "abort"], nu = (i, t, e, s) => t + e * (1 - Math.cos(i / s * xe)), zi = (i) => i && ((t, e, s) => i(new W(t).toRgba(), e, s));
class ou extends Nn {
  constructor(t) {
    let { startValue: e, endValue: s, easing: r = nu, onChange: n, onComplete: o, abort: a } = t, c = G(t, iu);
    const l = new W(e).getSource(), h = new W(s).getSource();
    super(v(v({}, c), {}, { startValue: l, byValue: h.map((u, d) => u - l[d]), easing: r, onChange: zi(n), onComplete: zi(o), abort: zi(a) }));
  }
  calculate(t) {
    const [e, s, r, n] = this.startValue.map((a, c) => this.easing(t, a, this.byValue[c], this.duration, c)), o = [...[e, s, r].map(Math.round), ze(0, n, 1)];
    return { value: o, valueProgress: o.map((a, c) => this.byValue[c] !== 0 ? Math.abs((a - this.startValue[c]) / this.byValue[c]) : 0).find((a) => a !== 0) || 0 };
  }
}
function Un(i) {
  const t = ((e) => Array.isArray(e.startValue) || Array.isArray(e.endValue))(i) ? new ru(i) : new eu(i);
  return t.start(), t;
}
function dc(i) {
  const t = new ou(i);
  return t.start(), t;
}
class N {
  constructor(t) {
    this.status = t, this.points = [];
  }
  includes(t) {
    return this.points.some((e) => e.eq(t));
  }
  append() {
    for (var t = arguments.length, e = new Array(t), s = 0; s < t; s++) e[s] = arguments[s];
    return this.points = this.points.concat(e.filter((r) => !this.includes(r))), this;
  }
  static isPointContained(t, e, s) {
    let r = arguments.length > 3 && arguments[3] !== void 0 && arguments[3];
    if (e.eq(s)) return t.eq(e);
    if (e.x === s.x) return t.x === e.x && (r || t.y >= Math.min(e.y, s.y) && t.y <= Math.max(e.y, s.y));
    if (e.y === s.y) return t.y === e.y && (r || t.x >= Math.min(e.x, s.x) && t.x <= Math.max(e.x, s.x));
    {
      const n = Zr(e, s), o = Zr(e, t).divide(n);
      return r ? Math.abs(o.x) === Math.abs(o.y) : o.x === o.y && o.x >= 0 && o.x <= 1;
    }
  }
  static isPointInPolygon(t, e) {
    const s = new _(t).setX(Math.min(t.x - 1, ...e.map((n) => n.x)));
    let r = 0;
    for (let n = 0; n < e.length; n++) {
      const o = this.intersectSegmentSegment(e[n], e[(n + 1) % e.length], t, s);
      if (o.includes(t)) return !0;
      r += +(o.status === "Intersection");
    }
    return r % 2 == 1;
  }
  static intersectLineLine(t, e, s, r) {
    let n = !(arguments.length > 4 && arguments[4] !== void 0) || arguments[4], o = !(arguments.length > 5 && arguments[5] !== void 0) || arguments[5];
    const a = e.x - t.x, c = e.y - t.y, l = r.x - s.x, h = r.y - s.y, u = t.x - s.x, d = t.y - s.y, f = l * d - h * u, g = a * d - c * u, p = h * a - l * c;
    if (p !== 0) {
      const m = f / p, b = g / p;
      return (n || 0 <= m && m <= 1) && (o || 0 <= b && b <= 1) ? new N("Intersection").append(new _(t.x + m * a, t.y + m * c)) : new N();
    }
    if (f === 0 || g === 0) {
      const m = n || o || N.isPointContained(t, s, r) || N.isPointContained(e, s, r) || N.isPointContained(s, t, e) || N.isPointContained(r, t, e);
      return new N(m ? "Coincident" : void 0);
    }
    return new N("Parallel");
  }
  static intersectSegmentLine(t, e, s, r) {
    return N.intersectLineLine(t, e, s, r, !1, !0);
  }
  static intersectSegmentSegment(t, e, s, r) {
    return N.intersectLineLine(t, e, s, r, !1, !1);
  }
  static intersectLinePolygon(t, e, s) {
    let r = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3];
    const n = new N(), o = s.length;
    for (let a, c, l, h = 0; h < o; h++) {
      if (a = s[h], c = s[(h + 1) % o], l = N.intersectLineLine(t, e, a, c, r, !1), l.status === "Coincident") return l;
      n.append(...l.points);
    }
    return n.points.length > 0 && (n.status = "Intersection"), n;
  }
  static intersectSegmentPolygon(t, e, s) {
    return N.intersectLinePolygon(t, e, s, !1);
  }
  static intersectPolygonPolygon(t, e) {
    const s = new N(), r = t.length, n = [];
    for (let o = 0; o < r; o++) {
      const a = t[o], c = t[(o + 1) % r], l = N.intersectSegmentPolygon(a, c, e);
      l.status === "Coincident" ? (n.push(l), s.append(a, c)) : s.append(...l.points);
    }
    return n.length > 0 && n.length === t.length ? new N("Coincident") : (s.points.length > 0 && (s.status = "Intersection"), s);
  }
  static intersectPolygonRectangle(t, e, s) {
    const r = e.min(s), n = e.max(s), o = new _(n.x, r.y), a = new _(r.x, n.y);
    return N.intersectPolygonPolygon(t, [r, o, n, a]);
  }
}
class au extends Ha {
  getX() {
    return this.getXY().x;
  }
  setX(t) {
    this.setXY(this.getXY().setX(t));
  }
  getY() {
    return this.getXY().y;
  }
  setY(t) {
    this.setXY(this.getXY().setY(t));
  }
  getRelativeX() {
    return this.left;
  }
  setRelativeX(t) {
    this.left = t;
  }
  getRelativeY() {
    return this.top;
  }
  setRelativeY(t) {
    this.top = t;
  }
  getXY() {
    const t = this.getRelativeXY();
    return this.group ? ot(t, this.group.calcTransformMatrix()) : t;
  }
  setXY(t, e, s) {
    this.group && (t = ot(t, St(this.group.calcTransformMatrix()))), this.setRelativeXY(t, e, s);
  }
  getRelativeXY() {
    return new _(this.left, this.top);
  }
  setRelativeXY(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.originX, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.originY;
    this.setPositionByOrigin(t, e, s);
  }
  isStrokeAccountedForInDimensions() {
    return !1;
  }
  getCoords() {
    const { tl: t, tr: e, br: s, bl: r } = this.aCoords || (this.aCoords = this.calcACoords()), n = [t, e, s, r];
    if (this.group) {
      const o = this.group.calcTransformMatrix();
      return n.map((a) => ot(a, o));
    }
    return n;
  }
  intersectsWithRect(t, e) {
    return N.intersectPolygonRectangle(this.getCoords(), t, e).status === "Intersection";
  }
  intersectsWithObject(t) {
    const e = N.intersectPolygonPolygon(this.getCoords(), t.getCoords());
    return e.status === "Intersection" || e.status === "Coincident" || t.isContainedWithinObject(this) || this.isContainedWithinObject(t);
  }
  isContainedWithinObject(t) {
    return this.getCoords().every((e) => t.containsPoint(e));
  }
  isContainedWithinRect(t, e) {
    const { left: s, top: r, width: n, height: o } = this.getBoundingRect();
    return s >= t.x && s + n <= e.x && r >= t.y && r + o <= e.y;
  }
  isOverlapping(t) {
    return this.intersectsWithObject(t) || this.isContainedWithinObject(t) || t.isContainedWithinObject(this);
  }
  containsPoint(t) {
    return N.isPointInPolygon(t, this.getCoords());
  }
  isOnScreen() {
    if (!this.canvas) return !1;
    const { tl: t, br: e } = this.canvas.vptCoords;
    return !!this.getCoords().some((s) => s.x <= e.x && s.x >= t.x && s.y <= e.y && s.y >= t.y) || !!this.intersectsWithRect(t, e) || this.containsPoint(t.midPointFrom(e));
  }
  isPartiallyOnScreen() {
    if (!this.canvas) return !1;
    const { tl: t, br: e } = this.canvas.vptCoords;
    return this.intersectsWithRect(t, e) ? !0 : this.getCoords().every((s) => (s.x >= e.x || s.x <= t.x) && (s.y >= e.y || s.y <= t.y)) && this.containsPoint(t.midPointFrom(e));
  }
  getBoundingRect() {
    return Gt(this.getCoords());
  }
  getScaledWidth() {
    return this._getTransformedDimensions().x;
  }
  getScaledHeight() {
    return this._getTransformedDimensions().y;
  }
  scale(t) {
    this._set(ut, t), this._set(Tt, t), this.setCoords();
  }
  scaleToWidth(t) {
    const e = this.getBoundingRect().width / this.getScaledWidth();
    return this.scale(t / this.width / e);
  }
  scaleToHeight(t) {
    const e = this.getBoundingRect().height / this.getScaledHeight();
    return this.scale(t / this.height / e);
  }
  getCanvasRetinaScaling() {
    var t;
    return ((t = this.canvas) === null || t === void 0 ? void 0 : t.getRetinaScaling()) || 1;
  }
  getTotalAngle() {
    return this.group ? Ce(Na(this.calcTransformMatrix())) : this.angle;
  }
  getViewportTransform() {
    var t;
    return ((t = this.canvas) === null || t === void 0 ? void 0 : t.viewportTransform) || ht.concat();
  }
  calcACoords() {
    const t = Is({ angle: this.angle }), { x: e, y: s } = this.getRelativeCenterPoint(), r = Ms(e, s), n = J(r, t), o = this._getTransformedDimensions(), a = o.x / 2, c = o.y / 2;
    return { tl: ot({ x: -a, y: -c }, n), tr: ot({ x: a, y: -c }, n), bl: ot({ x: -a, y: c }, n), br: ot({ x: a, y: c }, n) };
  }
  setCoords() {
    this.aCoords = this.calcACoords();
  }
  transformMatrixKey() {
    let t = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], e = [];
    return !t && this.group && (e = this.group.transformMatrixKey(t)), e.push(this.top, this.left, this.width, this.height, this.scaleX, this.scaleY, this.angle, this.strokeWidth, this.skewX, this.skewY, +this.flipX, +this.flipY, st(this.originX), st(this.originY)), e;
  }
  calcTransformMatrix() {
    let t = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], e = this.calcOwnMatrix();
    if (t || !this.group) return e;
    const s = this.transformMatrixKey(t), r = this.matrixCache;
    return r && r.key.every((n, o) => n === s[o]) ? r.value : (this.group && (e = J(this.group.calcTransformMatrix(!1), e)), this.matrixCache = { key: s, value: e }, e);
  }
  calcOwnMatrix() {
    const t = this.transformMatrixKey(!0), e = this.ownMatrixCache;
    if (e && e.key === t) return e.value;
    const s = this.getRelativeCenterPoint(), r = { angle: this.angle, translateX: s.x, translateY: s.y, scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, flipX: this.flipX, flipY: this.flipY }, n = $a(r);
    return this.ownMatrixCache = { key: t, value: n }, n;
  }
  _getNonTransformedDimensions() {
    return new _(this.width, this.height).scalarAdd(this.strokeWidth);
  }
  _calculateCurrentDimensions(t) {
    return this._getTransformedDimensions(t).transform(this.getViewportTransform(), !0).scalarAdd(2 * this.padding);
  }
  _getTransformedDimensions() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const e = v({ scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, width: this.width, height: this.height, strokeWidth: this.strokeWidth }, t), s = e.strokeWidth;
    let r = s, n = 0;
    this.strokeUniform && (r = 0, n = s);
    const o = e.width + r, a = e.height + r;
    let c;
    return c = e.skewX === 0 && e.skewY === 0 ? new _(o * e.scaleX, a * e.scaleY) : yi(o, a, ar(e)), c.scalarAdd(n);
  }
  translateToGivenOrigin(t, e, s, r, n) {
    let o = t.x, a = t.y;
    const c = st(r) - st(e), l = st(n) - st(s);
    if (c || l) {
      const h = this._getTransformedDimensions();
      o += c * h.x, a += l * h.y;
    }
    return new _(o, a);
  }
  translateToCenterPoint(t, e, s) {
    if (e === j && s === j) return t;
    const r = this.translateToGivenOrigin(t, e, s, j, j);
    return this.angle ? r.rotate(K(this.angle), t) : r;
  }
  translateToOriginPoint(t, e, s) {
    const r = this.translateToGivenOrigin(t, j, j, e, s);
    return this.angle ? r.rotate(K(this.angle), t) : r;
  }
  getCenterPoint() {
    const t = this.getRelativeCenterPoint();
    return this.group ? ot(t, this.group.calcTransformMatrix()) : t;
  }
  getRelativeCenterPoint() {
    return this.translateToCenterPoint(new _(this.left, this.top), this.originX, this.originY);
  }
  getPointByOrigin(t, e) {
    return this.translateToOriginPoint(this.getRelativeCenterPoint(), t, e);
  }
  setPositionByOrigin(t, e, s) {
    const r = this.translateToCenterPoint(t, e, s), n = this.translateToOriginPoint(r, this.originX, this.originY);
    this.set({ left: n.x, top: n.y });
  }
  _getLeftTopCoords() {
    return this.translateToOriginPoint(this.getRelativeCenterPoint(), L, gt);
  }
}
const cu = ["type"], lu = ["extraParam"];
let ee = class Gr extends au {
  static getDefaults() {
    return Gr.ownDefaults;
  }
  get type() {
    const t = this.constructor.type;
    return t === "FabricObject" ? "object" : t.toLowerCase();
  }
  set type(t) {
    Te("warn", "Setting type has no effect", t);
  }
  constructor(t) {
    super(), y(this, "_cacheContext", null), Object.assign(this, Gr.ownDefaults), this.setOptions(t);
  }
  _createCacheCanvas() {
    this._cacheCanvas = kt(), this._cacheContext = this._cacheCanvas.getContext("2d"), this._updateCacheCanvas(), this.dirty = !0;
  }
  _limitCacheSize(t) {
    const e = t.width, s = t.height, r = A.maxCacheSideLimit, n = A.minCacheSideLimit;
    if (e <= r && s <= r && e * s <= A.perfLimitSizeTotal) return e < n && (t.width = n), s < n && (t.height = n), t;
    const o = e / s, [a, c] = zs.limitDimsByArea(o), l = ze(n, a, r), h = ze(n, c, r);
    return e > l && (t.zoomX /= e / l, t.width = l, t.capped = !0), s > h && (t.zoomY /= s / h, t.height = h, t.capped = !0), t;
  }
  _getCacheCanvasDimensions() {
    const t = this.getTotalObjectScaling(), e = this._getTransformedDimensions({ skewX: 0, skewY: 0 }), s = e.x * t.x / this.scaleX, r = e.y * t.y / this.scaleY;
    return { width: Math.ceil(s + 2), height: Math.ceil(r + 2), zoomX: t.x, zoomY: t.y, x: s, y: r };
  }
  _updateCacheCanvas() {
    const t = this._cacheCanvas, e = this._cacheContext, { width: s, height: r, zoomX: n, zoomY: o, x: a, y: c } = this._limitCacheSize(this._getCacheCanvasDimensions()), l = s !== t.width || r !== t.height, h = this.zoomX !== n || this.zoomY !== o;
    if (!t || !e) return !1;
    if (l || h) {
      s !== t.width || r !== t.height ? (t.width = s, t.height = r) : (e.setTransform(1, 0, 0, 1, 0, 0), e.clearRect(0, 0, t.width, t.height));
      const u = a / 2, d = c / 2;
      return this.cacheTranslationX = Math.round(t.width / 2 - u) + u, this.cacheTranslationY = Math.round(t.height / 2 - d) + d, e.translate(this.cacheTranslationX, this.cacheTranslationY), e.scale(n, o), this.zoomX = n, this.zoomY = o, !0;
    }
    return !1;
  }
  setOptions() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this._setOptions(t);
  }
  transform(t) {
    const e = this.group && !this.group._transformDone || this.group && this.canvas && t === this.canvas.contextTop, s = this.calcTransformMatrix(!e);
    t.transform(s[0], s[1], s[2], s[3], s[4], s[5]);
  }
  getObjectScaling() {
    if (!this.group) return new _(Math.abs(this.scaleX), Math.abs(this.scaleY));
    const t = ys(this.calcTransformMatrix());
    return new _(Math.abs(t.scaleX), Math.abs(t.scaleY));
  }
  getTotalObjectScaling() {
    const t = this.getObjectScaling();
    if (this.canvas) {
      const e = this.canvas.getZoom(), s = this.getCanvasRetinaScaling();
      return t.scalarMultiply(e * s);
    }
    return t;
  }
  getObjectOpacity() {
    let t = this.opacity;
    return this.group && (t *= this.group.getObjectOpacity()), t;
  }
  _constrainScale(t) {
    return Math.abs(t) < this.minScaleLimit ? t < 0 ? -this.minScaleLimit : this.minScaleLimit : t === 0 ? 1e-4 : t;
  }
  _set(t, e) {
    t !== ut && t !== Tt || (e = this._constrainScale(e)), t === ut && e < 0 ? (this.flipX = !this.flipX, e *= -1) : t === "scaleY" && e < 0 ? (this.flipY = !this.flipY, e *= -1) : t !== "shadow" || !e || e instanceof ce || (e = new ce(e));
    const s = this[t] !== e;
    return this[t] = e, s && this.constructor.cacheProperties.includes(t) && (this.dirty = !0), this.parent && (this.dirty || s && this.constructor.stateProperties.includes(t)) && this.parent._set("dirty", !0), this;
  }
  isNotVisible() {
    return this.opacity === 0 || !this.width && !this.height && this.strokeWidth === 0 || !this.visible;
  }
  render(t) {
    this.isNotVisible() || this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (t.save(), this._setupCompositeOperation(t), this.drawSelectionBackground(t), this.transform(t), this._setOpacity(t), this._setShadow(t), this.shouldCache() ? (this.renderCache(), this.drawCacheOnCanvas(t)) : (this._removeCacheCanvas(), this.drawObject(t, !1, {}), this.dirty = !1), t.restore());
  }
  drawSelectionBackground(t) {
  }
  renderCache(t) {
    if (t = t || {}, this._cacheCanvas && this._cacheContext || this._createCacheCanvas(), this.isCacheDirty() && this._cacheContext) {
      const { zoomX: e, zoomY: s, cacheTranslationX: r, cacheTranslationY: n } = this, { width: o, height: a } = this._cacheCanvas;
      this.drawObject(this._cacheContext, t.forClipping, { zoomX: e, zoomY: s, cacheTranslationX: r, cacheTranslationY: n, width: o, height: a, parentClipPaths: [] }), this.dirty = !1;
    }
  }
  _removeCacheCanvas() {
    this._cacheCanvas = void 0, this._cacheContext = null;
  }
  hasStroke() {
    return this.stroke && this.stroke !== "transparent" && this.strokeWidth !== 0;
  }
  hasFill() {
    return this.fill && this.fill !== "transparent";
  }
  needsItsOwnCache() {
    return !!(this.paintFirst === mt && this.hasFill() && this.hasStroke() && this.shadow) || !!this.clipPath;
  }
  shouldCache() {
    return this.ownCaching = this.objectCaching && (!this.parent || !this.parent.isOnACache()) || this.needsItsOwnCache(), this.ownCaching;
  }
  willDrawShadow() {
    return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0);
  }
  drawClipPathOnCache(t, e, s) {
    t.save(), e.inverted ? t.globalCompositeOperation = "destination-out" : t.globalCompositeOperation = "destination-in", t.setTransform(1, 0, 0, 1, 0, 0), t.drawImage(s, 0, 0), t.restore();
  }
  drawObject(t, e, s) {
    const r = this.fill, n = this.stroke;
    e ? (this.fill = "black", this.stroke = "", this._setClippingProperties(t)) : this._renderBackground(t), this._render(t), this._drawClipPath(t, this.clipPath, s), this.fill = r, this.stroke = n;
  }
  createClipPathLayer(t, e) {
    const s = Wt(e), r = s.getContext("2d");
    if (r.translate(e.cacheTranslationX, e.cacheTranslationY), r.scale(e.zoomX, e.zoomY), t._cacheCanvas = s, e.parentClipPaths.forEach((n) => {
      n.transform(r);
    }), e.parentClipPaths.push(t), t.absolutePositioned) {
      const n = St(this.calcTransformMatrix());
      r.transform(n[0], n[1], n[2], n[3], n[4], n[5]);
    }
    return t.transform(r), t.drawObject(r, !0, e), s;
  }
  _drawClipPath(t, e, s) {
    if (!e) return;
    e._transformDone = !0;
    const r = this.createClipPathLayer(e, s);
    this.drawClipPathOnCache(t, e, r);
  }
  drawCacheOnCanvas(t) {
    t.scale(1 / this.zoomX, 1 / this.zoomY), t.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);
  }
  isCacheDirty() {
    let t = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
    if (this.isNotVisible()) return !1;
    const e = this._cacheCanvas, s = this._cacheContext;
    return !(!e || !s || t || !this._updateCacheCanvas()) || !!(this.dirty || this.clipPath && this.clipPath.absolutePositioned) && (e && s && !t && (s.save(), s.setTransform(1, 0, 0, 1, 0, 0), s.clearRect(0, 0, e.width, e.height), s.restore()), !0);
  }
  _renderBackground(t) {
    if (!this.backgroundColor) return;
    const e = this._getNonTransformedDimensions();
    t.fillStyle = this.backgroundColor, t.fillRect(-e.x / 2, -e.y / 2, e.x, e.y), this._removeShadow(t);
  }
  _setOpacity(t) {
    this.group && !this.group._transformDone ? t.globalAlpha = this.getObjectOpacity() : t.globalAlpha *= this.opacity;
  }
  _setStrokeStyles(t, e) {
    const s = e.stroke;
    s && (t.lineWidth = e.strokeWidth, t.lineCap = e.strokeLineCap, t.lineDashOffset = e.strokeDashOffset, t.lineJoin = e.strokeLineJoin, t.miterLimit = e.strokeMiterLimit, Ct(s) ? s.gradientUnits === "percentage" || s.gradientTransform || s.patternTransform ? this._applyPatternForTransformedGradient(t, s) : (t.strokeStyle = s.toLive(t), this._applyPatternGradientTransform(t, s)) : t.strokeStyle = e.stroke);
  }
  _setFillStyles(t, e) {
    let { fill: s } = e;
    s && (Ct(s) ? (t.fillStyle = s.toLive(t), this._applyPatternGradientTransform(t, s)) : t.fillStyle = s);
  }
  _setClippingProperties(t) {
    t.globalAlpha = 1, t.strokeStyle = "transparent", t.fillStyle = "#000000";
  }
  _setLineDash(t, e) {
    e && e.length !== 0 && t.setLineDash(e);
  }
  _setShadow(t) {
    if (!this.shadow) return;
    const e = this.shadow, s = this.canvas, r = this.getCanvasRetinaScaling(), [n, , , o] = (s == null ? void 0 : s.viewportTransform) || ht, a = n * r, c = o * r, l = e.nonScaling ? new _(1, 1) : this.getObjectScaling();
    t.shadowColor = e.color, t.shadowBlur = e.blur * A.browserShadowBlurConstant * (a + c) * (l.x + l.y) / 4, t.shadowOffsetX = e.offsetX * a * l.x, t.shadowOffsetY = e.offsetY * c * l.y;
  }
  _removeShadow(t) {
    this.shadow && (t.shadowColor = "", t.shadowBlur = t.shadowOffsetX = t.shadowOffsetY = 0);
  }
  _applyPatternGradientTransform(t, e) {
    if (!Ct(e)) return { offsetX: 0, offsetY: 0 };
    const s = e.gradientTransform || e.patternTransform, r = -this.width / 2 + e.offsetX || 0, n = -this.height / 2 + e.offsetY || 0;
    return e.gradientUnits === "percentage" ? t.transform(this.width, 0, 0, this.height, r, n) : t.transform(1, 0, 0, 1, r, n), s && t.transform(s[0], s[1], s[2], s[3], s[4], s[5]), { offsetX: r, offsetY: n };
  }
  _renderPaintInOrder(t) {
    this.paintFirst === mt ? (this._renderStroke(t), this._renderFill(t)) : (this._renderFill(t), this._renderStroke(t));
  }
  _render(t) {
  }
  _renderFill(t) {
    this.fill && (t.save(), this._setFillStyles(t, this), this.fillRule === "evenodd" ? t.fill("evenodd") : t.fill(), t.restore());
  }
  _renderStroke(t) {
    if (this.stroke && this.strokeWidth !== 0) {
      if (this.shadow && !this.shadow.affectStroke && this._removeShadow(t), t.save(), this.strokeUniform) {
        const e = this.getObjectScaling();
        t.scale(1 / e.x, 1 / e.y);
      }
      this._setLineDash(t, this.strokeDashArray), this._setStrokeStyles(t, this), t.stroke(), t.restore();
    }
  }
  _applyPatternForTransformedGradient(t, e) {
    var s;
    const r = this._limitCacheSize(this._getCacheCanvasDimensions()), n = this.getCanvasRetinaScaling(), o = r.x / this.scaleX / n, a = r.y / this.scaleY / n, c = Wt({ width: Math.ceil(o), height: Math.ceil(a) }), l = c.getContext("2d");
    l && (l.beginPath(), l.moveTo(0, 0), l.lineTo(o, 0), l.lineTo(o, a), l.lineTo(0, a), l.closePath(), l.translate(o / 2, a / 2), l.scale(r.zoomX / this.scaleX / n, r.zoomY / this.scaleY / n), this._applyPatternGradientTransform(l, e), l.fillStyle = e.toLive(t), l.fill(), t.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2), t.scale(n * this.scaleX / r.zoomX, n * this.scaleY / r.zoomY), t.strokeStyle = (s = l.createPattern(c, "no-repeat")) !== null && s !== void 0 ? s : "");
  }
  _findCenterFromElement() {
    return new _(this.left + this.width / 2, this.top + this.height / 2);
  }
  clone(t) {
    const e = this.toObject(t);
    return this.constructor.fromObject(e);
  }
  cloneAsImage(t) {
    const e = this.toCanvasElement(t);
    return new (C.getClass("image"))(e);
  }
  toCanvasElement() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const e = zn(this), s = this.group, r = this.shadow, n = Math.abs, o = t.enableRetinaScaling ? Ra() : 1, a = (t.multiplier || 1) * o, c = t.canvasProvider || ((S) => new lr(S, { enableRetinaScaling: !1, renderOnAddRemove: !1, skipOffscreen: !1 }));
    delete this.group, t.withoutTransform && sc(this), t.withoutShadow && (this.shadow = null), t.viewportTransform && an(this, this.getViewportTransform()), this.setCoords();
    const l = kt(), h = this.getBoundingRect(), u = this.shadow, d = new _();
    if (u) {
      const S = u.blur, w = u.nonScaling ? new _(1, 1) : this.getObjectScaling();
      d.x = 2 * Math.round(n(u.offsetX) + S) * n(w.x), d.y = 2 * Math.round(n(u.offsetY) + S) * n(w.y);
    }
    const f = h.width + d.x, g = h.height + d.y;
    l.width = Math.ceil(f), l.height = Math.ceil(g);
    const p = c(l);
    t.format === "jpeg" && (p.backgroundColor = "#fff"), this.setPositionByOrigin(new _(p.width / 2, p.height / 2), j, j);
    const m = this.canvas;
    p._objects = [this], this.set("canvas", p), this.setCoords();
    const b = p.toCanvasElement(a || 1, t);
    return this.set("canvas", m), this.shadow = r, s && (this.group = s), this.set(e), this.setCoords(), p._objects = [], p.destroy(), b;
  }
  toDataURL() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return Rn(this.toCanvasElement(t), t.format || "png", t.quality || 1);
  }
  toBlob() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return Ln(this.toCanvasElement(t), t.format || "png", t.quality || 1);
  }
  isType() {
    for (var t = arguments.length, e = new Array(t), s = 0; s < t; s++) e[s] = arguments[s];
    return e.includes(this.constructor.type) || e.includes(this.type);
  }
  complexity() {
    return 1;
  }
  toJSON() {
    return this.toObject();
  }
  rotate(t) {
    const { centeredRotation: e, originX: s, originY: r } = this;
    if (e) {
      const { x: n, y: o } = this.getRelativeCenterPoint();
      this.originX = j, this.originY = j, this.left = n, this.top = o;
    }
    if (this.set("angle", t), e) {
      const { x: n, y: o } = this.translateToOriginPoint(this.getRelativeCenterPoint(), s, r);
      this.left = n, this.top = o, this.originX = s, this.originY = r;
    }
  }
  setOnGroup() {
  }
  _setupCompositeOperation(t) {
    this.globalCompositeOperation && (t.globalCompositeOperation = this.globalCompositeOperation);
  }
  dispose() {
    qr.cancelByTarget(this), this.off(), this._set("canvas", void 0), this._cacheCanvas && $t().dispose(this._cacheCanvas), this._cacheCanvas = void 0, this._cacheContext = null;
  }
  animate(t, e) {
    return Object.entries(t).reduce((s, r) => {
      let [n, o] = r;
      return s[n] = this._animate(n, o, e), s;
    }, {});
  }
  _animate(t, e) {
    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const r = t.split("."), n = this.constructor.colorProperties.includes(r[r.length - 1]), { abort: o, startValue: a, onChange: c, onComplete: l } = s, h = v(v({}, s), {}, { target: this, startValue: a ?? r.reduce((u, d) => u[d], this), endValue: e, abort: o == null ? void 0 : o.bind(this), onChange: (u, d, f) => {
      r.reduce((g, p, m) => (m === r.length - 1 && (g[p] = u), g[p]), this), c && c(u, d, f);
    }, onComplete: (u, d, f) => {
      this.setCoords(), l && l(u, d, f);
    } });
    return n ? dc(h) : Un(h);
  }
  isDescendantOf(t) {
    const { parent: e, group: s } = this;
    return e === t || s === t || !!e && e.isDescendantOf(t) || !!s && s !== e && s.isDescendantOf(t);
  }
  getAncestors() {
    const t = [];
    let e = this;
    do
      e = e.parent, e && t.push(e);
    while (e);
    return t;
  }
  findCommonAncestors(t) {
    if (this === t) return { fork: [], otherFork: [], common: [this, ...this.getAncestors()] };
    const e = this.getAncestors(), s = t.getAncestors();
    if (e.length === 0 && s.length > 0 && this === s[s.length - 1]) return { fork: [], otherFork: [t, ...s.slice(0, s.length - 1)], common: [this] };
    for (let r, n = 0; n < e.length; n++) {
      if (r = e[n], r === t) return { fork: [this, ...e.slice(0, n)], otherFork: [], common: e.slice(n) };
      for (let o = 0; o < s.length; o++) {
        if (this === s[o]) return { fork: [], otherFork: [t, ...s.slice(0, o)], common: [this, ...e] };
        if (r === s[o]) return { fork: [this, ...e.slice(0, n)], otherFork: [t, ...s.slice(0, o)], common: e.slice(n) };
      }
    }
    return { fork: [this, ...e], otherFork: [t, ...s], common: [] };
  }
  hasCommonAncestors(t) {
    const e = this.findCommonAncestors(t);
    return e && !!e.common.length;
  }
  isInFrontOf(t) {
    if (this === t) return;
    const e = this.findCommonAncestors(t);
    if (e.fork.includes(t)) return !0;
    if (e.otherFork.includes(this)) return !1;
    const s = e.common[0] || this.canvas;
    if (!s) return;
    const r = e.fork.pop(), n = e.otherFork.pop(), o = s._objects.indexOf(r), a = s._objects.indexOf(n);
    return o > -1 && o > a;
  }
  toObject() {
    const t = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).concat(Gr.customProperties, this.constructor.customProperties || []);
    let e;
    const s = A.NUM_FRACTION_DIGITS, { clipPath: r, fill: n, stroke: o, shadow: a, strokeDashArray: c, left: l, top: h, originX: u, originY: d, width: f, height: g, strokeWidth: p, strokeLineCap: m, strokeDashOffset: b, strokeLineJoin: S, strokeUniform: w, strokeMiterLimit: k, scaleX: O, scaleY: x, angle: I, flipX: M, flipY: E, opacity: R, visible: tt, backgroundColor: F, fillRule: B, paintFirst: $, globalCompositeOperation: yt, skewX: dt, skewY: Dt } = this;
    r && !r.excludeFromExport && (e = r.toObject(t.concat("inverted", "absolutePositioned")));
    const q = (te) => V(te, s), zt = v(v({}, Ve(this, t)), {}, { type: this.constructor.type, version: sn, originX: u, originY: d, left: q(l), top: q(h), width: q(f), height: q(g), fill: _o(n) ? n.toObject() : n, stroke: _o(o) ? o.toObject() : o, strokeWidth: q(p), strokeDashArray: c && c.concat(), strokeLineCap: m, strokeDashOffset: b, strokeLineJoin: S, strokeUniform: w, strokeMiterLimit: q(k), scaleX: q(O), scaleY: q(x), angle: q(I), flipX: M, flipY: E, opacity: q(R), shadow: a && a.toObject(), visible: tt, backgroundColor: F, fillRule: B, paintFirst: $, globalCompositeOperation: yt, skewX: q(dt), skewY: q(Dt) }, e ? { clipPath: e } : null);
    return this.includeDefaultValues ? zt : this._removeDefaultValues(zt);
  }
  toDatalessObject(t) {
    return this.toObject(t);
  }
  _removeDefaultValues(t) {
    const e = this.constructor.getDefaults(), s = Object.keys(e).length > 0 ? e : Object.getPrototypeOf(this);
    return Xn(t, (r, n) => {
      if (n === L || n === gt || n === "type") return !0;
      const o = s[n];
      return r !== o && !(Array.isArray(r) && Array.isArray(o) && r.length === 0 && o.length === 0);
    });
  }
  toString() {
    return "#<".concat(this.constructor.type, ">");
  }
  static _fromObject(t) {
    let e = G(t, cu), s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, { extraParam: r } = s, n = G(s, lu);
    return cr(e, n).then((o) => r ? (delete o[r], new this(e[r], o)) : new this(o));
  }
  static fromObject(t, e) {
    return this._fromObject(t, e);
  }
};
y(ee, "stateProperties", Kh), y(ee, "cacheProperties", de), y(ee, "ownDefaults", Jh), y(ee, "type", "FabricObject"), y(ee, "colorProperties", [rt, mt, "backgroundColor"]), y(ee, "customProperties", []), C.setClass(ee), C.setClass(ee, "object");
const Ie = (i, t, e) => (s, r, n, o) => {
  const a = t(s, r, n, o);
  return a && Hn(i, v(v({}, Yn(s, r, n, o)), e)), a;
};
function Ge(i) {
  return (t, e, s, r) => {
    const { target: n, originX: o, originY: a } = e, c = n.getRelativeCenterPoint(), l = n.translateToOriginPoint(c, o, a), h = i(t, e, s, r);
    return n.setPositionByOrigin(l, e.originX, e.originY), h;
  };
}
const hn = Ie($s, Ge((i, t, e, s) => {
  const r = bi(t, t.originX, t.originY, e, s);
  if (st(t.originX) === st(j) || st(t.originX) === st(Z) && r.x < 0 || st(t.originX) === st(L) && r.x > 0) {
    const { target: n } = t, o = n.strokeWidth / (n.strokeUniform ? n.scaleX : 1), a = ic(t) ? 2 : 1, c = n.width, l = Math.abs(r.x * a / n.scaleX) - o;
    return n.set("width", Math.max(l, 1)), c !== n.width;
  }
  return !1;
}));
function fc(i, t, e, s, r) {
  s = s || {};
  const n = this.sizeX || s.cornerSize || r.cornerSize, o = this.sizeY || s.cornerSize || r.cornerSize, a = s.transparentCorners !== void 0 ? s.transparentCorners : r.transparentCorners, c = a ? mt : rt, l = !a && (s.cornerStrokeColor || r.cornerStrokeColor);
  let h, u = t, d = e;
  i.save(), i.fillStyle = s.cornerColor || r.cornerColor || "", i.strokeStyle = s.cornerStrokeColor || r.cornerStrokeColor || "", n > o ? (h = n, i.scale(1, o / n), d = e * n / o) : o > n ? (h = o, i.scale(n / o, 1), u = t * o / n) : h = n, i.beginPath(), i.arc(u, d, h / 2, 0, he, !1), i[c](), l && i.stroke(), i.restore();
}
function gc(i, t, e, s, r) {
  s = s || {};
  const n = this.sizeX || s.cornerSize || r.cornerSize, o = this.sizeY || s.cornerSize || r.cornerSize, a = s.transparentCorners !== void 0 ? s.transparentCorners : r.transparentCorners, c = a ? mt : rt, l = !a && (s.cornerStrokeColor || r.cornerStrokeColor), h = n / 2, u = o / 2;
  i.save(), i.fillStyle = s.cornerColor || r.cornerColor || "", i.strokeStyle = s.cornerStrokeColor || r.cornerStrokeColor || "", i.translate(t, e);
  const d = r.getTotalAngle();
  i.rotate(K(d)), i["".concat(c, "Rect")](-h, -u, n, o), l && i.strokeRect(-h, -u, n, o), i.restore();
}
class U {
  constructor(t) {
    y(this, "visible", !0), y(this, "actionName", pi), y(this, "angle", 0), y(this, "x", 0), y(this, "y", 0), y(this, "offsetX", 0), y(this, "offsetY", 0), y(this, "sizeX", 0), y(this, "sizeY", 0), y(this, "touchSizeX", 0), y(this, "touchSizeY", 0), y(this, "cursorStyle", "crosshair"), y(this, "withConnection", !1), Object.assign(this, t);
  }
  shouldActivate(t, e, s, r) {
    var n;
    let { tl: o, tr: a, br: c, bl: l } = r;
    return ((n = e.canvas) === null || n === void 0 ? void 0 : n.getActiveObject()) === e && e.isControlVisible(t) && N.isPointInPolygon(s, [o, a, c, l]);
  }
  getActionHandler(t, e, s) {
    return this.actionHandler;
  }
  getMouseDownHandler(t, e, s) {
    return this.mouseDownHandler;
  }
  getMouseUpHandler(t, e, s) {
    return this.mouseUpHandler;
  }
  cursorStyleHandler(t, e, s) {
    return e.cursorStyle;
  }
  getActionName(t, e, s) {
    return e.actionName;
  }
  getVisibility(t, e) {
    var s, r;
    return (s = (r = t._controlsVisibility) === null || r === void 0 ? void 0 : r[e]) !== null && s !== void 0 ? s : this.visible;
  }
  setVisibility(t, e, s) {
    this.visible = t;
  }
  positionHandler(t, e, s, r) {
    return new _(this.x * t.x + this.offsetX, this.y * t.y + this.offsetY).transform(e);
  }
  calcCornerCoords(t, e, s, r, n, o) {
    const a = mi([Ms(s, r), Is({ angle: t }), vi((n ? this.touchSizeX : this.sizeX) || e, (n ? this.touchSizeY : this.sizeY) || e)]);
    return { tl: new _(-0.5, -0.5).transform(a), tr: new _(0.5, -0.5).transform(a), br: new _(0.5, 0.5).transform(a), bl: new _(-0.5, 0.5).transform(a) };
  }
  render(t, e, s, r, n) {
    ((r = r || {}).cornerStyle || n.cornerStyle) === "circle" ? fc.call(this, t, e, s, r, n) : gc.call(this, t, e, s, r, n);
  }
}
const pc = (i, t, e) => e.lockRotation ? Jr : t.cursorStyle, mc = Ie(Ba, Ge((i, t, e, s) => {
  let { target: r, ex: n, ey: o, theta: a, originX: c, originY: l } = t;
  const h = r.translateToOriginPoint(r.getRelativeCenterPoint(), c, l);
  if (Rt(r, "lockRotation")) return !1;
  const u = Math.atan2(o - h.y, n - h.x), d = Math.atan2(s - h.y, e - h.x);
  let f = Ce(d - u + a);
  if (r.snapAngle && r.snapAngle > 0) {
    const p = r.snapAngle, m = r.snapThreshold || p, b = Math.ceil(f / p) * p, S = Math.floor(f / p) * p;
    Math.abs(f - S) < m ? f = S : Math.abs(f - b) < m && (f = b);
  }
  f < 0 && (f = 360 + f), f %= 360;
  const g = r.angle !== f;
  return r.angle = f, g;
}));
function vc(i, t) {
  const e = t.canvas, s = i[e.uniScaleKey];
  return e.uniformScaling && !s || !e.uniformScaling && s;
}
function yc(i, t, e) {
  const s = Rt(i, "lockScalingX"), r = Rt(i, "lockScalingY");
  if (s && r || !t && (s || r) && e || s && t === "x" || r && t === "y") return !0;
  const { width: n, height: o, strokeWidth: a } = i;
  return n === 0 && a === 0 && t !== "y" || o === 0 && a === 0 && t !== "x";
}
const hu = ["e", "se", "s", "sw", "w", "nw", "n", "ne", "e"], Ze = (i, t, e) => {
  const s = vc(i, e);
  if (yc(e, t.x !== 0 && t.y === 0 ? "x" : t.x === 0 && t.y !== 0 ? "y" : "", s)) return Jr;
  const r = nc(e, t);
  return "".concat(hu[r], "-resize");
};
function $n(i, t, e, s) {
  let r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  const n = t.target, o = r.by, a = vc(i, n);
  let c, l, h, u, d, f;
  if (yc(n, o, a)) return !1;
  if (t.gestureScale) l = t.scaleX * t.gestureScale, h = t.scaleY * t.gestureScale;
  else {
    if (c = bi(t, t.originX, t.originY, e, s), d = o !== "y" ? Math.sign(c.x || t.signX || 1) : 1, f = o !== "x" ? Math.sign(c.y || t.signY || 1) : 1, t.signX || (t.signX = d), t.signY || (t.signY = f), Rt(n, "lockScalingFlip") && (t.signX !== d || t.signY !== f)) return !1;
    if (u = n._getTransformedDimensions(), a && !o) {
      const m = Math.abs(c.x) + Math.abs(c.y), { original: b } = t, S = m / (Math.abs(u.x * b.scaleX / n.scaleX) + Math.abs(u.y * b.scaleY / n.scaleY));
      l = b.scaleX * S, h = b.scaleY * S;
    } else l = Math.abs(c.x * n.scaleX / u.x), h = Math.abs(c.y * n.scaleY / u.y);
    ic(t) && (l *= 2, h *= 2), t.signX !== d && o !== "y" && (t.originX = xo(t.originX), l *= -1, t.signX = d), t.signY !== f && o !== "x" && (t.originY = xo(t.originY), h *= -1, t.signY = f);
  }
  const g = n.scaleX, p = n.scaleY;
  return o ? (o === "x" && n.set(ut, l), o === "y" && n.set(Tt, h)) : (!Rt(n, "lockScalingX") && n.set(ut, l), !Rt(n, "lockScalingY") && n.set(Tt, h)), g !== n.scaleX || p !== n.scaleY;
}
const Ls = Ie(gi, Ge((i, t, e, s) => $n(i, t, e, s))), bc = Ie(gi, Ge((i, t, e, s) => $n(i, t, e, s, { by: "x" }))), _c = Ie(gi, Ge((i, t, e, s) => $n(i, t, e, s, { by: "y" }))), uu = ["target", "ex", "ey", "skewingSide"], Hi = { x: { counterAxis: "y", scale: ut, skew: Os, lockSkewing: "lockSkewingX", origin: "originX", flip: "flipX" }, y: { counterAxis: "x", scale: Tt, skew: ks, lockSkewing: "lockSkewingY", origin: "originY", flip: "flipY" } }, du = ["ns", "nesw", "ew", "nwse"], Sc = (i, t, e) => {
  if (t.x !== 0 && Rt(e, "lockSkewingY") || t.y !== 0 && Rt(e, "lockSkewingX")) return Jr;
  const s = nc(e, t) % 4;
  return "".concat(du[s], "-resize");
};
function Tc(i, t, e, s, r) {
  const { target: n } = e, { counterAxis: o, origin: a, lockSkewing: c, skew: l, flip: h } = Hi[i];
  if (Rt(n, c)) return !1;
  const { origin: u, flip: d } = Hi[o], f = st(e[u]) * (n[d] ? -1 : 1), g = -Math.sign(f) * (n[h] ? -1 : 1), p = 0.5 * -((n[l] === 0 && bi(e, j, j, s, r)[i] > 0 || n[l] > 0 ? 1 : -1) * g) + 0.5;
  return Ie(Wa, Ge((b, S, w, k) => function(O, x, I) {
    let { target: M, ex: E, ey: R, skewingSide: tt } = x, F = G(x, uu);
    const { skew: B } = Hi[O], $ = I.subtract(new _(E, R)).divide(new _(M.scaleX, M.scaleY))[O], yt = M[B], dt = F[B], Dt = Math.tan(K(dt)), q = O === "y" ? M._getTransformedDimensions({ scaleX: 1, scaleY: 1, skewX: 0 }).x : M._getTransformedDimensions({ scaleX: 1, scaleY: 1 }).y, zt = 2 * $ * tt / Math.max(q, 1) + Dt, te = Ce(Math.atan(zt));
    M.set(B, te);
    const pr = yt !== M[B];
    if (pr && O === "y") {
      const { skewX: Ai, scaleX: Ps } = M, me = M._getTransformedDimensions({ skewY: yt }), mr = M._getTransformedDimensions(), je = Ai !== 0 ? me.x / mr.x : 1;
      je !== 1 && M.set(ut, je * Ps);
    }
    return pr;
  }(i, S, new _(w, k))))(t, v(v({}, e), {}, { [a]: p, skewingSide: g }), s, r);
}
const xc = (i, t, e, s) => Tc("x", i, t, e, s), wc = (i, t, e, s) => Tc("y", i, t, e, s);
function Ti(i, t) {
  return i[t.canvas.altActionKey];
}
const Bs = (i, t, e) => {
  const s = Ti(i, e);
  return t.x === 0 ? s ? Os : Tt : t.y === 0 ? s ? ks : ut : "";
}, Fe = (i, t, e) => Ti(i, e) ? Sc(0, t, e) : Ze(i, t, e), un = (i, t, e, s) => Ti(i, t.target) ? wc(i, t, e, s) : bc(i, t, e, s), dn = (i, t, e, s) => Ti(i, t.target) ? xc(i, t, e, s) : _c(i, t, e, s), qn = () => ({ ml: new U({ x: -0.5, y: 0, cursorStyleHandler: Fe, actionHandler: un, getActionName: Bs }), mr: new U({ x: 0.5, y: 0, cursorStyleHandler: Fe, actionHandler: un, getActionName: Bs }), mb: new U({ x: 0, y: 0.5, cursorStyleHandler: Fe, actionHandler: dn, getActionName: Bs }), mt: new U({ x: 0, y: -0.5, cursorStyleHandler: Fe, actionHandler: dn, getActionName: Bs }), tl: new U({ x: -0.5, y: -0.5, cursorStyleHandler: Ze, actionHandler: Ls }), tr: new U({ x: 0.5, y: -0.5, cursorStyleHandler: Ze, actionHandler: Ls }), bl: new U({ x: -0.5, y: 0.5, cursorStyleHandler: Ze, actionHandler: Ls }), br: new U({ x: 0.5, y: 0.5, cursorStyleHandler: Ze, actionHandler: Ls }), mtr: new U({ x: 0, y: -0.5, actionHandler: mc, cursorStyleHandler: pc, offsetY: -40, withConnection: !0, actionName: An }) }), Cc = () => ({ mr: new U({ x: 0.5, y: 0, actionHandler: hn, cursorStyleHandler: Fe, actionName: $s }), ml: new U({ x: -0.5, y: 0, actionHandler: hn, cursorStyleHandler: Fe, actionName: $s }) }), Oc = () => v(v({}, qn()), Cc());
class Js extends ee {
  static getDefaults() {
    return v(v({}, super.getDefaults()), Js.ownDefaults);
  }
  constructor(t) {
    super(), Object.assign(this, this.constructor.createControls(), Js.ownDefaults), this.setOptions(t);
  }
  static createControls() {
    return { controls: qn() };
  }
  _updateCacheCanvas() {
    const t = this.canvas;
    if (this.noScaleCache && t && t._currentTransform) {
      const e = t._currentTransform, s = e.target, r = e.action;
      if (this === s && r && r.startsWith(pi)) return !1;
    }
    return super._updateCacheCanvas();
  }
  getActiveControl() {
    const t = this.__corner;
    return t ? { key: t, control: this.controls[t], coord: this.oCoords[t] } : void 0;
  }
  findControl(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
    if (!this.hasControls || !this.canvas) return;
    this.__corner = void 0;
    const s = Object.entries(this.oCoords);
    for (let r = s.length - 1; r >= 0; r--) {
      const [n, o] = s[r], a = this.controls[n];
      if (a.shouldActivate(n, this, t, e ? o.touchCorner : o.corner)) return this.__corner = n, { key: n, control: a, coord: this.oCoords[n] };
    }
  }
  calcOCoords() {
    const t = this.getViewportTransform(), e = this.getCenterPoint(), s = Ms(e.x, e.y), r = Is({ angle: this.getTotalAngle() - (this.group && this.flipX ? 180 : 0) }), n = J(s, r), o = J(t, n), a = J(o, [1 / t[0], 0, 0, 1 / t[3], 0, 0]), c = this.group ? ys(this.calcTransformMatrix()) : void 0;
    c && (c.scaleX = Math.abs(c.scaleX), c.scaleY = Math.abs(c.scaleY));
    const l = this._calculateCurrentDimensions(c), h = {};
    return this.forEachControl((u, d) => {
      const f = u.positionHandler(l, a, this, u);
      h[d] = Object.assign(f, this._calcCornerCoords(u, f));
    }), h;
  }
  _calcCornerCoords(t, e) {
    const s = this.getTotalAngle();
    return { corner: t.calcCornerCoords(s, this.cornerSize, e.x, e.y, !1, this), touchCorner: t.calcCornerCoords(s, this.touchCornerSize, e.x, e.y, !0, this) };
  }
  setCoords() {
    super.setCoords(), this.canvas && (this.oCoords = this.calcOCoords());
  }
  forEachControl(t) {
    for (const e in this.controls) t(this.controls[e], e, this);
  }
  drawSelectionBackground(t) {
    if (!this.selectionBackgroundColor || this.canvas && this.canvas._activeObject !== this) return;
    t.save();
    const e = this.getRelativeCenterPoint(), s = this._calculateCurrentDimensions(), r = this.getViewportTransform();
    t.translate(e.x, e.y), t.scale(1 / r[0], 1 / r[3]), t.rotate(K(this.angle)), t.fillStyle = this.selectionBackgroundColor, t.fillRect(-s.x / 2, -s.y / 2, s.x, s.y), t.restore();
  }
  strokeBorders(t, e) {
    t.strokeRect(-e.x / 2, -e.y / 2, e.x, e.y);
  }
  _drawBorders(t, e) {
    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const r = v({ hasControls: this.hasControls, borderColor: this.borderColor, borderDashArray: this.borderDashArray }, s);
    t.save(), t.strokeStyle = r.borderColor, this._setLineDash(t, r.borderDashArray), this.strokeBorders(t, e), r.hasControls && this.drawControlsConnectingLines(t, e), t.restore();
  }
  _renderControls(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const { hasBorders: s, hasControls: r } = this, n = v({ hasBorders: s, hasControls: r }, e), o = this.getViewportTransform(), a = n.hasBorders, c = n.hasControls, l = J(o, this.calcTransformMatrix()), h = ys(l);
    t.save(), t.translate(h.translateX, h.translateY), t.lineWidth = this.borderScaleFactor, this.group === this.parent && (t.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1), this.flipX && (h.angle -= 180), t.rotate(K(this.group ? h.angle : this.angle)), a && this.drawBorders(t, h, e), c && this.drawControls(t, e), t.restore();
  }
  drawBorders(t, e, s) {
    let r;
    if (s && s.forActiveSelection || this.group) {
      const n = yi(this.width, this.height, ar(e)), o = this.isStrokeAccountedForInDimensions() ? Fn : (this.strokeUniform ? new _().scalarAdd(this.canvas ? this.canvas.getZoom() : 1) : new _(e.scaleX, e.scaleY)).scalarMultiply(this.strokeWidth);
      r = n.add(o).scalarAdd(this.borderScaleFactor).scalarAdd(2 * this.padding);
    } else r = this._calculateCurrentDimensions().scalarAdd(this.borderScaleFactor);
    this._drawBorders(t, r, s);
  }
  drawControlsConnectingLines(t, e) {
    let s = !1;
    t.beginPath(), this.forEachControl((r, n) => {
      r.withConnection && r.getVisibility(this, n) && (s = !0, t.moveTo(r.x * e.x, r.y * e.y), t.lineTo(r.x * e.x + r.offsetX, r.y * e.y + r.offsetY));
    }), s && t.stroke();
  }
  drawControls(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    t.save();
    const s = this.getCanvasRetinaScaling(), { cornerStrokeColor: r, cornerDashArray: n, cornerColor: o } = this, a = v({ cornerStrokeColor: r, cornerDashArray: n, cornerColor: o }, e);
    t.setTransform(s, 0, 0, s, 0, 0), t.strokeStyle = t.fillStyle = a.cornerColor, this.transparentCorners || (t.strokeStyle = a.cornerStrokeColor), this._setLineDash(t, a.cornerDashArray), this.forEachControl((c, l) => {
      if (c.getVisibility(this, l)) {
        const h = this.oCoords[l];
        c.render(t, h.x, h.y, a, this);
      }
    }), t.restore();
  }
  isControlVisible(t) {
    return this.controls[t] && this.controls[t].getVisibility(this, t);
  }
  setControlVisible(t, e) {
    this._controlsVisibility || (this._controlsVisibility = {}), this._controlsVisibility[t] = e;
  }
  setControlsVisibility() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Object.entries(t).forEach((e) => {
      let [s, r] = e;
      return this.setControlVisible(s, r);
    });
  }
  clearContextTop(t) {
    if (!this.canvas) return;
    const e = this.canvas.contextTop;
    if (!e) return;
    const s = this.canvas.viewportTransform;
    e.save(), e.transform(s[0], s[1], s[2], s[3], s[4], s[5]), this.transform(e);
    const r = this.width + 4, n = this.height + 4;
    return e.clearRect(-r / 2, -n / 2, r, n), t || e.restore(), e;
  }
  onDeselect(t) {
    return !1;
  }
  onSelect(t) {
    return !1;
  }
  shouldStartDragging(t) {
    return !1;
  }
  onDragStart(t) {
    return !1;
  }
  canDrop(t) {
    return !1;
  }
  renderDragSourceEffect(t) {
  }
  renderDropTargetEffect(t) {
  }
}
function kc(i, t) {
  return t.forEach((e) => {
    Object.getOwnPropertyNames(e.prototype).forEach((s) => {
      s !== "constructor" && Object.defineProperty(i.prototype, s, Object.getOwnPropertyDescriptor(e.prototype, s) || /* @__PURE__ */ Object.create(null));
    });
  }), i;
}
y(Js, "ownDefaults", { noScaleCache: !0, lockMovementX: !1, lockMovementY: !1, lockRotation: !1, lockScalingX: !1, lockScalingY: !1, lockSkewingX: !1, lockSkewingY: !1, lockScalingFlip: !1, cornerSize: 13, touchCornerSize: 24, transparentCorners: !0, cornerColor: "rgb(178,204,255)", cornerStrokeColor: "", cornerStyle: "rect", cornerDashArray: null, hasControls: !0, borderColor: "rgb(178,204,255)", borderDashArray: null, borderOpacityWhenMoving: 0.4, borderScaleFactor: 1, hasBorders: !0, selectionBackgroundColor: "", selectable: !0, evented: !0, perPixelTargetFind: !1, activeOn: "down", hoverCursor: null, moveCursor: null });
class nt extends Js {
}
kc(nt, [ac]), C.setClass(nt), C.setClass(nt, "object");
const Mc = (i, t, e, s) => {
  const r = 2 * (s = Math.round(s)) + 1, { data: n } = i.getImageData(t - s, e - s, r, r);
  for (let o = 3; o < n.length; o += 4)
    if (n[o] > 0) return !1;
  return !0;
};
class Ic {
  constructor(t) {
    this.options = t, this.strokeProjectionMagnitude = this.options.strokeWidth / 2, this.scale = new _(this.options.scaleX, this.options.scaleY), this.strokeUniformScalar = this.options.strokeUniform ? new _(1 / this.options.scaleX, 1 / this.options.scaleY) : new _(1, 1);
  }
  createSideVector(t, e) {
    const s = Zr(t, e);
    return this.options.strokeUniform ? s.multiply(this.scale) : s;
  }
  projectOrthogonally(t, e, s) {
    return this.applySkew(t.add(this.calcOrthogonalProjection(t, e, s)));
  }
  isSkewed() {
    return this.options.skewX !== 0 || this.options.skewY !== 0;
  }
  applySkew(t) {
    const e = new _(t);
    return e.y += e.x * Math.tan(K(this.options.skewY)), e.x += e.y * Math.tan(K(this.options.skewX)), e;
  }
  scaleUnitVector(t, e) {
    return t.multiply(this.strokeUniformScalar).scalarMultiply(e);
  }
}
const fu = new _();
class ms extends Ic {
  static getOrthogonalRotationFactor(t, e) {
    const s = e ? ti(t, e) : lc(t);
    return Math.abs(s) < xe ? -1 : 1;
  }
  constructor(t, e, s, r) {
    super(r), y(this, "AB", void 0), y(this, "AC", void 0), y(this, "alpha", void 0), y(this, "bisector", void 0), this.A = new _(t), this.B = new _(e), this.C = new _(s), this.AB = this.createSideVector(this.A, this.B), this.AC = this.createSideVector(this.A, this.C), this.alpha = ti(this.AB, this.AC), this.bisector = Si(Vn(this.AB.eq(fu) ? this.AC : this.AB, this.alpha / 2));
  }
  calcOrthogonalProjection(t, e) {
    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.strokeProjectionMagnitude;
    const r = this.createSideVector(t, e), n = Gn(r), o = ms.getOrthogonalRotationFactor(n, this.bisector);
    return this.scaleUnitVector(n, s * o);
  }
  projectBevel() {
    const t = [];
    return (this.alpha % he == 0 ? [this.B] : [this.B, this.C]).forEach((e) => {
      t.push(this.projectOrthogonally(this.A, e)), t.push(this.projectOrthogonally(this.A, e, -this.strokeProjectionMagnitude));
    }), t;
  }
  projectMiter() {
    const t = [], e = Math.abs(this.alpha), s = 1 / Math.sin(e / 2), r = this.scaleUnitVector(this.bisector, -this.strokeProjectionMagnitude * s), n = this.options.strokeUniform ? Qr(this.scaleUnitVector(this.bisector, this.options.strokeMiterLimit)) : this.options.strokeMiterLimit;
    return Qr(r) / this.strokeProjectionMagnitude <= n && t.push(this.applySkew(this.A.add(r))), t.push(...this.projectBevel()), t;
  }
  projectRoundNoSkew(t, e) {
    const s = [], r = new _(ms.getOrthogonalRotationFactor(this.bisector), ms.getOrthogonalRotationFactor(new _(this.bisector.y, this.bisector.x)));
    return [new _(1, 0).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar).multiply(r), new _(0, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar).multiply(r)].forEach((n) => {
      cn(n, t, e) && s.push(this.A.add(n));
    }), s;
  }
  projectRoundWithSkew(t, e) {
    const s = [], { skewX: r, skewY: n, scaleX: o, scaleY: a, strokeUniform: c } = this.options, l = new _(Math.tan(K(r)), Math.tan(K(n))), h = this.strokeProjectionMagnitude, u = c ? h / a / Math.sqrt(1 / a ** 2 + 1 / o ** 2 * l.y ** 2) : h / Math.sqrt(1 + l.y ** 2), d = new _(Math.sqrt(Math.max(h ** 2 - u ** 2, 0)), u), f = c ? h / Math.sqrt(1 + l.x ** 2 * (1 / a) ** 2 / (1 / o + 1 / o * l.x * l.y) ** 2) : h / Math.sqrt(1 + l.x ** 2 / (1 + l.x * l.y) ** 2), g = new _(f, Math.sqrt(Math.max(h ** 2 - f ** 2, 0)));
    return [g, g.scalarMultiply(-1), d, d.scalarMultiply(-1)].map((p) => this.applySkew(c ? p.multiply(this.strokeUniformScalar) : p)).forEach((p) => {
      cn(p, t, e) && s.push(this.applySkew(this.A).add(p));
    }), s;
  }
  projectRound() {
    const t = [];
    t.push(...this.projectBevel());
    const e = this.alpha % he == 0, s = this.applySkew(this.A), r = t[e ? 0 : 2].subtract(s), n = t[e ? 1 : 0].subtract(s), o = e ? this.applySkew(this.AB.scalarMultiply(-1)) : this.applySkew(this.bisector.multiply(this.strokeUniformScalar).scalarMultiply(-1)), a = ps(r, o) > 0, c = a ? r : n, l = a ? n : r;
    return this.isSkewed() ? t.push(...this.projectRoundWithSkew(c, l)) : t.push(...this.projectRoundNoSkew(c, l)), t;
  }
  projectPoints() {
    switch (this.options.strokeLineJoin) {
      case "miter":
        return this.projectMiter();
      case "round":
        return this.projectRound();
      default:
        return this.projectBevel();
    }
  }
  project() {
    return this.projectPoints().map((t) => ({ originPoint: this.A, projectedPoint: t, angle: this.alpha, bisector: this.bisector }));
  }
}
class Do extends Ic {
  constructor(t, e, s) {
    super(s), this.A = new _(t), this.T = new _(e);
  }
  calcOrthogonalProjection(t, e) {
    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.strokeProjectionMagnitude;
    const r = this.createSideVector(t, e);
    return this.scaleUnitVector(Gn(r), s);
  }
  projectButt() {
    return [this.projectOrthogonally(this.A, this.T, this.strokeProjectionMagnitude), this.projectOrthogonally(this.A, this.T, -this.strokeProjectionMagnitude)];
  }
  projectRound() {
    const t = [];
    if (!this.isSkewed() && this.A.eq(this.T)) {
      const e = new _(1, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar);
      t.push(this.applySkew(this.A.add(e)), this.applySkew(this.A.subtract(e)));
    } else t.push(...new ms(this.A, this.T, this.T, this.options).projectRound());
    return t;
  }
  projectSquare() {
    const t = [];
    if (this.A.eq(this.T)) {
      const e = new _(1, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar);
      t.push(this.A.add(e), this.A.subtract(e));
    } else {
      const e = this.calcOrthogonalProjection(this.A, this.T, this.strokeProjectionMagnitude), s = this.scaleUnitVector(Si(this.createSideVector(this.A, this.T)), -this.strokeProjectionMagnitude), r = this.A.add(s);
      t.push(r.add(e), r.subtract(e));
    }
    return t.map((e) => this.applySkew(e));
  }
  projectPoints() {
    switch (this.options.strokeLineCap) {
      case "round":
        return this.projectRound();
      case "square":
        return this.projectSquare();
      default:
        return this.projectButt();
    }
  }
  project() {
    return this.projectPoints().map((t) => ({ originPoint: this.A, projectedPoint: t }));
  }
}
const Dc = function(i, t) {
  let e = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
  const s = [];
  if (i.length === 0) return s;
  const r = i.reduce((n, o) => (n[n.length - 1].eq(o) || n.push(new _(o)), n), [new _(i[0])]);
  if (r.length === 1) e = !0;
  else if (!e) {
    const n = r[0], o = ((a, c) => {
      for (let l = a.length - 1; l >= 0; l--) if (c(a[l], l, a)) return l;
      return -1;
    })(r, (a) => !a.eq(n));
    r.splice(o + 1);
  }
  return r.forEach((n, o, a) => {
    let c, l;
    o === 0 ? (l = a[1], c = e ? n : a[a.length - 1]) : o === a.length - 1 ? (c = a[o - 1], l = e ? n : a[0]) : (c = a[o - 1], l = a[o + 1]), e && a.length === 1 ? s.push(...new Do(n, n, t).project()) : !e || o !== 0 && o !== a.length - 1 ? s.push(...new ms(n, c, l, t).project()) : s.push(...new Do(n, o === 0 ? l : c, t).project());
  }), s;
}, Kn = (i) => {
  const t = {};
  return Object.keys(i).forEach((e) => {
    t[e] = {}, Object.keys(i[e]).forEach((s) => {
      t[e][s] = v({}, i[e][s]);
    });
  }), t;
}, jc = (i) => i.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), xi = (i) => {
  const t = [];
  for (let e, s = 0; s < i.length; s++) (e = gu(i, s)) !== !1 && t.push(e);
  return t;
}, gu = (i, t) => {
  const e = i.charCodeAt(t);
  if (isNaN(e)) return "";
  if (e < 55296 || e > 57343) return i.charAt(t);
  if (55296 <= e && e <= 56319) {
    if (i.length <= t + 1) throw "High surrogate without following low surrogate";
    const r = i.charCodeAt(t + 1);
    if (56320 > r || r > 57343) throw "High surrogate without following low surrogate";
    return i.charAt(t) + i.charAt(t + 1);
  }
  if (t === 0) throw "Low surrogate without preceding high surrogate";
  const s = i.charCodeAt(t - 1);
  if (55296 > s || s > 56319) throw "Low surrogate without preceding high surrogate";
  return !1;
};
var pu = Object.freeze({ __proto__: null, capitalize: function(i) {
  let t = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
  return "".concat(i.charAt(0).toUpperCase()).concat(t ? i.slice(1) : i.slice(1).toLowerCase());
}, escapeXml: jc, graphemeSplit: xi });
const wi = function(i, t) {
  let e = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
  return i.fill !== t.fill || i.stroke !== t.stroke || i.strokeWidth !== t.strokeWidth || i.fontSize !== t.fontSize || i.fontFamily !== t.fontFamily || i.fontWeight !== t.fontWeight || i.fontStyle !== t.fontStyle || i.textBackgroundColor !== t.textBackgroundColor || i.deltaY !== t.deltaY || e && (i.overline !== t.overline || i.underline !== t.underline || i.linethrough !== t.linethrough);
}, Ec = (i, t) => {
  const e = t.split(`
`), s = [];
  let r = -1, n = {};
  i = Kn(i);
  for (let o = 0; o < e.length; o++) {
    const a = xi(e[o]);
    if (i[o]) for (let c = 0; c < a.length; c++) {
      r++;
      const l = i[o][c];
      l && Object.keys(l).length > 0 && (wi(n, l, !0) ? s.push({ start: r, end: r + 1, style: l }) : s[s.length - 1].end++), n = l || {};
    }
    else r += a.length, n = {};
  }
  return s;
}, Pc = (i, t) => {
  if (!Array.isArray(i)) return Kn(i);
  const e = t.split(Pn), s = {};
  let r = -1, n = 0;
  for (let o = 0; o < e.length; o++) {
    const a = xi(e[o]);
    for (let c = 0; c < a.length; c++) r++, i[n] && i[n].start <= r && r < i[n].end && (s[o] = s[o] || {}, s[o][c] = v({}, i[n].style), r === i[n].end - 1 && n++);
  }
  return s;
}, De = ["display", "transform", rt, "fill-opacity", "fill-rule", "opacity", mt, "stroke-dasharray", "stroke-linecap", "stroke-dashoffset", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "id", "paint-order", "vector-effect", "instantiated_by_use", "clip-path"];
function jo(i, t) {
  const e = i.nodeName, s = i.getAttribute("class"), r = i.getAttribute("id"), n = "(?![a-zA-Z\\-]+)";
  let o;
  if (o = new RegExp("^" + e, "i"), t = t.replace(o, ""), r && t.length && (o = new RegExp("#" + r + n, "i"), t = t.replace(o, "")), s && t.length) {
    const a = s.split(" ");
    for (let c = a.length; c--; ) o = new RegExp("\\." + a[c] + n, "i"), t = t.replace(o, "");
  }
  return t.length === 0;
}
function mu(i, t) {
  let e = !0;
  const s = jo(i, t.pop());
  return s && t.length && (e = function(r, n) {
    let o, a = !0;
    for (; r.parentElement && r.parentElement.nodeType === 1 && n.length; ) a && (o = n.pop()), a = jo(r = r.parentElement, o);
    return n.length === 0;
  }(i, t)), s && e && t.length === 0;
}
const vu = (i) => {
  var t;
  return (t = $h[i]) !== null && t !== void 0 ? t : i;
}, yu = new RegExp("(".concat(Xe, ")"), "gi"), bu = (i) => i.replace(yu, " $1 ").replace(/,/gi, " ").replace(/\s+/gi, " ");
var Eo, Po, Ao, Fo, Ro, Lo, Bo;
const lt = "(".concat(Xe, ")"), _u = String.raw(Eo || (Eo = Me(["(skewX)(", ")"], ["(skewX)\\(", "\\)"])), lt), Su = String.raw(Po || (Po = Me(["(skewY)(", ")"], ["(skewY)\\(", "\\)"])), lt), Tu = String.raw(Ao || (Ao = Me(["(rotate)(", "(?: ", " ", ")?)"], ["(rotate)\\(", "(?: ", " ", ")?\\)"])), lt, lt, lt), xu = String.raw(Fo || (Fo = Me(["(scale)(", "(?: ", ")?)"], ["(scale)\\(", "(?: ", ")?\\)"])), lt, lt), wu = String.raw(Ro || (Ro = Me(["(translate)(", "(?: ", ")?)"], ["(translate)\\(", "(?: ", ")?\\)"])), lt, lt), Cu = String.raw(Lo || (Lo = Me(["(matrix)(", " ", " ", " ", " ", " ", ")"], ["(matrix)\\(", " ", " ", " ", " ", " ", "\\)"])), lt, lt, lt, lt, lt, lt), Jn = "(?:".concat(Cu, "|").concat(wu, "|").concat(Tu, "|").concat(xu, "|").concat(_u, "|").concat(Su, ")"), Ou = "(?:".concat(Jn, "*)"), ku = String.raw(Bo || (Bo = Me(["^s*(?:", "?)s*$"], ["^\\s*(?:", "?)\\s*$"])), Ou), Mu = new RegExp(ku), Iu = new RegExp(Jn), Du = new RegExp(Jn, "g");
function fn(i) {
  const t = [];
  if (!(i = bu(i).replace(/\s*([()])\s*/gi, "$1")) || i && !Mu.test(i)) return [...ht];
  for (const e of i.matchAll(Du)) {
    const s = Iu.exec(e[0]);
    if (!s) continue;
    let r = ht;
    const n = s.filter((g) => !!g), [, o, ...a] = n, [c, l, h, u, d, f] = a.map((g) => parseFloat(g));
    switch (o) {
      case "translate":
        r = Ms(c, l);
        break;
      case An:
        r = Is({ angle: c }, { x: l, y: h });
        break;
      case pi:
        r = vi(c, l);
        break;
      case Os:
        r = Bn(c);
        break;
      case ks:
        r = Wn(c);
        break;
      case "matrix":
        r = [c, l, h, u, d, f];
    }
    t.push(r);
  }
  return mi(t);
}
function ju(i, t, e, s) {
  const r = Array.isArray(t);
  let n, o = t;
  if (i !== rt && i !== mt || t !== pt) {
    if (i === "strokeUniform") return t === "non-scaling-stroke";
    if (i === "strokeDashArray") o = t === pt ? null : t.replace(/,/g, " ").split(/\s+/).map(parseFloat);
    else if (i === "transformMatrix") o = e && e.transformMatrix ? J(e.transformMatrix, fn(t)) : fn(t);
    else if (i === "visible") o = t !== pt && t !== "hidden", e && e.visible === !1 && (o = !1);
    else if (i === "opacity") o = parseFloat(t), e && e.opacity !== void 0 && (o *= e.opacity);
    else if (i === "textAnchor") o = t === "start" ? L : t === "end" ? Z : j;
    else if (i === "charSpacing") n = We(t, s) / s * 1e3;
    else if (i === "paintFirst") {
      const a = t.indexOf(rt), c = t.indexOf(mt);
      o = rt, (a > -1 && c > -1 && c < a || a === -1 && c > -1) && (o = mt);
    } else {
      if (i === "href" || i === "xlink:href" || i === "font" || i === "id") return t;
      if (i === "imageSmoothing") return t === "optimizeQuality";
      n = r ? t.map(We) : We(t, s);
    }
  } else o = "";
  return !r && isNaN(n) ? o : n;
}
function Eu(i, t) {
  const e = i.match(Uh);
  if (!e) return;
  const s = e[1], r = e[3], n = e[4], o = e[5], a = e[6];
  s && (t.fontStyle = s), r && (t.fontWeight = isNaN(parseFloat(r)) ? r : parseFloat(r)), n && (t.fontSize = We(n)), a && (t.fontFamily = a), o && (t.lineHeight = o === "normal" ? 1 : o);
}
function Pu(i, t) {
  i.replace(/;\s*$/, "").split(";").forEach((e) => {
    if (!e) return;
    const [s, r] = e.split(":");
    t[s.trim().toLowerCase()] = r.trim();
  });
}
function Au(i) {
  const t = {}, e = i.getAttribute("style");
  return e && (typeof e == "string" ? Pu(e, t) : function(s, r) {
    Object.entries(s).forEach((n) => {
      let [o, a] = n;
      a !== void 0 && (r[o.toLowerCase()] = a);
    });
  }(e, t)), t;
}
const Fu = { stroke: "strokeOpacity", fill: "fillOpacity" };
function fe(i, t, e) {
  if (!i) return {};
  let s, r = {}, n = En;
  i.parentNode && Co.test(i.parentNode.nodeName) && (r = fe(i.parentElement, t, e), r.fontSize && (s = n = We(r.fontSize)));
  const o = v(v(v({}, t.reduce((l, h) => {
    const u = i.getAttribute(h);
    return u && (l[h] = u), l;
  }, {})), function(l) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, u = {};
    for (const d in h) mu(l, d.split(" ")) && (u = v(v({}, u), h[d]));
    return u;
  }(i, e)), Au(i));
  o[Wi] && i.setAttribute(Wi, o[Wi]), o[Bi] && (s = We(o[Bi], n), o[Bi] = "".concat(s));
  const a = {};
  for (const l in o) {
    const h = vu(l), u = ju(h, o[l], r, s);
    a[h] = u;
  }
  a && a.font && Eu(a.font, a);
  const c = v(v({}, r), a);
  return Co.test(i.nodeName) ? c : function(l) {
    const h = nt.getDefaults();
    return Object.entries(Fu).forEach((u) => {
      let [d, f] = u;
      if (l[f] === void 0 || l[d] === "") return;
      if (l[d] === void 0) {
        if (!h[d]) return;
        l[d] = h[d];
      }
      if (l[d].indexOf("url(") === 0) return;
      const g = new W(l[d]);
      l[d] = g.setAlpha(V(g.getAlpha() * l[f], 2)).toRgba();
    }), l;
  }(c);
}
const Ru = ["left", "top", "width", "height", "visible"], Ac = ["rx", "ry"];
class X extends nt {
  static getDefaults() {
    return v(v({}, super.getDefaults()), X.ownDefaults);
  }
  constructor(t) {
    super(), Object.assign(this, X.ownDefaults), this.setOptions(t), this._initRxRy();
  }
  _initRxRy() {
    const { rx: t, ry: e } = this;
    t && !e ? this.ry = t : e && !t && (this.rx = e);
  }
  _render(t) {
    const { width: e, height: s } = this, r = -e / 2, n = -s / 2, o = this.rx ? Math.min(this.rx, e / 2) : 0, a = this.ry ? Math.min(this.ry, s / 2) : 0, c = o !== 0 || a !== 0;
    t.beginPath(), t.moveTo(r + o, n), t.lineTo(r + e - o, n), c && t.bezierCurveTo(r + e - ye * o, n, r + e, n + ye * a, r + e, n + a), t.lineTo(r + e, n + s - a), c && t.bezierCurveTo(r + e, n + s - ye * a, r + e - ye * o, n + s, r + e - o, n + s), t.lineTo(r + o, n + s), c && t.bezierCurveTo(r + ye * o, n + s, r, n + s - ye * a, r, n + s - a), t.lineTo(r, n + a), c && t.bezierCurveTo(r, n + ye * a, r + ye * o, n, r + o, n), t.closePath(), this._renderPaintInOrder(t);
  }
  toObject() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject([...Ac, ...t]);
  }
  _toSVG() {
    const { width: t, height: e, rx: s, ry: r } = this;
    return ["<rect ", "COMMON_PARTS", 'x="'.concat(-t / 2, '" y="').concat(-e / 2, '" rx="').concat(s, '" ry="').concat(r, '" width="').concat(t, '" height="').concat(e, `" />
`)];
  }
  static async fromElement(t, e, s) {
    const r = fe(t, this.ATTRIBUTE_NAMES, s), { left: n = 0, top: o = 0, width: a = 0, height: c = 0, visible: l = !0 } = r, h = G(r, Ru);
    return new this(v(v(v({}, e), h), {}, { left: n, top: o, width: a, height: c, visible: !!(l && a && c) }));
  }
}
y(X, "type", "Rect"), y(X, "cacheProperties", [...de, ...Ac]), y(X, "ownDefaults", { rx: 0, ry: 0 }), y(X, "ATTRIBUTE_NAMES", [...De, "x", "y", "rx", "ry", "width", "height"]), C.setClass(X), C.setSVGClass(X);
const ne = "initialization", ei = "added", Zn = "removed", si = "imperative", Fc = (i, t) => {
  const { strokeUniform: e, strokeWidth: s, width: r, height: n, group: o } = t, a = o && o !== i ? hr(o.calcTransformMatrix(), i.calcTransformMatrix()) : null, c = a ? t.getRelativeCenterPoint().transform(a) : t.getRelativeCenterPoint(), l = !t.isStrokeAccountedForInDimensions(), h = e && l ? rc(new _(s, s), void 0, i.calcTransformMatrix()) : Fn, u = !e && l ? s : 0, d = yi(r + u, n + u, mi([a, t.calcOwnMatrix()], !0)).add(h).scalarDivide(2);
  return [c.subtract(d), c.add(d)];
};
class Ci {
  calcLayoutResult(t, e) {
    if (this.shouldPerformLayout(t)) return this.calcBoundingBox(e, t);
  }
  shouldPerformLayout(t) {
    let { type: e, prevStrategy: s, strategy: r } = t;
    return e === ne || e === si || !!s && r !== s;
  }
  shouldLayoutClipPath(t) {
    let { type: e, target: { clipPath: s } } = t;
    return e !== ne && s && !s.absolutePositioned;
  }
  getInitialSize(t, e) {
    return e.size;
  }
  calcBoundingBox(t, e) {
    const { type: s, target: r } = e;
    if (s === si && e.overrides) return e.overrides;
    if (t.length === 0) return;
    const { left: n, top: o, width: a, height: c } = Gt(t.map((u) => Fc(r, u)).reduce((u, d) => u.concat(d), [])), l = new _(a, c), h = new _(n, o).add(l.scalarDivide(2));
    if (s === ne) {
      const u = this.getInitialSize(e, { size: l, center: h });
      return { center: h, relativeCorrection: new _(0, 0), size: u };
    }
    return { center: h.transform(r.calcOwnMatrix()), size: l };
  }
}
y(Ci, "type", "strategy");
class gn extends Ci {
  shouldPerformLayout(t) {
    return !0;
  }
}
y(gn, "type", "fit-content"), C.setClass(gn);
const Lu = ["strategy"], Bu = ["target", "strategy", "bubbles", "prevStrategy"], Rc = "layoutManager";
class Zs {
  constructor() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new gn();
    y(this, "strategy", void 0), this.strategy = t, this._subscriptions = /* @__PURE__ */ new Map();
  }
  performLayout(t) {
    const e = v(v({ bubbles: !0, strategy: this.strategy }, t), {}, { prevStrategy: this._prevLayoutStrategy, stopPropagation() {
      this.bubbles = !1;
    } });
    this.onBeforeLayout(e);
    const s = this.getLayoutResult(e);
    s && this.commitLayout(e, s), this.onAfterLayout(e, s), this._prevLayoutStrategy = e.strategy;
  }
  attachHandlers(t, e) {
    const { target: s } = e;
    return [$r, La, $s, Ba, gi, Wa, Ur, Xa, Xh].map((r) => t.on(r, (n) => this.performLayout(r === $r ? { type: "object_modified", trigger: r, e: n, target: s } : { type: "object_modifying", trigger: r, e: n, target: s })));
  }
  subscribe(t, e) {
    this.unsubscribe(t, e);
    const s = this.attachHandlers(t, e);
    this._subscriptions.set(t, s);
  }
  unsubscribe(t, e) {
    (this._subscriptions.get(t) || []).forEach((s) => s()), this._subscriptions.delete(t);
  }
  unsubscribeTargets(t) {
    t.targets.forEach((e) => this.unsubscribe(e, t));
  }
  subscribeTargets(t) {
    t.targets.forEach((e) => this.subscribe(e, t));
  }
  onBeforeLayout(t) {
    const { target: e, type: s } = t, { canvas: r } = e;
    if (s === ne || s === ei ? this.subscribeTargets(t) : s === Zn && this.unsubscribeTargets(t), e.fire("layout:before", { context: t }), r && r.fire("object:layout:before", { target: e, context: t }), s === si && t.deep) {
      const n = G(t, Lu);
      e.forEachObject((o) => o.layoutManager && o.layoutManager.performLayout(v(v({}, n), {}, { bubbles: !1, target: o })));
    }
  }
  getLayoutResult(t) {
    const { target: e, strategy: s, type: r } = t, n = s.calcLayoutResult(t, e.getObjects());
    if (!n) return;
    const o = r === ne ? new _() : e.getRelativeCenterPoint(), { center: a, correction: c = new _(), relativeCorrection: l = new _() } = n, h = o.subtract(a).add(c).transform(r === ne ? ht : St(e.calcOwnMatrix()), !0).add(l);
    return { result: n, prevCenter: o, nextCenter: a, offset: h };
  }
  commitLayout(t, e) {
    const { target: s } = t, { result: { size: r }, nextCenter: n } = e;
    var o, a;
    s.set({ width: r.x, height: r.y }), this.layoutObjects(t, e), t.type === ne ? s.set({ left: (o = t.x) !== null && o !== void 0 ? o : n.x + r.x * st(s.originX), top: (a = t.y) !== null && a !== void 0 ? a : n.y + r.y * st(s.originY) }) : (s.setPositionByOrigin(n, j, j), s.setCoords(), s.set("dirty", !0));
  }
  layoutObjects(t, e) {
    const { target: s } = t;
    s.forEachObject((r) => {
      r.group === s && this.layoutObject(t, e, r);
    }), t.strategy.shouldLayoutClipPath(t) && this.layoutObject(t, e, s.clipPath);
  }
  layoutObject(t, e, s) {
    let { offset: r } = e;
    s.set({ left: s.left + r.x, top: s.top + r.y });
  }
  onAfterLayout(t, e) {
    const { target: s, strategy: r, bubbles: n, prevStrategy: o } = t, a = G(t, Bu), { canvas: c } = s;
    s.fire("layout:after", { context: t, result: e }), c && c.fire("object:layout:after", { context: t, result: e, target: s });
    const l = s.parent;
    n && l != null && l.layoutManager && ((a.path || (a.path = [])).push(s), l.layoutManager.performLayout(v(v({}, a), {}, { target: l }))), s.set("dirty", !0);
  }
  dispose() {
    const { _subscriptions: t } = this;
    t.forEach((e) => e.forEach((s) => s())), t.clear();
  }
  toObject() {
    return { type: Rc, strategy: this.strategy.constructor.type };
  }
  toJSON() {
    return this.toObject();
  }
}
C.setClass(Zs, Rc);
const Wu = ["type", "objects", "layoutManager"];
class Xu extends Zs {
  performLayout() {
  }
}
class Nt extends za(nt) {
  static getDefaults() {
    return v(v({}, super.getDefaults()), Nt.ownDefaults);
  }
  constructor() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), y(this, "_activeObjects", []), y(this, "__objectSelectionTracker", void 0), y(this, "__objectSelectionDisposer", void 0), Object.assign(this, Nt.ownDefaults), this.setOptions(e), this.groupInit(t, e);
  }
  groupInit(t, e) {
    var s;
    this._objects = [...t], this.__objectSelectionTracker = this.__objectSelectionMonitor.bind(this, !0), this.__objectSelectionDisposer = this.__objectSelectionMonitor.bind(this, !1), this.forEachObject((r) => {
      this.enterGroup(r, !1);
    }), this.layoutManager = (s = e.layoutManager) !== null && s !== void 0 ? s : new Zs(), this.layoutManager.performLayout({ type: ne, target: this, targets: [...t], x: e.left, y: e.top });
  }
  canEnterGroup(t) {
    return t === this || this.isDescendantOf(t) ? (Te("error", "Group: circular object trees are not supported, this call has no effect"), !1) : this._objects.indexOf(t) === -1 || (Te("error", "Group: duplicate objects are not supported inside group, this call has no effect"), !1);
  }
  _filterObjectsBeforeEnteringGroup(t) {
    return t.filter((e, s, r) => this.canEnterGroup(e) && r.indexOf(e) === s);
  }
  add() {
    for (var t = arguments.length, e = new Array(t), s = 0; s < t; s++) e[s] = arguments[s];
    const r = this._filterObjectsBeforeEnteringGroup(e), n = super.add(...r);
    return this._onAfterObjectsChange(ei, r), n;
  }
  insertAt(t) {
    for (var e = arguments.length, s = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) s[r - 1] = arguments[r];
    const n = this._filterObjectsBeforeEnteringGroup(s), o = super.insertAt(t, ...n);
    return this._onAfterObjectsChange(ei, n), o;
  }
  remove() {
    const t = super.remove(...arguments);
    return this._onAfterObjectsChange(Zn, t), t;
  }
  _onObjectAdded(t) {
    this.enterGroup(t, !0), this.fire("object:added", { target: t }), t.fire("added", { target: this });
  }
  _onObjectRemoved(t, e) {
    this.exitGroup(t, e), this.fire("object:removed", { target: t }), t.fire("removed", { target: this });
  }
  _onAfterObjectsChange(t, e) {
    this.layoutManager.performLayout({ type: t, targets: e, target: this });
  }
  _onStackOrderChanged() {
    this._set("dirty", !0);
  }
  _set(t, e) {
    const s = this[t];
    return super._set(t, e), t === "canvas" && s !== e && (this._objects || []).forEach((r) => {
      r._set(t, e);
    }), this;
  }
  _shouldSetNestedCoords() {
    return this.subTargetCheck;
  }
  removeAll() {
    return this._activeObjects = [], this.remove(...this._objects);
  }
  __objectSelectionMonitor(t, e) {
    let { target: s } = e;
    const r = this._activeObjects;
    if (t) r.push(s), this._set("dirty", !0);
    else if (r.length > 0) {
      const n = r.indexOf(s);
      n > -1 && (r.splice(n, 1), this._set("dirty", !0));
    }
  }
  _watchObject(t, e) {
    t && this._watchObject(!1, e), t ? (e.on("selected", this.__objectSelectionTracker), e.on("deselected", this.__objectSelectionDisposer)) : (e.off("selected", this.__objectSelectionTracker), e.off("deselected", this.__objectSelectionDisposer));
  }
  enterGroup(t, e) {
    t.group && t.group.remove(t), t._set("parent", this), this._enterGroup(t, e);
  }
  _enterGroup(t, e) {
    e && _s(t, J(St(this.calcTransformMatrix()), t.calcTransformMatrix())), this._shouldSetNestedCoords() && t.setCoords(), t._set("group", this), t._set("canvas", this.canvas), this._watchObject(!0, t);
    const s = this.canvas && this.canvas.getActiveObject && this.canvas.getActiveObject();
    s && (s === t || t.isDescendantOf(s)) && this._activeObjects.push(t);
  }
  exitGroup(t, e) {
    this._exitGroup(t, e), t._set("parent", void 0), t._set("canvas", void 0);
  }
  _exitGroup(t, e) {
    t._set("group", void 0), e || (_s(t, J(this.calcTransformMatrix(), t.calcTransformMatrix())), t.setCoords()), this._watchObject(!1, t);
    const s = this._activeObjects.length > 0 ? this._activeObjects.indexOf(t) : -1;
    s > -1 && this._activeObjects.splice(s, 1);
  }
  shouldCache() {
    const t = nt.prototype.shouldCache.call(this);
    if (t) {
      for (let e = 0; e < this._objects.length; e++) if (this._objects[e].willDrawShadow()) return this.ownCaching = !1, !1;
    }
    return t;
  }
  willDrawShadow() {
    if (super.willDrawShadow()) return !0;
    for (let t = 0; t < this._objects.length; t++) if (this._objects[t].willDrawShadow()) return !0;
    return !1;
  }
  isOnACache() {
    return this.ownCaching || !!this.parent && this.parent.isOnACache();
  }
  drawObject(t, e, s) {
    this._renderBackground(t);
    for (let n = 0; n < this._objects.length; n++) {
      var r;
      const o = this._objects[n];
      (r = this.canvas) !== null && r !== void 0 && r.preserveObjectStacking && o.group !== this ? (t.save(), t.transform(...St(this.calcTransformMatrix())), o.render(t), t.restore()) : o.group === this && o.render(t);
    }
    this._drawClipPath(t, this.clipPath, s);
  }
  setCoords() {
    super.setCoords(), this._shouldSetNestedCoords() && this.forEachObject((t) => t.setCoords());
  }
  triggerLayout() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.layoutManager.performLayout(v({ target: this, type: si }, t));
  }
  render(t) {
    this._transformDone = !0, super.render(t), this._transformDone = !1;
  }
  __serializeObjects(t, e) {
    const s = this.includeDefaultValues;
    return this._objects.filter(function(r) {
      return !r.excludeFromExport;
    }).map(function(r) {
      const n = r.includeDefaultValues;
      r.includeDefaultValues = s;
      const o = r[t || "toObject"](e);
      return r.includeDefaultValues = n, o;
    });
  }
  toObject() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const e = this.layoutManager.toObject();
    return v(v(v({}, super.toObject(["subTargetCheck", "interactive", ...t])), e.strategy !== "fit-content" || this.includeDefaultValues ? { layoutManager: e } : {}), {}, { objects: this.__serializeObjects("toObject", t) });
  }
  toString() {
    return "#<Group: (".concat(this.complexity(), ")>");
  }
  dispose() {
    this.layoutManager.unsubscribeTargets({ targets: this.getObjects(), target: this }), this._activeObjects = [], this.forEachObject((t) => {
      this._watchObject(!1, t), t.dispose();
    }), super.dispose();
  }
  _createSVGBgRect(t) {
    if (!this.backgroundColor) return "";
    const e = X.prototype._toSVG.call(this), s = e.indexOf("COMMON_PARTS");
    e[s] = 'for="group" ';
    const r = e.join("");
    return t ? t(r) : r;
  }
  _toSVG(t) {
    const e = ["<g ", "COMMON_PARTS", ` >
`], s = this._createSVGBgRect(t);
    s && e.push("		", s);
    for (let r = 0; r < this._objects.length; r++) e.push("		", this._objects[r].toSVG(t));
    return e.push(`</g>
`), e;
  }
  getSvgStyles() {
    const t = this.opacity !== void 0 && this.opacity !== 1 ? "opacity: ".concat(this.opacity, ";") : "", e = this.visible ? "" : " visibility: hidden;";
    return [t, this.getSvgFilter(), e].join("");
  }
  toClipPathSVG(t) {
    const e = [], s = this._createSVGBgRect(t);
    s && e.push("	", s);
    for (let r = 0; r < this._objects.length; r++) e.push("	", this._objects[r].toClipPathSVG(t));
    return this._createBaseClipPathSVGMarkup(e, { reviver: t });
  }
  static fromObject(t, e) {
    let { type: s, objects: r = [], layoutManager: n } = t, o = G(t, Wu);
    return Promise.all([bs(r, e), cr(o, e)]).then((a) => {
      let [c, l] = a;
      const h = new this(c, v(v(v({}, o), l), {}, { layoutManager: new Xu() }));
      if (n) {
        const u = C.getClass(n.type), d = C.getClass(n.strategy);
        h.layoutManager = new u(new d());
      } else h.layoutManager = new Zs();
      return h.layoutManager.subscribeTargets({ type: ne, target: h, targets: h.getObjects() }), h.setCoords(), h;
    });
  }
}
y(Nt, "type", "Group"), y(Nt, "ownDefaults", { strokeWidth: 0, subTargetCheck: !1, interactive: !1 }), C.setClass(Nt);
const Lc = (i, t) => Math.min(t.width / i.width, t.height / i.height), Bc = (i, t) => Math.max(t.width / i.width, t.height / i.height), pn = "\\s*,?\\s*", Fs = "".concat(pn, "(").concat(Xe, ")"), zu = "".concat(Fs).concat(Fs).concat(Fs).concat(pn, "([01])").concat(pn, "([01])").concat(Fs).concat(Fs), Hu = { m: "l", M: "L" }, Yu = (i, t, e, s, r, n, o, a, c, l, h) => {
  const u = Lt(i), d = Bt(i), f = Lt(t), g = Bt(t), p = e * r * f - s * n * g + o, m = s * r * f + e * n * g + a;
  return ["C", l + c * (-e * r * d - s * n * u), h + c * (-s * r * d + e * n * u), p + c * (e * r * g + s * n * f), m + c * (s * r * g - e * n * f), p, m];
}, Wo = (i, t, e, s) => {
  const r = Math.atan2(t, i), n = Math.atan2(s, e);
  return n >= r ? n - r : 2 * Math.PI - (r - n);
};
function mn(i, t, e, s, r, n, o, a) {
  let c;
  if (A.cachesBoundsOfCurve && (c = [...arguments].join(), zs.boundsOfCurveCache[c])) return zs.boundsOfCurveCache[c];
  const l = Math.sqrt, h = Math.abs, u = [], d = [[0, 0], [0, 0]];
  let f = 6 * i - 12 * e + 6 * r, g = -3 * i + 9 * e - 9 * r + 3 * o, p = 3 * e - 3 * i;
  for (let k = 0; k < 2; ++k) {
    if (k > 0 && (f = 6 * t - 12 * s + 6 * n, g = -3 * t + 9 * s - 9 * n + 3 * a, p = 3 * s - 3 * t), h(g) < 1e-12) {
      if (h(f) < 1e-12) continue;
      const E = -p / f;
      0 < E && E < 1 && u.push(E);
      continue;
    }
    const O = f * f - 4 * p * g;
    if (O < 0) continue;
    const x = l(O), I = (-f + x) / (2 * g);
    0 < I && I < 1 && u.push(I);
    const M = (-f - x) / (2 * g);
    0 < M && M < 1 && u.push(M);
  }
  let m = u.length;
  const b = m, S = Xc(i, t, e, s, r, n, o, a);
  for (; m--; ) {
    const { x: k, y: O } = S(u[m]);
    d[0][m] = k, d[1][m] = O;
  }
  d[0][b] = i, d[1][b] = t, d[0][b + 1] = o, d[1][b + 1] = a;
  const w = [new _(Math.min(...d[0]), Math.min(...d[1])), new _(Math.max(...d[0]), Math.max(...d[1]))];
  return A.cachesBoundsOfCurve && (zs.boundsOfCurveCache[c] = w), w;
}
const Vu = (i, t, e) => {
  let [s, r, n, o, a, c, l, h] = e;
  const u = ((d, f, g, p, m, b, S) => {
    if (g === 0 || p === 0) return [];
    let w = 0, k = 0, O = 0;
    const x = Math.PI, I = S * jn, M = Bt(I), E = Lt(I), R = 0.5 * (-E * d - M * f), tt = 0.5 * (-E * f + M * d), F = g ** 2, B = p ** 2, $ = tt ** 2, yt = R ** 2, dt = F * B - F * $ - B * yt;
    let Dt = Math.abs(g), q = Math.abs(p);
    if (dt < 0) {
      const ve = Math.sqrt(1 - dt / (F * B));
      Dt *= ve, q *= ve;
    } else O = (m === b ? -1 : 1) * Math.sqrt(dt / (F * $ + B * yt));
    const zt = O * Dt * tt / q, te = -O * q * R / Dt, pr = E * zt - M * te + 0.5 * d, Ai = M * zt + E * te + 0.5 * f;
    let Ps = Wo(1, 0, (R - zt) / Dt, (tt - te) / q), me = Wo((R - zt) / Dt, (tt - te) / q, (-R - zt) / Dt, (-tt - te) / q);
    b === 0 && me > 0 ? me -= 2 * x : b === 1 && me < 0 && (me += 2 * x);
    const mr = Math.ceil(Math.abs(me / x * 2)), je = [], As = me / mr, Ah = 8 / 3 * Math.sin(As / 4) * Math.sin(As / 4) / Math.sin(As / 2);
    let Fi = Ps + As;
    for (let ve = 0; ve < mr; ve++) je[ve] = Yu(Ps, Fi, E, M, Dt, q, pr, Ai, Ah, w, k), w = je[ve][5], k = je[ve][6], Ps = Fi, Fi += As;
    return je;
  })(l - i, h - t, r, n, a, c, o);
  for (let d = 0, f = u.length; d < f; d++) u[d][1] += i, u[d][2] += t, u[d][3] += i, u[d][4] += t, u[d][5] += i, u[d][6] += t;
  return u;
}, Wc = (i) => {
  let t = 0, e = 0, s = 0, r = 0;
  const n = [];
  let o, a = 0, c = 0;
  for (const l of i) {
    const h = [...l];
    let u;
    switch (h[0]) {
      case "l":
        h[1] += t, h[2] += e;
      case "L":
        t = h[1], e = h[2], u = ["L", t, e];
        break;
      case "h":
        h[1] += t;
      case "H":
        t = h[1], u = ["L", t, e];
        break;
      case "v":
        h[1] += e;
      case "V":
        e = h[1], u = ["L", t, e];
        break;
      case "m":
        h[1] += t, h[2] += e;
      case "M":
        t = h[1], e = h[2], s = h[1], r = h[2], u = ["M", t, e];
        break;
      case "c":
        h[1] += t, h[2] += e, h[3] += t, h[4] += e, h[5] += t, h[6] += e;
      case "C":
        a = h[3], c = h[4], t = h[5], e = h[6], u = ["C", h[1], h[2], a, c, t, e];
        break;
      case "s":
        h[1] += t, h[2] += e, h[3] += t, h[4] += e;
      case "S":
        o === "C" ? (a = 2 * t - a, c = 2 * e - c) : (a = t, c = e), t = h[3], e = h[4], u = ["C", a, c, h[1], h[2], t, e], a = u[3], c = u[4];
        break;
      case "q":
        h[1] += t, h[2] += e, h[3] += t, h[4] += e;
      case "Q":
        a = h[1], c = h[2], t = h[3], e = h[4], u = ["Q", a, c, t, e];
        break;
      case "t":
        h[1] += t, h[2] += e;
      case "T":
        o === "Q" ? (a = 2 * t - a, c = 2 * e - c) : (a = t, c = e), t = h[1], e = h[2], u = ["Q", a, c, t, e];
        break;
      case "a":
        h[6] += t, h[7] += e;
      case "A":
        Vu(t, e, h).forEach((d) => n.push(d)), t = h[6], e = h[7];
        break;
      case "z":
      case "Z":
        t = s, e = r, u = ["Z"];
    }
    u ? (n.push(u), o = u[0]) : o = "";
  }
  return n;
}, ri = (i, t, e, s) => Math.sqrt((e - i) ** 2 + (s - t) ** 2), Xc = (i, t, e, s, r, n, o, a) => (c) => {
  const l = c ** 3, h = ((f) => 3 * f ** 2 * (1 - f))(c), u = ((f) => 3 * f * (1 - f) ** 2)(c), d = ((f) => (1 - f) ** 3)(c);
  return new _(o * l + r * h + e * u + i * d, a * l + n * h + s * u + t * d);
}, zc = (i) => i ** 2, Hc = (i) => 2 * i * (1 - i), Yc = (i) => (1 - i) ** 2, Gu = (i, t, e, s, r, n, o, a) => (c) => {
  const l = zc(c), h = Hc(c), u = Yc(c), d = 3 * (u * (e - i) + h * (r - e) + l * (o - r)), f = 3 * (u * (s - t) + h * (n - s) + l * (a - n));
  return Math.atan2(f, d);
}, Nu = (i, t, e, s, r, n) => (o) => {
  const a = zc(o), c = Hc(o), l = Yc(o);
  return new _(r * a + e * c + i * l, n * a + s * c + t * l);
}, Uu = (i, t, e, s, r, n) => (o) => {
  const a = 1 - o, c = 2 * (a * (e - i) + o * (r - e)), l = 2 * (a * (s - t) + o * (n - s));
  return Math.atan2(l, c);
}, Xo = (i, t, e) => {
  let s = new _(t, e), r = 0;
  for (let n = 1; n <= 100; n += 1) {
    const o = i(n / 100);
    r += ri(s.x, s.y, o.x, o.y), s = o;
  }
  return r;
}, $u = (i, t) => {
  let e, s = 0, r = 0, n = { x: i.x, y: i.y }, o = v({}, n), a = 0.01, c = 0;
  const l = i.iterator, h = i.angleFinder;
  for (; r < t && a > 1e-4; ) o = l(s), c = s, e = ri(n.x, n.y, o.x, o.y), e + r > t ? (s -= a, a /= 2) : (n = o, s += a, r += e);
  return v(v({}, o), {}, { angle: h(c) });
}, Qn = (i) => {
  let t, e, s = 0, r = 0, n = 0, o = 0, a = 0;
  const c = [];
  for (const l of i) {
    const h = { x: r, y: n, command: l[0], length: 0 };
    switch (l[0]) {
      case "M":
        e = h, e.x = o = r = l[1], e.y = a = n = l[2];
        break;
      case "L":
        e = h, e.length = ri(r, n, l[1], l[2]), r = l[1], n = l[2];
        break;
      case "C":
        t = Xc(r, n, l[1], l[2], l[3], l[4], l[5], l[6]), e = h, e.iterator = t, e.angleFinder = Gu(r, n, l[1], l[2], l[3], l[4], l[5], l[6]), e.length = Xo(t, r, n), r = l[5], n = l[6];
        break;
      case "Q":
        t = Nu(r, n, l[1], l[2], l[3], l[4]), e = h, e.iterator = t, e.angleFinder = Uu(r, n, l[1], l[2], l[3], l[4]), e.length = Xo(t, r, n), r = l[3], n = l[4];
        break;
      case "Z":
        e = h, e.destX = o, e.destY = a, e.length = ri(r, n, o, a), r = o, n = a;
    }
    s += e.length, c.push(e);
  }
  return c.push({ length: s, x: r, y: n }), c;
}, Vc = function(i, t) {
  let e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Qn(i), s = 0;
  for (; t - e[s].length > 0 && s < e.length - 2; ) t -= e[s].length, s++;
  const r = e[s], n = t / r.length, o = i[s];
  switch (r.command) {
    case "M":
      return { x: r.x, y: r.y, angle: 0 };
    case "Z":
      return v(v({}, new _(r.x, r.y).lerp(new _(r.destX, r.destY), n)), {}, { angle: Math.atan2(r.destY - r.y, r.destX - r.x) });
    case "L":
      return v(v({}, new _(r.x, r.y).lerp(new _(o[1], o[2]), n)), {}, { angle: Math.atan2(o[2] - r.y, o[1] - r.x) });
    case "C":
    case "Q":
      return $u(r, t);
  }
}, qu = new RegExp("[mzlhvcsqta][^mzlhvcsqta]*", "gi"), zo = new RegExp(zu, "g"), Ku = new RegExp(Xe, "gi"), Ju = { m: 2, l: 2, h: 1, v: 1, c: 6, s: 4, q: 4, t: 2, a: 7 }, Gc = (i) => {
  var t;
  const e = [], s = (t = i.match(qu)) !== null && t !== void 0 ? t : [];
  for (const r of s) {
    const n = r[0];
    if (n === "z" || n === "Z") {
      e.push([n]);
      continue;
    }
    const o = Ju[n.toLowerCase()];
    let a = [];
    if (n === "a" || n === "A") {
      zo.lastIndex = 0;
      for (let c = null; c = zo.exec(r); ) a.push(...c.slice(1));
    } else a = r.match(Ku) || [];
    for (let c = 0; c < a.length; c += o) {
      const l = new Array(o), h = Hu[n];
      l[0] = c > 0 && h ? h : n;
      for (let u = 0; u < o; u++) l[u + 1] = parseFloat(a[c + u]);
      e.push(l);
    }
  }
  return e;
}, Zu = function(i) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, e = new _(i[0]), s = new _(i[1]), r = 1, n = 0;
  const o = [], a = i.length, c = a > 2;
  let l;
  for (c && (r = i[2].x < s.x ? -1 : i[2].x === s.x ? 0 : 1, n = i[2].y < s.y ? -1 : i[2].y === s.y ? 0 : 1), o.push(["M", e.x - r * t, e.y - n * t]), l = 1; l < a; l++) {
    if (!e.eq(s)) {
      const h = e.midPointFrom(s);
      o.push(["Q", e.x, e.y, h.x, h.y]);
    }
    e = i[l], l + 1 < i.length && (s = i[l + 1]);
  }
  return c && (r = e.x > i[l - 2].x ? 1 : e.x === i[l - 2].x ? 0 : -1, n = e.y > i[l - 2].y ? 1 : e.y === i[l - 2].y ? 0 : -1), o.push(["L", e.x + r * t, e.y + n * t]), o;
}, Nc = (i, t) => i.map((e) => e.map((s, r) => r === 0 || t === void 0 ? s : V(s, t)).join(" ")).join(" ");
function ii(i, t) {
  const e = i.style;
  e && t && (typeof t == "string" ? e.cssText += ";" + t : Object.entries(t).forEach((s) => {
    let [r, n] = s;
    return e.setProperty(r, n);
  }));
}
const Qu = (i, t) => Math.floor(Math.random() * (t - i + 1)) + i;
function td(i) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const e = t.onComplete || Be, s = new (fi()).XMLHttpRequest(), r = t.signal, n = function() {
    s.abort();
  }, o = function() {
    r && r.removeEventListener("abort", n), s.onerror = s.ontimeout = Be;
  };
  if (r && r.aborted) throw new Fa("request");
  return r && r.addEventListener("abort", n, { once: !0 }), s.onreadystatechange = function() {
    s.readyState === 4 && (o(), e(s), s.onreadystatechange = Be);
  }, s.onerror = s.ontimeout = o, s.open("get", i, !0), s.send(), s;
}
const ed = (i, t) => {
  let e = i._findCenterFromElement();
  i.transformMatrix && (((s) => {
    if (s.transformMatrix) {
      const { scaleX: r, scaleY: n, angle: o, skewX: a } = ys(s.transformMatrix);
      s.flipX = !1, s.flipY = !1, s.set(ut, r), s.set(Tt, n), s.angle = o, s.skewX = a, s.skewY = 0;
    }
  })(i), e = e.transform(i.transformMatrix)), delete i.transformMatrix, t && (i.scaleX *= t.scaleX, i.scaleY *= t.scaleY, i.cropX = t.cropX, i.cropY = t.cropY, e.x += t.offsetLeft, e.y += t.offsetTop, i.width = t.width, i.height = t.height), i.setPositionByOrigin(e, j, j);
};
var sd = Object.freeze({ __proto__: null, addTransformToObject: ec, animate: Un, animateColor: dc, applyTransformToObject: _s, calcAngleBetweenVectors: ti, calcDimensionsMatrix: ar, calcPlaneChangeMatrix: hr, calcVectorRotation: lc, cancelAnimFrame: Ya, capValue: ze, composeMatrix: $a, copyCanvasElement: (i) => {
  var t;
  const e = Wt(i);
  return (t = e.getContext("2d")) === null || t === void 0 || t.drawImage(i, 0, 0), e;
}, cos: Lt, createCanvasElement: kt, createImage: Va, createRotateMatrix: Is, createScaleMatrix: vi, createSkewXMatrix: Bn, createSkewYMatrix: Wn, createTranslateMatrix: Ms, createVector: Zr, crossProduct: ps, degreesToRadians: K, dotProduct: hc, ease: Zh, enlivenObjectEnlivables: cr, enlivenObjects: bs, findScaleToCover: Bc, findScaleToFit: Lc, getBoundsOfCurve: mn, getOrthonormalVector: Gn, getPathSegmentsInfo: Qn, getPointOnPath: Vc, getPointer: tc, getRandomInt: Qu, getRegularPolygonPath: (i, t) => {
  const e = 2 * Math.PI / i;
  let s = -xe;
  i % 2 == 0 && (s += e / 2);
  const r = new Array(i + 1);
  for (let n = 0; n < i; n++) {
    const o = n * e + s, { x: a, y: c } = new _(Lt(o), Bt(o)).scalarMultiply(t);
    r[n] = [n === 0 ? "M" : "L", a, c];
  }
  return r[i] = ["Z"], r;
}, getSmoothPathFromPoints: Zu, getSvgAttributes: (i) => {
  const t = ["instantiated_by_use", "style", "id", "class"];
  switch (i) {
    case "linearGradient":
      return t.concat(["x1", "y1", "x2", "y2", "gradientUnits", "gradientTransform"]);
    case "radialGradient":
      return t.concat(["gradientUnits", "gradientTransform", "cx", "cy", "r", "fx", "fy", "fr"]);
    case "stop":
      return t.concat(["offset", "stop-color", "stop-opacity"]);
  }
  return t;
}, getUnitVector: Si, groupSVGElements: (i, t) => i && i.length === 1 ? i[0] : new Nt(i, t), hasStyleChanged: wi, invertTransform: St, isBetweenVectors: cn, isIdentityMatrix: Ga, isTouchEvent: Kr, isTransparent: Mc, joinPath: Nc, loadImage: Ys, magnitude: Qr, makeBoundingBoxFromPoints: Gt, makePathSimpler: Wc, matrixToSVG: qs, mergeClipPaths: (i, t) => {
  var e;
  let s = i, r = t;
  s.inverted && !r.inverted && (s = t, r = i), an(r, (e = r.group) === null || e === void 0 ? void 0 : e.calcTransformMatrix(), s.calcTransformMatrix());
  const n = s.inverted && r.inverted;
  return n && (s.inverted = r.inverted = !1), new Nt([s], { clipPath: r, inverted: n });
}, multiplyTransformMatrices: J, multiplyTransformMatrixArray: mi, parsePath: Gc, parsePreserveAspectRatioAttribute: qa, parseUnit: We, pick: Ve, projectStrokeOnPoints: Dc, qrDecompose: ys, radiansToDegrees: Ce, removeFromArray: Ee, removeTransformFromObject: (i, t) => {
  const e = St(t), s = J(e, i.calcOwnMatrix());
  _s(i, s);
}, removeTransformMatrixForSvgParsing: ed, request: td, requestAnimFrame: Hs, resetObjectTransform: sc, rotatePoint: (i, t, e) => i.rotate(e, t), rotateVector: Vn, saveObjectTransform: zn, sendObjectToPlane: an, sendPointToPlane: ae, sendVectorToPlane: rc, setStyle: ii, sin: Bt, sizeAfterTransform: yi, string: pu, stylesFromArray: Pc, stylesToArray: Ec, toBlob: Ln, toDataURL: Rn, toFixed: V, transformPath: (i, t, e) => (e && (t = J(t, [1, 0, 0, 1, -e.x, -e.y])), i.map((s) => {
  const r = [...s];
  for (let n = 1; n < s.length - 1; n += 2) {
    const { x: o, y: a } = ot({ x: s[n], y: s[n + 1] }, t);
    r[n] = o, r[n + 1] = a;
  }
  return r;
})), transformPoint: ot });
class rd extends Qa {
  constructor(t) {
    let { allowTouchScrolling: e = !1, containerClass: s = "" } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(t), y(this, "upper", void 0), y(this, "container", void 0);
    const { el: r } = this.lower, n = this.createUpperCanvas();
    this.upper = { el: n, ctx: n.getContext("2d") }, this.applyCanvasStyle(r, { allowTouchScrolling: e }), this.applyCanvasStyle(n, { allowTouchScrolling: e, styles: { position: "absolute", left: "0", top: "0" } });
    const o = this.createContainerElement();
    o.classList.add(s), r.parentNode && r.parentNode.replaceChild(o, r), o.append(r, n), this.container = o;
  }
  createUpperCanvas() {
    const { el: t } = this.lower, e = kt();
    return e.className = t.className, e.classList.remove("lower-canvas"), e.classList.add("upper-canvas"), e.setAttribute("data-fabric", "top"), e.style.cssText = t.style.cssText, e.setAttribute("draggable", "true"), e;
  }
  createContainerElement() {
    const t = Cs().createElement("div");
    return t.setAttribute("data-fabric", "wrapper"), ii(t, { position: "relative" }), To(t), t;
  }
  applyCanvasStyle(t, e) {
    const { styles: s, allowTouchScrolling: r } = e;
    ii(t, v(v({}, s), {}, { "touch-action": r ? "manipulation" : pt })), To(t);
  }
  setDimensions(t, e) {
    super.setDimensions(t, e);
    const { el: s, ctx: r } = this.upper;
    Za(s, r, t, e);
  }
  setCSSDimensions(t) {
    super.setCSSDimensions(t), nn(this.upper.el, t), nn(this.container, t);
  }
  cleanupDOM(t) {
    const e = this.container, { el: s } = this.lower, { el: r } = this.upper;
    super.cleanupDOM(t), e.removeChild(r), e.removeChild(s), e.parentNode && e.parentNode.replaceChild(s, e);
  }
  dispose() {
    super.dispose(), $t().dispose(this.upper.el), delete this.upper, delete this.container;
  }
}
class Oi extends lr {
  constructor() {
    super(...arguments), y(this, "targets", []), y(this, "_hoveredTargets", []), y(this, "_objectsToRender", void 0), y(this, "_currentTransform", null), y(this, "_groupSelector", null), y(this, "contextTopDirty", !1);
  }
  static getDefaults() {
    return v(v({}, super.getDefaults()), Oi.ownDefaults);
  }
  get upperCanvasEl() {
    var t;
    return (t = this.elements.upper) === null || t === void 0 ? void 0 : t.el;
  }
  get contextTop() {
    var t;
    return (t = this.elements.upper) === null || t === void 0 ? void 0 : t.ctx;
  }
  get wrapperEl() {
    return this.elements.container;
  }
  initElements(t) {
    this.elements = new rd(t, { allowTouchScrolling: this.allowTouchScrolling, containerClass: this.containerClass }), this._createCacheCanvas();
  }
  _onObjectAdded(t) {
    this._objectsToRender = void 0, super._onObjectAdded(t);
  }
  _onObjectRemoved(t) {
    this._objectsToRender = void 0, t === this._activeObject && (this.fire("before:selection:cleared", { deselected: [t] }), this._discardActiveObject(), this.fire("selection:cleared", { deselected: [t] }), t.fire("deselected", { target: t })), t === this._hoveredTarget && (this._hoveredTarget = void 0, this._hoveredTargets = []), super._onObjectRemoved(t);
  }
  _onStackOrderChanged() {
    this._objectsToRender = void 0, super._onStackOrderChanged();
  }
  _chooseObjectsToRender() {
    const t = this._activeObject;
    return !this.preserveObjectStacking && t ? this._objects.filter((e) => !e.group && e !== t).concat(t) : this._objects;
  }
  renderAll() {
    this.cancelRequestedRender(), this.destroyed || (!this.contextTopDirty || this._groupSelector || this.isDrawingMode || (this.clearContext(this.contextTop), this.contextTopDirty = !1), this.hasLostContext && (this.renderTopLayer(this.contextTop), this.hasLostContext = !1), !this._objectsToRender && (this._objectsToRender = this._chooseObjectsToRender()), this.renderCanvas(this.getContext(), this._objectsToRender));
  }
  renderTopLayer(t) {
    t.save(), this.isDrawingMode && this._isCurrentlyDrawing && (this.freeDrawingBrush && this.freeDrawingBrush._render(), this.contextTopDirty = !0), this.selection && this._groupSelector && (this._drawSelection(t), this.contextTopDirty = !0), t.restore();
  }
  renderTop() {
    const t = this.contextTop;
    this.clearContext(t), this.renderTopLayer(t), this.fire("after:render", { ctx: t });
  }
  setTargetFindTolerance(t) {
    t = Math.round(t), this.targetFindTolerance = t;
    const e = this.getRetinaScaling(), s = Math.ceil((2 * t + 1) * e);
    this.pixelFindCanvasEl.width = this.pixelFindCanvasEl.height = s, this.pixelFindContext.scale(e, e);
  }
  isTargetTransparent(t, e, s) {
    const r = this.targetFindTolerance, n = this.pixelFindContext;
    this.clearContext(n), n.save(), n.translate(-e + r, -s + r), n.transform(...this.viewportTransform);
    const o = t.selectionBackgroundColor;
    t.selectionBackgroundColor = "", t.render(n), t.selectionBackgroundColor = o, n.restore();
    const a = Math.round(r * this.getRetinaScaling());
    return Mc(n, a, a, a);
  }
  _isSelectionKeyPressed(t) {
    const e = this.selectionKey;
    return !!e && (Array.isArray(e) ? !!e.find((s) => !!s && t[s] === !0) : t[e]);
  }
  _shouldClearSelection(t, e) {
    const s = this.getActiveObjects(), r = this._activeObject;
    return !!(!e || e && r && s.length > 1 && s.indexOf(e) === -1 && r !== e && !this._isSelectionKeyPressed(t) || e && !e.evented || e && !e.selectable && r && r !== e);
  }
  _shouldCenterTransform(t, e, s) {
    if (!t) return;
    let r;
    return e === pi || e === ut || e === Tt || e === $s ? r = this.centeredScaling || t.centeredScaling : e === An && (r = this.centeredRotation || t.centeredRotation), r ? !s : s;
  }
  _getOriginFromCorner(t, e) {
    const s = { x: t.originX, y: t.originY };
    return e && (["ml", "tl", "bl"].includes(e) ? s.x = Z : ["mr", "tr", "br"].includes(e) && (s.x = L), ["tl", "mt", "tr"].includes(e) ? s.y = rn : ["bl", "mb", "br"].includes(e) && (s.y = gt)), s;
  }
  _setupCurrentTransform(t, e, s) {
    var r;
    const n = e.group ? ae(this.getScenePoint(t), void 0, e.group.calcTransformMatrix()) : this.getScenePoint(t), { key: o = "", control: a } = e.getActiveControl() || {}, c = s && a ? (r = a.getActionHandler(t, e, a)) === null || r === void 0 ? void 0 : r.bind(a) : oc, l = ((f, g, p, m) => {
      if (!g || !f) return "drag";
      const b = m.controls[g];
      return b.getActionName(p, b, m);
    })(s, o, t, e), h = t[this.centeredKey], u = this._shouldCenterTransform(e, l, h) ? { x: j, y: j } : this._getOriginFromCorner(e, o), d = { target: e, action: l, actionHandler: c, actionPerformed: !1, corner: o, scaleX: e.scaleX, scaleY: e.scaleY, skewX: e.skewX, skewY: e.skewY, offsetX: n.x - e.left, offsetY: n.y - e.top, originX: u.x, originY: u.y, ex: n.x, ey: n.y, lastX: n.x, lastY: n.y, theta: K(e.angle), width: e.width, height: e.height, shiftKey: t.shiftKey, altKey: h, original: v(v({}, zn(e)), {}, { originX: u.x, originY: u.y }) };
    this._currentTransform = d, this.fire("before:transform", { e: t, transform: d });
  }
  setCursor(t) {
    this.upperCanvasEl.style.cursor = t;
  }
  _drawSelection(t) {
    const { x: e, y: s, deltaX: r, deltaY: n } = this._groupSelector, o = new _(e, s).transform(this.viewportTransform), a = new _(e + r, s + n).transform(this.viewportTransform), c = this.selectionLineWidth / 2;
    let l = Math.min(o.x, a.x), h = Math.min(o.y, a.y), u = Math.max(o.x, a.x), d = Math.max(o.y, a.y);
    this.selectionColor && (t.fillStyle = this.selectionColor, t.fillRect(l, h, u - l, d - h)), this.selectionLineWidth && this.selectionBorderColor && (t.lineWidth = this.selectionLineWidth, t.strokeStyle = this.selectionBorderColor, l += c, h += c, u -= c, d -= c, nt.prototype._setLineDash.call(this, t, this.selectionDashArray), t.strokeRect(l, h, u - l, d - h));
  }
  findTarget(t) {
    if (this.skipTargetFind) return;
    const e = this.getViewportPoint(t), s = this._activeObject, r = this.getActiveObjects();
    if (this.targets = [], s && r.length >= 1) {
      if (s.findControl(e, Kr(t)) || r.length > 1 && this.searchPossibleTargets([s], e)) return s;
      if (s === this.searchPossibleTargets([s], e)) {
        if (this.preserveObjectStacking) {
          const n = this.targets;
          this.targets = [];
          const o = this.searchPossibleTargets(this._objects, e);
          return t[this.altSelectionKey] && o && o !== s ? (this.targets = n, s) : o;
        }
        return s;
      }
    }
    return this.searchPossibleTargets(this._objects, e);
  }
  _pointIsInObjectSelectionArea(t, e) {
    let s = t.getCoords();
    const r = this.getZoom(), n = t.padding / r;
    if (n) {
      const [o, a, c, l] = s, h = Math.atan2(a.y - o.y, a.x - o.x), u = Lt(h) * n, d = Bt(h) * n, f = u + d, g = u - d;
      s = [new _(o.x - g, o.y - f), new _(a.x + f, a.y - g), new _(c.x + g, c.y + f), new _(l.x - f, l.y + g)];
    }
    return N.isPointInPolygon(e, s);
  }
  _checkTarget(t, e) {
    return !!(t && t.visible && t.evented && this._pointIsInObjectSelectionArea(t, ae(e, void 0, this.viewportTransform)) && (!this.perPixelTargetFind && !t.perPixelTargetFind || t.isEditing || !this.isTargetTransparent(t, e.x, e.y)));
  }
  _searchPossibleTargets(t, e) {
    let s = t.length;
    for (; s--; ) {
      const r = t[s];
      if (this._checkTarget(r, e)) {
        if (Vr(r) && r.subTargetCheck) {
          const n = this._searchPossibleTargets(r._objects, e);
          n && this.targets.push(n);
        }
        return r;
      }
    }
  }
  searchPossibleTargets(t, e) {
    const s = this._searchPossibleTargets(t, e);
    if (s && Vr(s) && s.interactive && this.targets[0]) {
      const r = this.targets;
      for (let n = r.length - 1; n > 0; n--) {
        const o = r[n];
        if (!Vr(o) || !o.interactive) return o;
      }
      return r[0];
    }
    return s;
  }
  getViewportPoint(t) {
    return this._pointer ? this._pointer : this.getPointer(t, !0);
  }
  getScenePoint(t) {
    return this._absolutePointer ? this._absolutePointer : this.getPointer(t);
  }
  getPointer(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
    const s = this.upperCanvasEl, r = s.getBoundingClientRect();
    let n = tc(t), o = r.width || 0, a = r.height || 0;
    o && a || (gt in r && rn in r && (a = Math.abs(r.top - r.bottom)), Z in r && L in r && (o = Math.abs(r.right - r.left))), this.calcOffset(), n.x = n.x - this._offset.left, n.y = n.y - this._offset.top, e || (n = ae(n, void 0, this.viewportTransform));
    const c = this.getRetinaScaling();
    c !== 1 && (n.x /= c, n.y /= c);
    const l = o === 0 || a === 0 ? new _(1, 1) : new _(s.width / o, s.height / a);
    return n.multiply(l);
  }
  _setDimensionsImpl(t, e) {
    this._resetTransformEventData(), super._setDimensionsImpl(t, e), this._isCurrentlyDrawing && this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles(this.contextTop);
  }
  _createCacheCanvas() {
    this.pixelFindCanvasEl = kt(), this.pixelFindContext = this.pixelFindCanvasEl.getContext("2d", { willReadFrequently: !0 }), this.setTargetFindTolerance(this.targetFindTolerance);
  }
  getTopContext() {
    return this.elements.upper.ctx;
  }
  getSelectionContext() {
    return this.elements.upper.ctx;
  }
  getSelectionElement() {
    return this.elements.upper.el;
  }
  getActiveObject() {
    return this._activeObject;
  }
  getActiveObjects() {
    const t = this._activeObject;
    return Pe(t) ? t.getObjects() : t ? [t] : [];
  }
  _fireSelectionEvents(t, e) {
    let s = !1, r = !1;
    const n = this.getActiveObjects(), o = [], a = [];
    t.forEach((c) => {
      n.includes(c) || (s = !0, c.fire("deselected", { e, target: c }), a.push(c));
    }), n.forEach((c) => {
      t.includes(c) || (s = !0, c.fire("selected", { e, target: c }), o.push(c));
    }), t.length > 0 && n.length > 0 ? (r = !0, s && this.fire("selection:updated", { e, selected: o, deselected: a })) : n.length > 0 ? (r = !0, this.fire("selection:created", { e, selected: o })) : t.length > 0 && (r = !0, this.fire("selection:cleared", { e, deselected: a })), r && (this._objectsToRender = void 0);
  }
  setActiveObject(t, e) {
    const s = this.getActiveObjects(), r = this._setActiveObject(t, e);
    return this._fireSelectionEvents(s, e), r;
  }
  _setActiveObject(t, e) {
    const s = this._activeObject;
    return s !== t && !(!this._discardActiveObject(e, t) && this._activeObject) && !t.onSelect({ e }) && (this._activeObject = t, Pe(t) && s !== t && t.set("canvas", this), t.setCoords(), !0);
  }
  _discardActiveObject(t, e) {
    const s = this._activeObject;
    return !!s && !s.onDeselect({ e: t, object: e }) && (this._currentTransform && this._currentTransform.target === s && this.endCurrentTransform(t), Pe(s) && s === this._hoveredTarget && (this._hoveredTarget = void 0), this._activeObject = void 0, !0);
  }
  discardActiveObject(t) {
    const e = this.getActiveObjects(), s = this.getActiveObject();
    e.length && this.fire("before:selection:cleared", { e: t, deselected: [s] });
    const r = this._discardActiveObject(t);
    return this._fireSelectionEvents(e, t), r;
  }
  endCurrentTransform(t) {
    const e = this._currentTransform;
    this._finalizeCurrentTransform(t), e && e.target && (e.target.isMoving = !1), this._currentTransform = null;
  }
  _finalizeCurrentTransform(t) {
    const e = this._currentTransform, s = e.target, r = { e: t, target: s, transform: e, action: e.action };
    s._scaling && (s._scaling = !1), s.setCoords(), e.actionPerformed && (this.fire("object:modified", r), s.fire($r, r));
  }
  setViewportTransform(t) {
    super.setViewportTransform(t);
    const e = this._activeObject;
    e && e.setCoords();
  }
  destroy() {
    const t = this._activeObject;
    Pe(t) && (t.removeAll(), t.dispose()), delete this._activeObject, super.destroy(), this.pixelFindContext = null, this.pixelFindCanvasEl = void 0;
  }
  clear() {
    this.discardActiveObject(), this._activeObject = void 0, this.clearContext(this.contextTop), super.clear();
  }
  drawControls(t) {
    const e = this._activeObject;
    e && e._renderControls(t);
  }
  _toObject(t, e, s) {
    const r = this._realizeGroupTransformOnObject(t), n = super._toObject(t, e, s);
    return t.set(r), n;
  }
  _realizeGroupTransformOnObject(t) {
    const { group: e } = t;
    if (e && Pe(e) && this._activeObject === e) {
      const s = Ve(t, ["angle", "flipX", "flipY", L, ut, Tt, Os, ks, gt]);
      return ec(t, e.calcOwnMatrix()), s;
    }
    return {};
  }
  _setSVGObject(t, e, s) {
    const r = this._realizeGroupTransformOnObject(e);
    super._setSVGObject(t, e, s), e.set(r);
  }
}
y(Oi, "ownDefaults", { uniformScaling: !0, uniScaleKey: "shiftKey", centeredScaling: !1, centeredRotation: !1, centeredKey: "altKey", altActionKey: "shiftKey", selection: !0, selectionKey: "shiftKey", selectionColor: "rgba(100, 100, 255, 0.3)", selectionDashArray: [], selectionBorderColor: "rgba(255, 255, 255, 0.3)", selectionLineWidth: 1, selectionFullyContained: !1, hoverCursor: "move", moveCursor: "move", defaultCursor: "default", freeDrawingCursor: "crosshair", notAllowedCursor: "not-allowed", perPixelTargetFind: !1, targetFindTolerance: 0, skipTargetFind: !1, stopContextMenu: !1, fireRightClick: !1, fireMiddleClick: !1, enablePointerEvents: !1, containerClass: "canvas-container", preserveObjectStacking: !1 });
class id {
  constructor(t) {
    y(this, "targets", []), y(this, "__disposer", void 0);
    const e = () => {
      const { hiddenTextarea: r } = t.getActiveObject() || {};
      r && r.focus();
    }, s = t.upperCanvasEl;
    s.addEventListener("click", e), this.__disposer = () => s.removeEventListener("click", e);
  }
  exitTextEditing() {
    this.target = void 0, this.targets.forEach((t) => {
      t.isEditing && t.exitEditing();
    });
  }
  add(t) {
    this.targets.push(t);
  }
  remove(t) {
    this.unregister(t), Ee(this.targets, t);
  }
  register(t) {
    this.target = t;
  }
  unregister(t) {
    t === this.target && (this.target = void 0);
  }
  onMouseMove(t) {
    var e;
    !((e = this.target) === null || e === void 0) && e.isEditing && this.target.updateSelectionOnMouseMove(t);
  }
  clear() {
    this.targets = [], this.target = void 0;
  }
  dispose() {
    this.clear(), this.__disposer(), delete this.__disposer;
  }
}
const nd = ["target", "oldTarget", "fireCanvas", "e"], bt = { passive: !1 }, Ke = (i, t) => {
  const e = i.getViewportPoint(t), s = i.getScenePoint(t);
  return { viewportPoint: e, scenePoint: s, pointer: e, absolutePointer: s };
}, be = function(i) {
  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++) e[s - 1] = arguments[s];
  return i.addEventListener(...e);
}, xt = function(i) {
  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++) e[s - 1] = arguments[s];
  return i.removeEventListener(...e);
}, od = { mouse: { in: "over", out: "out", targetIn: "mouseover", targetOut: "mouseout", canvasIn: "mouse:over", canvasOut: "mouse:out" }, drag: { in: "enter", out: "leave", targetIn: "dragenter", targetOut: "dragleave", canvasIn: "drag:enter", canvasOut: "drag:leave" } };
class vn extends Oi {
  constructor(t) {
    super(t, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}), y(this, "_isClick", void 0), y(this, "textEditingManager", new id(this)), ["_onMouseDown", "_onTouchStart", "_onMouseMove", "_onMouseUp", "_onTouchEnd", "_onResize", "_onMouseWheel", "_onMouseOut", "_onMouseEnter", "_onContextMenu", "_onDoubleClick", "_onDragStart", "_onDragEnd", "_onDragProgress", "_onDragOver", "_onDragEnter", "_onDragLeave", "_onDrop"].forEach((e) => {
      this[e] = this[e].bind(this);
    }), this.addOrRemove(be, "add");
  }
  _getEventPrefix() {
    return this.enablePointerEvents ? "pointer" : "mouse";
  }
  addOrRemove(t, e) {
    const s = this.upperCanvasEl, r = this._getEventPrefix();
    t(Ja(s), "resize", this._onResize), t(s, r + "down", this._onMouseDown), t(s, "".concat(r, "move"), this._onMouseMove, bt), t(s, "".concat(r, "out"), this._onMouseOut), t(s, "".concat(r, "enter"), this._onMouseEnter), t(s, "wheel", this._onMouseWheel), t(s, "contextmenu", this._onContextMenu), t(s, "dblclick", this._onDoubleClick), t(s, "dragstart", this._onDragStart), t(s, "dragend", this._onDragEnd), t(s, "dragover", this._onDragOver), t(s, "dragenter", this._onDragEnter), t(s, "dragleave", this._onDragLeave), t(s, "drop", this._onDrop), this.enablePointerEvents || t(s, "touchstart", this._onTouchStart, bt);
  }
  removeListeners() {
    this.addOrRemove(xt, "remove");
    const t = this._getEventPrefix(), e = At(this.upperCanvasEl);
    xt(e, "".concat(t, "up"), this._onMouseUp), xt(e, "touchend", this._onTouchEnd, bt), xt(e, "".concat(t, "move"), this._onMouseMove, bt), xt(e, "touchmove", this._onMouseMove, bt), clearTimeout(this._willAddMouseDown);
  }
  _onMouseWheel(t) {
    this.__onMouseWheel(t);
  }
  _onMouseOut(t) {
    const e = this._hoveredTarget, s = v({ e: t }, Ke(this, t));
    this.fire("mouse:out", v(v({}, s), {}, { target: e })), this._hoveredTarget = void 0, e && e.fire("mouseout", v({}, s)), this._hoveredTargets.forEach((r) => {
      this.fire("mouse:out", v(v({}, s), {}, { target: r })), r && r.fire("mouseout", v({}, s));
    }), this._hoveredTargets = [];
  }
  _onMouseEnter(t) {
    this._currentTransform || this.findTarget(t) || (this.fire("mouse:over", v({ e: t }, Ke(this, t))), this._hoveredTarget = void 0, this._hoveredTargets = []);
  }
  _onDragStart(t) {
    this._isClick = !1;
    const e = this.getActiveObject();
    if (e && e.onDragStart(t)) {
      this._dragSource = e;
      const s = { e: t, target: e };
      return this.fire("dragstart", s), e.fire("dragstart", s), void be(this.upperCanvasEl, "drag", this._onDragProgress);
    }
    on(t);
  }
  _renderDragEffects(t, e, s) {
    let r = !1;
    const n = this._dropTarget;
    n && n !== e && n !== s && (n.clearContextTop(), r = !0), e == null || e.clearContextTop(), s !== e && (s == null || s.clearContextTop());
    const o = this.contextTop;
    o.save(), o.transform(...this.viewportTransform), e && (o.save(), e.transform(o), e.renderDragSourceEffect(t), o.restore(), r = !0), s && (o.save(), s.transform(o), s.renderDropTargetEffect(t), o.restore(), r = !0), o.restore(), r && (this.contextTopDirty = !0);
  }
  _onDragEnd(t) {
    const e = !!t.dataTransfer && t.dataTransfer.dropEffect !== pt, s = e ? this._activeObject : void 0, r = { e: t, target: this._dragSource, subTargets: this.targets, dragSource: this._dragSource, didDrop: e, dropTarget: s };
    xt(this.upperCanvasEl, "drag", this._onDragProgress), this.fire("dragend", r), this._dragSource && this._dragSource.fire("dragend", r), delete this._dragSource, this._onMouseUp(t);
  }
  _onDragProgress(t) {
    const e = { e: t, target: this._dragSource, dragSource: this._dragSource, dropTarget: this._draggedoverTarget };
    this.fire("drag", e), this._dragSource && this._dragSource.fire("drag", e);
  }
  findDragTargets(t) {
    return this.targets = [], { target: this._searchPossibleTargets(this._objects, this.getViewportPoint(t)), targets: [...this.targets] };
  }
  _onDragOver(t) {
    const e = "dragover", { target: s, targets: r } = this.findDragTargets(t), n = this._dragSource, o = { e: t, target: s, subTargets: r, dragSource: n, canDrop: !1, dropTarget: void 0 };
    let a;
    this.fire(e, o), this._fireEnterLeaveEvents(s, o), s && (s.canDrop(t) && (a = s), s.fire(e, o));
    for (let c = 0; c < r.length; c++) {
      const l = r[c];
      l.canDrop(t) && (a = l), l.fire(e, o);
    }
    this._renderDragEffects(t, n, a), this._dropTarget = a;
  }
  _onDragEnter(t) {
    const { target: e, targets: s } = this.findDragTargets(t), r = { e: t, target: e, subTargets: s, dragSource: this._dragSource };
    this.fire("dragenter", r), this._fireEnterLeaveEvents(e, r);
  }
  _onDragLeave(t) {
    const e = { e: t, target: this._draggedoverTarget, subTargets: this.targets, dragSource: this._dragSource };
    this.fire("dragleave", e), this._fireEnterLeaveEvents(void 0, e), this._renderDragEffects(t, this._dragSource), this._dropTarget = void 0, this.targets = [], this._hoveredTargets = [];
  }
  _onDrop(t) {
    const { target: e, targets: s } = this.findDragTargets(t), r = this._basicEventHandler("drop:before", v({ e: t, target: e, subTargets: s, dragSource: this._dragSource }, Ke(this, t)));
    r.didDrop = !1, r.dropTarget = void 0, this._basicEventHandler("drop", r), this.fire("drop:after", r);
  }
  _onContextMenu(t) {
    const e = this.findTarget(t), s = this.targets || [], r = this._basicEventHandler("contextmenu:before", { e: t, target: e, subTargets: s });
    return this.stopContextMenu && on(t), this._basicEventHandler("contextmenu", r), !1;
  }
  _onDoubleClick(t) {
    this._cacheTransformEventData(t), this._handleEvent(t, "dblclick"), this._resetTransformEventData();
  }
  getPointerId(t) {
    const e = t.changedTouches;
    return e ? e[0] && e[0].identifier : this.enablePointerEvents ? t.pointerId : -1;
  }
  _isMainEvent(t) {
    return t.isPrimary === !0 || t.isPrimary !== !1 && (t.type === "touchend" && t.touches.length === 0 || !t.changedTouches || t.changedTouches[0].identifier === this.mainTouchId);
  }
  _onTouchStart(t) {
    let e = !this.allowTouchScrolling;
    const s = this._activeObject;
    this.mainTouchId === void 0 && (this.mainTouchId = this.getPointerId(t)), this.__onMouseDown(t), (this.isDrawingMode || s && this._target === s) && (e = !0), e && t.preventDefault(), this._resetTransformEventData();
    const r = this.upperCanvasEl, n = this._getEventPrefix(), o = At(r);
    be(o, "touchend", this._onTouchEnd, bt), e && be(o, "touchmove", this._onMouseMove, bt), xt(r, "".concat(n, "down"), this._onMouseDown);
  }
  _onMouseDown(t) {
    this.__onMouseDown(t), this._resetTransformEventData();
    const e = this.upperCanvasEl, s = this._getEventPrefix();
    xt(e, "".concat(s, "move"), this._onMouseMove, bt);
    const r = At(e);
    be(r, "".concat(s, "up"), this._onMouseUp), be(r, "".concat(s, "move"), this._onMouseMove, bt);
  }
  _onTouchEnd(t) {
    if (t.touches.length > 0) return;
    this.__onMouseUp(t), this._resetTransformEventData(), delete this.mainTouchId;
    const e = this._getEventPrefix(), s = At(this.upperCanvasEl);
    xt(s, "touchend", this._onTouchEnd, bt), xt(s, "touchmove", this._onMouseMove, bt), this._willAddMouseDown && clearTimeout(this._willAddMouseDown), this._willAddMouseDown = setTimeout(() => {
      be(this.upperCanvasEl, "".concat(e, "down"), this._onMouseDown), this._willAddMouseDown = 0;
    }, 400);
  }
  _onMouseUp(t) {
    this.__onMouseUp(t), this._resetTransformEventData();
    const e = this.upperCanvasEl, s = this._getEventPrefix();
    if (this._isMainEvent(t)) {
      const r = At(this.upperCanvasEl);
      xt(r, "".concat(s, "up"), this._onMouseUp), xt(r, "".concat(s, "move"), this._onMouseMove, bt), be(e, "".concat(s, "move"), this._onMouseMove, bt);
    }
  }
  _onMouseMove(t) {
    const e = this.getActiveObject();
    !this.allowTouchScrolling && (!e || !e.shouldStartDragging(t)) && t.preventDefault && t.preventDefault(), this.__onMouseMove(t);
  }
  _onResize() {
    this.calcOffset(), this._resetTransformEventData();
  }
  _shouldRender(t) {
    const e = this.getActiveObject();
    return !!e != !!t || e && t && e !== t;
  }
  __onMouseUp(t) {
    var e;
    this._cacheTransformEventData(t), this._handleEvent(t, "up:before");
    const s = this._currentTransform, r = this._isClick, n = this._target, { button: o } = t;
    if (o) return (this.fireMiddleClick && o === 1 || this.fireRightClick && o === 2) && this._handleEvent(t, "up"), void this._resetTransformEventData();
    if (this.isDrawingMode && this._isCurrentlyDrawing) return void this._onMouseUpInDrawingMode(t);
    if (!this._isMainEvent(t)) return;
    let a, c, l = !1;
    if (s && (this._finalizeCurrentTransform(t), l = s.actionPerformed), !r) {
      const h = n === this._activeObject;
      this.handleSelection(t), l || (l = this._shouldRender(n) || !h && n === this._activeObject);
    }
    if (n) {
      const h = n.findControl(this.getViewportPoint(t), Kr(t)), { key: u, control: d } = h || {};
      if (c = u, n.selectable && n !== this._activeObject && n.activeOn === "up") this.setActiveObject(n, t), l = !0;
      else if (d) {
        const f = d.getMouseUpHandler(t, n, d);
        f && (a = this.getScenePoint(t), f.call(d, t, s, a.x, a.y));
      }
      n.isMoving = !1;
    }
    if (s && (s.target !== n || s.corner !== c)) {
      const h = s.target && s.target.controls[s.corner], u = h && h.getMouseUpHandler(t, s.target, h);
      a = a || this.getScenePoint(t), u && u.call(h, t, s, a.x, a.y);
    }
    this._setCursorFromEvent(t, n), this._handleEvent(t, "up"), this._groupSelector = null, this._currentTransform = null, n && (n.__corner = void 0), l ? this.requestRenderAll() : r || (e = this._activeObject) !== null && e !== void 0 && e.isEditing || this.renderTop();
  }
  _basicEventHandler(t, e) {
    const { target: s, subTargets: r = [] } = e;
    this.fire(t, e), s && s.fire(t, e);
    for (let n = 0; n < r.length; n++) r[n] !== s && r[n].fire(t, e);
    return e;
  }
  _handleEvent(t, e) {
    const s = this._target, r = this.targets || [], n = v(v({ e: t, target: s, subTargets: r }, Ke(this, t)), {}, { transform: this._currentTransform }, e === "up:before" || e === "up" ? { isClick: this._isClick, currentTarget: this.findTarget(t), currentSubTargets: this.targets } : {});
    this.fire("mouse:".concat(e), n), s && s.fire("mouse".concat(e), n);
    for (let o = 0; o < r.length; o++) r[o] !== s && r[o].fire("mouse".concat(e), n);
  }
  _onMouseDownInDrawingMode(t) {
    this._isCurrentlyDrawing = !0, this.getActiveObject() && (this.discardActiveObject(t), this.requestRenderAll());
    const e = this.getScenePoint(t);
    this.freeDrawingBrush && this.freeDrawingBrush.onMouseDown(e, { e: t, pointer: e }), this._handleEvent(t, "down");
  }
  _onMouseMoveInDrawingMode(t) {
    if (this._isCurrentlyDrawing) {
      const e = this.getScenePoint(t);
      this.freeDrawingBrush && this.freeDrawingBrush.onMouseMove(e, { e: t, pointer: e });
    }
    this.setCursor(this.freeDrawingCursor), this._handleEvent(t, "move");
  }
  _onMouseUpInDrawingMode(t) {
    const e = this.getScenePoint(t);
    this.freeDrawingBrush ? this._isCurrentlyDrawing = !!this.freeDrawingBrush.onMouseUp({ e: t, pointer: e }) : this._isCurrentlyDrawing = !1, this._handleEvent(t, "up");
  }
  __onMouseDown(t) {
    this._isClick = !0, this._cacheTransformEventData(t), this._handleEvent(t, "down:before");
    let e = this._target;
    const { button: s } = t;
    if (s) return (this.fireMiddleClick && s === 1 || this.fireRightClick && s === 2) && this._handleEvent(t, "down"), void this._resetTransformEventData();
    if (this.isDrawingMode) return void this._onMouseDownInDrawingMode(t);
    if (!this._isMainEvent(t) || this._currentTransform) return;
    let r = this._shouldRender(e), n = !1;
    if (this.handleMultiSelection(t, e) ? (e = this._activeObject, n = !0, r = !0) : this._shouldClearSelection(t, e) && this.discardActiveObject(t), this.selection && (!e || !e.selectable && !e.isEditing && e !== this._activeObject)) {
      const o = this.getScenePoint(t);
      this._groupSelector = { x: o.x, y: o.y, deltaY: 0, deltaX: 0 };
    }
    if (e) {
      const o = e === this._activeObject;
      e.selectable && e.activeOn === "down" && this.setActiveObject(e, t);
      const a = e.findControl(this.getViewportPoint(t), Kr(t));
      if (e === this._activeObject && (a || !n)) {
        this._setupCurrentTransform(t, e, o);
        const c = a ? a.control : void 0, l = this.getScenePoint(t), h = c && c.getMouseDownHandler(t, e, c);
        h && h.call(c, t, this._currentTransform, l.x, l.y);
      }
    }
    r && (this._objectsToRender = void 0), this._handleEvent(t, "down"), r && this.requestRenderAll();
  }
  _resetTransformEventData() {
    this._target = this._pointer = this._absolutePointer = void 0;
  }
  _cacheTransformEventData(t) {
    this._resetTransformEventData(), this._pointer = this.getViewportPoint(t), this._absolutePointer = ae(this._pointer, void 0, this.viewportTransform), this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(t);
  }
  __onMouseMove(t) {
    if (this._isClick = !1, this._cacheTransformEventData(t), this._handleEvent(t, "move:before"), this.isDrawingMode) return void this._onMouseMoveInDrawingMode(t);
    if (!this._isMainEvent(t)) return;
    const e = this._groupSelector;
    if (e) {
      const s = this.getScenePoint(t);
      e.deltaX = s.x - e.x, e.deltaY = s.y - e.y, this.renderTop();
    } else if (this._currentTransform) this._transformObject(t);
    else {
      const s = this.findTarget(t);
      this._setCursorFromEvent(t, s), this._fireOverOutEvents(t, s);
    }
    this.textEditingManager.onMouseMove(t), this._handleEvent(t, "move"), this._resetTransformEventData();
  }
  _fireOverOutEvents(t, e) {
    const s = this._hoveredTarget, r = this._hoveredTargets, n = this.targets, o = Math.max(r.length, n.length);
    this.fireSyntheticInOutEvents("mouse", { e: t, target: e, oldTarget: s, fireCanvas: !0 });
    for (let a = 0; a < o; a++) this.fireSyntheticInOutEvents("mouse", { e: t, target: n[a], oldTarget: r[a] });
    this._hoveredTarget = e, this._hoveredTargets = this.targets.concat();
  }
  _fireEnterLeaveEvents(t, e) {
    const s = this._draggedoverTarget, r = this._hoveredTargets, n = this.targets, o = Math.max(r.length, n.length);
    this.fireSyntheticInOutEvents("drag", v(v({}, e), {}, { target: t, oldTarget: s, fireCanvas: !0 }));
    for (let a = 0; a < o; a++) this.fireSyntheticInOutEvents("drag", v(v({}, e), {}, { target: n[a], oldTarget: r[a] }));
    this._draggedoverTarget = t;
  }
  fireSyntheticInOutEvents(t, e) {
    let { target: s, oldTarget: r, fireCanvas: n, e: o } = e, a = G(e, nd);
    const { targetIn: c, targetOut: l, canvasIn: h, canvasOut: u } = od[t], d = r !== s;
    if (r && d) {
      const f = v(v({}, a), {}, { e: o, target: r, nextTarget: s }, Ke(this, o));
      n && this.fire(u, f), r.fire(l, f);
    }
    if (s && d) {
      const f = v(v({}, a), {}, { e: o, target: s, previousTarget: r }, Ke(this, o));
      n && this.fire(h, f), s.fire(c, f);
    }
  }
  __onMouseWheel(t) {
    this._cacheTransformEventData(t), this._handleEvent(t, "wheel"), this._resetTransformEventData();
  }
  _transformObject(t) {
    const e = this.getScenePoint(t), s = this._currentTransform, r = s.target, n = r.group ? ae(e, void 0, r.group.calcTransformMatrix()) : e;
    s.shiftKey = t.shiftKey, s.altKey = !!this.centeredKey && t[this.centeredKey], this._performTransformAction(t, s, n), s.actionPerformed && this.requestRenderAll();
  }
  _performTransformAction(t, e, s) {
    const { action: r, actionHandler: n, target: o } = e, a = !!n && n(t, e, s.x, s.y);
    a && o.setCoords(), r === "drag" && a && (e.target.isMoving = !0, this.setCursor(e.target.moveCursor || this.moveCursor)), e.actionPerformed = e.actionPerformed || a;
  }
  _setCursorFromEvent(t, e) {
    if (!e) return void this.setCursor(this.defaultCursor);
    let s = e.hoverCursor || this.hoverCursor;
    const r = Pe(this._activeObject) ? this._activeObject : null, n = (!r || e.group !== r) && e.findControl(this.getViewportPoint(t));
    if (n) {
      const o = n.control;
      this.setCursor(o.cursorStyleHandler(t, o, e));
    } else e.subTargetCheck && this.targets.concat().reverse().map((o) => {
      s = o.hoverCursor || s;
    }), this.setCursor(s);
  }
  handleMultiSelection(t, e) {
    const s = this._activeObject, r = Pe(s);
    if (s && this._isSelectionKeyPressed(t) && this.selection && e && e.selectable && (s !== e || r) && (r || !e.isDescendantOf(s) && !s.isDescendantOf(e)) && !e.onSelect({ e: t }) && !s.getActiveControl()) {
      if (r) {
        const n = s.getObjects();
        if (e === s) {
          const o = this.getViewportPoint(t);
          if (!(e = this.searchPossibleTargets(n, o) || this.searchPossibleTargets(this._objects, o)) || !e.selectable) return !1;
        }
        e.group === s ? (s.remove(e), this._hoveredTarget = e, this._hoveredTargets = [...this.targets], s.size() === 1 && this._setActiveObject(s.item(0), t)) : (s.multiSelectAdd(e), this._hoveredTarget = s, this._hoveredTargets = [...this.targets]), this._fireSelectionEvents(n, t);
      } else {
        s.isEditing && s.exitEditing();
        const n = new (C.getClass("ActiveSelection"))([], { canvas: this });
        n.multiSelectAdd(s, e), this._hoveredTarget = n, this._setActiveObject(n, t), this._fireSelectionEvents([s], t);
      }
      return !0;
    }
    return !1;
  }
  handleSelection(t) {
    if (!this.selection || !this._groupSelector) return !1;
    const { x: e, y: s, deltaX: r, deltaY: n } = this._groupSelector, o = new _(e, s), a = o.add(new _(r, n)), c = o.min(a), l = o.max(a).subtract(c), h = this.collectObjects({ left: c.x, top: c.y, width: l.x, height: l.y }, { includeIntersecting: !this.selectionFullyContained }), u = o.eq(a) ? h[0] ? [h[0]] : [] : h.length > 1 ? h.filter((d) => !d.onSelect({ e: t })).reverse() : h;
    if (u.length === 1) this.setActiveObject(u[0], t);
    else if (u.length > 1) {
      const d = C.getClass("ActiveSelection");
      this.setActiveObject(new d(u, { canvas: this }), t);
    }
    return this._groupSelector = null, !0;
  }
  clear() {
    this.textEditingManager.clear(), super.clear();
  }
  destroy() {
    this.removeListeners(), this.textEditingManager.dispose(), super.destroy();
  }
}
const Uc = { x1: 0, y1: 0, x2: 0, y2: 0 }, ad = v(v({}, Uc), {}, { r1: 0, r2: 0 }), Qe = (i, t) => isNaN(i) && typeof t == "number" ? t : i, cd = /^(\d+\.\d+)%|(\d+)%$/;
function $c(i) {
  return i && cd.test(i);
}
function qc(i, t) {
  const e = typeof i == "number" ? i : typeof i == "string" ? parseFloat(i) / ($c(i) ? 100 : 1) : NaN;
  return ze(0, Qe(e, t), 1);
}
const ld = /\s*;\s*/, hd = /\s*:\s*/;
function ud(i, t) {
  let e, s;
  const r = i.getAttribute("style");
  if (r) {
    const o = r.split(ld);
    o[o.length - 1] === "" && o.pop();
    for (let a = o.length; a--; ) {
      const [c, l] = o[a].split(hd).map((h) => h.trim());
      c === "stop-color" ? e = l : c === "stop-opacity" && (s = l);
    }
  }
  const n = new W(e || i.getAttribute("stop-color") || "rgb(0,0,0)");
  return { offset: qc(i.getAttribute("offset"), 0), color: n.toRgb(), opacity: Qe(parseFloat(s || i.getAttribute("stop-opacity") || ""), 1) * n.getAlpha() * t };
}
function dd(i, t) {
  const e = [], s = i.getElementsByTagName("stop"), r = qc(t, 1);
  for (let n = s.length; n--; ) e.push(ud(s[n], r));
  return e;
}
function Kc(i) {
  return i.nodeName === "linearGradient" || i.nodeName === "LINEARGRADIENT" ? "linear" : "radial";
}
function Jc(i) {
  return i.getAttribute("gradientUnits") === "userSpaceOnUse" ? "pixels" : "percentage";
}
function jt(i, t) {
  return i.getAttribute(t);
}
function fd(i, t) {
  return function(e, s) {
    let r, { width: n, height: o, gradientUnits: a } = s;
    return Object.keys(e).reduce((c, l) => {
      const h = e[l];
      return h === "Infinity" ? r = 1 : h === "-Infinity" ? r = 0 : (r = typeof h == "string" ? parseFloat(h) : h, typeof h == "string" && $c(h) && (r *= 0.01, a === "pixels" && (l !== "x1" && l !== "x2" && l !== "r2" || (r *= n), l !== "y1" && l !== "y2" || (r *= o)))), c[l] = r, c;
    }, {});
  }(Kc(i) === "linear" ? function(e) {
    return { x1: jt(e, "x1") || 0, y1: jt(e, "y1") || 0, x2: jt(e, "x2") || "100%", y2: jt(e, "y2") || 0 };
  }(i) : function(e) {
    return { x1: jt(e, "fx") || jt(e, "cx") || "50%", y1: jt(e, "fy") || jt(e, "cy") || "50%", r1: 0, x2: jt(e, "cx") || "50%", y2: jt(e, "cy") || "50%", r2: jt(e, "r") || "50%" };
  }(i), v(v({}, t), {}, { gradientUnits: Jc(i) }));
}
class yr {
  constructor(t) {
    const { type: e = "linear", gradientUnits: s = "pixels", coords: r = {}, colorStops: n = [], offsetX: o = 0, offsetY: a = 0, gradientTransform: c, id: l } = t || {};
    Object.assign(this, { type: e, gradientUnits: s, coords: v(v({}, e === "radial" ? ad : Uc), r), colorStops: n, offsetX: o, offsetY: a, gradientTransform: c, id: l ? "".concat(l, "_").concat(we()) : we() });
  }
  addColorStop(t) {
    for (const e in t) {
      const s = new W(t[e]);
      this.colorStops.push({ offset: parseFloat(e), color: s.toRgb(), opacity: s.getAlpha() });
    }
    return this;
  }
  toObject(t) {
    return v(v({}, Ve(this, t)), {}, { type: this.type, coords: v({}, this.coords), colorStops: this.colorStops.map((e) => v({}, e)), offsetX: this.offsetX, offsetY: this.offsetY, gradientUnits: this.gradientUnits, gradientTransform: this.gradientTransform ? [...this.gradientTransform] : void 0 });
  }
  toSVG(t) {
    let { additionalTransform: e } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const s = [], r = this.gradientTransform ? this.gradientTransform.concat() : ht.concat(), n = this.gradientUnits === "pixels" ? "userSpaceOnUse" : "objectBoundingBox", o = this.colorStops.map((u) => v({}, u)).sort((u, d) => u.offset - d.offset);
    let a = -this.offsetX, c = -this.offsetY;
    var l;
    n === "objectBoundingBox" ? (a /= t.width, c /= t.height) : (a += t.width / 2, c += t.height / 2), (l = t) && typeof l._renderPathCommands == "function" && this.gradientUnits !== "percentage" && (a -= t.pathOffset.x, c -= t.pathOffset.y), r[4] -= a, r[5] -= c;
    const h = ['id="SVGID_'.concat(this.id, '"'), 'gradientUnits="'.concat(n, '"'), 'gradientTransform="'.concat(e ? e + " " : "").concat(qs(r), '"'), ""].join(" ");
    if (this.type === "linear") {
      const { x1: u, y1: d, x2: f, y2: g } = this.coords;
      s.push("<linearGradient ", h, ' x1="', u, '" y1="', d, '" x2="', f, '" y2="', g, `">
`);
    } else if (this.type === "radial") {
      const { x1: u, y1: d, x2: f, y2: g, r1: p, r2: m } = this.coords, b = p > m;
      s.push("<radialGradient ", h, ' cx="', b ? u : f, '" cy="', b ? d : g, '" r="', b ? p : m, '" fx="', b ? f : u, '" fy="', b ? g : d, `">
`), b && (o.reverse(), o.forEach((w) => {
        w.offset = 1 - w.offset;
      }));
      const S = Math.min(p, m);
      if (S > 0) {
        const w = S / Math.max(p, m);
        o.forEach((k) => {
          k.offset += w * (1 - k.offset);
        });
      }
    }
    return o.forEach((u) => {
      let { color: d, offset: f, opacity: g } = u;
      s.push("<stop ", 'offset="', 100 * f + "%", '" style="stop-color:', d, g !== void 0 ? ";stop-opacity: " + g : ";", `"/>
`);
    }), s.push(this.type === "linear" ? "</linearGradient>" : "</radialGradient>", `
`), s.join("");
  }
  toLive(t) {
    const { x1: e, y1: s, x2: r, y2: n, r1: o, r2: a } = this.coords, c = this.type === "linear" ? t.createLinearGradient(e, s, r, n) : t.createRadialGradient(e, s, o, r, n, a);
    return this.colorStops.forEach((l) => {
      let { color: h, opacity: u, offset: d } = l;
      c.addColorStop(d, u !== void 0 ? new W(h).setAlpha(u).toRgba() : h);
    }), c;
  }
  static async fromObject(t) {
    const { colorStops: e, gradientTransform: s } = t;
    return new this(v(v({}, t), {}, { colorStops: e ? e.map((r) => v({}, r)) : void 0, gradientTransform: s ? [...s] : void 0 }));
  }
  static fromElement(t, e, s) {
    const r = Jc(t), n = e._findCenterFromElement();
    return new this(v({ id: t.getAttribute("id") || void 0, type: Kc(t), coords: fd(t, { width: s.viewBoxWidth || s.width, height: s.viewBoxHeight || s.height }), colorStops: dd(t, s.opacity), gradientUnits: r, gradientTransform: fn(t.getAttribute("gradientTransform") || "") }, r === "pixels" ? { offsetX: e.width / 2 - n.x, offsetY: e.height / 2 - n.y } : { offsetX: 0, offsetY: 0 }));
  }
}
y(yr, "type", "Gradient"), C.setClass(yr, "gradient"), C.setClass(yr, "linear"), C.setClass(yr, "radial");
const gd = ["type", "source", "patternTransform"];
class Yi {
  get type() {
    return "pattern";
  }
  set type(t) {
    Te("warn", "Setting type has no effect", t);
  }
  constructor(t) {
    y(this, "repeat", "repeat"), y(this, "offsetX", 0), y(this, "offsetY", 0), y(this, "crossOrigin", ""), this.id = we(), Object.assign(this, t);
  }
  isImageSource() {
    return !!this.source && typeof this.source.src == "string";
  }
  isCanvasSource() {
    return !!this.source && !!this.source.toDataURL;
  }
  sourceToString() {
    return this.isImageSource() ? this.source.src : this.isCanvasSource() ? this.source.toDataURL() : "";
  }
  toLive(t) {
    return this.source && (!this.isImageSource() || this.source.complete && this.source.naturalWidth !== 0 && this.source.naturalHeight !== 0) ? t.createPattern(this.source, this.repeat) : null;
  }
  toObject() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const { repeat: e, crossOrigin: s } = this;
    return v(v({}, Ve(this, t)), {}, { type: "pattern", source: this.sourceToString(), repeat: e, crossOrigin: s, offsetX: V(this.offsetX, A.NUM_FRACTION_DIGITS), offsetY: V(this.offsetY, A.NUM_FRACTION_DIGITS), patternTransform: this.patternTransform ? [...this.patternTransform] : null });
  }
  toSVG(t) {
    let { width: e, height: s } = t;
    const { source: r, repeat: n, id: o } = this, a = Qe(this.offsetX / e, 0), c = Qe(this.offsetY / s, 0), l = n === "repeat-y" || n === "no-repeat" ? 1 + Math.abs(a || 0) : Qe(r.width / e, 0), h = n === "repeat-x" || n === "no-repeat" ? 1 + Math.abs(c || 0) : Qe(r.height / s, 0);
    return ['<pattern id="SVGID_'.concat(o, '" x="').concat(a, '" y="').concat(c, '" width="').concat(l, '" height="').concat(h, '">'), '<image x="0" y="0" width="'.concat(r.width, '" height="').concat(r.height, '" xlink:href="').concat(this.sourceToString(), '"></image>'), "</pattern>", ""].join(`
`);
  }
  static async fromObject(t, e) {
    let { type: s, source: r, patternTransform: n } = t, o = G(t, gd);
    const a = await Ys(r, v(v({}, e), {}, { crossOrigin: o.crossOrigin }));
    return new this(v(v({}, o), {}, { patternTransform: n && n.slice(0), source: a }));
  }
}
y(Yi, "type", "Pattern"), C.setClass(Yi), C.setClass(Yi, "pattern");
const pd = ["path", "left", "top"], md = ["d"];
class Ae extends nt {
  constructor(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, { path: s, left: r, top: n } = e, o = G(e, pd);
    super(), Object.assign(this, Ae.ownDefaults), this.setOptions(o), this._setPath(t || [], !0), typeof r == "number" && this.set(L, r), typeof n == "number" && this.set(gt, n);
  }
  _setPath(t, e) {
    this.path = Wc(Array.isArray(t) ? t : Gc(t)), this.setBoundingBox(e);
  }
  _findCenterFromElement() {
    const t = this._calcBoundsFromPath();
    return new _(t.left + t.width / 2, t.top + t.height / 2);
  }
  _renderPathCommands(t) {
    const e = -this.pathOffset.x, s = -this.pathOffset.y;
    t.beginPath();
    for (const r of this.path) switch (r[0]) {
      case "L":
        t.lineTo(r[1] + e, r[2] + s);
        break;
      case "M":
        t.moveTo(r[1] + e, r[2] + s);
        break;
      case "C":
        t.bezierCurveTo(r[1] + e, r[2] + s, r[3] + e, r[4] + s, r[5] + e, r[6] + s);
        break;
      case "Q":
        t.quadraticCurveTo(r[1] + e, r[2] + s, r[3] + e, r[4] + s);
        break;
      case "Z":
        t.closePath();
    }
  }
  _render(t) {
    this._renderPathCommands(t), this._renderPaintInOrder(t);
  }
  toString() {
    return "#<Path (".concat(this.complexity(), '): { "top": ').concat(this.top, ', "left": ').concat(this.left, " }>");
  }
  toObject() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return v(v({}, super.toObject(t)), {}, { path: this.path.map((e) => e.slice()) });
  }
  toDatalessObject() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const e = this.toObject(t);
    return this.sourcePath && (delete e.path, e.sourcePath = this.sourcePath), e;
  }
  _toSVG() {
    const t = Nc(this.path, A.NUM_FRACTION_DIGITS);
    return ["<path ", "COMMON_PARTS", 'd="'.concat(t, `" stroke-linecap="round" />
`)];
  }
  _getOffsetTransform() {
    const t = A.NUM_FRACTION_DIGITS;
    return " translate(".concat(V(-this.pathOffset.x, t), ", ").concat(V(-this.pathOffset.y, t), ")");
  }
  toClipPathSVG(t) {
    const e = this._getOffsetTransform();
    return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(), { reviver: t, additionalTransform: e });
  }
  toSVG(t) {
    const e = this._getOffsetTransform();
    return this._createBaseSVGMarkup(this._toSVG(), { reviver: t, additionalTransform: e });
  }
  complexity() {
    return this.path.length;
  }
  setDimensions() {
    this.setBoundingBox();
  }
  setBoundingBox(t) {
    const { width: e, height: s, pathOffset: r } = this._calcDimensions();
    this.set({ width: e, height: s, pathOffset: r }), t && this.setPositionByOrigin(r, j, j);
  }
  _calcBoundsFromPath() {
    const t = [];
    let e = 0, s = 0, r = 0, n = 0;
    for (const o of this.path) switch (o[0]) {
      case "L":
        r = o[1], n = o[2], t.push({ x: e, y: s }, { x: r, y: n });
        break;
      case "M":
        r = o[1], n = o[2], e = r, s = n;
        break;
      case "C":
        t.push(...mn(r, n, o[1], o[2], o[3], o[4], o[5], o[6])), r = o[5], n = o[6];
        break;
      case "Q":
        t.push(...mn(r, n, o[1], o[2], o[1], o[2], o[3], o[4])), r = o[3], n = o[4];
        break;
      case "Z":
        r = e, n = s;
    }
    return Gt(t);
  }
  _calcDimensions() {
    const t = this._calcBoundsFromPath();
    return v(v({}, t), {}, { pathOffset: new _(t.left + t.width / 2, t.top + t.height / 2) });
  }
  static fromObject(t) {
    return this._fromObject(t, { extraParam: "path" });
  }
  static async fromElement(t, e, s) {
    const r = fe(t, this.ATTRIBUTE_NAMES, s), { d: n } = r;
    return new this(n, v(v(v({}, G(r, md)), e), {}, { left: void 0, top: void 0 }));
  }
}
y(Ae, "type", "Path"), y(Ae, "cacheProperties", [...de, "path", "fillRule"]), y(Ae, "ATTRIBUTE_NAMES", [...De, "d"]), C.setClass(Ae), C.setSVGClass(Ae);
const vd = ["left", "top", "radius"], Zc = ["radius", "startAngle", "endAngle", "counterClockwise"];
class se extends nt {
  static getDefaults() {
    return v(v({}, super.getDefaults()), se.ownDefaults);
  }
  constructor(t) {
    super(), Object.assign(this, se.ownDefaults), this.setOptions(t);
  }
  _set(t, e) {
    return super._set(t, e), t === "radius" && this.setRadius(e), this;
  }
  _render(t) {
    t.beginPath(), t.arc(0, 0, this.radius, K(this.startAngle), K(this.endAngle), this.counterClockwise), this._renderPaintInOrder(t);
  }
  getRadiusX() {
    return this.get("radius") * this.get(ut);
  }
  getRadiusY() {
    return this.get("radius") * this.get(Tt);
  }
  setRadius(t) {
    this.radius = t, this.set({ width: 2 * t, height: 2 * t });
  }
  toObject() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject([...Zc, ...t]);
  }
  _toSVG() {
    const t = (this.endAngle - this.startAngle) % 360;
    if (t === 0) return ["<circle ", "COMMON_PARTS", 'cx="0" cy="0" ', 'r="', "".concat(this.radius), `" />
`];
    {
      const { radius: e } = this, s = K(this.startAngle), r = K(this.endAngle), n = Lt(s) * e, o = Bt(s) * e, a = Lt(r) * e, c = Bt(r) * e, l = t > 180 ? 1 : 0, h = this.counterClockwise ? 0 : 1;
      return ['<path d="M '.concat(n, " ").concat(o, " A ").concat(e, " ").concat(e, " 0 ").concat(l, " ").concat(h, " ").concat(a, " ").concat(c, '" '), "COMMON_PARTS", ` />
`];
    }
  }
  static async fromElement(t, e, s) {
    const r = fe(t, this.ATTRIBUTE_NAMES, s), { left: n = 0, top: o = 0, radius: a = 0 } = r;
    return new this(v(v({}, G(r, vd)), {}, { radius: a, left: n - a, top: o - a }));
  }
  static fromObject(t) {
    return super._fromObject(t);
  }
}
y(se, "type", "Circle"), y(se, "cacheProperties", [...de, ...Zc]), y(se, "ownDefaults", { radius: 0, startAngle: 0, endAngle: 360, counterClockwise: !1 }), y(se, "ATTRIBUTE_NAMES", ["cx", "cy", "r", ...De]), C.setClass(se), C.setSVGClass(se);
const yd = ["x1", "y1", "x2", "y2"], bd = ["x1", "y1", "x2", "y2"], yn = ["x1", "x2", "y1", "y2"];
class Se extends nt {
  constructor() {
    let [t, e, s, r] = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [0, 0, 0, 0], n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), Object.assign(this, Se.ownDefaults), this.setOptions(n), this.x1 = t, this.x2 = s, this.y1 = e, this.y2 = r, this._setWidthHeight();
    const { left: o, top: a } = n;
    typeof o == "number" && this.set(L, o), typeof a == "number" && this.set(gt, a);
  }
  _setWidthHeight() {
    const { x1: t, y1: e, x2: s, y2: r } = this;
    this.width = Math.abs(s - t), this.height = Math.abs(r - e);
    const { left: n, top: o, width: a, height: c } = Gt([{ x: t, y: e }, { x: s, y: r }]), l = new _(n + a / 2, o + c / 2);
    this.setPositionByOrigin(l, j, j);
  }
  _set(t, e) {
    return super._set(t, e), yn.includes(t) && this._setWidthHeight(), this;
  }
  _render(t) {
    t.beginPath();
    const e = this.calcLinePoints();
    t.moveTo(e.x1, e.y1), t.lineTo(e.x2, e.y2), t.lineWidth = this.strokeWidth;
    const s = t.strokeStyle;
    var r;
    Ct(this.stroke) ? t.strokeStyle = this.stroke.toLive(t) : t.strokeStyle = (r = this.stroke) !== null && r !== void 0 ? r : t.fillStyle, this.stroke && this._renderStroke(t), t.strokeStyle = s;
  }
  _findCenterFromElement() {
    return new _((this.x1 + this.x2) / 2, (this.y1 + this.y2) / 2);
  }
  toObject() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return v(v({}, super.toObject(t)), this.calcLinePoints());
  }
  _getNonTransformedDimensions() {
    const t = super._getNonTransformedDimensions();
    return this.strokeLineCap === "butt" && (this.width === 0 && (t.y -= this.strokeWidth), this.height === 0 && (t.x -= this.strokeWidth)), t;
  }
  calcLinePoints() {
    const { x1: t, x2: e, y1: s, y2: r, width: n, height: o } = this, a = t <= e ? -1 : 1, c = s <= r ? -1 : 1;
    return { x1: a * n / 2, x2: a * -n / 2, y1: c * o / 2, y2: c * -o / 2 };
  }
  _toSVG() {
    const { x1: t, x2: e, y1: s, y2: r } = this.calcLinePoints();
    return ["<line ", "COMMON_PARTS", 'x1="'.concat(t, '" y1="').concat(s, '" x2="').concat(e, '" y2="').concat(r, `" />
`)];
  }
  static async fromElement(t, e, s) {
    const r = fe(t, this.ATTRIBUTE_NAMES, s), { x1: n = 0, y1: o = 0, x2: a = 0, y2: c = 0 } = r;
    return new this([n, o, a, c], G(r, yd));
  }
  static fromObject(t) {
    let { x1: e, y1: s, x2: r, y2: n } = t, o = G(t, bd);
    return this._fromObject(v(v({}, o), {}, { points: [e, s, r, n] }), { extraParam: "points" });
  }
}
y(Se, "type", "Line"), y(Se, "cacheProperties", [...de, ...yn]), y(Se, "ATTRIBUTE_NAMES", De.concat(yn)), C.setClass(Se), C.setSVGClass(Se);
class Re extends nt {
  static getDefaults() {
    return v(v({}, super.getDefaults()), Re.ownDefaults);
  }
  constructor(t) {
    super(), Object.assign(this, Re.ownDefaults), this.setOptions(t);
  }
  _render(t) {
    const e = this.width / 2, s = this.height / 2;
    t.beginPath(), t.moveTo(-e, s), t.lineTo(0, -s), t.lineTo(e, s), t.closePath(), this._renderPaintInOrder(t);
  }
  _toSVG() {
    const t = this.width / 2, e = this.height / 2;
    return ["<polygon ", "COMMON_PARTS", 'points="', "".concat(-t, " ").concat(e, ",0 ").concat(-e, ",").concat(t, " ").concat(e), '" />'];
  }
}
y(Re, "type", "Triangle"), y(Re, "ownDefaults", { width: 100, height: 100 }), C.setClass(Re), C.setSVGClass(Re);
const Qc = ["rx", "ry"];
class re extends nt {
  static getDefaults() {
    return v(v({}, super.getDefaults()), re.ownDefaults);
  }
  constructor(t) {
    super(), Object.assign(this, re.ownDefaults), this.setOptions(t);
  }
  _set(t, e) {
    switch (super._set(t, e), t) {
      case "rx":
        this.rx = e, this.set("width", 2 * e);
        break;
      case "ry":
        this.ry = e, this.set("height", 2 * e);
    }
    return this;
  }
  getRx() {
    return this.get("rx") * this.get(ut);
  }
  getRy() {
    return this.get("ry") * this.get(Tt);
  }
  toObject() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject([...Qc, ...t]);
  }
  _toSVG() {
    return ["<ellipse ", "COMMON_PARTS", 'cx="0" cy="0" rx="'.concat(this.rx, '" ry="').concat(this.ry, `" />
`)];
  }
  _render(t) {
    t.beginPath(), t.save(), t.transform(1, 0, 0, this.ry / this.rx, 0, 0), t.arc(0, 0, this.rx, 0, he, !1), t.restore(), this._renderPaintInOrder(t);
  }
  static async fromElement(t, e, s) {
    const r = fe(t, this.ATTRIBUTE_NAMES, s);
    return r.left = (r.left || 0) - r.rx, r.top = (r.top || 0) - r.ry, new this(r);
  }
}
function _d(i) {
  if (!i) return [];
  const t = i.replace(/,/g, " ").trim().split(/\s+/), e = [];
  for (let s = 0; s < t.length; s += 2) e.push({ x: parseFloat(t[s]), y: parseFloat(t[s + 1]) });
  return e;
}
y(re, "type", "Ellipse"), y(re, "cacheProperties", [...de, ...Qc]), y(re, "ownDefaults", { rx: 0, ry: 0 }), y(re, "ATTRIBUTE_NAMES", [...De, "cx", "cy", "rx", "ry"]), C.setClass(re), C.setSVGClass(re);
const Sd = ["left", "top"], tl = { exactBoundingBox: !1 };
class Et extends nt {
  static getDefaults() {
    return v(v({}, super.getDefaults()), Et.ownDefaults);
  }
  constructor() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), y(this, "strokeDiff", void 0), Object.assign(this, Et.ownDefaults), this.setOptions(e), this.points = t;
    const { left: s, top: r } = e;
    this.initialized = !0, this.setBoundingBox(!0), typeof s == "number" && this.set(L, s), typeof r == "number" && this.set(gt, r);
  }
  isOpen() {
    return !0;
  }
  _projectStrokeOnPoints(t) {
    return Dc(this.points, t, this.isOpen());
  }
  _calcDimensions(t) {
    t = v({ scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, strokeLineCap: this.strokeLineCap, strokeLineJoin: this.strokeLineJoin, strokeMiterLimit: this.strokeMiterLimit, strokeUniform: this.strokeUniform, strokeWidth: this.strokeWidth }, t || {});
    const e = this.exactBoundingBox ? this._projectStrokeOnPoints(t).map((l) => l.projectedPoint) : this.points;
    if (e.length === 0) return { left: 0, top: 0, width: 0, height: 0, pathOffset: new _(), strokeOffset: new _(), strokeDiff: new _() };
    const s = Gt(e), r = ar(v(v({}, t), {}, { scaleX: 1, scaleY: 1 })), n = Gt(this.points.map((l) => ot(l, r, !0))), o = new _(this.scaleX, this.scaleY);
    let a = s.left + s.width / 2, c = s.top + s.height / 2;
    return this.exactBoundingBox && (a -= c * Math.tan(K(this.skewX)), c -= a * Math.tan(K(this.skewY))), v(v({}, s), {}, { pathOffset: new _(a, c), strokeOffset: new _(n.left, n.top).subtract(new _(s.left, s.top)).multiply(o), strokeDiff: new _(s.width, s.height).subtract(new _(n.width, n.height)).multiply(o) });
  }
  _findCenterFromElement() {
    const t = Gt(this.points);
    return new _(t.left + t.width / 2, t.top + t.height / 2);
  }
  setDimensions() {
    this.setBoundingBox();
  }
  setBoundingBox(t) {
    const { left: e, top: s, width: r, height: n, pathOffset: o, strokeOffset: a, strokeDiff: c } = this._calcDimensions();
    this.set({ width: r, height: n, pathOffset: o, strokeOffset: a, strokeDiff: c }), t && this.setPositionByOrigin(new _(e + r / 2, s + n / 2), j, j);
  }
  isStrokeAccountedForInDimensions() {
    return this.exactBoundingBox;
  }
  _getNonTransformedDimensions() {
    return this.exactBoundingBox ? new _(this.width, this.height) : super._getNonTransformedDimensions();
  }
  _getTransformedDimensions() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (this.exactBoundingBox) {
      let o;
      if (Object.keys(t).some((a) => this.strokeUniform || this.constructor.layoutProperties.includes(a))) {
        var e, s;
        const { width: a, height: c } = this._calcDimensions(t);
        o = new _((e = t.width) !== null && e !== void 0 ? e : a, (s = t.height) !== null && s !== void 0 ? s : c);
      } else {
        var r, n;
        o = new _((r = t.width) !== null && r !== void 0 ? r : this.width, (n = t.height) !== null && n !== void 0 ? n : this.height);
      }
      return o.multiply(new _(t.scaleX || this.scaleX, t.scaleY || this.scaleY));
    }
    return super._getTransformedDimensions(t);
  }
  _set(t, e) {
    const s = this.initialized && this[t] !== e, r = super._set(t, e);
    return this.exactBoundingBox && s && ((t === ut || t === Tt) && this.strokeUniform && this.constructor.layoutProperties.includes("strokeUniform") || this.constructor.layoutProperties.includes(t)) && this.setDimensions(), r;
  }
  toObject() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return v(v({}, super.toObject(t)), {}, { points: this.points.map((e) => {
      let { x: s, y: r } = e;
      return { x: s, y: r };
    }) });
  }
  _toSVG() {
    const t = [], e = this.pathOffset.x, s = this.pathOffset.y, r = A.NUM_FRACTION_DIGITS;
    for (let n = 0, o = this.points.length; n < o; n++) t.push(V(this.points[n].x - e, r), ",", V(this.points[n].y - s, r), " ");
    return ["<".concat(this.constructor.type.toLowerCase(), " "), "COMMON_PARTS", 'points="'.concat(t.join(""), `" />
`)];
  }
  _render(t) {
    const e = this.points.length, s = this.pathOffset.x, r = this.pathOffset.y;
    if (e && !isNaN(this.points[e - 1].y)) {
      t.beginPath(), t.moveTo(this.points[0].x - s, this.points[0].y - r);
      for (let n = 0; n < e; n++) {
        const o = this.points[n];
        t.lineTo(o.x - s, o.y - r);
      }
      !this.isOpen() && t.closePath(), this._renderPaintInOrder(t);
    }
  }
  complexity() {
    return this.points.length;
  }
  static async fromElement(t, e, s) {
    return new this(_d(t.getAttribute("points")), v(v({}, G(fe(t, this.ATTRIBUTE_NAMES, s), Sd)), e));
  }
  static fromObject(t) {
    return this._fromObject(t, { extraParam: "points" });
  }
}
y(Et, "ownDefaults", tl), y(Et, "type", "Polyline"), y(Et, "layoutProperties", [Os, ks, "strokeLineCap", "strokeLineJoin", "strokeMiterLimit", "strokeWidth", "strokeUniform", "points"]), y(Et, "cacheProperties", [...de, "points"]), y(Et, "ATTRIBUTE_NAMES", [...De]), C.setClass(Et), C.setSVGClass(Et);
class br extends Et {
  isOpen() {
    return !1;
  }
}
y(br, "ownDefaults", tl), y(br, "type", "Polygon"), C.setClass(br), C.setSVGClass(br);
const el = ["fontSize", "fontWeight", "fontFamily", "fontStyle"], sl = ["underline", "overline", "linethrough"], rl = [...el, "lineHeight", "text", "charSpacing", "textAlign", "styles", "path", "pathStartOffset", "pathSide", "pathAlign"], il = [...rl, ...sl, "textBackgroundColor", "direction"], Td = [...el, ...sl, mt, "strokeWidth", rt, "deltaY", "textBackgroundColor"], xd = { _reNewline: Pn, _reSpacesAndTabs: /[ \t\r]/g, _reSpaceAndTab: /[ \t\r]/, _reWords: /\S+/g, fontSize: 40, fontWeight: "normal", fontFamily: "Times New Roman", underline: !1, overline: !1, linethrough: !1, textAlign: L, fontStyle: "normal", lineHeight: 1.16, superscript: { size: 0.6, baseline: -0.35 }, subscript: { size: 0.6, baseline: 0.11 }, textBackgroundColor: "", stroke: null, shadow: null, path: void 0, pathStartOffset: 0, pathSide: L, pathAlign: "baseline", _fontSizeFraction: 0.222, offsets: { underline: 0.1, linethrough: -0.315, overline: -0.88 }, _fontSizeMult: 1.13, charSpacing: 0, deltaY: 0, direction: "ltr", CACHE_FONT_SIZE: 400, MIN_TEXT_WIDTH: 2 }, Ht = "justify", ni = "justify-left", Vs = "justify-right", Gs = "justify-center";
class nl extends nt {
  isEmptyStyles(t) {
    if (!this.styles || t !== void 0 && !this.styles[t]) return !0;
    const e = t === void 0 ? this.styles : { line: this.styles[t] };
    for (const s in e) for (const r in e[s]) for (const n in e[s][r]) return !1;
    return !0;
  }
  styleHas(t, e) {
    if (!this.styles || e !== void 0 && !this.styles[e]) return !1;
    const s = e === void 0 ? this.styles : { 0: this.styles[e] };
    for (const r in s) for (const n in s[r]) if (s[r][n][t] !== void 0) return !0;
    return !1;
  }
  cleanStyle(t) {
    if (!this.styles) return !1;
    const e = this.styles;
    let s, r, n = 0, o = !0, a = 0;
    for (const c in e) {
      s = 0;
      for (const l in e[c]) {
        const h = e[c][l] || {};
        n++, h[t] !== void 0 ? (r ? h[t] !== r && (o = !1) : r = h[t], h[t] === this[t] && delete h[t]) : o = !1, Object.keys(h).length !== 0 ? s++ : delete e[c][l];
      }
      s === 0 && delete e[c];
    }
    for (let c = 0; c < this._textLines.length; c++) a += this._textLines[c].length;
    o && n === a && (this[t] = r, this.removeStyle(t));
  }
  removeStyle(t) {
    if (!this.styles) return;
    const e = this.styles;
    let s, r, n;
    for (r in e) {
      for (n in s = e[r], s) delete s[n][t], Object.keys(s[n]).length === 0 && delete s[n];
      Object.keys(s).length === 0 && delete e[r];
    }
  }
  _extendStyles(t, e) {
    const { lineIndex: s, charIndex: r } = this.get2DCursorLocation(t);
    this._getLineStyle(s) || this._setLineStyle(s);
    const n = Xn(v(v({}, this._getStyleDeclaration(s, r)), e), (o) => o !== void 0);
    this._setStyleDeclaration(s, r, n);
  }
  getSelectionStyles(t, e, s) {
    const r = [];
    for (let n = t; n < (e || t); n++) r.push(this.getStyleAtPosition(n, s));
    return r;
  }
  getStyleAtPosition(t, e) {
    const { lineIndex: s, charIndex: r } = this.get2DCursorLocation(t);
    return e ? this.getCompleteStyleDeclaration(s, r) : this._getStyleDeclaration(s, r);
  }
  setSelectionStyles(t, e, s) {
    for (let r = e; r < (s || e); r++) this._extendStyles(r, t);
    this._forceClearCache = !0;
  }
  _getStyleDeclaration(t, e) {
    var s;
    const r = this.styles && this.styles[t];
    return r && (s = r[e]) !== null && s !== void 0 ? s : {};
  }
  getCompleteStyleDeclaration(t, e) {
    return v(v({}, Ve(this, this.constructor._styleProperties)), this._getStyleDeclaration(t, e));
  }
  _setStyleDeclaration(t, e, s) {
    this.styles[t][e] = s;
  }
  _deleteStyleDeclaration(t, e) {
    delete this.styles[t][e];
  }
  _getLineStyle(t) {
    return !!this.styles[t];
  }
  _setLineStyle(t) {
    this.styles[t] = {};
  }
  _deleteLineStyle(t) {
    delete this.styles[t];
  }
}
y(nl, "_styleProperties", Td);
const wd = /  +/g, Cd = /"/g;
function Vi(i, t, e, s, r) {
  return "		".concat(function(n, o) {
    let { left: a, top: c, width: l, height: h } = o, u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : A.NUM_FRACTION_DIGITS;
    const d = Ks(rt, n, !1), [f, g, p, m] = [a, c, l, h].map((b) => V(b, u));
    return "<rect ".concat(d, ' x="').concat(f, '" y="').concat(g, '" width="').concat(p, '" height="').concat(m, '"></rect>');
  }(i, { left: t, top: e, width: s, height: r }), `
`);
}
const Od = ["textAnchor", "textDecoration", "dx", "dy", "top", "left", "fontSize", "strokeWidth"];
let Gi;
class ct extends nl {
  static getDefaults() {
    return v(v({}, super.getDefaults()), ct.ownDefaults);
  }
  constructor(t, e) {
    super(), y(this, "__charBounds", []), Object.assign(this, ct.ownDefaults), this.setOptions(e), this.styles || (this.styles = {}), this.text = t, this.initialized = !0, this.path && this.setPathInfo(), this.initDimensions(), this.setCoords();
  }
  setPathInfo() {
    const t = this.path;
    t && (t.segmentsInfo = Qn(t.path));
  }
  _splitText() {
    const t = this._splitTextIntoLines(this.text);
    return this.textLines = t.lines, this._textLines = t.graphemeLines, this._unwrappedTextLines = t._unwrappedLines, this._text = t.graphemeText, t;
  }
  initDimensions() {
    this._splitText(), this._clearCache(), this.dirty = !0, this.path ? (this.width = this.path.width, this.height = this.path.height) : (this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH, this.height = this.calcTextHeight()), this.textAlign.includes(Ht) && this.enlargeSpaces();
  }
  enlargeSpaces() {
    let t, e, s, r, n, o, a;
    for (let c = 0, l = this._textLines.length; c < l; c++) if ((this.textAlign === Ht || c !== l - 1 && !this.isEndOfWrapping(c)) && (r = 0, n = this._textLines[c], e = this.getLineWidth(c), e < this.width && (a = this.textLines[c].match(this._reSpacesAndTabs)))) {
      s = a.length, t = (this.width - e) / s;
      for (let h = 0; h <= n.length; h++) o = this.__charBounds[c][h], this._reSpaceAndTab.test(n[h]) ? (o.width += t, o.kernedWidth += t, o.left += r, r += t) : o.left += r;
    }
  }
  isEndOfWrapping(t) {
    return t === this._textLines.length - 1;
  }
  missingNewlineOffset(t) {
    return 1;
  }
  get2DCursorLocation(t, e) {
    const s = e ? this._unwrappedTextLines : this._textLines;
    let r;
    for (r = 0; r < s.length; r++) {
      if (t <= s[r].length) return { lineIndex: r, charIndex: t };
      t -= s[r].length + this.missingNewlineOffset(r, e);
    }
    return { lineIndex: r - 1, charIndex: s[r - 1].length < t ? s[r - 1].length : t };
  }
  toString() {
    return "#<Text (".concat(this.complexity(), '): { "text": "').concat(this.text, '", "fontFamily": "').concat(this.fontFamily, '" }>');
  }
  _getCacheCanvasDimensions() {
    const t = super._getCacheCanvasDimensions(), e = this.fontSize;
    return t.width += e * t.zoomX, t.height += e * t.zoomY, t;
  }
  _render(t) {
    const e = this.path;
    e && !e.isNotVisible() && e._render(t), this._setTextStyles(t), this._renderTextLinesBackground(t), this._renderTextDecoration(t, "underline"), this._renderText(t), this._renderTextDecoration(t, "overline"), this._renderTextDecoration(t, "linethrough");
  }
  _renderText(t) {
    this.paintFirst === mt ? (this._renderTextStroke(t), this._renderTextFill(t)) : (this._renderTextFill(t), this._renderTextStroke(t));
  }
  _setTextStyles(t, e, s) {
    if (t.textBaseline = "alphabetic", this.path) switch (this.pathAlign) {
      case j:
        t.textBaseline = "middle";
        break;
      case "ascender":
        t.textBaseline = gt;
        break;
      case "descender":
        t.textBaseline = rn;
    }
    t.font = this._getFontDeclaration(e, s);
  }
  calcTextWidth() {
    let t = this.getLineWidth(0);
    for (let e = 1, s = this._textLines.length; e < s; e++) {
      const r = this.getLineWidth(e);
      r > t && (t = r);
    }
    return t;
  }
  _renderTextLine(t, e, s, r, n, o) {
    this._renderChars(t, e, s, r, n, o);
  }
  _renderTextLinesBackground(t) {
    if (!this.textBackgroundColor && !this.styleHas("textBackgroundColor")) return;
    const e = t.fillStyle, s = this._getLeftOffset();
    let r = this._getTopOffset();
    for (let n = 0, o = this._textLines.length; n < o; n++) {
      const a = this.getHeightOfLine(n);
      if (!this.textBackgroundColor && !this.styleHas("textBackgroundColor", n)) {
        r += a;
        continue;
      }
      const c = this._textLines[n].length, l = this._getLineLeftOffset(n);
      let h, u, d = 0, f = 0, g = this.getValueOfPropertyAt(n, 0, "textBackgroundColor");
      for (let p = 0; p < c; p++) {
        const m = this.__charBounds[n][p];
        u = this.getValueOfPropertyAt(n, p, "textBackgroundColor"), this.path ? (t.save(), t.translate(m.renderLeft, m.renderTop), t.rotate(m.angle), t.fillStyle = u, u && t.fillRect(-m.width / 2, -a / this.lineHeight * (1 - this._fontSizeFraction), m.width, a / this.lineHeight), t.restore()) : u !== g ? (h = s + l + f, this.direction === "rtl" && (h = this.width - h - d), t.fillStyle = g, g && t.fillRect(h, r, d, a / this.lineHeight), f = m.left, d = m.width, g = u) : d += m.kernedWidth;
      }
      u && !this.path && (h = s + l + f, this.direction === "rtl" && (h = this.width - h - d), t.fillStyle = u, t.fillRect(h, r, d, a / this.lineHeight)), r += a;
    }
    t.fillStyle = e, this._removeShadow(t);
  }
  _measureChar(t, e, s, r) {
    const n = zs.getFontCache(e), o = this._getFontDeclaration(e), a = s + t, c = s && o === this._getFontDeclaration(r), l = e.fontSize / this.CACHE_FONT_SIZE;
    let h, u, d, f;
    if (s && n[s] !== void 0 && (d = n[s]), n[t] !== void 0 && (f = h = n[t]), c && n[a] !== void 0 && (u = n[a], f = u - d), h === void 0 || d === void 0 || u === void 0) {
      const g = function() {
        return Gi || (Gi = Wt({ width: 0, height: 0 }).getContext("2d")), Gi;
      }();
      this._setTextStyles(g, e, !0), h === void 0 && (f = h = g.measureText(t).width, n[t] = h), d === void 0 && c && s && (d = g.measureText(s).width, n[s] = d), c && u === void 0 && (u = g.measureText(a).width, n[a] = u, f = u - d);
    }
    return { width: h * l, kernedWidth: f * l };
  }
  getHeightOfChar(t, e) {
    return this.getValueOfPropertyAt(t, e, "fontSize");
  }
  measureLine(t) {
    const e = this._measureLine(t);
    return this.charSpacing !== 0 && (e.width -= this._getWidthOfCharSpacing()), e.width < 0 && (e.width = 0), e;
  }
  _measureLine(t) {
    let e, s, r = 0;
    const n = this.pathSide === Z, o = this.path, a = this._textLines[t], c = a.length, l = new Array(c);
    this.__charBounds[t] = l;
    for (let h = 0; h < c; h++) {
      const u = a[h];
      s = this._getGraphemeBox(u, t, h, e), l[h] = s, r += s.kernedWidth, e = u;
    }
    if (l[c] = { left: s ? s.left + s.width : 0, width: 0, kernedWidth: 0, height: this.fontSize, deltaY: 0 }, o && o.segmentsInfo) {
      let h = 0;
      const u = o.segmentsInfo[o.segmentsInfo.length - 1].length;
      switch (this.textAlign) {
        case L:
          h = n ? u - r : 0;
          break;
        case j:
          h = (u - r) / 2;
          break;
        case Z:
          h = n ? 0 : u - r;
      }
      h += this.pathStartOffset * (n ? -1 : 1);
      for (let d = n ? c - 1 : 0; n ? d >= 0 : d < c; n ? d-- : d++) s = l[d], h > u ? h %= u : h < 0 && (h += u), this._setGraphemeOnPath(h, s), h += s.kernedWidth;
    }
    return { width: r, numOfSpaces: 0 };
  }
  _setGraphemeOnPath(t, e) {
    const s = t + e.kernedWidth / 2, r = this.path, n = Vc(r.path, s, r.segmentsInfo);
    e.renderLeft = n.x - r.pathOffset.x, e.renderTop = n.y - r.pathOffset.y, e.angle = n.angle + (this.pathSide === Z ? Math.PI : 0);
  }
  _getGraphemeBox(t, e, s, r, n) {
    const o = this.getCompleteStyleDeclaration(e, s), a = r ? this.getCompleteStyleDeclaration(e, s - 1) : {}, c = this._measureChar(t, o, r, a);
    let l, h = c.kernedWidth, u = c.width;
    this.charSpacing !== 0 && (l = this._getWidthOfCharSpacing(), u += l, h += l);
    const d = { width: u, left: 0, height: o.fontSize, kernedWidth: h, deltaY: o.deltaY };
    if (s > 0 && !n) {
      const f = this.__charBounds[e][s - 1];
      d.left = f.left + f.width + c.kernedWidth - c.width;
    }
    return d;
  }
  getHeightOfLine(t) {
    if (this.__lineHeights[t]) return this.__lineHeights[t];
    let e = this.getHeightOfChar(t, 0);
    for (let s = 1, r = this._textLines[t].length; s < r; s++) e = Math.max(this.getHeightOfChar(t, s), e);
    return this.__lineHeights[t] = e * this.lineHeight * this._fontSizeMult;
  }
  calcTextHeight() {
    let t, e = 0;
    for (let s = 0, r = this._textLines.length; s < r; s++) t = this.getHeightOfLine(s), e += s === r - 1 ? t / this.lineHeight : t;
    return e;
  }
  _getLeftOffset() {
    return this.direction === "ltr" ? -this.width / 2 : this.width / 2;
  }
  _getTopOffset() {
    return -this.height / 2;
  }
  _renderTextCommon(t, e) {
    t.save();
    let s = 0;
    const r = this._getLeftOffset(), n = this._getTopOffset();
    for (let o = 0, a = this._textLines.length; o < a; o++) {
      const c = this.getHeightOfLine(o), l = c / this.lineHeight, h = this._getLineLeftOffset(o);
      this._renderTextLine(e, t, this._textLines[o], r + h, n + s + l, o), s += c;
    }
    t.restore();
  }
  _renderTextFill(t) {
    (this.fill || this.styleHas(rt)) && this._renderTextCommon(t, "fillText");
  }
  _renderTextStroke(t) {
    (this.stroke && this.strokeWidth !== 0 || !this.isEmptyStyles()) && (this.shadow && !this.shadow.affectStroke && this._removeShadow(t), t.save(), this._setLineDash(t, this.strokeDashArray), t.beginPath(), this._renderTextCommon(t, "strokeText"), t.closePath(), t.restore());
  }
  _renderChars(t, e, s, r, n, o) {
    const a = this.getHeightOfLine(o), c = this.textAlign.includes(Ht), l = this.path, h = !c && this.charSpacing === 0 && this.isEmptyStyles(o) && !l, u = this.direction === "ltr", d = this.direction === "ltr" ? 1 : -1, f = e.direction;
    let g, p, m, b, S, w = "", k = 0;
    if (e.save(), f !== this.direction && (e.canvas.setAttribute("dir", u ? "ltr" : "rtl"), e.direction = u ? "ltr" : "rtl", e.textAlign = u ? L : Z), n -= a * this._fontSizeFraction / this.lineHeight, h) return this._renderChar(t, e, o, 0, s.join(""), r, n), void e.restore();
    for (let O = 0, x = s.length - 1; O <= x; O++) b = O === x || this.charSpacing || l, w += s[O], m = this.__charBounds[o][O], k === 0 ? (r += d * (m.kernedWidth - m.width), k += m.width) : k += m.kernedWidth, c && !b && this._reSpaceAndTab.test(s[O]) && (b = !0), b || (g = g || this.getCompleteStyleDeclaration(o, O), p = this.getCompleteStyleDeclaration(o, O + 1), b = wi(g, p, !1)), b && (l ? (e.save(), e.translate(m.renderLeft, m.renderTop), e.rotate(m.angle), this._renderChar(t, e, o, O, w, -k / 2, 0), e.restore()) : (S = r, this._renderChar(t, e, o, O, w, S, n)), w = "", g = p, r += d * k, k = 0);
    e.restore();
  }
  _applyPatternGradientTransformText(t) {
    const e = this.width + this.strokeWidth, s = this.height + this.strokeWidth, r = Wt({ width: e, height: s }), n = r.getContext("2d");
    return r.width = e, r.height = s, n.beginPath(), n.moveTo(0, 0), n.lineTo(e, 0), n.lineTo(e, s), n.lineTo(0, s), n.closePath(), n.translate(e / 2, s / 2), n.fillStyle = t.toLive(n), this._applyPatternGradientTransform(n, t), n.fill(), n.createPattern(r, "no-repeat");
  }
  handleFiller(t, e, s) {
    let r, n;
    return Ct(s) ? s.gradientUnits === "percentage" || s.gradientTransform || s.patternTransform ? (r = -this.width / 2, n = -this.height / 2, t.translate(r, n), t[e] = this._applyPatternGradientTransformText(s), { offsetX: r, offsetY: n }) : (t[e] = s.toLive(t), this._applyPatternGradientTransform(t, s)) : (t[e] = s, { offsetX: 0, offsetY: 0 });
  }
  _setStrokeStyles(t, e) {
    let { stroke: s, strokeWidth: r } = e;
    return t.lineWidth = r, t.lineCap = this.strokeLineCap, t.lineDashOffset = this.strokeDashOffset, t.lineJoin = this.strokeLineJoin, t.miterLimit = this.strokeMiterLimit, this.handleFiller(t, "strokeStyle", s);
  }
  _setFillStyles(t, e) {
    let { fill: s } = e;
    return this.handleFiller(t, "fillStyle", s);
  }
  _renderChar(t, e, s, r, n, o, a) {
    const c = this._getStyleDeclaration(s, r), l = this.getCompleteStyleDeclaration(s, r), h = t === "fillText" && l.fill, u = t === "strokeText" && l.stroke && l.strokeWidth;
    if (u || h) {
      if (e.save(), e.font = this._getFontDeclaration(l), c.textBackgroundColor && this._removeShadow(e), c.deltaY && (a += c.deltaY), h) {
        const d = this._setFillStyles(e, l);
        e.fillText(n, o - d.offsetX, a - d.offsetY);
      }
      if (u) {
        const d = this._setStrokeStyles(e, l);
        e.strokeText(n, o - d.offsetX, a - d.offsetY);
      }
      e.restore();
    }
  }
  setSuperscript(t, e) {
    this._setScript(t, e, this.superscript);
  }
  setSubscript(t, e) {
    this._setScript(t, e, this.subscript);
  }
  _setScript(t, e, s) {
    const r = this.get2DCursorLocation(t, !0), n = this.getValueOfPropertyAt(r.lineIndex, r.charIndex, "fontSize"), o = this.getValueOfPropertyAt(r.lineIndex, r.charIndex, "deltaY"), a = { fontSize: n * s.size, deltaY: o + n * s.baseline };
    this.setSelectionStyles(a, t, e);
  }
  _getLineLeftOffset(t) {
    const e = this.getLineWidth(t), s = this.width - e, r = this.textAlign, n = this.direction, o = this.isEndOfWrapping(t);
    let a = 0;
    return r === Ht || r === Gs && !o || r === Vs && !o || r === ni && !o ? 0 : (r === j && (a = s / 2), r === Z && (a = s), r === Gs && (a = s / 2), r === Vs && (a = s), n === "rtl" && (r === Z || r === Ht || r === Vs ? a = 0 : r === L || r === ni ? a = -s : r !== j && r !== Gs || (a = -s / 2)), a);
  }
  _clearCache() {
    this._forceClearCache = !1, this.__lineWidths = [], this.__lineHeights = [], this.__charBounds = [];
  }
  getLineWidth(t) {
    if (this.__lineWidths[t] !== void 0) return this.__lineWidths[t];
    const { width: e } = this.measureLine(t);
    return this.__lineWidths[t] = e, e;
  }
  _getWidthOfCharSpacing() {
    return this.charSpacing !== 0 ? this.fontSize * this.charSpacing / 1e3 : 0;
  }
  getValueOfPropertyAt(t, e, s) {
    var r;
    return (r = this._getStyleDeclaration(t, e)[s]) !== null && r !== void 0 ? r : this[s];
  }
  _renderTextDecoration(t, e) {
    if (!this[e] && !this.styleHas(e)) return;
    let s = this._getTopOffset();
    const r = this._getLeftOffset(), n = this.path, o = this._getWidthOfCharSpacing(), a = this.offsets[e];
    for (let c = 0, l = this._textLines.length; c < l; c++) {
      const h = this.getHeightOfLine(c);
      if (!this[e] && !this.styleHas(e, c)) {
        s += h;
        continue;
      }
      const u = this._textLines[c], d = h / this.lineHeight, f = this._getLineLeftOffset(c);
      let g, p, m = 0, b = 0, S = this.getValueOfPropertyAt(c, 0, e), w = this.getValueOfPropertyAt(c, 0, rt);
      const k = s + d * (1 - this._fontSizeFraction);
      let O = this.getHeightOfChar(c, 0), x = this.getValueOfPropertyAt(c, 0, "deltaY");
      for (let M = 0, E = u.length; M < E; M++) {
        const R = this.__charBounds[c][M];
        g = this.getValueOfPropertyAt(c, M, e), p = this.getValueOfPropertyAt(c, M, rt);
        const tt = this.getHeightOfChar(c, M), F = this.getValueOfPropertyAt(c, M, "deltaY");
        if (n && g && p) t.save(), t.fillStyle = w, t.translate(R.renderLeft, R.renderTop), t.rotate(R.angle), t.fillRect(-R.kernedWidth / 2, a * tt + F, R.kernedWidth, this.fontSize / 15), t.restore();
        else if ((g !== S || p !== w || tt !== O || F !== x) && b > 0) {
          let B = r + f + m;
          this.direction === "rtl" && (B = this.width - B - b), S && w && (t.fillStyle = w, t.fillRect(B, k + a * O + x, b, this.fontSize / 15)), m = R.left, b = R.width, S = g, w = p, O = tt, x = F;
        } else b += R.kernedWidth;
      }
      let I = r + f + m;
      this.direction === "rtl" && (I = this.width - I - b), t.fillStyle = p, g && p && t.fillRect(I, k + a * O + x, b - o, this.fontSize / 15), s += h;
    }
    this._removeShadow(t);
  }
  _getFontDeclaration() {
    let { fontFamily: t = this.fontFamily, fontStyle: e = this.fontStyle, fontWeight: s = this.fontWeight, fontSize: r = this.fontSize } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 ? arguments[1] : void 0;
    const o = t.includes("'") || t.includes('"') || t.includes(",") || ct.genericFonts.includes(t.toLowerCase()) ? t : '"'.concat(t, '"');
    return [e, s, "".concat(n ? this.CACHE_FONT_SIZE : r, "px"), o].join(" ");
  }
  render(t) {
    this.visible && (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (this._forceClearCache && this.initDimensions(), super.render(t)));
  }
  graphemeSplit(t) {
    return xi(t);
  }
  _splitTextIntoLines(t) {
    const e = t.split(this._reNewline), s = new Array(e.length), r = [`
`];
    let n = [];
    for (let o = 0; o < e.length; o++) s[o] = this.graphemeSplit(e[o]), n = n.concat(s[o], r);
    return n.pop(), { _unwrappedLines: s, lines: e, graphemeText: n, graphemeLines: s };
  }
  toObject() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return v(v({}, super.toObject([...il, ...t])), {}, { styles: Ec(this.styles, this.text) }, this.path ? { path: this.path.toObject() } : {});
  }
  set(t, e) {
    const { textLayoutProperties: s } = this.constructor;
    super.set(t, e);
    let r = !1, n = !1;
    if (typeof t == "object") for (const o in t) o === "path" && this.setPathInfo(), r = r || s.includes(o), n = n || o === "path";
    else r = s.includes(t), n = t === "path";
    return n && this.setPathInfo(), r && this.initialized && (this.initDimensions(), this.setCoords()), this;
  }
  complexity() {
    return 1;
  }
  static async fromElement(t, e, s) {
    const r = fe(t, ct.ATTRIBUTE_NAMES, s), n = v(v({}, e), r), { textAnchor: o = L, textDecoration: a = "", dx: c = 0, dy: l = 0, top: h = 0, left: u = 0, fontSize: d = En, strokeWidth: f = 1 } = n, g = G(n, Od), p = new this((t.textContent || "").replace(/^\s+|\s+$|\n+/g, "").replace(/\s+/g, " "), v({ left: u + c, top: h + l, underline: a.includes("underline"), overline: a.includes("overline"), linethrough: a.includes("line-through"), strokeWidth: 0, fontSize: d }, g)), m = p.getScaledHeight() / p.height, b = ((p.height + p.strokeWidth) * p.lineHeight - p.height) * m, S = p.getScaledHeight() + b;
    let w = 0;
    return o === j && (w = p.getScaledWidth() / 2), o === Z && (w = p.getScaledWidth()), p.set({ left: p.left - w, top: p.top - (S - p.fontSize * (0.07 + p._fontSizeFraction)) / p.lineHeight, strokeWidth: f }), p;
  }
  static fromObject(t) {
    return this._fromObject(v(v({}, t), {}, { styles: Pc(t.styles || {}, t.text) }), { extraParam: "text" });
  }
}
y(ct, "textLayoutProperties", rl), y(ct, "cacheProperties", [...de, ...il]), y(ct, "ownDefaults", xd), y(ct, "type", "Text"), y(ct, "genericFonts", ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong"]), y(ct, "ATTRIBUTE_NAMES", De.concat("x", "y", "dx", "dy", "font-family", "font-style", "font-weight", "font-size", "letter-spacing", "text-decoration", "text-anchor")), kc(ct, [class extends ac {
  _toSVG() {
    const i = this._getSVGLeftTopOffsets(), t = this._getSVGTextAndBg(i.textTop, i.textLeft);
    return this._wrapSVGTextAndBg(t);
  }
  toSVG(i) {
    return this._createBaseSVGMarkup(this._toSVG(), { reviver: i, noStyle: !0, withShadow: !0 });
  }
  _getSVGLeftTopOffsets() {
    return { textLeft: -this.width / 2, textTop: -this.height / 2, lineTop: this.getHeightOfLine(0) };
  }
  _wrapSVGTextAndBg(i) {
    let { textBgRects: t, textSpans: e } = i;
    const s = this.getSvgTextDecoration(this);
    return [t.join(""), '		<text xml:space="preserve" ', this.fontFamily ? 'font-family="'.concat(this.fontFamily.replace(Cd, "'"), '" ') : "", this.fontSize ? 'font-size="'.concat(this.fontSize, '" ') : "", this.fontStyle ? 'font-style="'.concat(this.fontStyle, '" ') : "", this.fontWeight ? 'font-weight="'.concat(this.fontWeight, '" ') : "", s ? 'text-decoration="'.concat(s, '" ') : "", this.direction === "rtl" ? 'direction="'.concat(this.direction, '" ') : "", 'style="', this.getSvgStyles(!0), '"', this.addPaintOrder(), " >", e.join(""), `</text>
`];
  }
  _getSVGTextAndBg(i, t) {
    const e = [], s = [];
    let r, n = i;
    this.backgroundColor && s.push(...Vi(this.backgroundColor, -this.width / 2, -this.height / 2, this.width, this.height));
    for (let o = 0, a = this._textLines.length; o < a; o++) r = this._getLineLeftOffset(o), this.direction === "rtl" && (r += this.width), (this.textBackgroundColor || this.styleHas("textBackgroundColor", o)) && this._setSVGTextLineBg(s, o, t + r, n), this._setSVGTextLineText(e, o, t + r, n), n += this.getHeightOfLine(o);
    return { textSpans: e, textBgRects: s };
  }
  _createTextCharSpan(i, t, e, s) {
    const r = this.getSvgSpanStyles(t, i !== i.trim() || !!i.match(wd)), n = r ? 'style="'.concat(r, '"') : "", o = t.deltaY, a = o ? ' dy="'.concat(V(o, A.NUM_FRACTION_DIGITS), '" ') : "";
    return '<tspan x="'.concat(V(e, A.NUM_FRACTION_DIGITS), '" y="').concat(V(s, A.NUM_FRACTION_DIGITS), '" ').concat(a).concat(n, ">").concat(jc(i), "</tspan>");
  }
  _setSVGTextLineText(i, t, e, s) {
    const r = this.getHeightOfLine(t), n = this.textAlign.includes(Ht), o = this._textLines[t];
    let a, c, l, h, u, d = "", f = 0;
    s += r * (1 - this._fontSizeFraction) / this.lineHeight;
    for (let g = 0, p = o.length - 1; g <= p; g++) u = g === p || this.charSpacing, d += o[g], l = this.__charBounds[t][g], f === 0 ? (e += l.kernedWidth - l.width, f += l.width) : f += l.kernedWidth, n && !u && this._reSpaceAndTab.test(o[g]) && (u = !0), u || (a = a || this.getCompleteStyleDeclaration(t, g), c = this.getCompleteStyleDeclaration(t, g + 1), u = wi(a, c, !0)), u && (h = this._getStyleDeclaration(t, g), i.push(this._createTextCharSpan(d, h, e, s)), d = "", a = c, this.direction === "rtl" ? e -= f : e += f, f = 0);
  }
  _setSVGTextLineBg(i, t, e, s) {
    const r = this._textLines[t], n = this.getHeightOfLine(t) / this.lineHeight;
    let o, a = 0, c = 0, l = this.getValueOfPropertyAt(t, 0, "textBackgroundColor");
    for (let h = 0; h < r.length; h++) {
      const { left: u, width: d, kernedWidth: f } = this.__charBounds[t][h];
      o = this.getValueOfPropertyAt(t, h, "textBackgroundColor"), o !== l ? (l && i.push(...Vi(l, e + c, s, a, n)), c = u, a = d, l = o) : a += f;
    }
    o && i.push(...Vi(l, e + c, s, a, n));
  }
  _getSVGLineTopOffset(i) {
    let t, e = 0;
    for (t = 0; t < i; t++) e += this.getHeightOfLine(t);
    const s = this.getHeightOfLine(t);
    return { lineTop: e, offset: (this._fontSizeMult - this._fontSizeFraction) * s / (this.lineHeight * this._fontSizeMult) };
  }
  getSvgStyles(i) {
    return "".concat(super.getSvgStyles(i), " white-space: pre;");
  }
  getSvgSpanStyles(i, t) {
    const { fontFamily: e, strokeWidth: s, stroke: r, fill: n, fontSize: o, fontStyle: a, fontWeight: c, deltaY: l } = i, h = this.getSvgTextDecoration(i);
    return [r ? Ks(mt, r) : "", s ? "stroke-width: ".concat(s, "; ") : "", e ? "font-family: ".concat(e.includes("'") || e.includes('"') ? e : "'".concat(e, "'"), "; ") : "", o ? "font-size: ".concat(o, "px; ") : "", a ? "font-style: ".concat(a, "; ") : "", c ? "font-weight: ".concat(c, "; ") : "", h && "text-decoration: ".concat(h, "; "), n ? Ks(rt, n) : "", l ? "baseline-shift: ".concat(-l, "; ") : "", t ? "white-space: pre; " : ""].join("");
  }
  getSvgTextDecoration(i) {
    return ["overline", "underline", "line-through"].filter((t) => i[t.replace("-", "")]).join(" ");
  }
}]), C.setClass(ct), C.setSVGClass(ct);
class kd {
  constructor(t) {
    y(this, "target", void 0), y(this, "__mouseDownInPlace", !1), y(this, "__dragStartFired", !1), y(this, "__isDraggingOver", !1), y(this, "__dragStartSelection", void 0), y(this, "__dragImageDisposer", void 0), y(this, "_dispose", void 0), this.target = t;
    const e = [this.target.on("dragenter", this.dragEnterHandler.bind(this)), this.target.on("dragover", this.dragOverHandler.bind(this)), this.target.on("dragleave", this.dragLeaveHandler.bind(this)), this.target.on("dragend", this.dragEndHandler.bind(this)), this.target.on("drop", this.dropHandler.bind(this))];
    this._dispose = () => {
      e.forEach((s) => s()), this._dispose = void 0;
    };
  }
  isPointerOverSelection(t) {
    const e = this.target, s = e.getSelectionStartFromPointer(t);
    return e.isEditing && s >= e.selectionStart && s <= e.selectionEnd && e.selectionStart < e.selectionEnd;
  }
  start(t) {
    return this.__mouseDownInPlace = this.isPointerOverSelection(t);
  }
  isActive() {
    return this.__mouseDownInPlace;
  }
  end(t) {
    const e = this.isActive();
    return e && !this.__dragStartFired && (this.target.setCursorByClick(t), this.target.initDelayedCursor(!0)), this.__mouseDownInPlace = !1, this.__dragStartFired = !1, this.__isDraggingOver = !1, e;
  }
  getDragStartSelection() {
    return this.__dragStartSelection;
  }
  setDragImage(t, e) {
    var s;
    let { selectionStart: r, selectionEnd: n } = e;
    const o = this.target, a = o.canvas, c = new _(o.flipX ? -1 : 1, o.flipY ? -1 : 1), l = o._getCursorBoundaries(r), h = new _(l.left + l.leftOffset, l.top + l.topOffset).multiply(c).transform(o.calcTransformMatrix()), u = a.getScenePoint(t).subtract(h), d = o.getCanvasRetinaScaling(), f = o.getBoundingRect(), g = h.subtract(new _(f.left, f.top)), p = a.viewportTransform, m = g.add(u).transform(p, !0), b = o.backgroundColor, S = Kn(o.styles);
    o.backgroundColor = "";
    const w = { stroke: "transparent", fill: "transparent", textBackgroundColor: "transparent" };
    o.setSelectionStyles(w, 0, r), o.setSelectionStyles(w, n, o.text.length), o.dirty = !0;
    const k = o.toCanvasElement({ enableRetinaScaling: a.enableRetinaScaling, viewportTransform: !0 });
    o.backgroundColor = b, o.styles = S, o.dirty = !0, ii(k, { position: "fixed", left: "".concat(-k.width, "px"), border: pt, width: "".concat(k.width / d, "px"), height: "".concat(k.height / d, "px") }), this.__dragImageDisposer && this.__dragImageDisposer(), this.__dragImageDisposer = () => {
      k.remove();
    }, At(t.target || this.target.hiddenTextarea).body.appendChild(k), (s = t.dataTransfer) === null || s === void 0 || s.setDragImage(k, m.x, m.y);
  }
  onDragStart(t) {
    this.__dragStartFired = !0;
    const e = this.target, s = this.isActive();
    if (s && t.dataTransfer) {
      const r = this.__dragStartSelection = { selectionStart: e.selectionStart, selectionEnd: e.selectionEnd }, n = e._text.slice(r.selectionStart, r.selectionEnd).join(""), o = v({ text: e.text, value: n }, r);
      t.dataTransfer.setData("text/plain", n), t.dataTransfer.setData("application/fabric", JSON.stringify({ value: n, styles: e.getSelectionStyles(r.selectionStart, r.selectionEnd, !0) })), t.dataTransfer.effectAllowed = "copyMove", this.setDragImage(t, o);
    }
    return e.abortCursorAnimation(), s;
  }
  canDrop(t) {
    if (this.target.editable && !this.target.getActiveControl() && !t.defaultPrevented) {
      if (this.isActive() && this.__dragStartSelection) {
        const e = this.target.getSelectionStartFromPointer(t), s = this.__dragStartSelection;
        return e < s.selectionStart || e > s.selectionEnd;
      }
      return !0;
    }
    return !1;
  }
  targetCanDrop(t) {
    return this.target.canDrop(t);
  }
  dragEnterHandler(t) {
    let { e } = t;
    const s = this.targetCanDrop(e);
    !this.__isDraggingOver && s && (this.__isDraggingOver = !0);
  }
  dragOverHandler(t) {
    const { e } = t, s = this.targetCanDrop(e);
    !this.__isDraggingOver && s ? this.__isDraggingOver = !0 : this.__isDraggingOver && !s && (this.__isDraggingOver = !1), this.__isDraggingOver && (e.preventDefault(), t.canDrop = !0, t.dropTarget = this.target);
  }
  dragLeaveHandler() {
    (this.__isDraggingOver || this.isActive()) && (this.__isDraggingOver = !1);
  }
  dropHandler(t) {
    var e;
    const { e: s } = t, r = s.defaultPrevented;
    this.__isDraggingOver = !1, s.preventDefault();
    let n = (e = s.dataTransfer) === null || e === void 0 ? void 0 : e.getData("text/plain");
    if (n && !r) {
      const o = this.target, a = o.canvas;
      let c = o.getSelectionStartFromPointer(s);
      const { styles: l } = s.dataTransfer.types.includes("application/fabric") ? JSON.parse(s.dataTransfer.getData("application/fabric")) : {}, h = n[Math.max(0, n.length - 1)], u = 0;
      if (this.__dragStartSelection) {
        const d = this.__dragStartSelection.selectionStart, f = this.__dragStartSelection.selectionEnd;
        c > d && c <= f ? c = d : c > f && (c -= f - d), o.removeChars(d, f), delete this.__dragStartSelection;
      }
      o._reNewline.test(h) && (o._reNewline.test(o._text[c]) || c === o._text.length) && (n = n.trimEnd()), t.didDrop = !0, t.dropTarget = o, o.insertChars(n, l, c), a.setActiveObject(o), o.enterEditing(s), o.selectionStart = Math.min(c + u, o._text.length), o.selectionEnd = Math.min(o.selectionStart + n.length, o._text.length), o.hiddenTextarea.value = o.text, o._updateTextarea(), o.hiddenTextarea.focus(), o.fire(Ur, { index: c + u, action: "drop" }), a.fire("text:changed", { target: o }), a.contextTopDirty = !0, a.requestRenderAll();
    }
  }
  dragEndHandler(t) {
    let { e } = t;
    if (this.isActive() && this.__dragStartFired && this.__dragStartSelection) {
      var s;
      const r = this.target, n = this.target.canvas, { selectionStart: o, selectionEnd: a } = this.__dragStartSelection, c = ((s = e.dataTransfer) === null || s === void 0 ? void 0 : s.dropEffect) || pt;
      c === pt ? (r.selectionStart = o, r.selectionEnd = a, r._updateTextarea(), r.hiddenTextarea.focus()) : (r.clearContextTop(), c === "move" && (r.removeChars(o, a), r.selectionStart = r.selectionEnd = o, r.hiddenTextarea && (r.hiddenTextarea.value = r.text), r._updateTextarea(), r.fire(Ur, { index: o, action: "dragend" }), n.fire("text:changed", { target: r }), n.requestRenderAll()), r.exitEditing());
    }
    this.__dragImageDisposer && this.__dragImageDisposer(), delete this.__dragImageDisposer, delete this.__dragStartSelection, this.__isDraggingOver = !1;
  }
  dispose() {
    this._dispose && this._dispose();
  }
}
const Ho = /[ \n\.,;!\?\-]/;
class Md extends ct {
  constructor() {
    super(...arguments), y(this, "_currentCursorOpacity", 1);
  }
  initBehavior() {
    this._tick = this._tick.bind(this), this._onTickComplete = this._onTickComplete.bind(this), this.updateSelectionOnMouseMove = this.updateSelectionOnMouseMove.bind(this);
  }
  onDeselect(t) {
    return this.isEditing && this.exitEditing(), this.selected = !1, super.onDeselect(t);
  }
  _animateCursor(t) {
    let { toValue: e, duration: s, delay: r, onComplete: n } = t;
    return Un({ startValue: this._currentCursorOpacity, endValue: e, duration: s, delay: r, onComplete: n, abort: () => !this.canvas || this.selectionStart !== this.selectionEnd, onChange: (o) => {
      this._currentCursorOpacity = o, this.renderCursorOrSelection();
    } });
  }
  _tick(t) {
    this._currentTickState = this._animateCursor({ toValue: 0, duration: this.cursorDuration / 2, delay: Math.max(t || 0, 100), onComplete: this._onTickComplete });
  }
  _onTickComplete() {
    var t;
    (t = this._currentTickCompleteState) === null || t === void 0 || t.abort(), this._currentTickCompleteState = this._animateCursor({ toValue: 1, duration: this.cursorDuration, onComplete: this._tick });
  }
  initDelayedCursor(t) {
    this.abortCursorAnimation(), this._tick(t ? 0 : this.cursorDelay);
  }
  abortCursorAnimation() {
    let t = !1;
    [this._currentTickState, this._currentTickCompleteState].forEach((e) => {
      e && !e.isDone() && (t = !0, e.abort());
    }), this._currentCursorOpacity = 1, t && this.clearContextTop();
  }
  restartCursorIfNeeded() {
    [this._currentTickState, this._currentTickCompleteState].some((t) => !t || t.isDone()) && this.initDelayedCursor();
  }
  selectAll() {
    return this.selectionStart = 0, this.selectionEnd = this._text.length, this._fireSelectionChanged(), this._updateTextarea(), this;
  }
  getSelectedText() {
    return this._text.slice(this.selectionStart, this.selectionEnd).join("");
  }
  findWordBoundaryLeft(t) {
    let e = 0, s = t - 1;
    if (this._reSpace.test(this._text[s])) for (; this._reSpace.test(this._text[s]); ) e++, s--;
    for (; /\S/.test(this._text[s]) && s > -1; ) e++, s--;
    return t - e;
  }
  findWordBoundaryRight(t) {
    let e = 0, s = t;
    if (this._reSpace.test(this._text[s])) for (; this._reSpace.test(this._text[s]); ) e++, s++;
    for (; /\S/.test(this._text[s]) && s < this._text.length; ) e++, s++;
    return t + e;
  }
  findLineBoundaryLeft(t) {
    let e = 0, s = t - 1;
    for (; !/\n/.test(this._text[s]) && s > -1; ) e++, s--;
    return t - e;
  }
  findLineBoundaryRight(t) {
    let e = 0, s = t;
    for (; !/\n/.test(this._text[s]) && s < this._text.length; ) e++, s++;
    return t + e;
  }
  searchWordBoundary(t, e) {
    const s = this._text;
    let r = t > 0 && this._reSpace.test(s[t]) && (e === -1 || !Pn.test(s[t - 1])) ? t - 1 : t, n = s[r];
    for (; r > 0 && r < s.length && !Ho.test(n); ) r += e, n = s[r];
    return e === -1 && Ho.test(n) && r++, r;
  }
  selectWord(t) {
    t = t || this.selectionStart;
    const e = this.searchWordBoundary(t, -1), s = Math.max(e, this.searchWordBoundary(t, 1));
    this.selectionStart = e, this.selectionEnd = s, this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection();
  }
  selectLine(t) {
    t = t || this.selectionStart;
    const e = this.findLineBoundaryLeft(t), s = this.findLineBoundaryRight(t);
    return this.selectionStart = e, this.selectionEnd = s, this._fireSelectionChanged(), this._updateTextarea(), this;
  }
  enterEditing(t) {
    !this.isEditing && this.editable && (this.enterEditingImpl(), this.fire("editing:entered", t ? { e: t } : void 0), this._fireSelectionChanged(), this.canvas && (this.canvas.fire("text:editing:entered", { target: this, e: t }), this.canvas.requestRenderAll()));
  }
  enterEditingImpl() {
    this.canvas && (this.canvas.calcOffset(), this.canvas.textEditingManager.exitTextEditing()), this.isEditing = !0, this.initHiddenTextarea(), this.hiddenTextarea.focus(), this.hiddenTextarea.value = this.text, this._updateTextarea(), this._saveEditingProps(), this._setEditingProps(), this._textBeforeEdit = this.text, this._tick();
  }
  updateSelectionOnMouseMove(t) {
    if (this.getActiveControl()) return;
    const e = this.hiddenTextarea;
    At(e).activeElement !== e && e.focus();
    const s = this.getSelectionStartFromPointer(t), r = this.selectionStart, n = this.selectionEnd;
    (s === this.__selectionStartOnMouseDown && r !== n || r !== s && n !== s) && (s > this.__selectionStartOnMouseDown ? (this.selectionStart = this.__selectionStartOnMouseDown, this.selectionEnd = s) : (this.selectionStart = s, this.selectionEnd = this.__selectionStartOnMouseDown), this.selectionStart === r && this.selectionEnd === n || (this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection()));
  }
  _setEditingProps() {
    this.hoverCursor = "text", this.canvas && (this.canvas.defaultCursor = this.canvas.moveCursor = "text"), this.borderColor = this.editingBorderColor, this.hasControls = this.selectable = !1, this.lockMovementX = this.lockMovementY = !0;
  }
  fromStringToGraphemeSelection(t, e, s) {
    const r = s.slice(0, t), n = this.graphemeSplit(r).length;
    if (t === e) return { selectionStart: n, selectionEnd: n };
    const o = s.slice(t, e);
    return { selectionStart: n, selectionEnd: n + this.graphemeSplit(o).length };
  }
  fromGraphemeToStringSelection(t, e, s) {
    const r = s.slice(0, t).join("").length;
    return t === e ? { selectionStart: r, selectionEnd: r } : { selectionStart: r, selectionEnd: r + s.slice(t, e).join("").length };
  }
  _updateTextarea() {
    if (this.cursorOffsetCache = {}, this.hiddenTextarea) {
      if (!this.inCompositionMode) {
        const t = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);
        this.hiddenTextarea.selectionStart = t.selectionStart, this.hiddenTextarea.selectionEnd = t.selectionEnd;
      }
      this.updateTextareaPosition();
    }
  }
  updateFromTextArea() {
    if (!this.hiddenTextarea) return;
    this.cursorOffsetCache = {};
    const t = this.hiddenTextarea;
    this.text = t.value, this.set("dirty", !0), this.initDimensions(), this.setCoords();
    const e = this.fromStringToGraphemeSelection(t.selectionStart, t.selectionEnd, t.value);
    this.selectionEnd = this.selectionStart = e.selectionEnd, this.inCompositionMode || (this.selectionStart = e.selectionStart), this.updateTextareaPosition();
  }
  updateTextareaPosition() {
    if (this.selectionStart === this.selectionEnd) {
      const t = this._calcTextareaPosition();
      this.hiddenTextarea.style.left = t.left, this.hiddenTextarea.style.top = t.top;
    }
  }
  _calcTextareaPosition() {
    if (!this.canvas) return { left: "1px", top: "1px" };
    const t = this.inCompositionMode ? this.compositionStart : this.selectionStart, e = this._getCursorBoundaries(t), s = this.get2DCursorLocation(t), r = s.lineIndex, n = s.charIndex, o = this.getValueOfPropertyAt(r, n, "fontSize") * this.lineHeight, a = e.leftOffset, c = this.getCanvasRetinaScaling(), l = this.canvas.upperCanvasEl, h = l.width / c, u = l.height / c, d = h - o, f = u - o, g = new _(e.left + a, e.top + e.topOffset + o).transform(this.calcTransformMatrix()).transform(this.canvas.viewportTransform).multiply(new _(l.clientWidth / h, l.clientHeight / u));
    return g.x < 0 && (g.x = 0), g.x > d && (g.x = d), g.y < 0 && (g.y = 0), g.y > f && (g.y = f), g.x += this.canvas._offset.left, g.y += this.canvas._offset.top, { left: "".concat(g.x, "px"), top: "".concat(g.y, "px"), fontSize: "".concat(o, "px"), charHeight: o };
  }
  _saveEditingProps() {
    this._savedProps = { hasControls: this.hasControls, borderColor: this.borderColor, lockMovementX: this.lockMovementX, lockMovementY: this.lockMovementY, hoverCursor: this.hoverCursor, selectable: this.selectable, defaultCursor: this.canvas && this.canvas.defaultCursor, moveCursor: this.canvas && this.canvas.moveCursor };
  }
  _restoreEditingProps() {
    this._savedProps && (this.hoverCursor = this._savedProps.hoverCursor, this.hasControls = this._savedProps.hasControls, this.borderColor = this._savedProps.borderColor, this.selectable = this._savedProps.selectable, this.lockMovementX = this._savedProps.lockMovementX, this.lockMovementY = this._savedProps.lockMovementY, this.canvas && (this.canvas.defaultCursor = this._savedProps.defaultCursor || this.canvas.defaultCursor, this.canvas.moveCursor = this._savedProps.moveCursor || this.canvas.moveCursor), delete this._savedProps);
  }
  _exitEditing() {
    const t = this.hiddenTextarea;
    this.selected = !1, this.isEditing = !1, t && (t.blur && t.blur(), t.parentNode && t.parentNode.removeChild(t)), this.hiddenTextarea = null, this.abortCursorAnimation(), this.selectionStart !== this.selectionEnd && this.clearContextTop();
  }
  exitEditingImpl() {
    this._exitEditing(), this.selectionEnd = this.selectionStart, this._restoreEditingProps(), this._forceClearCache && (this.initDimensions(), this.setCoords());
  }
  exitEditing() {
    const t = this._textBeforeEdit !== this.text;
    return this.exitEditingImpl(), this.fire("editing:exited"), t && this.fire($r), this.canvas && (this.canvas.fire("text:editing:exited", { target: this }), t && this.canvas.fire("object:modified", { target: this })), this;
  }
  _removeExtraneousStyles() {
    for (const t in this.styles) this._textLines[t] || delete this.styles[t];
  }
  removeStyleFromTo(t, e) {
    const { lineIndex: s, charIndex: r } = this.get2DCursorLocation(t, !0), { lineIndex: n, charIndex: o } = this.get2DCursorLocation(e, !0);
    if (s !== n) {
      if (this.styles[s]) for (let a = r; a < this._unwrappedTextLines[s].length; a++) delete this.styles[s][a];
      if (this.styles[n]) for (let a = o; a < this._unwrappedTextLines[n].length; a++) {
        const c = this.styles[n][a];
        c && (this.styles[s] || (this.styles[s] = {}), this.styles[s][r + a - o] = c);
      }
      for (let a = s + 1; a <= n; a++) delete this.styles[a];
      this.shiftLineStyles(n, s - n);
    } else if (this.styles[s]) {
      const a = this.styles[s], c = o - r;
      for (let l = r; l < o; l++) delete a[l];
      for (const l in this.styles[s]) {
        const h = parseInt(l, 10);
        h >= o && (a[h - c] = a[l], delete a[l]);
      }
    }
  }
  shiftLineStyles(t, e) {
    const s = Object.assign({}, this.styles);
    for (const r in this.styles) {
      const n = parseInt(r, 10);
      n > t && (this.styles[n + e] = s[n], s[n - e] || delete this.styles[n]);
    }
  }
  insertNewlineStyleObject(t, e, s, r) {
    const n = {}, o = this._unwrappedTextLines[t].length, a = o === e;
    let c = !1;
    s || (s = 1), this.shiftLineStyles(t, s);
    const l = this.styles[t] ? this.styles[t][e === 0 ? e : e - 1] : void 0;
    for (const u in this.styles[t]) {
      const d = parseInt(u, 10);
      d >= e && (c = !0, n[d - e] = this.styles[t][u], a && e === 0 || delete this.styles[t][u]);
    }
    let h = !1;
    for (c && !a && (this.styles[t + s] = n, h = !0), (h || o > e) && s--; s > 0; ) r && r[s - 1] ? this.styles[t + s] = { 0: v({}, r[s - 1]) } : l ? this.styles[t + s] = { 0: v({}, l) } : delete this.styles[t + s], s--;
    this._forceClearCache = !0;
  }
  insertCharStyleObject(t, e, s, r) {
    this.styles || (this.styles = {});
    const n = this.styles[t], o = n ? v({}, n) : {};
    s || (s = 1);
    for (const c in o) {
      const l = parseInt(c, 10);
      l >= e && (n[l + s] = o[l], o[l - s] || delete n[l]);
    }
    if (this._forceClearCache = !0, r) {
      for (; s--; ) Object.keys(r[s]).length && (this.styles[t] || (this.styles[t] = {}), this.styles[t][e + s] = v({}, r[s]));
      return;
    }
    if (!n) return;
    const a = n[e ? e - 1 : 1];
    for (; a && s--; ) this.styles[t][e + s] = v({}, a);
  }
  insertNewStyleBlock(t, e, s) {
    const r = this.get2DCursorLocation(e, !0), n = [0];
    let o, a = 0;
    for (let c = 0; c < t.length; c++) t[c] === `
` ? (a++, n[a] = 0) : n[a]++;
    for (n[0] > 0 && (this.insertCharStyleObject(r.lineIndex, r.charIndex, n[0], s), s = s && s.slice(n[0] + 1)), a && this.insertNewlineStyleObject(r.lineIndex, r.charIndex + n[0], a), o = 1; o < a; o++) n[o] > 0 ? this.insertCharStyleObject(r.lineIndex + o, 0, n[o], s) : s && this.styles[r.lineIndex + o] && s[0] && (this.styles[r.lineIndex + o][0] = s[0]), s = s && s.slice(n[o] + 1);
    n[o] > 0 && this.insertCharStyleObject(r.lineIndex + o, 0, n[o], s);
  }
  removeChars(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : t + 1;
    this.removeStyleFromTo(t, e), this._text.splice(t, e - t), this.text = this._text.join(""), this.set("dirty", !0), this.initDimensions(), this.setCoords(), this._removeExtraneousStyles();
  }
  insertChars(t, e, s) {
    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : s;
    r > s && this.removeStyleFromTo(s, r);
    const n = this.graphemeSplit(t);
    this.insertNewStyleBlock(n, s, e), this._text = [...this._text.slice(0, s), ...n, ...this._text.slice(r)], this.text = this._text.join(""), this.set("dirty", !0), this.initDimensions(), this.setCoords(), this._removeExtraneousStyles();
  }
  setSelectionStartEndWithShift(t, e, s) {
    s <= t ? (e === t ? this._selectionDirection = L : this._selectionDirection === Z && (this._selectionDirection = L, this.selectionEnd = t), this.selectionStart = s) : s > t && s < e ? this._selectionDirection === Z ? this.selectionEnd = s : this.selectionStart = s : (e === t ? this._selectionDirection = Z : this._selectionDirection === L && (this._selectionDirection = Z, this.selectionStart = e), this.selectionEnd = s);
  }
}
class Id extends Md {
  initHiddenTextarea() {
    const t = this.canvas && At(this.canvas.getElement()) || Cs(), e = t.createElement("textarea");
    Object.entries({ autocapitalize: "off", autocorrect: "off", autocomplete: "off", spellcheck: "false", "data-fabric": "textarea", wrap: "off" }).map((o) => {
      let [a, c] = o;
      return e.setAttribute(a, c);
    });
    const { top: s, left: r, fontSize: n } = this._calcTextareaPosition();
    e.style.cssText = "position: absolute; top: ".concat(s, "; left: ").concat(r, "; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px; padding-top: ").concat(n, ";"), (this.hiddenTextareaContainer || t.body).appendChild(e), Object.entries({ blur: "blur", keydown: "onKeyDown", keyup: "onKeyUp", input: "onInput", copy: "copy", cut: "copy", paste: "paste", compositionstart: "onCompositionStart", compositionupdate: "onCompositionUpdate", compositionend: "onCompositionEnd" }).map((o) => {
      let [a, c] = o;
      return e.addEventListener(a, this[c].bind(this));
    }), this.hiddenTextarea = e;
  }
  blur() {
    this.abortCursorAnimation();
  }
  onKeyDown(t) {
    if (!this.isEditing) return;
    const e = this.direction === "rtl" ? this.keysMapRtl : this.keysMap;
    if (t.keyCode in e) this[e[t.keyCode]](t);
    else {
      if (!(t.keyCode in this.ctrlKeysMapDown) || !t.ctrlKey && !t.metaKey) return;
      this[this.ctrlKeysMapDown[t.keyCode]](t);
    }
    t.stopImmediatePropagation(), t.preventDefault(), t.keyCode >= 33 && t.keyCode <= 40 ? (this.inCompositionMode = !1, this.clearContextTop(), this.renderCursorOrSelection()) : this.canvas && this.canvas.requestRenderAll();
  }
  onKeyUp(t) {
    !this.isEditing || this._copyDone || this.inCompositionMode ? this._copyDone = !1 : t.keyCode in this.ctrlKeysMapUp && (t.ctrlKey || t.metaKey) && (this[this.ctrlKeysMapUp[t.keyCode]](t), t.stopImmediatePropagation(), t.preventDefault(), this.canvas && this.canvas.requestRenderAll());
  }
  onInput(t) {
    const e = this.fromPaste;
    if (this.fromPaste = !1, t && t.stopPropagation(), !this.isEditing) return;
    const s = () => {
      this.updateFromTextArea(), this.fire(Ur), this.canvas && (this.canvas.fire("text:changed", { target: this }), this.canvas.requestRenderAll());
    };
    if (this.hiddenTextarea.value === "") return this.styles = {}, void s();
    const r = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText, n = this._text.length, o = r.length, a = this.selectionStart, c = this.selectionEnd, l = a !== c;
    let h, u, d, f, g = o - n;
    const p = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value), m = a > p.selectionStart;
    l ? (u = this._text.slice(a, c), g += c - a) : o < n && (u = m ? this._text.slice(c + g, c) : this._text.slice(a, a - g));
    const b = r.slice(p.selectionEnd - g, p.selectionEnd);
    if (u && u.length && (b.length && (h = this.getSelectionStyles(a, a + 1, !1), h = b.map(() => h[0])), l ? (d = a, f = c) : m ? (d = c - u.length, f = c) : (d = c, f = c + u.length), this.removeStyleFromTo(d, f)), b.length) {
      const { copyPasteData: S } = $t();
      e && b.join("") === S.copiedText && !A.disableStyleCopyPaste && (h = S.copiedTextStyle), this.insertNewStyleBlock(b, a, h);
    }
    s();
  }
  onCompositionStart() {
    this.inCompositionMode = !0;
  }
  onCompositionEnd() {
    this.inCompositionMode = !1;
  }
  onCompositionUpdate(t) {
    let { target: e } = t;
    const { selectionStart: s, selectionEnd: r } = e;
    this.compositionStart = s, this.compositionEnd = r, this.updateTextareaPosition();
  }
  copy() {
    if (this.selectionStart === this.selectionEnd) return;
    const { copyPasteData: t } = $t();
    t.copiedText = this.getSelectedText(), A.disableStyleCopyPaste ? t.copiedTextStyle = void 0 : t.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, !0), this._copyDone = !0;
  }
  paste() {
    this.fromPaste = !0;
  }
  _getWidthBeforeCursor(t, e) {
    let s, r = this._getLineLeftOffset(t);
    return e > 0 && (s = this.__charBounds[t][e - 1], r += s.left + s.width), r;
  }
  getDownCursorOffset(t, e) {
    const s = this._getSelectionForOffset(t, e), r = this.get2DCursorLocation(s), n = r.lineIndex;
    if (n === this._textLines.length - 1 || t.metaKey || t.keyCode === 34) return this._text.length - s;
    const o = r.charIndex, a = this._getWidthBeforeCursor(n, o), c = this._getIndexOnLine(n + 1, a);
    return this._textLines[n].slice(o).length + c + 1 + this.missingNewlineOffset(n);
  }
  _getSelectionForOffset(t, e) {
    return t.shiftKey && this.selectionStart !== this.selectionEnd && e ? this.selectionEnd : this.selectionStart;
  }
  getUpCursorOffset(t, e) {
    const s = this._getSelectionForOffset(t, e), r = this.get2DCursorLocation(s), n = r.lineIndex;
    if (n === 0 || t.metaKey || t.keyCode === 33) return -s;
    const o = r.charIndex, a = this._getWidthBeforeCursor(n, o), c = this._getIndexOnLine(n - 1, a), l = this._textLines[n].slice(0, o), h = this.missingNewlineOffset(n - 1);
    return -this._textLines[n - 1].length + c - l.length + (1 - h);
  }
  _getIndexOnLine(t, e) {
    const s = this._textLines[t];
    let r, n, o = this._getLineLeftOffset(t), a = 0;
    for (let c = 0, l = s.length; c < l; c++) if (r = this.__charBounds[t][c].width, o += r, o > e) {
      n = !0;
      const h = o - r, u = o, d = Math.abs(h - e);
      a = Math.abs(u - e) < d ? c : c - 1;
      break;
    }
    return n || (a = s.length - 1), a;
  }
  moveCursorDown(t) {
    this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorUpOrDown("Down", t);
  }
  moveCursorUp(t) {
    this.selectionStart === 0 && this.selectionEnd === 0 || this._moveCursorUpOrDown("Up", t);
  }
  _moveCursorUpOrDown(t, e) {
    const s = this["get".concat(t, "CursorOffset")](e, this._selectionDirection === Z);
    if (e.shiftKey ? this.moveCursorWithShift(s) : this.moveCursorWithoutShift(s), s !== 0) {
      const r = this.text.length;
      this.selectionStart = ze(0, this.selectionStart, r), this.selectionEnd = ze(0, this.selectionEnd, r), this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea();
    }
  }
  moveCursorWithShift(t) {
    const e = this._selectionDirection === L ? this.selectionStart + t : this.selectionEnd + t;
    return this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, e), t !== 0;
  }
  moveCursorWithoutShift(t) {
    return t < 0 ? (this.selectionStart += t, this.selectionEnd = this.selectionStart) : (this.selectionEnd += t, this.selectionStart = this.selectionEnd), t !== 0;
  }
  moveCursorLeft(t) {
    this.selectionStart === 0 && this.selectionEnd === 0 || this._moveCursorLeftOrRight("Left", t);
  }
  _move(t, e, s) {
    let r;
    if (t.altKey) r = this["findWordBoundary".concat(s)](this[e]);
    else {
      if (!t.metaKey && t.keyCode !== 35 && t.keyCode !== 36) return this[e] += s === "Left" ? -1 : 1, !0;
      r = this["findLineBoundary".concat(s)](this[e]);
    }
    return r !== void 0 && this[e] !== r && (this[e] = r, !0);
  }
  _moveLeft(t, e) {
    return this._move(t, e, "Left");
  }
  _moveRight(t, e) {
    return this._move(t, e, "Right");
  }
  moveCursorLeftWithoutShift(t) {
    let e = !0;
    return this._selectionDirection = L, this.selectionEnd === this.selectionStart && this.selectionStart !== 0 && (e = this._moveLeft(t, "selectionStart")), this.selectionEnd = this.selectionStart, e;
  }
  moveCursorLeftWithShift(t) {
    return this._selectionDirection === Z && this.selectionStart !== this.selectionEnd ? this._moveLeft(t, "selectionEnd") : this.selectionStart !== 0 ? (this._selectionDirection = L, this._moveLeft(t, "selectionStart")) : void 0;
  }
  moveCursorRight(t) {
    this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorLeftOrRight("Right", t);
  }
  _moveCursorLeftOrRight(t, e) {
    const s = "moveCursor".concat(t).concat(e.shiftKey ? "WithShift" : "WithoutShift");
    this._currentCursorOpacity = 1, this[s](e) && (this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea());
  }
  moveCursorRightWithShift(t) {
    return this._selectionDirection === L && this.selectionStart !== this.selectionEnd ? this._moveRight(t, "selectionStart") : this.selectionEnd !== this._text.length ? (this._selectionDirection = Z, this._moveRight(t, "selectionEnd")) : void 0;
  }
  moveCursorRightWithoutShift(t) {
    let e = !0;
    return this._selectionDirection = Z, this.selectionStart === this.selectionEnd ? (e = this._moveRight(t, "selectionStart"), this.selectionEnd = this.selectionStart) : this.selectionStart = this.selectionEnd, e;
  }
}
const Ni = (i) => !!i.button;
class Dd extends Id {
  constructor() {
    super(...arguments), y(this, "draggableTextDelegate", void 0);
  }
  initBehavior() {
    this.on("mousedown", this._mouseDownHandler), this.on("mousedown:before", this._mouseDownHandlerBefore), this.on("mouseup", this.mouseUpHandler), this.on("mousedblclick", this.doubleClickHandler), this.on("tripleclick", this.tripleClickHandler), this.__lastClickTime = +/* @__PURE__ */ new Date(), this.__lastLastClickTime = +/* @__PURE__ */ new Date(), this.__lastPointer = {}, this.on("mousedown", this.onMouseDown), this.draggableTextDelegate = new kd(this), super.initBehavior();
  }
  shouldStartDragging() {
    return this.draggableTextDelegate.isActive();
  }
  onDragStart(t) {
    return this.draggableTextDelegate.onDragStart(t);
  }
  canDrop(t) {
    return this.draggableTextDelegate.canDrop(t);
  }
  onMouseDown(t) {
    if (!this.canvas) return;
    this.__newClickTime = +/* @__PURE__ */ new Date();
    const e = t.pointer;
    this.isTripleClick(e) && (this.fire("tripleclick", t), on(t.e)), this.__lastLastClickTime = this.__lastClickTime, this.__lastClickTime = this.__newClickTime, this.__lastPointer = e, this.__lastSelected = this.selected && !this.getActiveControl();
  }
  isTripleClick(t) {
    return this.__newClickTime - this.__lastClickTime < 500 && this.__lastClickTime - this.__lastLastClickTime < 500 && this.__lastPointer.x === t.x && this.__lastPointer.y === t.y;
  }
  doubleClickHandler(t) {
    this.isEditing && this.selectWord(this.getSelectionStartFromPointer(t.e));
  }
  tripleClickHandler(t) {
    this.isEditing && this.selectLine(this.getSelectionStartFromPointer(t.e));
  }
  _mouseDownHandler(t) {
    let { e } = t;
    this.canvas && this.editable && !Ni(e) && !this.getActiveControl() && (this.draggableTextDelegate.start(e) || (this.canvas.textEditingManager.register(this), this.selected && (this.inCompositionMode = !1, this.setCursorByClick(e)), this.isEditing && (this.__selectionStartOnMouseDown = this.selectionStart, this.selectionStart === this.selectionEnd && this.abortCursorAnimation(), this.renderCursorOrSelection())));
  }
  _mouseDownHandlerBefore(t) {
    let { e } = t;
    this.canvas && this.editable && !Ni(e) && (this.selected = this === this.canvas._activeObject);
  }
  mouseUpHandler(t) {
    let { e, transform: s } = t;
    const r = this.draggableTextDelegate.end(e);
    if (this.canvas) {
      this.canvas.textEditingManager.unregister(this);
      const n = this.canvas._activeObject;
      if (n && n !== this) return;
    }
    !this.editable || this.group && !this.group.interactive || s && s.actionPerformed || Ni(e) || r || (this.__lastSelected && !this.getActiveControl() ? (this.selected = !1, this.__lastSelected = !1, this.enterEditing(e), this.selectionStart === this.selectionEnd ? this.initDelayedCursor(!0) : this.renderCursorOrSelection()) : this.selected = !0);
  }
  setCursorByClick(t) {
    const e = this.getSelectionStartFromPointer(t), s = this.selectionStart, r = this.selectionEnd;
    t.shiftKey ? this.setSelectionStartEndWithShift(s, r, e) : (this.selectionStart = e, this.selectionEnd = e), this.isEditing && (this._fireSelectionChanged(), this._updateTextarea());
  }
  getSelectionStartFromPointer(t) {
    const e = this.canvas.getScenePoint(t).transform(St(this.calcTransformMatrix())).add(new _(-this._getLeftOffset(), -this._getTopOffset()));
    let s = 0, r = 0, n = 0;
    for (let l = 0; l < this._textLines.length && s <= e.y; l++) s += this.getHeightOfLine(l), n = l, l > 0 && (r += this._textLines[l - 1].length + this.missingNewlineOffset(l - 1));
    let o = Math.abs(this._getLineLeftOffset(n));
    const a = this._textLines[n].length, c = this.__charBounds[n];
    for (let l = 0; l < a; l++) {
      const h = o + c[l].kernedWidth;
      if (e.x <= h) {
        Math.abs(e.x - h) <= Math.abs(e.x - o) && r++;
        break;
      }
      o = h, r++;
    }
    return Math.min(this.flipX ? a - r : r, this._text.length);
  }
}
const _r = "moveCursorUp", Sr = "moveCursorDown", Tr = "moveCursorLeft", xr = "moveCursorRight", wr = "exitEditing", jd = v({ selectionStart: 0, selectionEnd: 0, selectionColor: "rgba(17,119,255,0.3)", isEditing: !1, editable: !0, editingBorderColor: "rgba(102,153,255,0.25)", cursorWidth: 2, cursorColor: "", cursorDelay: 1e3, cursorDuration: 600, caching: !0, hiddenTextareaContainer: null, keysMap: { 9: wr, 27: wr, 33: _r, 34: Sr, 35: xr, 36: Tr, 37: Tr, 38: _r, 39: xr, 40: Sr }, keysMapRtl: { 9: wr, 27: wr, 33: _r, 34: Sr, 35: Tr, 36: xr, 37: xr, 38: _r, 39: Tr, 40: Sr }, ctrlKeysMapDown: { 65: "selectAll" }, ctrlKeysMapUp: { 67: "copy", 88: "cut" } }, { _selectionDirection: null, _reSpace: /\s|\r?\n/, inCompositionMode: !1 });
class oe extends Dd {
  static getDefaults() {
    return v(v({}, super.getDefaults()), oe.ownDefaults);
  }
  get type() {
    const t = super.type;
    return t === "itext" ? "i-text" : t;
  }
  constructor(t, e) {
    super(t, v(v({}, oe.ownDefaults), e)), this.initBehavior();
  }
  _set(t, e) {
    return this.isEditing && this._savedProps && t in this._savedProps ? (this._savedProps[t] = e, this) : (t === "canvas" && (this.canvas instanceof vn && this.canvas.textEditingManager.remove(this), e instanceof vn && e.textEditingManager.add(this)), super._set(t, e));
  }
  setSelectionStart(t) {
    t = Math.max(t, 0), this._updateAndFire("selectionStart", t);
  }
  setSelectionEnd(t) {
    t = Math.min(t, this.text.length), this._updateAndFire("selectionEnd", t);
  }
  _updateAndFire(t, e) {
    this[t] !== e && (this._fireSelectionChanged(), this[t] = e), this._updateTextarea();
  }
  _fireSelectionChanged() {
    this.fire("selection:changed"), this.canvas && this.canvas.fire("text:selection:changed", { target: this });
  }
  initDimensions() {
    this.isEditing && this.initDelayedCursor(), super.initDimensions();
  }
  getSelectionStyles() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart || 0, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selectionEnd, s = arguments.length > 2 ? arguments[2] : void 0;
    return super.getSelectionStyles(t, e, s);
  }
  setSelectionStyles(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selectionStart || 0, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.selectionEnd;
    return super.setSelectionStyles(t, e, s);
  }
  get2DCursorLocation() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart, e = arguments.length > 1 ? arguments[1] : void 0;
    return super.get2DCursorLocation(t, e);
  }
  render(t) {
    super.render(t), this.cursorOffsetCache = {}, this.renderCursorOrSelection();
  }
  toCanvasElement(t) {
    const e = this.isEditing;
    this.isEditing = !1;
    const s = super.toCanvasElement(t);
    return this.isEditing = e, s;
  }
  renderCursorOrSelection() {
    if (!this.isEditing) return;
    const t = this.clearContextTop(!0);
    if (!t) return;
    const e = this._getCursorBoundaries();
    this.selectionStart !== this.selectionEnd || this.inCompositionMode ? this.renderSelection(t, e) : this.renderCursor(t, e), this.canvas.contextTopDirty = !0, t.restore();
  }
  _getCursorBoundaries() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart, e = arguments.length > 1 ? arguments[1] : void 0;
    const s = this._getLeftOffset(), r = this._getTopOffset(), n = this._getCursorBoundariesOffsets(t, e);
    return { left: s, top: r, leftOffset: n.left, topOffset: n.top };
  }
  _getCursorBoundariesOffsets(t, e) {
    return e ? this.__getCursorBoundariesOffsets(t) : this.cursorOffsetCache && "top" in this.cursorOffsetCache ? this.cursorOffsetCache : this.cursorOffsetCache = this.__getCursorBoundariesOffsets(t);
  }
  __getCursorBoundariesOffsets(t) {
    let e = 0, s = 0;
    const { charIndex: r, lineIndex: n } = this.get2DCursorLocation(t);
    for (let l = 0; l < n; l++) e += this.getHeightOfLine(l);
    const o = this._getLineLeftOffset(n), a = this.__charBounds[n][r];
    a && (s = a.left), this.charSpacing !== 0 && r === this._textLines[n].length && (s -= this._getWidthOfCharSpacing());
    const c = { top: e, left: o + (s > 0 ? s : 0) };
    return this.direction === "rtl" && (this.textAlign === Z || this.textAlign === Ht || this.textAlign === Vs ? c.left *= -1 : this.textAlign === L || this.textAlign === ni ? c.left = o - (s > 0 ? s : 0) : this.textAlign !== j && this.textAlign !== Gs || (c.left = o - (s > 0 ? s : 0))), c;
  }
  renderCursorAt(t) {
    this._renderCursor(this.canvas.contextTop, this._getCursorBoundaries(t, !0), t);
  }
  renderCursor(t, e) {
    this._renderCursor(t, e, this.selectionStart);
  }
  getCursorRenderingData() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._getCursorBoundaries(t);
    const s = this.get2DCursorLocation(t), r = s.lineIndex, n = s.charIndex > 0 ? s.charIndex - 1 : 0, o = this.getValueOfPropertyAt(r, n, "fontSize"), a = this.getObjectScaling().x * this.canvas.getZoom(), c = this.cursorWidth / a, l = this.getValueOfPropertyAt(r, n, "deltaY"), h = e.topOffset + (1 - this._fontSizeFraction) * this.getHeightOfLine(r) / this.lineHeight - o * (1 - this._fontSizeFraction);
    return { color: this.cursorColor || this.getValueOfPropertyAt(r, n, "fill"), opacity: this._currentCursorOpacity, left: e.left + e.leftOffset - c / 2, top: h + e.top + l, width: c, height: o };
  }
  _renderCursor(t, e, s) {
    const { color: r, opacity: n, left: o, top: a, width: c, height: l } = this.getCursorRenderingData(s, e);
    t.fillStyle = r, t.globalAlpha = n, t.fillRect(o, a, c, l);
  }
  renderSelection(t, e) {
    const s = { selectionStart: this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart, selectionEnd: this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd };
    this._renderSelection(t, s, e);
  }
  renderDragSourceEffect() {
    const t = this.draggableTextDelegate.getDragStartSelection();
    this._renderSelection(this.canvas.contextTop, t, this._getCursorBoundaries(t.selectionStart, !0));
  }
  renderDropTargetEffect(t) {
    const e = this.getSelectionStartFromPointer(t);
    this.renderCursorAt(e);
  }
  _renderSelection(t, e, s) {
    const r = e.selectionStart, n = e.selectionEnd, o = this.textAlign.includes(Ht), a = this.get2DCursorLocation(r), c = this.get2DCursorLocation(n), l = a.lineIndex, h = c.lineIndex, u = a.charIndex < 0 ? 0 : a.charIndex, d = c.charIndex < 0 ? 0 : c.charIndex;
    for (let f = l; f <= h; f++) {
      const g = this._getLineLeftOffset(f) || 0;
      let p = this.getHeightOfLine(f), m = 0, b = 0, S = 0;
      if (f === l && (b = this.__charBounds[l][u].left), f >= l && f < h) S = o && !this.isEndOfWrapping(f) ? this.width : this.getLineWidth(f) || 5;
      else if (f === h) if (d === 0) S = this.__charBounds[h][d].left;
      else {
        const I = this._getWidthOfCharSpacing();
        S = this.__charBounds[h][d - 1].left + this.__charBounds[h][d - 1].width - I;
      }
      m = p, (this.lineHeight < 1 || f === h && this.lineHeight > 1) && (p /= this.lineHeight);
      let w = s.left + g + b, k = p, O = 0;
      const x = S - b;
      this.inCompositionMode ? (t.fillStyle = this.compositionColor || "black", k = 1, O = p) : t.fillStyle = this.selectionColor, this.direction === "rtl" && (this.textAlign === Z || this.textAlign === Ht || this.textAlign === Vs ? w = this.width - w - x : this.textAlign === L || this.textAlign === ni ? w = s.left + g - S : this.textAlign !== j && this.textAlign !== Gs || (w = s.left + g - S)), t.fillRect(w, s.top + s.topOffset + O, x, k), s.topOffset += m;
    }
  }
  getCurrentCharFontSize() {
    const t = this._getCurrentCharIndex();
    return this.getValueOfPropertyAt(t.l, t.c, "fontSize");
  }
  getCurrentCharColor() {
    const t = this._getCurrentCharIndex();
    return this.getValueOfPropertyAt(t.l, t.c, rt);
  }
  _getCurrentCharIndex() {
    const t = this.get2DCursorLocation(this.selectionStart, !0), e = t.charIndex > 0 ? t.charIndex - 1 : 0;
    return { l: t.lineIndex, c: e };
  }
  dispose() {
    this.exitEditingImpl(), this.draggableTextDelegate.dispose(), super.dispose();
  }
}
y(oe, "ownDefaults", jd), y(oe, "type", "IText"), C.setClass(oe), C.setClass(oe, "i-text");
class Le extends oe {
  static getDefaults() {
    return v(v({}, super.getDefaults()), Le.ownDefaults);
  }
  constructor(t, e) {
    super(t, v(v({}, Le.ownDefaults), e));
  }
  static createControls() {
    return { controls: Oc() };
  }
  initDimensions() {
    this.initialized && (this.isEditing && this.initDelayedCursor(), this._clearCache(), this.dynamicMinWidth = 0, this._styleMap = this._generateStyleMap(this._splitText()), this.dynamicMinWidth > this.width && this._set("width", this.dynamicMinWidth), this.textAlign.includes(Ht) && this.enlargeSpaces(), this.height = this.calcTextHeight());
  }
  _generateStyleMap(t) {
    let e = 0, s = 0, r = 0;
    const n = {};
    for (let o = 0; o < t.graphemeLines.length; o++) t.graphemeText[r] === `
` && o > 0 ? (s = 0, r++, e++) : !this.splitByGrapheme && this._reSpaceAndTab.test(t.graphemeText[r]) && o > 0 && (s++, r++), n[o] = { line: e, offset: s }, r += t.graphemeLines[o].length, s += t.graphemeLines[o].length;
    return n;
  }
  styleHas(t, e) {
    if (this._styleMap && !this.isWrapping) {
      const s = this._styleMap[e];
      s && (e = s.line);
    }
    return super.styleHas(t, e);
  }
  isEmptyStyles(t) {
    if (!this.styles) return !0;
    let e, s = 0, r = t + 1, n = !1;
    const o = this._styleMap[t], a = this._styleMap[t + 1];
    o && (t = o.line, s = o.offset), a && (r = a.line, n = r === t, e = a.offset);
    const c = t === void 0 ? this.styles : { line: this.styles[t] };
    for (const l in c) for (const h in c[l]) {
      const u = parseInt(h, 10);
      if (u >= s && (!n || u < e)) for (const d in c[l][h]) return !1;
    }
    return !0;
  }
  _getStyleDeclaration(t, e) {
    if (this._styleMap && !this.isWrapping) {
      const s = this._styleMap[t];
      if (!s) return {};
      t = s.line, e = s.offset + e;
    }
    return super._getStyleDeclaration(t, e);
  }
  _setStyleDeclaration(t, e, s) {
    const r = this._styleMap[t];
    super._setStyleDeclaration(r.line, r.offset + e, s);
  }
  _deleteStyleDeclaration(t, e) {
    const s = this._styleMap[t];
    super._deleteStyleDeclaration(s.line, s.offset + e);
  }
  _getLineStyle(t) {
    const e = this._styleMap[t];
    return !!this.styles[e.line];
  }
  _setLineStyle(t) {
    const e = this._styleMap[t];
    super._setLineStyle(e.line);
  }
  _wrapText(t, e) {
    this.isWrapping = !0;
    const s = this.getGraphemeDataForRender(t), r = [];
    for (let n = 0; n < s.wordsData.length; n++) r.push(...this._wrapLine(n, e, s));
    return this.isWrapping = !1, r;
  }
  getGraphemeDataForRender(t) {
    const e = this.splitByGrapheme, s = e ? "" : " ";
    let r = 0;
    return { wordsData: t.map((n, o) => {
      let a = 0;
      const c = e ? this.graphemeSplit(n) : this.wordSplit(n);
      return c.length === 0 ? [{ word: [], width: 0 }] : c.map((l) => {
        const h = e ? [l] : this.graphemeSplit(l), u = this._measureWord(h, o, a);
        return r = Math.max(u, r), a += h.length + s.length, { word: h, width: u };
      });
    }), largestWordWidth: r };
  }
  _measureWord(t, e) {
    let s, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, n = 0;
    for (let o = 0, a = t.length; o < a; o++)
      n += this._getGraphemeBox(t[o], e, o + r, s, !0).kernedWidth, s = t[o];
    return n;
  }
  wordSplit(t) {
    return t.split(this._wordJoiners);
  }
  _wrapLine(t, e, s) {
    let { largestWordWidth: r, wordsData: n } = s, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    const a = this._getWidthOfCharSpacing(), c = this.splitByGrapheme, l = [], h = c ? "" : " ";
    let u = 0, d = [], f = 0, g = 0, p = !0;
    e -= o;
    const m = Math.max(e, r, this.dynamicMinWidth), b = n[t];
    let S;
    for (f = 0, S = 0; S < b.length; S++) {
      const { word: w, width: k } = b[S];
      f += w.length, u += g + k - a, u > m && !p ? (l.push(d), d = [], u = k, p = !0) : u += a, p || c || d.push(h), d = d.concat(w), g = c ? 0 : this._measureWord([h], t, f), f++, p = !1;
    }
    return S && l.push(d), r + o > this.dynamicMinWidth && (this.dynamicMinWidth = r - a + o), l;
  }
  isEndOfWrapping(t) {
    return !this._styleMap[t + 1] || this._styleMap[t + 1].line !== this._styleMap[t].line;
  }
  missingNewlineOffset(t, e) {
    return this.splitByGrapheme && !e ? this.isEndOfWrapping(t) ? 1 : 0 : 1;
  }
  _splitTextIntoLines(t) {
    const e = super._splitTextIntoLines(t), s = this._wrapText(e.lines, this.width), r = new Array(s.length);
    for (let n = 0; n < s.length; n++) r[n] = s[n].join("");
    return e.lines = r, e.graphemeLines = s, e;
  }
  getMinWidth() {
    return Math.max(this.minWidth, this.dynamicMinWidth);
  }
  _removeExtraneousStyles() {
    const t = /* @__PURE__ */ new Map();
    for (const e in this._styleMap) {
      const s = parseInt(e, 10);
      if (this._textLines[s]) {
        const r = this._styleMap[e].line;
        t.set("".concat(r), !0);
      }
    }
    for (const e in this.styles) t.has(e) || delete this.styles[e];
  }
  toObject() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject(["minWidth", "splitByGrapheme", ...t]);
  }
}
y(Le, "type", "Textbox"), y(Le, "textLayoutProperties", [...oe.textLayoutProperties, "width"]), y(Le, "ownDefaults", { minWidth: 20, dynamicMinWidth: 2, lockScalingFlip: !0, noScaleCache: !1, _wordJoiners: /[ \t\r]/, splitByGrapheme: !1 }), C.setClass(Le);
class Yo extends Ci {
  shouldPerformLayout(t) {
    return !!t.target.clipPath && super.shouldPerformLayout(t);
  }
  shouldLayoutClipPath() {
    return !1;
  }
  calcLayoutResult(t, e) {
    const { target: s } = t, { clipPath: r, group: n } = s;
    if (!r || !this.shouldPerformLayout(t)) return;
    const { width: o, height: a } = Gt(Fc(s, r)), c = new _(o, a);
    if (r.absolutePositioned)
      return { center: ae(r.getRelativeCenterPoint(), void 0, n ? n.calcTransformMatrix() : void 0), size: c };
    {
      const l = r.getRelativeCenterPoint().transform(s.calcOwnMatrix(), !0);
      if (this.shouldPerformLayout(t)) {
        const { center: h = new _(), correction: u = new _() } = this.calcBoundingBox(e, t) || {};
        return { center: h.add(l), correction: u.subtract(l), size: c };
      }
      return { center: s.getRelativeCenterPoint().add(l), size: c };
    }
  }
}
y(Yo, "type", "clip-path"), C.setClass(Yo);
class Vo extends Ci {
  getInitialSize(t, e) {
    let { target: s } = t, { size: r } = e;
    return new _(s.width || r.x, s.height || r.y);
  }
}
y(Vo, "type", "fixed"), C.setClass(Vo);
class Ed extends Zs {
  subscribeTargets(t) {
    const e = t.target;
    t.targets.reduce((s, r) => (r.parent && s.add(r.parent), s), /* @__PURE__ */ new Set()).forEach((s) => {
      s.layoutManager.subscribeTargets({ target: s, targets: [e] });
    });
  }
  unsubscribeTargets(t) {
    const e = t.target, s = e.getObjects();
    t.targets.reduce((r, n) => (n.parent && r.add(n.parent), r), /* @__PURE__ */ new Set()).forEach((r) => {
      !s.some((n) => n.parent === r) && r.layoutManager.unsubscribeTargets({ target: r, targets: [e] });
    });
  }
}
class Ot extends Nt {
  static getDefaults() {
    return v(v({}, super.getDefaults()), Ot.ownDefaults);
  }
  constructor() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), Object.assign(this, Ot.ownDefaults), this.setOptions(e);
    const { left: s, top: r, layoutManager: n } = e;
    this.groupInit(t, { left: s, top: r, layoutManager: n ?? new Ed() });
  }
  _shouldSetNestedCoords() {
    return !0;
  }
  __objectSelectionMonitor() {
  }
  multiSelectAdd() {
    for (var t = arguments.length, e = new Array(t), s = 0; s < t; s++) e[s] = arguments[s];
    this.multiSelectionStacking === "selection-order" ? this.add(...e) : e.forEach((r) => {
      const n = this._objects.findIndex((a) => a.isInFrontOf(r)), o = n === -1 ? this.size() : n;
      this.insertAt(o, r);
    });
  }
  canEnterGroup(t) {
    return this.getObjects().some((e) => e.isDescendantOf(t) || t.isDescendantOf(e)) ? (Te("error", "ActiveSelection: circular object trees are not supported, this call has no effect"), !1) : super.canEnterGroup(t);
  }
  enterGroup(t, e) {
    t.parent && t.parent === t.group ? t.parent._exitGroup(t) : t.group && t.parent !== t.group && t.group.remove(t), this._enterGroup(t, e);
  }
  exitGroup(t, e) {
    this._exitGroup(t, e), t.parent && t.parent._enterGroup(t, !0);
  }
  _onAfterObjectsChange(t, e) {
    super._onAfterObjectsChange(t, e);
    const s = /* @__PURE__ */ new Set();
    e.forEach((r) => {
      const { parent: n } = r;
      n && s.add(n);
    }), t === Zn ? s.forEach((r) => {
      r._onAfterObjectsChange(ei, e);
    }) : s.forEach((r) => {
      r._set("dirty", !0);
    });
  }
  onDeselect() {
    return this.removeAll(), !1;
  }
  toString() {
    return "#<ActiveSelection: (".concat(this.complexity(), ")>");
  }
  shouldCache() {
    return !1;
  }
  isOnACache() {
    return !1;
  }
  _renderControls(t, e, s) {
    t.save(), t.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
    const r = v(v({ hasControls: !1 }, s), {}, { forActiveSelection: !0 });
    for (let n = 0; n < this._objects.length; n++) this._objects[n]._renderControls(t, r);
    super._renderControls(t, e), t.restore();
  }
}
y(Ot, "type", "ActiveSelection"), y(Ot, "ownDefaults", { multiSelectionStacking: "canvas-stacking" }), C.setClass(Ot), C.setClass(Ot, "activeSelection");
class Pd {
  constructor() {
    y(this, "resources", {});
  }
  applyFilters(t, e, s, r, n) {
    const o = n.getContext("2d");
    if (!o) return;
    o.drawImage(e, 0, 0, s, r);
    const a = { sourceWidth: s, sourceHeight: r, imageData: o.getImageData(0, 0, s, r), originalEl: e, originalImageData: o.getImageData(0, 0, s, r), canvasEl: n, ctx: o, filterBackend: this };
    t.forEach((l) => {
      l.applyTo(a);
    });
    const { imageData: c } = a;
    return c.width === s && c.height === r || (n.width = c.width, n.height = c.height), o.putImageData(c, 0, 0), a;
  }
}
class ol {
  constructor() {
    let { tileSize: t = A.textureSize } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    y(this, "aPosition", new Float32Array([0, 0, 0, 1, 1, 0, 1, 1])), y(this, "resources", {}), this.tileSize = t, this.setupGLContext(t, t), this.captureGPUInfo();
  }
  setupGLContext(t, e) {
    this.dispose(), this.createWebGLCanvas(t, e);
  }
  createWebGLCanvas(t, e) {
    const s = Wt({ width: t, height: e }), r = s.getContext("webgl", { alpha: !0, premultipliedAlpha: !1, depth: !1, stencil: !1, antialias: !1 });
    r && (r.clearColor(0, 0, 0, 0), this.canvas = s, this.gl = r);
  }
  applyFilters(t, e, s, r, n, o) {
    const a = this.gl, c = n.getContext("2d");
    if (!a || !c) return;
    let l;
    o && (l = this.getCachedTexture(o, e));
    const h = { originalWidth: e.width || e.naturalWidth || 0, originalHeight: e.height || e.naturalHeight || 0, sourceWidth: s, sourceHeight: r, destinationWidth: s, destinationHeight: r, context: a, sourceTexture: this.createTexture(a, s, r, l ? void 0 : e), targetTexture: this.createTexture(a, s, r), originalTexture: l || this.createTexture(a, s, r, l ? void 0 : e), passes: t.length, webgl: !0, aPosition: this.aPosition, programCache: this.programCache, pass: 0, filterBackend: this, targetCanvas: n }, u = a.createFramebuffer();
    return a.bindFramebuffer(a.FRAMEBUFFER, u), t.forEach((d) => {
      d && d.applyTo(h);
    }), function(d) {
      const f = d.targetCanvas, g = f.width, p = f.height, m = d.destinationWidth, b = d.destinationHeight;
      g === m && p === b || (f.width = m, f.height = b);
    }(h), this.copyGLTo2D(a, h), a.bindTexture(a.TEXTURE_2D, null), a.deleteTexture(h.sourceTexture), a.deleteTexture(h.targetTexture), a.deleteFramebuffer(u), c.setTransform(1, 0, 0, 1, 0, 0), h;
  }
  dispose() {
    this.canvas && (this.canvas = null, this.gl = null), this.clearWebGLCaches();
  }
  clearWebGLCaches() {
    this.programCache = {}, this.textureCache = {};
  }
  createTexture(t, e, s, r, n) {
    const { NEAREST: o, TEXTURE_2D: a, RGBA: c, UNSIGNED_BYTE: l, CLAMP_TO_EDGE: h, TEXTURE_MAG_FILTER: u, TEXTURE_MIN_FILTER: d, TEXTURE_WRAP_S: f, TEXTURE_WRAP_T: g } = t, p = t.createTexture();
    return t.bindTexture(a, p), t.texParameteri(a, u, n || o), t.texParameteri(a, d, n || o), t.texParameteri(a, f, h), t.texParameteri(a, g, h), r ? t.texImage2D(a, 0, c, c, l, r) : t.texImage2D(a, 0, c, e, s, 0, c, l, null), p;
  }
  getCachedTexture(t, e, s) {
    const { textureCache: r } = this;
    if (r[t]) return r[t];
    {
      const n = this.createTexture(this.gl, e.width, e.height, e, s);
      return n && (r[t] = n), n;
    }
  }
  evictCachesForKey(t) {
    this.textureCache[t] && (this.gl.deleteTexture(this.textureCache[t]), delete this.textureCache[t]);
  }
  copyGLTo2D(t, e) {
    const s = t.canvas, r = e.targetCanvas, n = r.getContext("2d");
    if (!n) return;
    n.translate(0, r.height), n.scale(1, -1);
    const o = s.height - r.height;
    n.drawImage(s, 0, o, r.width, r.height, 0, 0, r.width, r.height);
  }
  copyGLTo2DPutImageData(t, e) {
    const s = e.targetCanvas.getContext("2d"), r = e.destinationWidth, n = e.destinationHeight, o = r * n * 4;
    if (!s) return;
    const a = new Uint8Array(this.imageBuffer, 0, o), c = new Uint8ClampedArray(this.imageBuffer, 0, o);
    t.readPixels(0, 0, r, n, t.RGBA, t.UNSIGNED_BYTE, a);
    const l = new ImageData(c, r, n);
    s.putImageData(l, 0, 0);
  }
  captureGPUInfo() {
    if (this.gpuInfo) return this.gpuInfo;
    const t = this.gl, e = { renderer: "", vendor: "" };
    if (!t) return e;
    const s = t.getExtension("WEBGL_debug_renderer_info");
    if (s) {
      const r = t.getParameter(s.UNMASKED_RENDERER_WEBGL), n = t.getParameter(s.UNMASKED_VENDOR_WEBGL);
      r && (e.renderer = r.toLowerCase()), n && (e.vendor = n.toLowerCase());
    }
    return this.gpuInfo = e, e;
  }
}
let Ui;
function Ad() {
  const { WebGLProbe: i } = $t();
  return i.queryWebGL(kt()), A.enableGLFiltering && i.isSupported(A.textureSize) ? new ol({ tileSize: A.textureSize }) : new Pd();
}
function $i() {
  return !Ui && (!(arguments.length > 0 && arguments[0] !== void 0) || arguments[0]) && (Ui = Ad()), Ui;
}
const Fd = ["filters", "resizeFilter", "src", "crossOrigin", "type"], al = ["cropX", "cropY"];
class wt extends nt {
  static getDefaults() {
    return v(v({}, super.getDefaults()), wt.ownDefaults);
  }
  constructor(t, e) {
    super(), y(this, "_lastScaleX", 1), y(this, "_lastScaleY", 1), y(this, "_filterScalingX", 1), y(this, "_filterScalingY", 1), this.filters = [], Object.assign(this, wt.ownDefaults), this.setOptions(e), this.cacheKey = "texture".concat(we()), this.setElement(typeof t == "string" ? (this.canvas && At(this.canvas.getElement()) || Cs()).getElementById(t) : t, e);
  }
  getElement() {
    return this._element;
  }
  setElement(t) {
    var e;
    let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.removeTexture(this.cacheKey), this.removeTexture("".concat(this.cacheKey, "_filtered")), this._element = t, this._originalElement = t, this._setWidthHeight(s), (e = t.classList) === null || e === void 0 || e.add(wt.CSS_CANVAS), this.filters.length !== 0 && this.applyFilters(), this.resizeFilter && this.applyResizeFilters();
  }
  removeTexture(t) {
    const e = $i(!1);
    e instanceof ol && e.evictCachesForKey(t);
  }
  dispose() {
    super.dispose(), this.removeTexture(this.cacheKey), this.removeTexture("".concat(this.cacheKey, "_filtered")), this._cacheContext = null, ["_originalElement", "_element", "_filteredEl", "_cacheCanvas"].forEach((t) => {
      const e = this[t];
      e && $t().dispose(e), this[t] = void 0;
    });
  }
  getCrossOrigin() {
    return this._originalElement && (this._originalElement.crossOrigin || null);
  }
  getOriginalSize() {
    const t = this.getElement();
    return t ? { width: t.naturalWidth || t.width, height: t.naturalHeight || t.height } : { width: 0, height: 0 };
  }
  _stroke(t) {
    if (!this.stroke || this.strokeWidth === 0) return;
    const e = this.width / 2, s = this.height / 2;
    t.beginPath(), t.moveTo(-e, -s), t.lineTo(e, -s), t.lineTo(e, s), t.lineTo(-e, s), t.lineTo(-e, -s), t.closePath();
  }
  toObject() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const e = [];
    return this.filters.forEach((s) => {
      s && e.push(s.toObject());
    }), v(v({}, super.toObject([...al, ...t])), {}, { src: this.getSrc(), crossOrigin: this.getCrossOrigin(), filters: e }, this.resizeFilter ? { resizeFilter: this.resizeFilter.toObject() } : {});
  }
  hasCrop() {
    return !!this.cropX || !!this.cropY || this.width < this._element.width || this.height < this._element.height;
  }
  _toSVG() {
    const t = [], e = this._element, s = -this.width / 2, r = -this.height / 2;
    let n = [], o = [], a = "", c = "";
    if (!e) return [];
    if (this.hasCrop()) {
      const l = we();
      n.push('<clipPath id="imageCrop_' + l + `">
`, '	<rect x="' + s + '" y="' + r + '" width="' + this.width + '" height="' + this.height + `" />
`, `</clipPath>
`), a = ' clip-path="url(#imageCrop_' + l + ')" ';
    }
    if (this.imageSmoothing || (c = ' image-rendering="optimizeSpeed"'), t.push("	<image ", "COMMON_PARTS", 'xlink:href="'.concat(this.getSvgSrc(!0), '" x="').concat(s - this.cropX, '" y="').concat(r - this.cropY, '" width="').concat(e.width || e.naturalWidth, '" height="').concat(e.height || e.naturalHeight, '"').concat(c).concat(a, `></image>
`)), this.stroke || this.strokeDashArray) {
      const l = this.fill;
      this.fill = null, o = ['	<rect x="'.concat(s, '" y="').concat(r, '" width="').concat(this.width, '" height="').concat(this.height, '" style="').concat(this.getSvgStyles(), `" />
`)], this.fill = l;
    }
    return n = this.paintFirst !== rt ? n.concat(o, t) : n.concat(t, o), n;
  }
  getSrc(t) {
    const e = t ? this._element : this._originalElement;
    return e ? e.toDataURL ? e.toDataURL() : this.srcFromAttribute ? e.getAttribute("src") || "" : e.src : this.src || "";
  }
  getSvgSrc(t) {
    return this.getSrc(t);
  }
  setSrc(t) {
    let { crossOrigin: e, signal: s } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return Ys(t, { crossOrigin: e, signal: s }).then((r) => {
      e !== void 0 && this.set({ crossOrigin: e }), this.setElement(r);
    });
  }
  toString() {
    return '#<Image: { src: "'.concat(this.getSrc(), '" }>');
  }
  applyResizeFilters() {
    const t = this.resizeFilter, e = this.minimumScaleTrigger, s = this.getTotalObjectScaling(), r = s.x, n = s.y, o = this._filteredEl || this._originalElement;
    if (this.group && this.set("dirty", !0), !t || r > e && n > e) return this._element = o, this._filterScalingX = 1, this._filterScalingY = 1, this._lastScaleX = r, void (this._lastScaleY = n);
    const a = Wt(o), { width: c, height: l } = o;
    this._element = a, this._lastScaleX = t.scaleX = r, this._lastScaleY = t.scaleY = n, $i().applyFilters([t], o, c, l, this._element), this._filterScalingX = a.width / this._originalElement.width, this._filterScalingY = a.height / this._originalElement.height;
  }
  applyFilters() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.filters || [];
    if (t = t.filter((n) => n && !n.isNeutralState()), this.set("dirty", !0), this.removeTexture("".concat(this.cacheKey, "_filtered")), t.length === 0) return this._element = this._originalElement, this._filteredEl = void 0, this._filterScalingX = 1, void (this._filterScalingY = 1);
    const e = this._originalElement, s = e.naturalWidth || e.width, r = e.naturalHeight || e.height;
    if (this._element === this._originalElement) {
      const n = Wt({ width: s, height: r });
      this._element = n, this._filteredEl = n;
    } else this._filteredEl && (this._element = this._filteredEl, this._filteredEl.getContext("2d").clearRect(0, 0, s, r), this._lastScaleX = 1, this._lastScaleY = 1);
    $i().applyFilters(t, this._originalElement, s, r, this._element, this.cacheKey), this._originalElement.width === this._element.width && this._originalElement.height === this._element.height || (this._filterScalingX = this._element.width / this._originalElement.width, this._filterScalingY = this._element.height / this._originalElement.height);
  }
  _render(t) {
    t.imageSmoothingEnabled = this.imageSmoothing, this.isMoving !== !0 && this.resizeFilter && this._needsResize() && this.applyResizeFilters(), this._stroke(t), this._renderPaintInOrder(t);
  }
  drawCacheOnCanvas(t) {
    t.imageSmoothingEnabled = this.imageSmoothing, super.drawCacheOnCanvas(t);
  }
  shouldCache() {
    return this.needsItsOwnCache();
  }
  _renderFill(t) {
    const e = this._element;
    if (!e) return;
    const s = this._filterScalingX, r = this._filterScalingY, n = this.width, o = this.height, a = Math.max(this.cropX, 0), c = Math.max(this.cropY, 0), l = e.naturalWidth || e.width, h = e.naturalHeight || e.height, u = a * s, d = c * r, f = Math.min(n * s, l - u), g = Math.min(o * r, h - d), p = -n / 2, m = -o / 2, b = Math.min(n, l / s - a), S = Math.min(o, h / r - c);
    e && t.drawImage(e, u, d, f, g, p, m, b, S);
  }
  _needsResize() {
    const t = this.getTotalObjectScaling();
    return t.x !== this._lastScaleX || t.y !== this._lastScaleY;
  }
  _resetWidthHeight() {
    this.set(this.getOriginalSize());
  }
  _setWidthHeight() {
    let { width: t, height: e } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const s = this.getOriginalSize();
    this.width = t || s.width, this.height = e || s.height;
  }
  parsePreserveAspectRatioAttribute() {
    const t = qa(this.preserveAspectRatio || ""), e = this.width, s = this.height, r = { width: e, height: s };
    let n, o = this._element.width, a = this._element.height, c = 1, l = 1, h = 0, u = 0, d = 0, f = 0;
    return !t || t.alignX === pt && t.alignY === pt ? (c = e / o, l = s / a) : (t.meetOrSlice === "meet" && (c = l = Lc(this._element, r), n = (e - o * c) / 2, t.alignX === "Min" && (h = -n), t.alignX === "Max" && (h = n), n = (s - a * l) / 2, t.alignY === "Min" && (u = -n), t.alignY === "Max" && (u = n)), t.meetOrSlice === "slice" && (c = l = Bc(this._element, r), n = o - e / c, t.alignX === "Mid" && (d = n / 2), t.alignX === "Max" && (d = n), n = a - s / l, t.alignY === "Mid" && (f = n / 2), t.alignY === "Max" && (f = n), o = e / c, a = s / l)), { width: o, height: a, scaleX: c, scaleY: l, offsetLeft: h, offsetTop: u, cropX: d, cropY: f };
  }
  static fromObject(t, e) {
    let { filters: s, resizeFilter: r, src: n, crossOrigin: o, type: a } = t, c = G(t, Fd);
    return Promise.all([Ys(n, v(v({}, e), {}, { crossOrigin: o })), s && bs(s, e), r && bs([r], e), cr(c, e)]).then((l) => {
      let [h, u = [], [d] = [], f = {}] = l;
      return new this(h, v(v({}, c), {}, { src: n, filters: u, resizeFilter: d }, f));
    });
  }
  static fromURL(t) {
    let { crossOrigin: e = null, signal: s } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = arguments.length > 2 ? arguments[2] : void 0;
    return Ys(t, { crossOrigin: e, signal: s }).then((n) => new this(n, r));
  }
  static async fromElement(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, s = arguments.length > 2 ? arguments[2] : void 0;
    const r = fe(t, this.ATTRIBUTE_NAMES, s);
    return this.fromURL(r["xlink:href"], e, r).catch((n) => (Te("log", "Unable to parse Image", n), null));
  }
}
y(wt, "type", "Image"), y(wt, "cacheProperties", [...de, ...al]), y(wt, "ownDefaults", { strokeWidth: 0, srcFromAttribute: !1, minimumScaleTrigger: 0.5, cropX: 0, cropY: 0, imageSmoothing: !0 }), y(wt, "CSS_CANVAS", "canvas-img"), y(wt, "ATTRIBUTE_NAMES", [...De, "x", "y", "width", "height", "preserveAspectRatio", "xlink:href", "crossOrigin", "image-rendering"]), C.setClass(wt), C.setSVGClass(wt);
_i(["pattern", "defs", "symbol", "metadata", "clipPath", "mask", "desc"]);
const cl = Xa, Go = (i) => function(t, e, s) {
  const { points: r, pathOffset: n } = s;
  return new _(r[i]).subtract(n).transform(J(s.getViewportTransform(), s.calcTransformMatrix()));
}, ll = (i, t, e, s) => {
  const { target: r, pointIndex: n } = t, o = r, a = ae(new _(e, s), void 0, o.calcOwnMatrix());
  return o.points[n] = a.add(o.pathOffset), o.setDimensions(), !0;
}, hl = (i, t) => function(e, s, r, n) {
  const o = s.target, a = new _(o.points[(i > 0 ? i : o.points.length) - 1]), c = a.subtract(o.pathOffset).transform(o.calcOwnMatrix()), l = t(e, v(v({}, s), {}, { pointIndex: i }), r, n), h = a.subtract(o.pathOffset).transform(o.calcOwnMatrix()).subtract(c);
  return o.left -= h.x, o.top -= h.y, l;
}, No = (i) => Ie(cl, hl(i, ll)), bn = (i, t, e) => {
  const { path: s, pathOffset: r } = i, n = s[t];
  return new _(n[e] - r.x, n[e + 1] - r.y).transform(J(i.getViewportTransform(), i.calcTransformMatrix()));
};
function Rd(i, t, e) {
  const { commandIndex: s, pointIndex: r } = this;
  return bn(e, s, r);
}
function Ld(i, t, e, s) {
  const { target: r } = t, { commandIndex: n, pointIndex: o } = this, a = ((c, l, h, u, d) => {
    const { path: f, pathOffset: g } = c, p = f[(u > 0 ? u : f.length) - 1], m = new _(p[d], p[d + 1]), b = m.subtract(g).transform(c.calcOwnMatrix()), S = ae(new _(l, h), void 0, c.calcOwnMatrix());
    f[u][d] = S.x + g.x, f[u][d + 1] = S.y + g.y, c.setDimensions();
    const w = m.subtract(c.pathOffset).transform(c.calcOwnMatrix()).subtract(b);
    return c.left -= w.x, c.top -= w.y, c.set("dirty", !0), !0;
  })(r, e, s, n, o);
  return Hn(this.actionName, v(v({}, Yn(i, t, e, s)), {}, { commandIndex: n, pointIndex: o })), a;
}
class ul extends U {
  constructor(t) {
    super(t);
  }
  render(t, e, s, r, n) {
    const o = v(v({}, r), {}, { cornerColor: this.controlFill, cornerStrokeColor: this.controlStroke, transparentCorners: !this.controlFill });
    super.render(t, e, s, o, n);
  }
}
class Bd extends ul {
  constructor(t) {
    super(t);
  }
  render(t, e, s, r, n) {
    const { path: o } = n, { commandIndex: a, pointIndex: c, connectToCommandIndex: l, connectToPointIndex: h } = this;
    t.save(), t.strokeStyle = this.controlStroke, this.connectionDashArray && t.setLineDash(this.connectionDashArray);
    const [u] = o[a], d = bn(n, l, h);
    if (u === "Q") {
      const f = bn(n, a, c + 2);
      t.moveTo(f.x, f.y), t.lineTo(e, s);
    } else t.moveTo(e, s);
    t.lineTo(d.x, d.y), t.stroke(), t.restore(), super.render(t, e, s, r, n);
  }
}
const Cr = (i, t, e, s, r, n) => new (e ? Bd : ul)(v(v({ commandIndex: i, pointIndex: t, actionName: "modifyPath", positionHandler: Rd, actionHandler: Ld, connectToCommandIndex: r, connectToPointIndex: n }, s), e ? s.controlPointStyle : s.pointStyle));
var Ds = Object.freeze({ __proto__: null, changeWidth: hn, createObjectDefaultControls: qn, createPathControls: function(i) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const e = {};
  let s = "M";
  return i.path.forEach((r, n) => {
    const o = r[0];
    switch (o !== "Z" && (e["c_".concat(n, "_").concat(o)] = Cr(n, r.length - 2, !1, t)), o) {
      case "C":
        e["c_".concat(n, "_C_CP_1")] = Cr(n, 1, !0, t, n - 1, /* @__PURE__ */ ((a) => a === "C" ? 5 : a === "Q" ? 3 : 1)(s)), e["c_".concat(n, "_C_CP_2")] = Cr(n, 3, !0, t, n, 5);
        break;
      case "Q":
        e["c_".concat(n, "_Q_CP_1")] = Cr(n, 1, !0, t, n, 3);
    }
    s = o;
  }), e;
}, createPolyActionHandler: No, createPolyControls: function(i) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const e = {};
  for (let s = 0; s < (typeof i == "number" ? i : i.points.length); s++) e["p".concat(s)] = new U(v({ actionName: cl, positionHandler: Go(s), actionHandler: No(s) }, t));
  return e;
}, createPolyPositionHandler: Go, createResizeControls: Cc, createTextboxDefaultControls: Oc, dragHandler: oc, factoryPolyActionHandler: hl, getLocalPoint: bi, polyActionHandler: ll, renderCircleControl: fc, renderSquareControl: gc, rotationStyleHandler: pc, rotationWithSnapping: mc, scaleCursorStyleHandler: Ze, scaleOrSkewActionName: Bs, scaleSkewCursorStyleHandler: Fe, scalingEqually: Ls, scalingX: bc, scalingXOrSkewingY: un, scalingY: _c, scalingYOrSkewingX: dn, skewCursorStyleHandler: Sc, skewHandlerX: xc, skewHandlerY: wc, wrapWithFireEvent: Ie, wrapWithFixedAnchor: Ge });
const ki = (i) => i.webgl !== void 0, to = "precision highp float", Wd = `
    `.concat(to, `;
    varying vec2 vTexCoord;
    uniform sampler2D uTexture;
    void main() {
      gl_FragColor = texture2D(uTexture, vTexCoord);
    }`), Xd = ["type"], zd = ["type"], Hd = new RegExp(to, "g");
class it {
  get type() {
    return this.constructor.type;
  }
  constructor() {
    let t = G(arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, Xd);
    Object.assign(this, this.constructor.defaults, t);
  }
  getFragmentSource() {
    return Wd;
  }
  getVertexSource() {
    return `
    attribute vec2 aPosition;
    varying vec2 vTexCoord;
    void main() {
      vTexCoord = aPosition;
      gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);
    }`;
  }
  createProgram(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.getFragmentSource(), s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.getVertexSource();
    const { WebGLProbe: { GLPrecision: r = "highp" } } = $t();
    r !== "highp" && (e = e.replace(Hd, to.replace("highp", r)));
    const n = t.createShader(t.VERTEX_SHADER), o = t.createShader(t.FRAGMENT_SHADER), a = t.createProgram();
    if (!n || !o || !a) throw new Yt("Vertex, fragment shader or program creation error");
    if (t.shaderSource(n, s), t.compileShader(n), !t.getShaderParameter(n, t.COMPILE_STATUS)) throw new Yt("Vertex shader compile error for ".concat(this.type, ": ").concat(t.getShaderInfoLog(n)));
    if (t.shaderSource(o, e), t.compileShader(o), !t.getShaderParameter(o, t.COMPILE_STATUS)) throw new Yt("Fragment shader compile error for ".concat(this.type, ": ").concat(t.getShaderInfoLog(o)));
    if (t.attachShader(a, n), t.attachShader(a, o), t.linkProgram(a), !t.getProgramParameter(a, t.LINK_STATUS)) throw new Yt('Shader link error for "'.concat(this.type, '" ').concat(t.getProgramInfoLog(a)));
    const c = this.getUniformLocations(t, a) || {};
    return c.uStepW = t.getUniformLocation(a, "uStepW"), c.uStepH = t.getUniformLocation(a, "uStepH"), { program: a, attributeLocations: this.getAttributeLocations(t, a), uniformLocations: c };
  }
  getAttributeLocations(t, e) {
    return { aPosition: t.getAttribLocation(e, "aPosition") };
  }
  getUniformLocations(t, e) {
    const s = this.constructor.uniformLocations, r = {};
    for (let n = 0; n < s.length; n++) r[s[n]] = t.getUniformLocation(e, s[n]);
    return r;
  }
  sendAttributeData(t, e, s) {
    const r = e.aPosition, n = t.createBuffer();
    t.bindBuffer(t.ARRAY_BUFFER, n), t.enableVertexAttribArray(r), t.vertexAttribPointer(r, 2, t.FLOAT, !1, 0, 0), t.bufferData(t.ARRAY_BUFFER, s, t.STATIC_DRAW);
  }
  _setupFrameBuffer(t) {
    const e = t.context;
    if (t.passes > 1) {
      const s = t.destinationWidth, r = t.destinationHeight;
      t.sourceWidth === s && t.sourceHeight === r || (e.deleteTexture(t.targetTexture), t.targetTexture = t.filterBackend.createTexture(e, s, r)), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t.targetTexture, 0);
    } else e.bindFramebuffer(e.FRAMEBUFFER, null), e.finish();
  }
  _swapTextures(t) {
    t.passes--, t.pass++;
    const e = t.targetTexture;
    t.targetTexture = t.sourceTexture, t.sourceTexture = e;
  }
  isNeutralState(t) {
    return !1;
  }
  applyTo(t) {
    ki(t) ? (this._setupFrameBuffer(t), this.applyToWebGL(t), this._swapTextures(t)) : this.applyTo2d(t);
  }
  applyTo2d(t) {
  }
  getCacheKey() {
    return this.type;
  }
  retrieveShader(t) {
    const e = this.getCacheKey();
    return t.programCache[e] || (t.programCache[e] = this.createProgram(t.context)), t.programCache[e];
  }
  applyToWebGL(t) {
    const e = t.context, s = this.retrieveShader(t);
    t.pass === 0 && t.originalTexture ? e.bindTexture(e.TEXTURE_2D, t.originalTexture) : e.bindTexture(e.TEXTURE_2D, t.sourceTexture), e.useProgram(s.program), this.sendAttributeData(e, s.attributeLocations, t.aPosition), e.uniform1f(s.uniformLocations.uStepW, 1 / t.sourceWidth), e.uniform1f(s.uniformLocations.uStepH, 1 / t.sourceHeight), this.sendUniformData(e, s.uniformLocations), e.viewport(0, 0, t.destinationWidth, t.destinationHeight), e.drawArrays(e.TRIANGLE_STRIP, 0, 4);
  }
  bindAdditionalTexture(t, e, s) {
    t.activeTexture(s), t.bindTexture(t.TEXTURE_2D, e), t.activeTexture(t.TEXTURE0);
  }
  unbindAdditionalTexture(t, e) {
    t.activeTexture(e), t.bindTexture(t.TEXTURE_2D, null), t.activeTexture(t.TEXTURE0);
  }
  sendUniformData(t, e) {
  }
  createHelpLayer(t) {
    if (!t.helpLayer) {
      const { sourceWidth: e, sourceHeight: s } = t, r = Wt({ width: e, height: s });
      t.helpLayer = r;
    }
  }
  toObject() {
    const t = Object.keys(this.constructor.defaults || {});
    return v({ type: this.type }, t.reduce((e, s) => (e[s] = this[s], e), {}));
  }
  toJSON() {
    return this.toObject();
  }
  static async fromObject(t, e) {
    return new this(G(t, zd));
  }
}
y(it, "type", "BaseFilter"), y(it, "uniformLocations", []);
const Yd = { multiply: `gl_FragColor.rgb *= uColor.rgb;
`, screen: `gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);
`, add: `gl_FragColor.rgb += uColor.rgb;
`, difference: `gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);
`, subtract: `gl_FragColor.rgb -= uColor.rgb;
`, lighten: `gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);
`, darken: `gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);
`, exclusion: `gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);
`, overlay: `
    if (uColor.r < 0.5) {
      gl_FragColor.r *= 2.0 * uColor.r;
    } else {
      gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);
    }
    if (uColor.g < 0.5) {
      gl_FragColor.g *= 2.0 * uColor.g;
    } else {
      gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);
    }
    if (uColor.b < 0.5) {
      gl_FragColor.b *= 2.0 * uColor.b;
    } else {
      gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);
    }
    `, tint: `
    gl_FragColor.rgb *= (1.0 - uColor.a);
    gl_FragColor.rgb += uColor.rgb;
    ` };
class Or extends it {
  getCacheKey() {
    return "".concat(this.type, "_").concat(this.mode);
  }
  getFragmentSource() {
    return `
      precision highp float;
      uniform sampler2D uTexture;
      uniform vec4 uColor;
      varying vec2 vTexCoord;
      void main() {
        vec4 color = texture2D(uTexture, vTexCoord);
        gl_FragColor = color;
        if (color.a > 0.0) {
          `.concat(Yd[this.mode], `
        }
      }
      `);
  }
  applyTo2d(t) {
    let { imageData: { data: e } } = t;
    const s = new W(this.color).getSource(), r = this.alpha, n = s[0] * r, o = s[1] * r, a = s[2] * r, c = 1 - r;
    for (let l = 0; l < e.length; l += 4) {
      const h = e[l], u = e[l + 1], d = e[l + 2];
      let f, g, p;
      switch (this.mode) {
        case "multiply":
          f = h * n / 255, g = u * o / 255, p = d * a / 255;
          break;
        case "screen":
          f = 255 - (255 - h) * (255 - n) / 255, g = 255 - (255 - u) * (255 - o) / 255, p = 255 - (255 - d) * (255 - a) / 255;
          break;
        case "add":
          f = h + n, g = u + o, p = d + a;
          break;
        case "difference":
          f = Math.abs(h - n), g = Math.abs(u - o), p = Math.abs(d - a);
          break;
        case "subtract":
          f = h - n, g = u - o, p = d - a;
          break;
        case "darken":
          f = Math.min(h, n), g = Math.min(u, o), p = Math.min(d, a);
          break;
        case "lighten":
          f = Math.max(h, n), g = Math.max(u, o), p = Math.max(d, a);
          break;
        case "overlay":
          f = n < 128 ? 2 * h * n / 255 : 255 - 2 * (255 - h) * (255 - n) / 255, g = o < 128 ? 2 * u * o / 255 : 255 - 2 * (255 - u) * (255 - o) / 255, p = a < 128 ? 2 * d * a / 255 : 255 - 2 * (255 - d) * (255 - a) / 255;
          break;
        case "exclusion":
          f = n + h - 2 * n * h / 255, g = o + u - 2 * o * u / 255, p = a + d - 2 * a * d / 255;
          break;
        case "tint":
          f = n + h * c, g = o + u * c, p = a + d * c;
      }
      e[l] = f, e[l + 1] = g, e[l + 2] = p;
    }
  }
  sendUniformData(t, e) {
    const s = new W(this.color).getSource();
    s[0] = this.alpha * s[0] / 255, s[1] = this.alpha * s[1] / 255, s[2] = this.alpha * s[2] / 255, s[3] = this.alpha, t.uniform4fv(e.uColor, s);
  }
}
y(Or, "defaults", { color: "#F95C63", mode: "multiply", alpha: 1 }), y(Or, "type", "BlendColor"), y(Or, "uniformLocations", ["uColor"]), C.setClass(Or);
const Vd = { multiply: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform sampler2D uImage;
    uniform vec4 uColor;
    varying vec2 vTexCoord;
    varying vec2 vTexCoord2;
    void main() {
      vec4 color = texture2D(uTexture, vTexCoord);
      vec4 color2 = texture2D(uImage, vTexCoord2);
      color.rgba *= color2.rgba;
      gl_FragColor = color;
    }
    `, mask: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform sampler2D uImage;
    uniform vec4 uColor;
    varying vec2 vTexCoord;
    varying vec2 vTexCoord2;
    void main() {
      vec4 color = texture2D(uTexture, vTexCoord);
      vec4 color2 = texture2D(uImage, vTexCoord2);
      color.a = color2.a;
      gl_FragColor = color;
    }
    ` }, Gd = ["type", "image"];
class kr extends it {
  getCacheKey() {
    return "".concat(this.type, "_").concat(this.mode);
  }
  getFragmentSource() {
    return Vd[this.mode];
  }
  getVertexSource() {
    return `
    attribute vec2 aPosition;
    varying vec2 vTexCoord;
    varying vec2 vTexCoord2;
    uniform mat3 uTransformMatrix;
    void main() {
      vTexCoord = aPosition;
      vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;
      gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);
    }
    `;
  }
  applyToWebGL(t) {
    const e = t.context, s = this.createTexture(t.filterBackend, this.image);
    this.bindAdditionalTexture(e, s, e.TEXTURE1), super.applyToWebGL(t), this.unbindAdditionalTexture(e, e.TEXTURE1);
  }
  createTexture(t, e) {
    return t.getCachedTexture(e.cacheKey, e.getElement());
  }
  calculateMatrix() {
    const t = this.image, { width: e, height: s } = t.getElement();
    return [1 / t.scaleX, 0, 0, 0, 1 / t.scaleY, 0, -t.left / e, -t.top / s, 1];
  }
  applyTo2d(t) {
    let { imageData: { data: e, width: s, height: r }, filterBackend: { resources: n } } = t;
    const o = this.image;
    n.blendImage || (n.blendImage = kt());
    const a = n.blendImage, c = a.getContext("2d");
    a.width !== s || a.height !== r ? (a.width = s, a.height = r) : c.clearRect(0, 0, s, r), c.setTransform(o.scaleX, 0, 0, o.scaleY, o.left, o.top), c.drawImage(o.getElement(), 0, 0, s, r);
    const l = c.getImageData(0, 0, s, r).data;
    for (let h = 0; h < e.length; h += 4) {
      const u = e[h], d = e[h + 1], f = e[h + 2], g = e[h + 3], p = l[h], m = l[h + 1], b = l[h + 2], S = l[h + 3];
      switch (this.mode) {
        case "multiply":
          e[h] = u * p / 255, e[h + 1] = d * m / 255, e[h + 2] = f * b / 255, e[h + 3] = g * S / 255;
          break;
        case "mask":
          e[h + 3] = S;
      }
    }
  }
  sendUniformData(t, e) {
    const s = this.calculateMatrix();
    t.uniform1i(e.uImage, 1), t.uniformMatrix3fv(e.uTransformMatrix, !1, s);
  }
  toObject() {
    return v(v({}, super.toObject()), {}, { image: this.image && this.image.toObject() });
  }
  static async fromObject(t, e) {
    let { type: s, image: r } = t, n = G(t, Gd);
    return wt.fromObject(r, e).then((o) => new this(v(v({}, n), {}, { image: o })));
  }
}
y(kr, "type", "BlendImage"), y(kr, "defaults", { mode: "multiply", alpha: 1 }), y(kr, "uniformLocations", ["uTransformMatrix", "uImage"]), C.setClass(kr);
class Mr extends it {
  getFragmentSource() {
    return `
    precision highp float;
    uniform sampler2D uTexture;
    uniform vec2 uDelta;
    varying vec2 vTexCoord;
    const float nSamples = 15.0;
    vec3 v3offset = vec3(12.9898, 78.233, 151.7182);
    float random(vec3 scale) {
      /* use the fragment position for a different seed per-pixel */
      return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);
    }
    void main() {
      vec4 color = vec4(0.0);
      float total = 0.0;
      float offset = random(v3offset);
      for (float t = -nSamples; t <= nSamples; t++) {
        float percent = (t + offset - 0.5) / nSamples;
        float weight = 1.0 - abs(percent);
        color += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;
        total += weight;
      }
      gl_FragColor = color / total;
    }
  `;
  }
  applyTo(t) {
    ki(t) ? (this.aspectRatio = t.sourceWidth / t.sourceHeight, t.passes++, this._setupFrameBuffer(t), this.horizontal = !0, this.applyToWebGL(t), this._swapTextures(t), this._setupFrameBuffer(t), this.horizontal = !1, this.applyToWebGL(t), this._swapTextures(t)) : this.applyTo2d(t);
  }
  applyTo2d(t) {
    t.imageData = this.simpleBlur(t);
  }
  simpleBlur(t) {
    let { ctx: e, imageData: s, filterBackend: { resources: r } } = t;
    const { width: n, height: o } = s;
    r.blurLayer1 || (r.blurLayer1 = kt(), r.blurLayer2 = kt());
    const a = r.blurLayer1, c = r.blurLayer2;
    a.width === n && a.height === o || (c.width = a.width = n, c.height = a.height = o);
    const l = a.getContext("2d"), h = c.getContext("2d"), u = 15, d = 0.06 * this.blur * 0.5;
    let f, g, p, m;
    for (l.putImageData(s, 0, 0), h.clearRect(0, 0, n, o), m = -15; m <= u; m++) f = (Math.random() - 0.5) / 4, g = m / u, p = d * g * n + f, h.globalAlpha = 1 - Math.abs(g), h.drawImage(a, p, f), l.drawImage(c, 0, 0), h.globalAlpha = 1, h.clearRect(0, 0, c.width, c.height);
    for (m = -15; m <= u; m++) f = (Math.random() - 0.5) / 4, g = m / u, p = d * g * o + f, h.globalAlpha = 1 - Math.abs(g), h.drawImage(a, f, p), l.drawImage(c, 0, 0), h.globalAlpha = 1, h.clearRect(0, 0, c.width, c.height);
    e.drawImage(a, 0, 0);
    const b = e.getImageData(0, 0, a.width, a.height);
    return l.globalAlpha = 1, l.clearRect(0, 0, a.width, a.height), b;
  }
  sendUniformData(t, e) {
    const s = this.chooseRightDelta();
    t.uniform2fv(e.uDelta, s);
  }
  isNeutralState() {
    return this.blur === 0;
  }
  chooseRightDelta() {
    let t = 1;
    const e = [0, 0];
    this.horizontal ? this.aspectRatio > 1 && (t = 1 / this.aspectRatio) : this.aspectRatio < 1 && (t = this.aspectRatio);
    const s = t * this.blur * 0.12;
    return this.horizontal ? e[0] = s : e[1] = s, e;
  }
}
y(Mr, "type", "Blur"), y(Mr, "defaults", { blur: 0 }), y(Mr, "uniformLocations", ["uDelta"]), C.setClass(Mr);
class Ir extends it {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uBrightness;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    color.rgb += uBrightness;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(t) {
    let { imageData: { data: e } } = t;
    const s = Math.round(255 * this.brightness);
    for (let r = 0; r < e.length; r += 4) e[r] += s, e[r + 1] += s, e[r + 2] += s;
  }
  isNeutralState() {
    return this.brightness === 0;
  }
  sendUniformData(t, e) {
    t.uniform1f(e.uBrightness, this.brightness);
  }
}
y(Ir, "type", "Brightness"), y(Ir, "defaults", { brightness: 0 }), y(Ir, "uniformLocations", ["uBrightness"]), C.setClass(Ir);
const dl = { matrix: [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], colorsOnly: !0 };
class ts extends it {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  varying vec2 vTexCoord;
  uniform mat4 uColorMatrix;
  uniform vec4 uConstants;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    color *= uColorMatrix;
    color += uConstants;
    gl_FragColor = color;
  }`;
  }
  applyTo2d(t) {
    const e = t.imageData.data, s = this.matrix, r = this.colorsOnly;
    for (let n = 0; n < e.length; n += 4) {
      const o = e[n], a = e[n + 1], c = e[n + 2];
      if (e[n] = o * s[0] + a * s[1] + c * s[2] + 255 * s[4], e[n + 1] = o * s[5] + a * s[6] + c * s[7] + 255 * s[9], e[n + 2] = o * s[10] + a * s[11] + c * s[12] + 255 * s[14], !r) {
        const l = e[n + 3];
        e[n] += l * s[3], e[n + 1] += l * s[8], e[n + 2] += l * s[13], e[n + 3] = o * s[15] + a * s[16] + c * s[17] + l * s[18] + 255 * s[19];
      }
    }
  }
  sendUniformData(t, e) {
    const s = this.matrix, r = [s[0], s[1], s[2], s[3], s[5], s[6], s[7], s[8], s[10], s[11], s[12], s[13], s[15], s[16], s[17], s[18]], n = [s[4], s[9], s[14], s[19]];
    t.uniformMatrix4fv(e.uColorMatrix, !1, r), t.uniform4fv(e.uConstants, n);
  }
  toObject() {
    return v(v({}, super.toObject()), {}, { matrix: [...this.matrix] });
  }
}
function Ne(i, t) {
  var e;
  const s = (y(e = class extends ts {
    toObject() {
      return { type: this.type, colorsOnly: this.colorsOnly };
    }
  }, "type", i), y(e, "defaults", { colorsOnly: !1, matrix: t }), e);
  return C.setClass(s, i), s;
}
y(ts, "type", "ColorMatrix"), y(ts, "defaults", dl), y(ts, "uniformLocations", ["uColorMatrix", "uConstants"]), C.setClass(ts);
Ne("Brownie", [0.5997, 0.34553, -0.27082, 0, 0.186, -0.0377, 0.86095, 0.15059, 0, -0.1449, 0.24113, -0.07441, 0.44972, 0, -0.02965, 0, 0, 0, 1, 0]);
Ne("Vintage", [0.62793, 0.32021, -0.03965, 0, 0.03784, 0.02578, 0.64411, 0.03259, 0, 0.02926, 0.0466, -0.08512, 0.52416, 0, 0.02023, 0, 0, 0, 1, 0]);
Ne("Kodachrome", [1.12855, -0.39673, -0.03992, 0, 0.24991, -0.16404, 1.08352, -0.05498, 0, 0.09698, -0.16786, -0.56034, 1.60148, 0, 0.13972, 0, 0, 0, 1, 0]);
Ne("Technicolor", [1.91252, -0.85453, -0.09155, 0, 0.04624, -0.30878, 1.76589, -0.10601, 0, -0.27589, -0.2311, -0.75018, 1.84759, 0, 0.12137, 0, 0, 0, 1, 0]);
Ne("Polaroid", [1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0]);
Ne("Sepia", [0.393, 0.769, 0.189, 0, 0, 0.349, 0.686, 0.168, 0, 0, 0.272, 0.534, 0.131, 0, 0, 0, 0, 0, 1, 0]);
Ne("BlackWhite", [1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 0, 0, 0, 1, 0]);
class Uo extends it {
  constructor() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(t), this.subFilters = t.subFilters || [];
  }
  applyTo(t) {
    ki(t) && (t.passes += this.subFilters.length - 1), this.subFilters.forEach((e) => {
      e.applyTo(t);
    });
  }
  toObject() {
    return { type: this.type, subFilters: this.subFilters.map((t) => t.toObject()) };
  }
  isNeutralState() {
    return !this.subFilters.some((t) => !t.isNeutralState());
  }
  static fromObject(t, e) {
    return Promise.all((t.subFilters || []).map((s) => C.getClass(s.type).fromObject(s, e))).then((s) => new this({ subFilters: s }));
  }
}
y(Uo, "type", "Composed"), C.setClass(Uo);
class Dr extends it {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uContrast;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));
    color.rgb = contrastF * (color.rgb - 0.5) + 0.5;
    gl_FragColor = color;
  }`;
  }
  isNeutralState() {
    return this.contrast === 0;
  }
  applyTo2d(t) {
    let { imageData: { data: e } } = t;
    const s = Math.floor(255 * this.contrast), r = 259 * (s + 255) / (255 * (259 - s));
    for (let n = 0; n < e.length; n += 4) e[n] = r * (e[n] - 128) + 128, e[n + 1] = r * (e[n + 1] - 128) + 128, e[n + 2] = r * (e[n + 2] - 128) + 128;
  }
  sendUniformData(t, e) {
    t.uniform1f(e.uContrast, this.contrast);
  }
}
y(Dr, "type", "Contrast"), y(Dr, "defaults", { contrast: 0 }), y(Dr, "uniformLocations", ["uContrast"]), C.setClass(Dr);
const Nd = { Convolute_3_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[9];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 3.0; h+=1.0) {
        for (float w = 0.0; w < 3.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_3_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[9];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 3.0; h+=1.0) {
        for (float w = 0.0; w < 3.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    `, Convolute_5_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[25];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 5.0; h+=1.0) {
        for (float w = 0.0; w < 5.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_5_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[25];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 5.0; h+=1.0) {
        for (float w = 0.0; w < 5.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    `, Convolute_7_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[49];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 7.0; h+=1.0) {
        for (float w = 0.0; w < 7.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_7_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[49];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 7.0; h+=1.0) {
        for (float w = 0.0; w < 7.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    `, Convolute_9_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[81];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 9.0; h+=1.0) {
        for (float w = 0.0; w < 9.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_9_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[81];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 9.0; h+=1.0) {
        for (float w = 0.0; w < 9.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    ` };
class jr extends it {
  getCacheKey() {
    return "".concat(this.type, "_").concat(Math.sqrt(this.matrix.length), "_").concat(this.opaque ? 1 : 0);
  }
  getFragmentSource() {
    return Nd[this.getCacheKey()];
  }
  applyTo2d(t) {
    const e = t.imageData, s = e.data, r = this.matrix, n = Math.round(Math.sqrt(r.length)), o = Math.floor(n / 2), a = e.width, c = e.height, l = t.ctx.createImageData(a, c), h = l.data, u = this.opaque ? 1 : 0;
    let d, f, g, p, m, b, S, w, k, O, x, I, M;
    for (x = 0; x < c; x++) for (O = 0; O < a; O++) {
      for (m = 4 * (x * a + O), d = 0, f = 0, g = 0, p = 0, M = 0; M < n; M++) for (I = 0; I < n; I++) S = x + M - o, b = O + I - o, S < 0 || S >= c || b < 0 || b >= a || (w = 4 * (S * a + b), k = r[M * n + I], d += s[w] * k, f += s[w + 1] * k, g += s[w + 2] * k, u || (p += s[w + 3] * k));
      h[m] = d, h[m + 1] = f, h[m + 2] = g, h[m + 3] = u ? s[m + 3] : p;
    }
    t.imageData = l;
  }
  sendUniformData(t, e) {
    t.uniform1fv(e.uMatrix, this.matrix);
  }
  toObject() {
    return v(v({}, super.toObject()), {}, { opaque: this.opaque, matrix: [...this.matrix] });
  }
}
y(jr, "type", "Convolute"), y(jr, "defaults", { opaque: !1, matrix: [0, 0, 0, 0, 1, 0, 0, 0, 0] }), y(jr, "uniformLocations", ["uMatrix", "uOpaque", "uHalfSize", "uSize"]), C.setClass(jr);
const fl = "Gamma";
class Er extends it {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform vec3 uGamma;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    vec3 correction = (1.0 / uGamma);
    color.r = pow(color.r, correction.r);
    color.g = pow(color.g, correction.g);
    color.b = pow(color.b, correction.b);
    gl_FragColor = color;
    gl_FragColor.rgb *= color.a;
  }
`;
  }
  constructor() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(t), this.gamma = t.gamma || this.constructor.defaults.gamma.concat();
  }
  applyTo2d(t) {
    let { imageData: { data: e } } = t;
    const s = this.gamma, r = 1 / s[0], n = 1 / s[1], o = 1 / s[2];
    this.rgbValues || (this.rgbValues = { r: new Uint8Array(256), g: new Uint8Array(256), b: new Uint8Array(256) });
    const a = this.rgbValues;
    for (let c = 0; c < 256; c++) a.r[c] = 255 * Math.pow(c / 255, r), a.g[c] = 255 * Math.pow(c / 255, n), a.b[c] = 255 * Math.pow(c / 255, o);
    for (let c = 0; c < e.length; c += 4) e[c] = a.r[e[c]], e[c + 1] = a.g[e[c + 1]], e[c + 2] = a.b[e[c + 2]];
  }
  sendUniformData(t, e) {
    t.uniform3fv(e.uGamma, this.gamma);
  }
  isNeutralState() {
    const { gamma: t } = this;
    return t[0] === 1 && t[1] === 1 && t[2] === 1;
  }
  toObject() {
    return { type: fl, gamma: this.gamma.concat() };
  }
}
y(Er, "type", fl), y(Er, "defaults", { gamma: [1, 1, 1] }), y(Er, "uniformLocations", ["uGamma"]), C.setClass(Er);
const Ud = { average: `
    precision highp float;
    uniform sampler2D uTexture;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = texture2D(uTexture, vTexCoord);
      float average = (color.r + color.b + color.g) / 3.0;
      gl_FragColor = vec4(average, average, average, color.a);
    }
    `, lightness: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform int uMode;
    varying vec2 vTexCoord;
    void main() {
      vec4 col = texture2D(uTexture, vTexCoord);
      float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;
      gl_FragColor = vec4(average, average, average, col.a);
    }
    `, luminosity: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform int uMode;
    varying vec2 vTexCoord;
    void main() {
      vec4 col = texture2D(uTexture, vTexCoord);
      float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;
      gl_FragColor = vec4(average, average, average, col.a);
    }
    ` };
class Pr extends it {
  applyTo2d(t) {
    let { imageData: { data: e } } = t;
    for (let s, r = 0; r < e.length; r += 4) {
      const n = e[r], o = e[r + 1], a = e[r + 2];
      switch (this.mode) {
        case "average":
          s = (n + o + a) / 3;
          break;
        case "lightness":
          s = (Math.min(n, o, a) + Math.max(n, o, a)) / 2;
          break;
        case "luminosity":
          s = 0.21 * n + 0.72 * o + 0.07 * a;
      }
      e[r + 2] = e[r + 1] = e[r] = s;
    }
  }
  getCacheKey() {
    return "".concat(this.type, "_").concat(this.mode);
  }
  getFragmentSource() {
    return Ud[this.mode];
  }
  sendUniformData(t, e) {
    t.uniform1i(e.uMode, 1);
  }
  isNeutralState() {
    return !1;
  }
}
y(Pr, "type", "Grayscale"), y(Pr, "defaults", { mode: "average" }), y(Pr, "uniformLocations", ["uMode"]), C.setClass(Pr);
const $d = v(v({}, dl), {}, { rotation: 0 });
class qi extends ts {
  calculateMatrix() {
    const t = this.rotation * Math.PI, e = Lt(t), s = Bt(t), r = 1 / 3, n = Math.sqrt(r) * s, o = 1 - e;
    this.matrix = [e + o / 3, r * o - n, r * o + n, 0, 0, r * o + n, e + r * o, r * o - n, 0, 0, r * o - n, r * o + n, e + r * o, 0, 0, 0, 0, 0, 1, 0];
  }
  isNeutralState() {
    return this.rotation === 0;
  }
  applyTo(t) {
    this.calculateMatrix(), super.applyTo(t);
  }
  toObject() {
    return { type: this.type, rotation: this.rotation };
  }
}
y(qi, "type", "HueRotation"), y(qi, "defaults", $d), C.setClass(qi);
class Ar extends it {
  applyTo2d(t) {
    let { imageData: { data: e } } = t;
    for (let s = 0; s < e.length; s += 4) e[s] = 255 - e[s], e[s + 1] = 255 - e[s + 1], e[s + 2] = 255 - e[s + 2], this.alpha && (e[s + 3] = 255 - e[s + 3]);
  }
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform int uInvert;
  uniform int uAlpha;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    if (uInvert == 1) {
      if (uAlpha == 1) {
        gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,1.0 -color.a);
      } else {
        gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);
      }
    } else {
      gl_FragColor = color;
    }
  }
`;
  }
  isNeutralState() {
    return !this.invert;
  }
  sendUniformData(t, e) {
    t.uniform1i(e.uInvert, Number(this.invert)), t.uniform1i(e.uAlpha, Number(this.alpha));
  }
}
y(Ar, "type", "Invert"), y(Ar, "defaults", { alpha: !1, invert: !0 }), y(Ar, "uniformLocations", ["uInvert", "uAlpha"]), C.setClass(Ar);
class Fr extends it {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uStepH;
  uniform float uNoise;
  uniform float uSeed;
  varying vec2 vTexCoord;
  float rand(vec2 co, float seed, float vScale) {
    return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);
  }
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(t) {
    let { imageData: { data: e } } = t;
    const s = this.noise;
    for (let r = 0; r < e.length; r += 4) {
      const n = (0.5 - Math.random()) * s;
      e[r] += n, e[r + 1] += n, e[r + 2] += n;
    }
  }
  sendUniformData(t, e) {
    t.uniform1f(e.uNoise, this.noise / 255), t.uniform1f(e.uSeed, Math.random());
  }
  isNeutralState() {
    return this.noise === 0;
  }
}
y(Fr, "type", "Noise"), y(Fr, "defaults", { noise: 0 }), y(Fr, "uniformLocations", ["uNoise", "uSeed"]), C.setClass(Fr);
class Rr extends it {
  applyTo2d(t) {
    let { imageData: { data: e, width: s, height: r } } = t;
    for (let n = 0; n < r; n += this.blocksize) for (let o = 0; o < s; o += this.blocksize) {
      const a = 4 * n * s + 4 * o, c = e[a], l = e[a + 1], h = e[a + 2], u = e[a + 3];
      for (let d = n; d < Math.min(n + this.blocksize, r); d++) for (let f = o; f < Math.min(o + this.blocksize, s); f++) {
        const g = 4 * d * s + 4 * f;
        e[g] = c, e[g + 1] = l, e[g + 2] = h, e[g + 3] = u;
      }
    }
  }
  isNeutralState() {
    return this.blocksize === 1;
  }
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uBlocksize;
  uniform float uStepW;
  uniform float uStepH;
  varying vec2 vTexCoord;
  void main() {
    float blockW = uBlocksize * uStepW;
    float blockH = uBlocksize * uStepH;
    int posX = int(vTexCoord.x / blockW);
    int posY = int(vTexCoord.y / blockH);
    float fposX = float(posX);
    float fposY = float(posY);
    vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);
    vec4 color = texture2D(uTexture, squareCoords);
    gl_FragColor = color;
  }
`;
  }
  sendUniformData(t, e) {
    t.uniform1f(e.uBlocksize, this.blocksize);
  }
}
y(Rr, "type", "Pixelate"), y(Rr, "defaults", { blocksize: 4 }), y(Rr, "uniformLocations", ["uBlocksize"]), C.setClass(Rr);
class Lr extends it {
  getFragmentSource() {
    return `
precision highp float;
uniform sampler2D uTexture;
uniform vec4 uLow;
uniform vec4 uHigh;
varying vec2 vTexCoord;
void main() {
  gl_FragColor = texture2D(uTexture, vTexCoord);
  if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {
    gl_FragColor.a = 0.0;
  }
}
`;
  }
  applyTo2d(t) {
    let { imageData: { data: e } } = t;
    const s = 255 * this.distance, r = new W(this.color).getSource(), n = [r[0] - s, r[1] - s, r[2] - s], o = [r[0] + s, r[1] + s, r[2] + s];
    for (let a = 0; a < e.length; a += 4) {
      const c = e[a], l = e[a + 1], h = e[a + 2];
      c > n[0] && l > n[1] && h > n[2] && c < o[0] && l < o[1] && h < o[2] && (e[a + 3] = 0);
    }
  }
  sendUniformData(t, e) {
    const s = new W(this.color).getSource(), r = this.distance, n = [0 + s[0] / 255 - r, 0 + s[1] / 255 - r, 0 + s[2] / 255 - r, 1], o = [s[0] / 255 + r, s[1] / 255 + r, s[2] / 255 + r, 1];
    t.uniform4fv(e.uLow, n), t.uniform4fv(e.uHigh, o);
  }
}
y(Lr, "type", "RemoveColor"), y(Lr, "defaults", { color: "#FFFFFF", distance: 0.02, useAlpha: !1 }), y(Lr, "uniformLocations", ["uLow", "uHigh"]), C.setClass(Lr);
class Br extends it {
  sendUniformData(t, e) {
    t.uniform2fv(e.uDelta, this.horizontal ? [1 / this.width, 0] : [0, 1 / this.height]), t.uniform1fv(e.uTaps, this.taps);
  }
  getFilterWindow() {
    const t = this.tempScale;
    return Math.ceil(this.lanczosLobes / t);
  }
  getCacheKey() {
    const t = this.getFilterWindow();
    return "".concat(this.type, "_").concat(t);
  }
  getFragmentSource() {
    const t = this.getFilterWindow();
    return this.generateShader(t);
  }
  getTaps() {
    const t = this.lanczosCreate(this.lanczosLobes), e = this.tempScale, s = this.getFilterWindow(), r = new Array(s);
    for (let n = 1; n <= s; n++) r[n - 1] = t(n * e);
    return r;
  }
  generateShader(t) {
    const e = new Array(t);
    for (let s = 1; s <= t; s++) e[s - 1] = "".concat(s, ".0 * uDelta");
    return `
      precision highp float;
      uniform sampler2D uTexture;
      uniform vec2 uDelta;
      varying vec2 vTexCoord;
      uniform float uTaps[`.concat(t, `];
      void main() {
        vec4 color = texture2D(uTexture, vTexCoord);
        float sum = 1.0;
        `).concat(e.map((s, r) => `
              color += texture2D(uTexture, vTexCoord + `.concat(s, ") * uTaps[").concat(r, "] + texture2D(uTexture, vTexCoord - ").concat(s, ") * uTaps[").concat(r, `];
              sum += 2.0 * uTaps[`).concat(r, `];
            `)).join(`
`), `
        gl_FragColor = color / sum;
      }
    `);
  }
  applyToForWebgl(t) {
    t.passes++, this.width = t.sourceWidth, this.horizontal = !0, this.dW = Math.round(this.width * this.scaleX), this.dH = t.sourceHeight, this.tempScale = this.dW / this.width, this.taps = this.getTaps(), t.destinationWidth = this.dW, super.applyTo(t), t.sourceWidth = t.destinationWidth, this.height = t.sourceHeight, this.horizontal = !1, this.dH = Math.round(this.height * this.scaleY), this.tempScale = this.dH / this.height, this.taps = this.getTaps(), t.destinationHeight = this.dH, super.applyTo(t), t.sourceHeight = t.destinationHeight;
  }
  applyTo(t) {
    ki(t) ? this.applyToForWebgl(t) : this.applyTo2d(t);
  }
  isNeutralState() {
    return this.scaleX === 1 && this.scaleY === 1;
  }
  lanczosCreate(t) {
    return (e) => {
      if (e >= t || e <= -t) return 0;
      if (e < 11920929e-14 && e > -11920929e-14) return 1;
      const s = (e *= Math.PI) / t;
      return Math.sin(e) / e * Math.sin(s) / s;
    };
  }
  applyTo2d(t) {
    const e = t.imageData, s = this.scaleX, r = this.scaleY;
    this.rcpScaleX = 1 / s, this.rcpScaleY = 1 / r;
    const n = e.width, o = e.height, a = Math.round(n * s), c = Math.round(o * r);
    let l;
    l = this.resizeType === "sliceHack" ? this.sliceByTwo(t, n, o, a, c) : this.resizeType === "hermite" ? this.hermiteFastResize(t, n, o, a, c) : this.resizeType === "bilinear" ? this.bilinearFiltering(t, n, o, a, c) : this.resizeType === "lanczos" ? this.lanczosResize(t, n, o, a, c) : new ImageData(a, c), t.imageData = l;
  }
  sliceByTwo(t, e, s, r, n) {
    const o = t.imageData, a = 0.5;
    let c = !1, l = !1, h = e * a, u = s * a;
    const d = t.filterBackend.resources;
    let f = 0, g = 0;
    const p = e;
    let m = 0;
    d.sliceByTwo || (d.sliceByTwo = kt());
    const b = d.sliceByTwo;
    (b.width < 1.5 * e || b.height < s) && (b.width = 1.5 * e, b.height = s);
    const S = b.getContext("2d");
    for (S.clearRect(0, 0, 1.5 * e, s), S.putImageData(o, 0, 0), r = Math.floor(r), n = Math.floor(n); !c || !l; ) e = h, s = u, r < Math.floor(h * a) ? h = Math.floor(h * a) : (h = r, c = !0), n < Math.floor(u * a) ? u = Math.floor(u * a) : (u = n, l = !0), S.drawImage(b, f, g, e, s, p, m, h, u), f = p, g = m, m += u;
    return S.getImageData(f, g, r, n);
  }
  lanczosResize(t, e, s, r, n) {
    const o = t.imageData.data, a = t.ctx.createImageData(r, n), c = a.data, l = this.lanczosCreate(this.lanczosLobes), h = this.rcpScaleX, u = this.rcpScaleY, d = 2 / this.rcpScaleX, f = 2 / this.rcpScaleY, g = Math.ceil(h * this.lanczosLobes / 2), p = Math.ceil(u * this.lanczosLobes / 2), m = {}, b = { x: 0, y: 0 }, S = { x: 0, y: 0 };
    return function w(k) {
      let O, x, I, M, E, R, tt, F, B, $, yt;
      for (b.x = (k + 0.5) * h, S.x = Math.floor(b.x), O = 0; O < n; O++) {
        for (b.y = (O + 0.5) * u, S.y = Math.floor(b.y), E = 0, R = 0, tt = 0, F = 0, B = 0, x = S.x - g; x <= S.x + g; x++) if (!(x < 0 || x >= e)) {
          $ = Math.floor(1e3 * Math.abs(x - b.x)), m[$] || (m[$] = {});
          for (let dt = S.y - p; dt <= S.y + p; dt++) dt < 0 || dt >= s || (yt = Math.floor(1e3 * Math.abs(dt - b.y)), m[$][yt] || (m[$][yt] = l(Math.sqrt(Math.pow($ * d, 2) + Math.pow(yt * f, 2)) / 1e3)), I = m[$][yt], I > 0 && (M = 4 * (dt * e + x), E += I, R += I * o[M], tt += I * o[M + 1], F += I * o[M + 2], B += I * o[M + 3]));
        }
        M = 4 * (O * r + k), c[M] = R / E, c[M + 1] = tt / E, c[M + 2] = F / E, c[M + 3] = B / E;
      }
      return ++k < r ? w(k) : a;
    }(0);
  }
  bilinearFiltering(t, e, s, r, n) {
    let o, a, c, l, h, u, d, f, g, p, m, b, S, w = 0;
    const k = this.rcpScaleX, O = this.rcpScaleY, x = 4 * (e - 1), I = t.imageData.data, M = t.ctx.createImageData(r, n), E = M.data;
    for (d = 0; d < n; d++) for (f = 0; f < r; f++) for (h = Math.floor(k * f), u = Math.floor(O * d), g = k * f - h, p = O * d - u, S = 4 * (u * e + h), m = 0; m < 4; m++) o = I[S + m], a = I[S + 4 + m], c = I[S + x + m], l = I[S + x + 4 + m], b = o * (1 - g) * (1 - p) + a * g * (1 - p) + c * p * (1 - g) + l * g * p, E[w++] = b;
    return M;
  }
  hermiteFastResize(t, e, s, r, n) {
    const o = this.rcpScaleX, a = this.rcpScaleY, c = Math.ceil(o / 2), l = Math.ceil(a / 2), h = t.imageData.data, u = t.ctx.createImageData(r, n), d = u.data;
    for (let f = 0; f < n; f++) for (let g = 0; g < r; g++) {
      const p = 4 * (g + f * r);
      let m = 0, b = 0, S = 0, w = 0, k = 0, O = 0, x = 0;
      const I = (f + 0.5) * a;
      for (let M = Math.floor(f * a); M < (f + 1) * a; M++) {
        const E = Math.abs(I - (M + 0.5)) / l, R = (g + 0.5) * o, tt = E * E;
        for (let F = Math.floor(g * o); F < (g + 1) * o; F++) {
          let B = Math.abs(R - (F + 0.5)) / c;
          const $ = Math.sqrt(tt + B * B);
          $ > 1 && $ < -1 || (m = 2 * $ * $ * $ - 3 * $ * $ + 1, m > 0 && (B = 4 * (F + M * e), x += m * h[B + 3], S += m, h[B + 3] < 255 && (m = m * h[B + 3] / 250), w += m * h[B], k += m * h[B + 1], O += m * h[B + 2], b += m));
        }
      }
      d[p] = w / b, d[p + 1] = k / b, d[p + 2] = O / b, d[p + 3] = x / S;
    }
    return u;
  }
}
y(Br, "type", "Resize"), y(Br, "defaults", { resizeType: "hermite", scaleX: 1, scaleY: 1, lanczosLobes: 3 }), y(Br, "uniformLocations", ["uDelta", "uTaps"]), C.setClass(Br);
class Wr extends it {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uSaturation;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    float rgMax = max(color.r, color.g);
    float rgbMax = max(rgMax, color.b);
    color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;
    color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;
    color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(t) {
    let { imageData: { data: e } } = t;
    const s = -this.saturation;
    for (let r = 0; r < e.length; r += 4) {
      const n = e[r], o = e[r + 1], a = e[r + 2], c = Math.max(n, o, a);
      e[r] += c !== n ? (c - n) * s : 0, e[r + 1] += c !== o ? (c - o) * s : 0, e[r + 2] += c !== a ? (c - a) * s : 0;
    }
  }
  sendUniformData(t, e) {
    t.uniform1f(e.uSaturation, -this.saturation);
  }
  isNeutralState() {
    return this.saturation === 0;
  }
}
y(Wr, "type", "Saturation"), y(Wr, "defaults", { saturation: 0 }), y(Wr, "uniformLocations", ["uSaturation"]), C.setClass(Wr);
class Xr extends it {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uVibrance;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    float max = max(color.r, max(color.g, color.b));
    float avg = (color.r + color.g + color.b) / 3.0;
    float amt = (abs(max - avg) * 2.0) * uVibrance;
    color.r += max != color.r ? (max - color.r) * amt : 0.00;
    color.g += max != color.g ? (max - color.g) * amt : 0.00;
    color.b += max != color.b ? (max - color.b) * amt : 0.00;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(t) {
    let { imageData: { data: e } } = t;
    const s = -this.vibrance;
    for (let r = 0; r < e.length; r += 4) {
      const n = e[r], o = e[r + 1], a = e[r + 2], c = Math.max(n, o, a), l = (n + o + a) / 3, h = 2 * Math.abs(c - l) / 255 * s;
      e[r] += c !== n ? (c - n) * h : 0, e[r + 1] += c !== o ? (c - o) * h : 0, e[r + 2] += c !== a ? (c - a) * h : 0;
    }
  }
  sendUniformData(t, e) {
    t.uniform1f(e.uVibrance, -this.vibrance);
  }
  isNeutralState() {
    return this.vibrance === 0;
  }
}
y(Xr, "type", "Vibrance"), y(Xr, "defaults", { vibrance: 0 }), y(Xr, "uniformLocations", ["uVibrance"]), C.setClass(Xr);
function qt(i, t, e, s, r) {
  const c = r.canvas.viewportTransform;
  i.save(), this.controlOrientation === "left" ? i.translate(
    r.left + c[4],
    r.top + c[5] + r.height / 2
  ) : i.translate(
    r.left + r.width + c[4],
    r.top + c[5] + r.height / 2
  ), i.rotate(sd.degreesToRadians(90 + r.angle)), i.lineWidth = 6, i.lineCap = "round", i.strokeStyle = "white", i.beginPath(), i.moveTo(-6, 0), i.lineTo(6, 0), i.stroke(), i.lineWidth = 4, i.strokeStyle = "black", i.beginPath(), i.moveTo(-6, 0), i.lineTo(6, 0), i.stroke(), i.restore();
}
const It = 1, vt = "rgba(255, 255, 255,1.0)", $o = [
  "Image",
  "Text",
  "Video",
  "Audio",
  "Caption",
  "Template",
  "Composition",
  "Illustration",
  "Shape"
], qd = [
  "image",
  "text",
  "video",
  "audio",
  "caption",
  "template",
  "composition",
  "illustration",
  "shape"
], Kd = {
  left: -0.5,
  top: -0.5,
  center: 0,
  bottom: 0.5,
  right: 0.5
}, P = (i) => typeof i == "string" ? Kd[i] : i - 0.5, He = "center", ur = "left", Q0 = "top", tb = "bottom", dr = "right", eb = "none";
function fr(i) {
  return P(i.originX) === P(He) && P(i.originY) === P(He);
}
function Mi(i) {
  return (t, e, s, r) => {
    const { target: n, originX: o, originY: a } = e, c = n.getRelativeCenterPoint(), l = n.translateToOriginPoint(c, o, a), h = i(t, e, s, r);
    return n.setPositionByOrigin(
      l,
      e.originX,
      e.originY
    ), h;
  };
}
const qo = 3, Jd = 4, gl = 188, Zd = 60, Qd = 1e3 / Zd;
function D(i, t = 1, e = 1) {
  const s = gl * t;
  return i * (60 / 1e3) * s / e;
}
function Y(i, t = 1, e = 1) {
  const s = gl * t;
  return i / s * Qd * e;
}
function sb(i, t = 1) {
  return D(i, t);
}
const pl = (i) => Object.keys(i).reduce((t, e) => {
  const { display: s, playbackRate: r } = i[e];
  return Math.max(t, s.to / (r || 1));
}, 0), { wrapWithFireEvent: tf, getLocalPoint: ef } = Ds, sf = (i, t, e, s) => {
  const r = ef(
    t,
    t.originX,
    t.originY,
    e,
    s
  );
  if (P(t.originX) === P(He) || P(t.originX) === P(dr) && r.x < 0 || P(t.originX) === P(ur) && r.x > 0) {
    let { target: n } = t, o = n.strokeWidth / (n.strokeUniform ? n.scaleX : 1), a = fr(t) ? 2 : 1, c = n.width, l = Math.ceil(
      Math.abs(r.x * a / n.scaleX) - o
    );
    if (t.corner === "mr") {
      const u = n.trim.to, d = l - c, f = Y(
        d,
        n.tScale,
        n.playbackRate
      ), g = u + f;
      if (g > n.duration) return !1;
      n.set("width", Math.max(l, 0)), n.trim.to = g;
    } else {
      if (n.left < 0) return !1;
      const u = c - l;
      if (n.left + u < 0) {
        const b = D(
          n.duration,
          n.tScale,
          n.playbackRate
        ), S = n.width + n.left;
        if (S <= b) {
          n.set("width", S);
          const w = Y(
            b - S,
            n.tScale,
            n.playbackRate
          );
          return n.trim.from = w, !0;
        }
        return !1;
      }
      const f = l - c, g = n.trim.from, p = Y(
        f,
        n.tScale,
        n.playbackRate
      ), m = g - p;
      if (m < 0) return !1;
      n.set("width", Math.max(l, 0)), n.trim.from = m, n.onResize && n.onResize();
    }
    return c !== n.width;
  }
  return !1;
}, _n = tf(
  "resizing",
  Mi(sf)
), { wrapWithFireEvent: rf, getLocalPoint: nf, wrapWithFixedAnchor: of } = Ds, af = (i, t, e, s) => {
  const r = nf(
    t,
    t.originX,
    t.originY,
    e,
    s
  );
  if (P(t.originX) === P(He) || P(t.originX) === P(dr) && r.x < 0 || P(t.originX) === P(ur) && r.x > 0) {
    const { target: n } = t, o = n.strokeWidth / (n.strokeUniform ? n.scaleX : 1), a = fr(t) ? 2 : 1, c = n.width, l = Math.ceil(
      Math.abs(r.x * a / n.scaleX) - o
    ), h = t.corner === "ml";
    if (n.left < 0) return !1;
    if (h) {
      const u = c - l;
      if (n.left + u < 0)
        return n.set("width", n.width + n.left), !0;
    }
    return n.set("width", Math.max(l, 0)), c !== n.width;
  }
  return !1;
}, Sn = rf(
  "resizing",
  of(af)
), { wrapWithFireEvent: cf, getLocalPoint: lf } = Ds, hf = (i, t, e, s) => {
  const r = lf(
    t,
    t.originX,
    t.originY,
    e,
    s
  );
  if (P(t.originX) === P(He) || P(t.originX) === P(dr) && r.x < 0 || P(t.originX) === P(ur) && r.x > 0) {
    const { target: n } = t, o = n.strokeWidth / (n.strokeUniform ? n.scaleX : 1), a = fr(t) ? 2 : 1, c = n.width, l = Math.ceil(
      Math.abs(r.x * a / n.scaleX) - o
    ), h = Y(
      l,
      n.tScale,
      n.playbackRate
    );
    return h >= 1500 || h < 500 ? !1 : (n.set("width", Math.max(l, 0)), n.set("duration", h), c !== n.width);
  }
  return !1;
}, Tn = cf(
  "resizing",
  Mi(hf)
), { wrapWithFireEvent: uf, getLocalPoint: df } = Ds, ff = (i, t, e, s) => {
  const r = df(
    t,
    t.originX,
    t.originY,
    e,
    s
  );
  if (P(t.originX) === P(He) || P(t.originX) === P(dr) && r.x < 0 || P(t.originX) === P(ur) && r.x > 0) {
    let { target: n } = t, o = n.strokeWidth / (n.strokeUniform ? n.scaleX : 1), a = fr(t) ? 2 : 1, c = n.width, l = Math.ceil(
      Math.abs(r.x * a / n.scaleX) - o
    );
    if (t.corner === "mr") {
      const u = n.trim.to, d = l - c, f = Y(
        d,
        n.tScale,
        n.playbackRate
      ), g = u + f;
      if (g > n.duration) return !1;
      n.set("width", Math.max(l, 0)), n.trim.to = g;
    } else {
      if (n.left < 0) return !1;
      const u = c - l;
      if (n.left + u < 0) return !1;
      const f = l - c, g = n.trim.from, p = Y(
        f,
        n.tScale,
        n.playbackRate
      ), m = g - p;
      if (m < 0) return !1;
      n.set("width", Math.max(l, 0)), n.trim.from = m;
    }
    return c !== n.width;
  }
  return !1;
}, Ko = uf(
  "resizing",
  Mi(ff)
), { scaleSkewCursorStyleHandler: Kt } = Ds, js = () => ({
  mr: new U({
    x: 0.5,
    y: 0,
    actionHandler: Sn,
    cursorStyleHandler: Kt,
    actionName: "resizing",
    render: qt,
    controlOrientation: "right"
  }),
  ml: new U({
    x: -0.5,
    y: 0,
    actionHandler: Sn,
    cursorStyleHandler: Kt,
    actionName: "resizing",
    render: qt,
    controlOrientation: "left"
  })
}), gf = () => ({
  mr: new U({
    x: 0.5,
    y: 0,
    render: qt,
    actionHandler: Ko,
    cursorStyleHandler: Kt,
    actionName: "resizing",
    controlOrientation: "right"
  }),
  ml: new U({
    x: -0.5,
    y: 0,
    render: qt,
    actionHandler: Ko,
    cursorStyleHandler: Kt,
    actionName: "resizing",
    controlOrientation: "left"
  })
}), pf = () => ({
  mr: new U({
    x: 0.5,
    y: 0,
    render: qt,
    actionHandler: _n,
    cursorStyleHandler: Kt,
    actionName: "resizing",
    controlOrientation: "right"
  }),
  ml: new U({
    x: -0.5,
    y: 0,
    render: qt,
    actionHandler: _n,
    cursorStyleHandler: Kt,
    actionName: "resizing",
    controlOrientation: "left"
  })
}), mf = () => ({
  mr: new U({
    x: 0.5,
    y: 0,
    render: qt,
    actionHandler: xn,
    cursorStyleHandler: Kt,
    actionName: "resizing",
    controlOrientation: "right"
  }),
  ml: new U({
    x: -0.5,
    y: 0,
    render: qt,
    actionHandler: xn,
    cursorStyleHandler: Kt,
    actionName: "resizing",
    controlOrientation: "left"
  })
}), ml = () => ({
  mr: new U({
    x: 0.5,
    y: 0,
    actionHandler: Tn,
    cursorStyleHandler: Kt,
    actionName: "resizing",
    render: qt,
    controlOrientation: "right"
  }),
  ml: new U({
    x: -0.5,
    y: 0,
    actionHandler: Tn,
    cursorStyleHandler: Kt,
    actionName: "resizing",
    render: qt,
    controlOrientation: "left"
  })
}), vf = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let gr = (i = 21) => {
  let t = "", e = crypto.getRandomValues(new Uint8Array(i |= 0));
  for (; i--; )
    t += vf[e[i] & 63];
  return t;
};
function Ws(i = 16) {
  const t = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", e = t.charAt(Math.floor(Math.random() * t.length));
  let s = gr(i - 1);
  return s = s.replace(/[^a-zA-Z0-9]/g, "").slice(0, i - 1), e + s;
}
const { wrapWithFireEvent: yf, getLocalPoint: bf } = Ds, _f = (i, t, e, s) => {
  const r = bf(
    t,
    t.originX,
    t.originY,
    e,
    s
  );
  if (P(t.originX) === P(He) || P(t.originX) === P(dr) && r.x < 0 || P(t.originX) === P(ur) && r.x > 0) {
    let { target: n } = t, o = n.strokeWidth / (n.strokeUniform ? n.scaleX : 1), a = fr(t) ? 2 : 1, c = n.width, l = Math.ceil(
      Math.abs(r.x * a / n.scaleX) - o
    );
    if (t.corner === "mr") {
      const u = n.trim.to, d = l - c, f = Y(
        d,
        n.tScale,
        n.playbackRate
      ), g = u + f;
      if (g > n.duration) return !1;
      n.set("width", Math.max(l, 0)), n.trim.to = g;
    } else {
      if (n.left < 0) return !1;
      const u = c - l;
      if (n.left + u < 0) {
        const b = D(
          n.duration,
          n.tScale,
          n.playbackRate
        ), S = n.width + n.left;
        if (S <= b) {
          n.set("width", S);
          const w = Y(
            b - S,
            n.tScale,
            n.playbackRate
          );
          return n.trim.from = w, !0;
        }
        return !1;
      }
      const f = l - c, g = n.trim.from, p = Y(
        f,
        n.tScale,
        n.playbackRate
      ), m = g - p;
      if (m < 0) return !1;
      n.set("width", Math.max(l, 0)), n.trim.from = m, n.onResize && n.onResize();
    }
    return c !== n.width;
  }
  return !1;
}, xn = yf(
  "resizing",
  Mi(_f)
), es = class es extends X {
  constructor(e) {
    super(e);
    T(this, "itemType", "image");
    T(this, "src");
    T(this, "isSelected", !1);
    Object.assign(this, es.ownDefaults), this.id = e.id, this.src = e.src, this.display = e.display, this.tScale = e.tScale;
  }
  static createControls() {
    return { controls: js() };
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...es.ownDefaults
    };
  }
  // add custom text to the track item
  _render(e) {
    super._render(e), this.updateSelected(e);
  }
  setSelected(e) {
    this.isSelected = e, this.set({ dirty: !0 });
  }
  updateSelected(e) {
    this.isSelected && (e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      this.rx
    ), e.lineWidth = It, e.strokeStyle = vt, e.stroke(), e.restore());
  }
  setSrc(e) {
    this.src = e;
  }
};
T(es, "type", "Image"), T(es, "ownDefaults", {
  rx: 8,
  ry: 8,
  objectCaching: !1,
  borderColor: "transparent",
  stroke: "transparent",
  strokeWidth: 0,
  borderOpacityWhenMoving: 1,
  hoverCursor: "default",
  fill: "#27272a"
});
let Qs = es;
C.setClass(Qs, "Image");
class _t extends X {
  constructor(e) {
    super(e);
    T(this, "id");
    T(this, "resourceId", "");
    T(this, "tScale");
    T(this, "isSelected", !1);
    T(this, "display");
    T(this, "trim");
    T(this, "duration");
    T(this, "src");
    this.id = e.id, this.tScale = e.tScale, this.objectCaching = !1, this.rx = 8, this.ry = 8, this.display = e.display, this.trim = e.trim, this.duration = e.duration, this.fill = "#27272a";
  }
  static createControls() {
    return { controls: mf() };
  }
  // add custom text to the track item
  _render(e) {
    super._render(e), this.updateSelected(e);
  }
  setSelected(e) {
    this.isSelected = e, this.set({ dirty: !0 });
  }
  updateSelected(e) {
    this.isSelected && (e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      this.rx
    ), e.lineWidth = It, e.strokeStyle = vt, e.stroke(), e.restore());
  }
  onResizeSnap() {
  }
  setSrc(e) {
    this.src = e;
  }
}
T(_t, "type", "Video");
C.setClass(_t, "Video");
const ss = class ss extends X {
  constructor(e) {
    super(e);
    T(this, "itemType", "audio");
    T(this, "isSelected", !1);
    T(this, "trim");
    T(this, "src");
    T(this, "duration");
    Object.assign(this, ss.ownDefaults), this.id = e.id, this.borderColor = "transparent", this.stroke = "transparent", this.strokeWidth = 0, this.tScale = e.tScale, this.display = e.display, this.trim = e.trim, this.src = e.src, this.duration = e.duration;
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...ss.ownDefaults
    };
  }
  static createControls() {
    return { controls: pf() };
  }
  setSelected(e) {
    this.isSelected = e, this.set({ dirty: !0 });
  }
  // add custom Audio to the track item
  _render(e) {
    super._render(e), this.updateSelected(e);
  }
  updateSelected(e) {
    this.isSelected && (e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      6
    ), e.lineWidth = It, e.strokeStyle = vt, e.stroke(), e.restore());
  }
  setSrc(e) {
    this.src = e;
  }
};
T(ss, "type", "Audio"), T(ss, "ownDefaults", {
  rx: 6,
  ry: 6,
  objectCaching: !1,
  borderColor: "transparent",
  stroke: "transparent",
  strokeWidth: 0,
  fill: "#27272a",
  borderOpacityWhenMoving: 1,
  hoverCursor: "default"
});
let ft = ss;
C.setClass(ft, "Audio");
const rs = class rs extends X {
  constructor(e) {
    super(e);
    T(this, "isSelected", !1);
    T(this, "text");
    Object.assign(this, rs.ownDefaults), this.id = e.id, this.borderColor = "transparent", this.stroke = "transparent", this.strokeWidth = 0, this.tScale = e.tScale, this.display = e.display, this.text = e.text;
  }
  static createControls() {
    return { controls: js() };
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...rs.ownDefaults
    };
  }
  setSelected(e) {
    this.isSelected = e, this.set({ dirty: !0 });
  }
  // add custom text to the track item
  _render(e) {
    super._render(e), this.updateSelected(e);
  }
  updateSelected(e) {
    this.isSelected && (e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      6
    ), e.lineWidth = It, e.strokeStyle = vt, e.stroke(), e.restore());
  }
};
T(rs, "type", "Text"), T(rs, "ownDefaults", {
  rx: 6,
  ry: 6,
  objectCaching: !1,
  borderColor: "transparent",
  stroke: "transparent",
  strokeWidth: 0,
  fill: "#27272a",
  borderOpacityWhenMoving: 1,
  hoverCursor: "default"
});
let tr = rs;
C.setClass(tr, "Text");
const Sf = {
  selectable: !1,
  evented: !1,
  strokeWidth: 0,
  stroke: "transparent"
}, is = class is extends X {
  constructor(e) {
    super(e);
    T(this, "id");
    T(this, "accepts", [
      "audio",
      "video",
      "image",
      "text",
      "caption",
      "template"
    ]);
    T(this, "metadata");
    T(this, "items", []);
    T(this, "magnetic");
    T(this, "static");
    Object.assign(this, is.ownDefaults), this.id = e.id, this.accepts = e.accepts || [], this.items = e.items || [], this.magnetic = e.magnetic, this.static = e.static, this.metadata = e.metadata, this.fill = "rgba(34, 34, 37, 0.8)";
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...is.ownDefaults
    };
  }
  updateCoords(e) {
    this.width = e;
  }
};
T(is, "ownDefaults", Sf), T(is, "type", "Track");
let ue = is;
C.setClass(ue, "Track");
const Tf = {
  top: {
    top: 35,
    guide: 2,
    bottom: 3
  },
  center: {
    top: 3,
    guide: 2,
    bottom: 3
  },
  bottom: {
    top: 3,
    guide: 2,
    bottom: 35
  }
}, xf = (i, t) => {
  const e = Tf[i];
  return i === "top" ? {
    top: t - (e.guide + e.bottom),
    guide: e.guide,
    bottom: e.bottom
  } : i === "center" ? {
    top: e.top,
    guide: e.guide,
    bottom: e.bottom
  } : {
    top: e == null ? void 0 : e.top,
    guide: e == null ? void 0 : e.guide,
    bottom: t - ((e == null ? void 0 : e.guide) + (e == null ? void 0 : e.top))
  };
}, ns = class ns extends Nt {
  constructor(e) {
    const s = xf(e.kind, e.height), r = new X({
      top: 0,
      left: 0,
      strokeWidth: 0,
      fill: "transparent",
      selectable: !0,
      height: s.top,
      width: e.width
    }), n = new X({
      top: s.top,
      left: 0,
      strokeWidth: 0,
      fill: "transparent",
      selectable: !0,
      height: s.guide,
      width: e.width
    }), o = new X({
      top: s.top + s.guide,
      left: 0,
      strokeWidth: 0,
      fill: "transparent",
      selectable: !0,
      height: s.bottom,
      width: e.width
    });
    super([r, n, o], e);
    T(this, "guide");
    T(this, "topGuide");
    T(this, "bottomGuide");
    T(this, "metadata");
    T(this, "accepts", []);
    T(this, "kind");
    T(this, "activeGuideFill");
    Object.assign(this, ns.ownDefaults), this.guide = n, this.topGuide = r, this.bottomGuide = o, this.id = e.id, this.metadata = e.metadata, this.tScale = e.tScale, this.kind = e.kind, this.activeGuideFill = e.activeGuideFill || vt;
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...ns.ownDefaults
    };
  }
  updateCoords(e) {
    this.scaleToWidth(e), this.set("scaleY", 1);
  }
  setSelected(e) {
    e ? this.guide.set("fill", this.activeGuideFill) : this.guide.set("fill", "transparent");
  }
};
T(ns, "type", "Helper"), T(ns, "ownDefaults", {
  selectable: !1,
  evented: !1
});
let Ss = ns;
C.setClass(Ss, "Helper");
const os = class os extends X {
  constructor(e) {
    super(e);
    T(this, "guideItemId");
    T(this, "distXToActCenter");
    T(this, "trackItemType");
    T(this, "defaultPos");
    T(this, "draggedObject");
    Object.assign(this, os.ownDefaults), this.id = e.id;
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...os.ownDefaults
    };
  }
  // add custom text to the track item
  _render(e) {
    super._render(e), this.updateSelected(e);
  }
  updateSelected(e) {
    e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      this.rx
    ), e.lineWidth = It, e.setLineDash(this.strokeDashArray), e.strokeStyle = vt, e.stroke(), e.restore();
  }
};
T(os, "type", "Placeholder"), T(os, "ownDefaults", {
  rx: 6,
  ry: 6,
  objectCaching: !1,
  borderColor: "transparent",
  strokeWidth: 0,
  fill: "rgba(255, 211, 42,0.1)",
  stroke: "rgba(255, 211, 42,1.0)",
  selectable: !1,
  borderOpacityWhenMoving: 1,
  hoverCursor: "default",
  strokeDashArray: [5, 1],
  evented: !1
});
let er = os;
C.setClass(er, "Placeholder");
const as = class as extends X {
  constructor(e) {
    super(e);
    T(this, "duration");
    T(this, "fromId");
    T(this, "toId");
    T(this, "kind", "none");
    T(this, "isSelected", !1);
    Object.assign(this, as.ownDefaults), this.id = e.id, this.centeredScaling = !0, this.strokeWidth = 0, this.tScale = e.tScale, this.duration = e.duration, this.fromId = e.fromId, this.toId = e.toId, this.kind = e.kind, this.strokeDashArray = e.strokeDashArray || [];
  }
  static createControls() {
    return { controls: ml() };
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...as.ownDefaults
    };
  }
  updateCoords() {
  }
  // add custom text to the track item
  _render(e) {
    super._render(e), this.updateSelected(e);
  }
  setSelected(e) {
    this.isSelected = e, this.set({ dirty: !0 });
  }
  updateSelected(e) {
    const s = this.isSelected ? vt : "rgba(255, 255, 255,0.15)";
    e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      this.rx
    ), e.lineWidth = It, e.setLineDash(this.strokeDashArray), e.strokeStyle = s, e.stroke(), e.restore();
  }
};
T(as, "type", "Transition"), T(as, "ownDefaults", {
  objectCaching: !1,
  borderColor: "transparent",
  stroke: "transparent",
  strokeWidth: 1.5,
  fill: "rgba(0,0,0, 0.5)",
  borderOpacityWhenMoving: 1,
  hoverCursor: "default",
  lockMovementX: !0,
  lockMovementY: !0,
  duration: 1500,
  rx: 8,
  ry: 8
});
let Jt = as;
C.setClass(Jt, "Transition");
const cs = class cs extends X {
  constructor(e) {
    super(e);
    T(this, "isSelected", !1);
    T(this, "text");
    Object.assign(this, cs.ownDefaults), this.id = e.id, this.borderColor = "transparent", this.stroke = "transparent", this.strokeWidth = 0, this.tScale = e.tScale, this.display = e.display, this.text = e.text;
  }
  static createControls() {
    return { controls: js() };
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...cs.ownDefaults
    };
  }
  setSelected(e) {
    this.isSelected = e, this.set({ dirty: !0 });
  }
  // add custom text to the track item
  _render(e) {
    super._render(e), this.updateSelected(e);
  }
  updateSelected(e) {
    this.isSelected && (e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      6
    ), e.lineWidth = It, e.strokeStyle = vt, e.stroke(), e.restore());
  }
};
T(cs, "type", "Caption"), T(cs, "ownDefaults", {
  rx: 6,
  ry: 6,
  objectCaching: !1,
  borderColor: "transparent",
  stroke: "transparent",
  strokeWidth: 0,
  fill: "#27272a",
  borderOpacityWhenMoving: 1,
  hoverCursor: "default"
});
let sr = cs;
C.setClass(sr, "Caption");
const ls = class ls extends X {
  constructor(e) {
    super(e);
    T(this, "itemType", "template");
    T(this, "isSelected", !1);
    T(this, "trim");
    Object.assign(this, ls.ownDefaults), this.id = e.id, this.borderColor = "transparent", this.stroke = "transparent", this.strokeWidth = 0, this.tScale = e.tScale, this.display = e.display, this.trim = e.trim;
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...ls.ownDefaults
    };
  }
  static createControls() {
    return { controls: gf() };
  }
  setSelected(e) {
    this.isSelected = e, this.set({ dirty: !0 });
  }
  // add custom Audio to the track item
  _render(e) {
    super._render(e), this.updateSelected(e);
  }
  updateSelected(e) {
    this.isSelected && (e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      6
    ), e.lineWidth = It, e.strokeStyle = vt, e.stroke(), e.restore());
  }
};
T(ls, "type", "Template"), T(ls, "ownDefaults", {
  rx: 6,
  ry: 6,
  objectCaching: !1,
  borderColor: "transparent",
  stroke: "transparent",
  strokeWidth: 0,
  fill: "#27272a",
  borderOpacityWhenMoving: 1,
  hoverCursor: "default"
});
let Vt = ls;
C.setClass(Vt, "Template");
function wf(i) {
  const t = Math.floor(i / 1e3), e = Math.floor(t / 60), s = t % 60, r = String(e).padStart(2, "0"), n = String(s).padStart(2, "0");
  return `${r}:${n}`;
}
const hs = class hs extends X {
  constructor(e) {
    super(e);
    T(this, "duration");
    T(this, "fromId");
    T(this, "toId");
    T(this, "isSelected", !1);
    T(this, "name");
    T(this, "durationString");
    T(this, "itemType");
    Object.assign(this, hs.ownDefaults), this.id = e.id, this.fill = "#27272a", this.name = e.type.toUpperCase(), this.durationString = wf(e.duration), this.itemType = e.type;
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...hs.ownDefaults
    };
  }
  _render(e) {
    e.save(), super._render(e), e.beginPath(), e.rect(-this.width / 2, -this.height / 2, this.width, this.height), e.clip(), this.drawTextIdentity(e), e.restore();
  }
  drawTextIdentity(e) {
    e.font = "600 12px 'Geist variable'", e.textAlign = "left";
    const s = e.measureText(this.name).width, r = e.measureText(this.durationString).width, n = 8, o = 4, a = 4 - this.height / 2, c = 20, l = 4, h = 4 - this.width / 2, u = s + n * 2;
    this.drawRoundedRect(
      e,
      h,
      a,
      u,
      c,
      l
    ), e.fillStyle = "#f4f4f5", e.fillText(this.name, h + n, a + 14);
    const d = h + u + o, f = r + n * 2;
    this.drawRoundedRect(
      e,
      d,
      a,
      f,
      c,
      l
    ), e.fillStyle = "#f4f4f5", e.fillText(this.durationString, d + n, a + 14);
  }
  drawRoundedRect(e, s, r, n, o, a) {
    e.fillStyle = "rgba(0, 0, 0, 0.5)", e.roundRect ? (e.beginPath(), e.roundRect(s, r, n, o, a), e.fill()) : e.fillRect(s, r, n, o);
  }
};
T(hs, "type", "PreviewTrackItem"), T(hs, "ownDefaults", {
  objectCaching: !1,
  borderColor: "transparent",
  stroke: "transparent",
  strokeWidth: 0,
  borderOpacityWhenMoving: 1,
  hoverCursor: "default",
  rx: 4,
  ry: 4
});
let Oe = hs;
C.setClass(Oe, "PreviewTrackItem");
class Cf {
  constructor() {
    T(this, "___eventListeners", {});
    T(this, "___activeObjects", []);
  }
  resize(t, { force: e } = { force: !1 }) {
    var s;
    this.lowerCanvasEl && (this.setDimensions(t), e && this.renderTracks(), (s = this.onResizeCanvas) == null || s.call(this, {
      width: this.width,
      height: this.height
    }));
  }
  pauseEventListeners() {
    this.___eventListeners = this.__eventListeners, this.__eventListeners = {};
    const t = this.getActiveObjects();
    this.discardActiveObject(), this.___activeObjects = t;
  }
  resumeEventListeners() {
    this.__eventListeners = this.___eventListeners, this.___eventListeners = {};
    const t = this.___activeObjects;
    if (!t.length)
      return this.requestRenderAll(), !1;
    if (t.length === 1)
      this.setActiveObject(t[0]);
    else {
      const e = new Ot(t);
      this.setActiveObject(e);
    }
    this.requestRenderAll();
  }
  updateCachingActiveObjects(t) {
    const e = this.___activeObjects;
    this.___activeObjects = e.map((s) => {
      const r = t.find((n) => n.id === s.id);
      return r || s;
    });
  }
}
function rr(i, t) {
  return i.map((e) => ({
    ...e,
    items: e.items.filter((s) => !t.includes(s))
  }));
}
const us = class us extends X {
  constructor(e) {
    super(e);
    T(this, "itemType", "composition");
    T(this, "isSelected", !1);
    Object.assign(this, us.ownDefaults), this.id = e.id, this.borderColor = "transparent", this.stroke = "transparent", this.strokeWidth = 0, this.tScale = e.tScale, this.display = e.display;
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...us.ownDefaults
    };
  }
  static createControls() {
    return { controls: js() };
  }
  setSelected(e) {
    this.isSelected = e, this.set({ dirty: !0 });
  }
  // add custom text to the track item
  _render(e) {
    super._render(e), this.updateSelected(e);
  }
  updateSelected(e) {
    this.isSelected && (e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      6
    ), e.lineWidth = It, e.strokeStyle = vt, e.stroke(), e.restore());
  }
};
T(us, "type", "Composition"), T(us, "ownDefaults", {
  rx: 6,
  ry: 6,
  objectCaching: !1,
  borderColor: "transparent",
  stroke: "transparent",
  strokeWidth: 0,
  fill: "#27272a",
  borderOpacityWhenMoving: 1,
  hoverCursor: "default"
});
let oi = us;
C.setClass(oi, "Composition");
const ds = class ds extends X {
  constructor(e) {
    super(e);
    T(this, "itemType", "illustration");
    T(this, "src");
    T(this, "isSelected", !1);
    Object.assign(this, ds.ownDefaults), this.id = e.id, this.borderColor = "transparent", this.stroke = "transparent", this.strokeWidth = 0, this.tScale = e.tScale, this.display = e.display, this.src = e.src;
  }
  static createControls() {
    return { controls: js() };
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...ds.ownDefaults
    };
  }
  setSelected(e) {
    this.isSelected = e, this.set({ dirty: !0 });
  }
  // add custom text to the track item
  _render(e) {
    super._render(e), this.updateSelected(e);
  }
  updateSelected(e) {
    this.isSelected && (e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      6
    ), e.lineWidth = It, e.strokeStyle = vt, e.stroke(), e.restore());
  }
  setSrc(e) {
    this.src = e, this.set({ dirty: !0 });
  }
};
T(ds, "type", "Illustration"), T(ds, "ownDefaults", {
  rx: 6,
  ry: 6,
  objectCaching: !1,
  borderColor: "transparent",
  stroke: "transparent",
  strokeWidth: 0,
  fill: "#27272a",
  borderOpacityWhenMoving: 1,
  hoverCursor: "default"
});
let ai = ds;
C.setClass(ai, "Illustration");
const fs = class fs extends X {
  constructor(e) {
    super(e);
    T(this, "itemType", "shape");
    T(this, "src");
    T(this, "isSelected", !1);
    Object.assign(this, fs.ownDefaults), this.id = e.id, this.borderColor = "transparent", this.stroke = "transparent", this.strokeWidth = 0, this.tScale = e.tScale, this.display = e.display, this.src = e.src;
  }
  static createControls() {
    return { controls: js() };
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...fs.ownDefaults
    };
  }
  setSelected(e) {
    this.isSelected = e, this.set({ dirty: !0 });
  }
  // add custom text to the track item
  _render(e) {
    super._render(e), this.updateSelected(e);
  }
  updateSelected(e) {
    this.isSelected && (e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      6
    ), e.lineWidth = It, e.strokeStyle = vt, e.stroke(), e.restore());
  }
  setSrc(e) {
    this.src = e, this.set({ dirty: !0 });
  }
};
T(fs, "type", "Shape"), T(fs, "ownDefaults", {
  rx: 6,
  ry: 6,
  objectCaching: !1,
  borderColor: "transparent",
  stroke: "transparent",
  strokeWidth: 0,
  fill: "#27272a",
  borderOpacityWhenMoving: 1,
  hoverCursor: "default"
});
let ci = fs;
C.setClass(ci, "Shape");
const Of = (i, t) => {
  var a;
  const e = D(i.display.from, t.tScale), s = D(
    i.duration,
    t.tScale,
    i.playbackRate
  ), r = t.sizesMap.video, n = C.getClass("Video") || _t;
  return new n({
    width: s,
    height: r,
    id: i.id,
    tScale: t.tScale,
    fill: "#333333",
    resourceId: (a = i.metadata) == null ? void 0 : a.resourceId,
    duration: i.duration,
    top: 10,
    left: e,
    display: i.display,
    trim: i.trim,
    src: i.details.src,
    metadata: i.metadata
  });
}, kf = (i, t) => {
  const e = i.display, s = D(e.from, t.tScale), r = D(e.to - e.from, t.tScale), n = t.sizesMap.text, o = C.getClass("Text") || tr;
  return new o({
    width: r,
    height: n,
    id: i.id,
    display: e,
    top: 10,
    left: s,
    text: i.details.text,
    tScale: t.tScale
  });
}, Mf = (i, t) => {
  const e = i.display, s = D(e.from, t.tScale), r = D(e.to - e.from, t.tScale), n = t.sizesMap.caption, o = C.getClass("Caption") || sr;
  return new o({
    width: r,
    height: n,
    id: i.id,
    display: e,
    top: 10,
    left: s,
    text: i.details.text,
    tScale: t.tScale
  });
}, If = (i, t) => {
  const e = D(i.display.from, t.tScale), s = D(
    i.display.to - (i.display.from || 5e3),
    t.tScale
  ), r = t.sizesMap.image, n = C.getClass("Image") || Qs;
  return new n({
    width: s,
    height: r,
    id: i.id,
    src: i.details.src,
    tScale: t.tScale,
    top: 10,
    left: e,
    display: i.display
  });
}, Df = (i, t) => {
  const e = i.display, s = D(e.from, t.tScale), r = D(
    e.to - e.from,
    t.tScale,
    i.playbackRate
  ), n = t.sizesMap.audio, o = C.getClass("Audio") || ft;
  return new o({
    width: r,
    height: n,
    top: 10,
    left: s,
    id: i.id,
    display: e,
    trim: i.trim || { from: 0, to: i.duration },
    duration: i.duration,
    src: i.details.src,
    tScale: t.tScale
  });
}, jf = (i, t) => {
  const e = i.display, s = D(e.from, t.tScale), r = D(e.to - e.from, t.tScale), n = 42, o = C.getClass("Template") || Vt;
  return new o({
    width: r,
    height: n,
    top: 10,
    left: s,
    id: i.id,
    display: e,
    duration: e.to - e.from,
    tScale: t.tScale,
    trim: i.trim || i.display
  });
}, Ef = (i, t) => {
  const e = i.display, s = D(e.from, t.tScale), r = D(e.to - e.from, t.tScale), n = 32, o = C.getClass("Composition") || oi;
  return new o({
    width: r,
    height: n,
    id: i.id,
    display: e,
    top: 10,
    left: s,
    duration: e.to - e.from,
    tScale: t.tScale
  });
}, Pf = (i, t) => {
  const e = D(i.display.from, t.tScale), s = D(
    i.display.to - (i.display.from || 5e3),
    t.tScale
  ), r = t.sizesMap.illustration, n = C.getClass("Illustration") || ai;
  return new n({
    width: s,
    height: r,
    id: i.id,
    src: i.details.src,
    tScale: t.tScale,
    top: 10,
    left: e,
    display: i.display
  });
}, Af = (i, t) => {
  const e = D(i.display.from, t.tScale), s = D(
    i.display.to - (i.display.from || 5e3),
    t.tScale
  ), r = t.sizesMap.shape, n = C.getClass("Shape") || ci;
  return new n({
    width: s,
    height: r,
    id: i.id,
    src: i.details.src,
    tScale: t.tScale,
    top: 10,
    left: e,
    display: i.display
  });
}, Ff = (i, t) => {
  if (i.type === "caption") return Mf(i, t);
  if (i.type === "text") return kf(i, t);
  if (i.type === "image") return If(i, t);
  if (i.type === "video") return Of(i, t);
  if (i.type === "audio") return Df(i, t);
  if (i.type === "template") return jf(i, t);
  if (i.type === "shape") return Af(i, t);
  if (i.type === "illustration")
    return Pf(i, t);
  if (i.type === "composition")
    return Ef(i, t);
};
var vl = typeof global == "object" && global && global.Object === Object && global, Rf = typeof self == "object" && self && self.Object === Object && self, Xt = vl || Rf || Function("return this")(), Mt = Xt.Symbol, yl = Object.prototype, Lf = yl.hasOwnProperty, Bf = yl.toString, Rs = Mt ? Mt.toStringTag : void 0;
function Wf(i) {
  var t = Lf.call(i, Rs), e = i[Rs];
  try {
    i[Rs] = void 0;
    var s = !0;
  } catch {
  }
  var r = Bf.call(i);
  return s && (t ? i[Rs] = e : delete i[Rs]), r;
}
var Xf = Object.prototype, zf = Xf.toString;
function Hf(i) {
  return zf.call(i);
}
var Yf = "[object Null]", Vf = "[object Undefined]", Jo = Mt ? Mt.toStringTag : void 0;
function Es(i) {
  return i == null ? i === void 0 ? Vf : Yf : Jo && Jo in Object(i) ? Wf(i) : Hf(i);
}
function ke(i) {
  return i != null && typeof i == "object";
}
var Gf = "[object Symbol]";
function Ii(i) {
  return typeof i == "symbol" || ke(i) && Es(i) == Gf;
}
function Nf(i, t) {
  for (var e = -1, s = i == null ? 0 : i.length, r = Array(s); ++e < s; )
    r[e] = t(i[e], e, i);
  return r;
}
var Zt = Array.isArray, Zo = Mt ? Mt.prototype : void 0, Qo = Zo ? Zo.toString : void 0;
function bl(i) {
  if (typeof i == "string")
    return i;
  if (Zt(i))
    return Nf(i, bl) + "";
  if (Ii(i))
    return Qo ? Qo.call(i) : "";
  var t = i + "";
  return t == "0" && 1 / i == -1 / 0 ? "-0" : t;
}
var Uf = /\s/;
function $f(i) {
  for (var t = i.length; t-- && Uf.test(i.charAt(t)); )
    ;
  return t;
}
var qf = /^\s+/;
function Kf(i) {
  return i && i.slice(0, $f(i) + 1).replace(qf, "");
}
function Qt(i) {
  var t = typeof i;
  return i != null && (t == "object" || t == "function");
}
var ta = NaN, Jf = /^[-+]0x[0-9a-f]+$/i, Zf = /^0b[01]+$/i, Qf = /^0o[0-7]+$/i, tg = parseInt;
function ea(i) {
  if (typeof i == "number")
    return i;
  if (Ii(i))
    return ta;
  if (Qt(i)) {
    var t = typeof i.valueOf == "function" ? i.valueOf() : i;
    i = Qt(t) ? t + "" : t;
  }
  if (typeof i != "string")
    return i === 0 ? i : +i;
  i = Kf(i);
  var e = Zf.test(i);
  return e || Qf.test(i) ? tg(i.slice(2), e ? 2 : 8) : Jf.test(i) ? ta : +i;
}
function eg(i) {
  return i;
}
var sg = "[object AsyncFunction]", rg = "[object Function]", ig = "[object GeneratorFunction]", ng = "[object Proxy]";
function _l(i) {
  if (!Qt(i))
    return !1;
  var t = Es(i);
  return t == rg || t == ig || t == sg || t == ng;
}
var Ki = Xt["__core-js_shared__"], sa = function() {
  var i = /[^.]+$/.exec(Ki && Ki.keys && Ki.keys.IE_PROTO || "");
  return i ? "Symbol(src)_1." + i : "";
}();
function og(i) {
  return !!sa && sa in i;
}
var ag = Function.prototype, cg = ag.toString;
function Ue(i) {
  if (i != null) {
    try {
      return cg.call(i);
    } catch {
    }
    try {
      return i + "";
    } catch {
    }
  }
  return "";
}
var lg = /[\\^$.*+?()[\]{}|]/g, hg = /^\[object .+?Constructor\]$/, ug = Function.prototype, dg = Object.prototype, fg = ug.toString, gg = dg.hasOwnProperty, pg = RegExp(
  "^" + fg.call(gg).replace(lg, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function mg(i) {
  if (!Qt(i) || og(i))
    return !1;
  var t = _l(i) ? pg : hg;
  return t.test(Ue(i));
}
function vg(i, t) {
  return i == null ? void 0 : i[t];
}
function $e(i, t) {
  var e = vg(i, t);
  return mg(e) ? e : void 0;
}
var wn = $e(Xt, "WeakMap"), ra = Object.create, yg = /* @__PURE__ */ function() {
  function i() {
  }
  return function(t) {
    if (!Qt(t))
      return {};
    if (ra)
      return ra(t);
    i.prototype = t;
    var e = new i();
    return i.prototype = void 0, e;
  };
}();
function bg(i, t, e) {
  switch (e.length) {
    case 0:
      return i.call(t);
    case 1:
      return i.call(t, e[0]);
    case 2:
      return i.call(t, e[0], e[1]);
    case 3:
      return i.call(t, e[0], e[1], e[2]);
  }
  return i.apply(t, e);
}
var _g = 800, Sg = 16, Tg = Date.now;
function xg(i) {
  var t = 0, e = 0;
  return function() {
    var s = Tg(), r = Sg - (s - e);
    if (e = s, r > 0) {
      if (++t >= _g)
        return arguments[0];
    } else
      t = 0;
    return i.apply(void 0, arguments);
  };
}
function wg(i) {
  return function() {
    return i;
  };
}
var li = function() {
  try {
    var i = $e(Object, "defineProperty");
    return i({}, "", {}), i;
  } catch {
  }
}(), Cg = li ? function(i, t) {
  return li(i, "toString", {
    configurable: !0,
    enumerable: !1,
    value: wg(t),
    writable: !0
  });
} : eg, Og = xg(Cg);
function kg(i, t) {
  for (var e = -1, s = i == null ? 0 : i.length; ++e < s && t(i[e], e, i) !== !1; )
    ;
  return i;
}
var Mg = 9007199254740991, Ig = /^(?:0|[1-9]\d*)$/;
function eo(i, t) {
  var e = typeof i;
  return t = t ?? Mg, !!t && (e == "number" || e != "symbol" && Ig.test(i)) && i > -1 && i % 1 == 0 && i < t;
}
function Dg(i, t, e) {
  t == "__proto__" && li ? li(i, t, {
    configurable: !0,
    enumerable: !0,
    value: e,
    writable: !0
  }) : i[t] = e;
}
function so(i, t) {
  return i === t || i !== i && t !== t;
}
var jg = Object.prototype, Eg = jg.hasOwnProperty;
function Sl(i, t, e) {
  var s = i[t];
  (!(Eg.call(i, t) && so(s, e)) || e === void 0 && !(t in i)) && Dg(i, t, e);
}
var ia = Math.max;
function Pg(i, t, e) {
  return t = ia(t === void 0 ? i.length - 1 : t, 0), function() {
    for (var s = arguments, r = -1, n = ia(s.length - t, 0), o = Array(n); ++r < n; )
      o[r] = s[t + r];
    r = -1;
    for (var a = Array(t + 1); ++r < t; )
      a[r] = s[r];
    return a[t] = e(o), bg(i, this, a);
  };
}
var Ag = 9007199254740991;
function ro(i) {
  return typeof i == "number" && i > -1 && i % 1 == 0 && i <= Ag;
}
function Fg(i) {
  return i != null && ro(i.length) && !_l(i);
}
var Rg = Object.prototype;
function Tl(i) {
  var t = i && i.constructor, e = typeof t == "function" && t.prototype || Rg;
  return i === e;
}
function Lg(i, t) {
  for (var e = -1, s = Array(i); ++e < i; )
    s[e] = t(e);
  return s;
}
var Bg = "[object Arguments]";
function na(i) {
  return ke(i) && Es(i) == Bg;
}
var xl = Object.prototype, Wg = xl.hasOwnProperty, Xg = xl.propertyIsEnumerable, io = na(/* @__PURE__ */ function() {
  return arguments;
}()) ? na : function(i) {
  return ke(i) && Wg.call(i, "callee") && !Xg.call(i, "callee");
};
function zg() {
  return !1;
}
var wl = typeof exports == "object" && exports && !exports.nodeType && exports, oa = wl && typeof module == "object" && module && !module.nodeType && module, Hg = oa && oa.exports === wl, aa = Hg ? Xt.Buffer : void 0, Yg = aa ? aa.isBuffer : void 0, hi = Yg || zg, Vg = "[object Arguments]", Gg = "[object Array]", Ng = "[object Boolean]", Ug = "[object Date]", $g = "[object Error]", qg = "[object Function]", Kg = "[object Map]", Jg = "[object Number]", Zg = "[object Object]", Qg = "[object RegExp]", tp = "[object Set]", ep = "[object String]", sp = "[object WeakMap]", rp = "[object ArrayBuffer]", ip = "[object DataView]", np = "[object Float32Array]", op = "[object Float64Array]", ap = "[object Int8Array]", cp = "[object Int16Array]", lp = "[object Int32Array]", hp = "[object Uint8Array]", up = "[object Uint8ClampedArray]", dp = "[object Uint16Array]", fp = "[object Uint32Array]", H = {};
H[np] = H[op] = H[ap] = H[cp] = H[lp] = H[hp] = H[up] = H[dp] = H[fp] = !0;
H[Vg] = H[Gg] = H[rp] = H[Ng] = H[ip] = H[Ug] = H[$g] = H[qg] = H[Kg] = H[Jg] = H[Zg] = H[Qg] = H[tp] = H[ep] = H[sp] = !1;
function gp(i) {
  return ke(i) && ro(i.length) && !!H[Es(i)];
}
function no(i) {
  return function(t) {
    return i(t);
  };
}
var Cl = typeof exports == "object" && exports && !exports.nodeType && exports, Ns = Cl && typeof module == "object" && module && !module.nodeType && module, pp = Ns && Ns.exports === Cl, Ji = pp && vl.process, Ts = function() {
  try {
    var i = Ns && Ns.require && Ns.require("util").types;
    return i || Ji && Ji.binding && Ji.binding("util");
  } catch {
  }
}(), ca = Ts && Ts.isTypedArray, Ol = ca ? no(ca) : gp, mp = Object.prototype, vp = mp.hasOwnProperty;
function yp(i, t) {
  var e = Zt(i), s = !e && io(i), r = !e && !s && hi(i), n = !e && !s && !r && Ol(i), o = e || s || r || n, a = o ? Lg(i.length, String) : [], c = a.length;
  for (var l in i)
    vp.call(i, l) && !(o && // Safari 9 has enumerable `arguments.length` in strict mode.
    (l == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    r && (l == "offset" || l == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    n && (l == "buffer" || l == "byteLength" || l == "byteOffset") || // Skip index properties.
    eo(l, c))) && a.push(l);
  return a;
}
function kl(i, t) {
  return function(e) {
    return i(t(e));
  };
}
var bp = kl(Object.keys, Object), _p = Object.prototype, Sp = _p.hasOwnProperty;
function Tp(i) {
  if (!Tl(i))
    return bp(i);
  var t = [];
  for (var e in Object(i))
    Sp.call(i, e) && e != "constructor" && t.push(e);
  return t;
}
function xp(i) {
  return Fg(i) ? yp(i) : Tp(i);
}
var wp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Cp = /^\w*$/;
function Op(i, t) {
  if (Zt(i))
    return !1;
  var e = typeof i;
  return e == "number" || e == "symbol" || e == "boolean" || i == null || Ii(i) ? !0 : Cp.test(i) || !wp.test(i) || t != null && i in Object(t);
}
var ir = $e(Object, "create");
function kp() {
  this.__data__ = ir ? ir(null) : {}, this.size = 0;
}
function Mp(i) {
  var t = this.has(i) && delete this.__data__[i];
  return this.size -= t ? 1 : 0, t;
}
var Ip = "__lodash_hash_undefined__", Dp = Object.prototype, jp = Dp.hasOwnProperty;
function Ep(i) {
  var t = this.__data__;
  if (ir) {
    var e = t[i];
    return e === Ip ? void 0 : e;
  }
  return jp.call(t, i) ? t[i] : void 0;
}
var Pp = Object.prototype, Ap = Pp.hasOwnProperty;
function Fp(i) {
  var t = this.__data__;
  return ir ? t[i] !== void 0 : Ap.call(t, i);
}
var Rp = "__lodash_hash_undefined__";
function Lp(i, t) {
  var e = this.__data__;
  return this.size += this.has(i) ? 0 : 1, e[i] = ir && t === void 0 ? Rp : t, this;
}
function Ye(i) {
  var t = -1, e = i == null ? 0 : i.length;
  for (this.clear(); ++t < e; ) {
    var s = i[t];
    this.set(s[0], s[1]);
  }
}
Ye.prototype.clear = kp;
Ye.prototype.delete = Mp;
Ye.prototype.get = Ep;
Ye.prototype.has = Fp;
Ye.prototype.set = Lp;
function Bp() {
  this.__data__ = [], this.size = 0;
}
function Di(i, t) {
  for (var e = i.length; e--; )
    if (so(i[e][0], t))
      return e;
  return -1;
}
var Wp = Array.prototype, Xp = Wp.splice;
function zp(i) {
  var t = this.__data__, e = Di(t, i);
  if (e < 0)
    return !1;
  var s = t.length - 1;
  return e == s ? t.pop() : Xp.call(t, e, 1), --this.size, !0;
}
function Hp(i) {
  var t = this.__data__, e = Di(t, i);
  return e < 0 ? void 0 : t[e][1];
}
function Yp(i) {
  return Di(this.__data__, i) > -1;
}
function Vp(i, t) {
  var e = this.__data__, s = Di(e, i);
  return s < 0 ? (++this.size, e.push([i, t])) : e[s][1] = t, this;
}
function ge(i) {
  var t = -1, e = i == null ? 0 : i.length;
  for (this.clear(); ++t < e; ) {
    var s = i[t];
    this.set(s[0], s[1]);
  }
}
ge.prototype.clear = Bp;
ge.prototype.delete = zp;
ge.prototype.get = Hp;
ge.prototype.has = Yp;
ge.prototype.set = Vp;
var nr = $e(Xt, "Map");
function Gp() {
  this.size = 0, this.__data__ = {
    hash: new Ye(),
    map: new (nr || ge)(),
    string: new Ye()
  };
}
function Np(i) {
  var t = typeof i;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? i !== "__proto__" : i === null;
}
function ji(i, t) {
  var e = i.__data__;
  return Np(t) ? e[typeof t == "string" ? "string" : "hash"] : e.map;
}
function Up(i) {
  var t = ji(this, i).delete(i);
  return this.size -= t ? 1 : 0, t;
}
function $p(i) {
  return ji(this, i).get(i);
}
function qp(i) {
  return ji(this, i).has(i);
}
function Kp(i, t) {
  var e = ji(this, i), s = e.size;
  return e.set(i, t), this.size += e.size == s ? 0 : 1, this;
}
function pe(i) {
  var t = -1, e = i == null ? 0 : i.length;
  for (this.clear(); ++t < e; ) {
    var s = i[t];
    this.set(s[0], s[1]);
  }
}
pe.prototype.clear = Gp;
pe.prototype.delete = Up;
pe.prototype.get = $p;
pe.prototype.has = qp;
pe.prototype.set = Kp;
var Jp = "Expected a function";
function oo(i, t) {
  if (typeof i != "function" || t != null && typeof t != "function")
    throw new TypeError(Jp);
  var e = function() {
    var s = arguments, r = t ? t.apply(this, s) : s[0], n = e.cache;
    if (n.has(r))
      return n.get(r);
    var o = i.apply(this, s);
    return e.cache = n.set(r, o) || n, o;
  };
  return e.cache = new (oo.Cache || pe)(), e;
}
oo.Cache = pe;
var Zp = 500;
function Qp(i) {
  var t = oo(i, function(s) {
    return e.size === Zp && e.clear(), s;
  }), e = t.cache;
  return t;
}
var tm = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, em = /\\(\\)?/g, sm = Qp(function(i) {
  var t = [];
  return i.charCodeAt(0) === 46 && t.push(""), i.replace(tm, function(e, s, r, n) {
    t.push(r ? n.replace(em, "$1") : s || e);
  }), t;
});
function rm(i) {
  return i == null ? "" : bl(i);
}
function Ei(i, t) {
  return Zt(i) ? i : Op(i, t) ? [i] : sm(rm(i));
}
function ao(i) {
  if (typeof i == "string" || Ii(i))
    return i;
  var t = i + "";
  return t == "0" && 1 / i == -1 / 0 ? "-0" : t;
}
function im(i, t) {
  t = Ei(t, i);
  for (var e = 0, s = t.length; i != null && e < s; )
    i = i[ao(t[e++])];
  return e && e == s ? i : void 0;
}
function Ml(i, t) {
  for (var e = -1, s = t.length, r = i.length; ++e < s; )
    i[r + e] = t[e];
  return i;
}
var la = Mt ? Mt.isConcatSpreadable : void 0;
function nm(i) {
  return Zt(i) || io(i) || !!(la && i && i[la]);
}
function om(i, t, e, s, r) {
  var n = -1, o = i.length;
  for (e || (e = nm), r || (r = []); ++n < o; ) {
    var a = i[n];
    e(a) ? Ml(r, a) : r[r.length] = a;
  }
  return r;
}
function co(i) {
  var t = i == null ? 0 : i.length;
  return t ? om(i) : [];
}
function am(i) {
  return Og(Pg(i, void 0, co), i + "");
}
var cm = kl(Object.getPrototypeOf, Object);
function lm() {
  this.__data__ = new ge(), this.size = 0;
}
function hm(i) {
  var t = this.__data__, e = t.delete(i);
  return this.size = t.size, e;
}
function um(i) {
  return this.__data__.get(i);
}
function dm(i) {
  return this.__data__.has(i);
}
var fm = 200;
function gm(i, t) {
  var e = this.__data__;
  if (e instanceof ge) {
    var s = e.__data__;
    if (!nr || s.length < fm - 1)
      return s.push([i, t]), this.size = ++e.size, this;
    e = this.__data__ = new pe(s);
  }
  return e.set(i, t), this.size = e.size, this;
}
function le(i) {
  var t = this.__data__ = new ge(i);
  this.size = t.size;
}
le.prototype.clear = lm;
le.prototype.delete = hm;
le.prototype.get = um;
le.prototype.has = dm;
le.prototype.set = gm;
var Il = typeof exports == "object" && exports && !exports.nodeType && exports, ha = Il && typeof module == "object" && module && !module.nodeType && module, pm = ha && ha.exports === Il, ua = pm ? Xt.Buffer : void 0;
ua && ua.allocUnsafe;
function mm(i, t) {
  return i.slice();
}
function vm(i, t) {
  for (var e = -1, s = i == null ? 0 : i.length, r = 0, n = []; ++e < s; ) {
    var o = i[e];
    t(o, e, i) && (n[r++] = o);
  }
  return n;
}
function ym() {
  return [];
}
var bm = Object.prototype, _m = bm.propertyIsEnumerable, da = Object.getOwnPropertySymbols, Sm = da ? function(i) {
  return i == null ? [] : (i = Object(i), vm(da(i), function(t) {
    return _m.call(i, t);
  }));
} : ym;
function Tm(i, t, e) {
  var s = t(i);
  return Zt(i) ? s : Ml(s, e(i));
}
function Cn(i) {
  return Tm(i, xp, Sm);
}
var On = $e(Xt, "DataView"), kn = $e(Xt, "Promise"), Mn = $e(Xt, "Set"), fa = "[object Map]", xm = "[object Object]", ga = "[object Promise]", pa = "[object Set]", ma = "[object WeakMap]", va = "[object DataView]", wm = Ue(On), Cm = Ue(nr), Om = Ue(kn), km = Ue(Mn), Mm = Ue(wn), Pt = Es;
(On && Pt(new On(new ArrayBuffer(1))) != va || nr && Pt(new nr()) != fa || kn && Pt(kn.resolve()) != ga || Mn && Pt(new Mn()) != pa || wn && Pt(new wn()) != ma) && (Pt = function(i) {
  var t = Es(i), e = t == xm ? i.constructor : void 0, s = e ? Ue(e) : "";
  if (s)
    switch (s) {
      case wm:
        return va;
      case Cm:
        return fa;
      case Om:
        return ga;
      case km:
        return pa;
      case Mm:
        return ma;
    }
  return t;
});
var Im = Object.prototype, Dm = Im.hasOwnProperty;
function jm(i) {
  var t = i.length, e = new i.constructor(t);
  return t && typeof i[0] == "string" && Dm.call(i, "index") && (e.index = i.index, e.input = i.input), e;
}
var ui = Xt.Uint8Array;
function lo(i) {
  var t = new i.constructor(i.byteLength);
  return new ui(t).set(new ui(i)), t;
}
function Em(i, t) {
  var e = lo(i.buffer);
  return new i.constructor(e, i.byteOffset, i.byteLength);
}
var Pm = /\w*$/;
function Am(i) {
  var t = new i.constructor(i.source, Pm.exec(i));
  return t.lastIndex = i.lastIndex, t;
}
var ya = Mt ? Mt.prototype : void 0, ba = ya ? ya.valueOf : void 0;
function Fm(i) {
  return ba ? Object(ba.call(i)) : {};
}
function Rm(i, t) {
  var e = lo(i.buffer);
  return new i.constructor(e, i.byteOffset, i.length);
}
var Lm = "[object Boolean]", Bm = "[object Date]", Wm = "[object Map]", Xm = "[object Number]", zm = "[object RegExp]", Hm = "[object Set]", Ym = "[object String]", Vm = "[object Symbol]", Gm = "[object ArrayBuffer]", Nm = "[object DataView]", Um = "[object Float32Array]", $m = "[object Float64Array]", qm = "[object Int8Array]", Km = "[object Int16Array]", Jm = "[object Int32Array]", Zm = "[object Uint8Array]", Qm = "[object Uint8ClampedArray]", tv = "[object Uint16Array]", ev = "[object Uint32Array]";
function sv(i, t, e) {
  var s = i.constructor;
  switch (t) {
    case Gm:
      return lo(i);
    case Lm:
    case Bm:
      return new s(+i);
    case Nm:
      return Em(i);
    case Um:
    case $m:
    case qm:
    case Km:
    case Jm:
    case Zm:
    case Qm:
    case tv:
    case ev:
      return Rm(i);
    case Wm:
      return new s();
    case Xm:
    case Ym:
      return new s(i);
    case zm:
      return Am(i);
    case Hm:
      return new s();
    case Vm:
      return Fm(i);
  }
}
function rv(i) {
  return typeof i.constructor == "function" && !Tl(i) ? yg(cm(i)) : {};
}
var iv = "[object Map]";
function nv(i) {
  return ke(i) && Pt(i) == iv;
}
var _a = Ts && Ts.isMap, ov = _a ? no(_a) : nv, av = "[object Set]";
function cv(i) {
  return ke(i) && Pt(i) == av;
}
var Sa = Ts && Ts.isSet, lv = Sa ? no(Sa) : cv, Dl = "[object Arguments]", hv = "[object Array]", uv = "[object Boolean]", dv = "[object Date]", fv = "[object Error]", jl = "[object Function]", gv = "[object GeneratorFunction]", pv = "[object Map]", mv = "[object Number]", El = "[object Object]", vv = "[object RegExp]", yv = "[object Set]", bv = "[object String]", _v = "[object Symbol]", Sv = "[object WeakMap]", Tv = "[object ArrayBuffer]", xv = "[object DataView]", wv = "[object Float32Array]", Cv = "[object Float64Array]", Ov = "[object Int8Array]", kv = "[object Int16Array]", Mv = "[object Int32Array]", Iv = "[object Uint8Array]", Dv = "[object Uint8ClampedArray]", jv = "[object Uint16Array]", Ev = "[object Uint32Array]", z = {};
z[Dl] = z[hv] = z[Tv] = z[xv] = z[uv] = z[dv] = z[wv] = z[Cv] = z[Ov] = z[kv] = z[Mv] = z[pv] = z[mv] = z[El] = z[vv] = z[yv] = z[bv] = z[_v] = z[Iv] = z[Dv] = z[jv] = z[Ev] = !0;
z[fv] = z[jl] = z[Sv] = !1;
function Nr(i, t, e, s, r, n) {
  var o;
  if (o !== void 0)
    return o;
  if (!Qt(i))
    return i;
  var a = Zt(i);
  if (a)
    o = jm(i);
  else {
    var c = Pt(i), l = c == jl || c == gv;
    if (hi(i))
      return mm(i);
    if (c == El || c == Dl || l && !r)
      o = l ? {} : rv(i);
    else {
      if (!z[c])
        return r ? i : {};
      o = sv(i, c);
    }
  }
  n || (n = new le());
  var h = n.get(i);
  if (h)
    return h;
  n.set(i, o), lv(i) ? i.forEach(function(f) {
    o.add(Nr(f, t, e, f, i, n));
  }) : ov(i) && i.forEach(function(f, g) {
    o.set(g, Nr(f, t, e, g, i, n));
  });
  var u = Cn, d = a ? void 0 : u(i);
  return kg(d || i, function(f, g) {
    d && (g = f, f = i[g]), Sl(o, g, Nr(f, t, e, g, i, n));
  }), o;
}
var Pv = 1, Av = 4;
function Ut(i) {
  return Nr(i, Pv | Av);
}
var Fv = "__lodash_hash_undefined__";
function Rv(i) {
  return this.__data__.set(i, Fv), this;
}
function Lv(i) {
  return this.__data__.has(i);
}
function di(i) {
  var t = -1, e = i == null ? 0 : i.length;
  for (this.__data__ = new pe(); ++t < e; )
    this.add(i[t]);
}
di.prototype.add = di.prototype.push = Rv;
di.prototype.has = Lv;
function Bv(i, t) {
  for (var e = -1, s = i == null ? 0 : i.length; ++e < s; )
    if (t(i[e], e, i))
      return !0;
  return !1;
}
function Wv(i, t) {
  return i.has(t);
}
var Xv = 1, zv = 2;
function Pl(i, t, e, s, r, n) {
  var o = e & Xv, a = i.length, c = t.length;
  if (a != c && !(o && c > a))
    return !1;
  var l = n.get(i), h = n.get(t);
  if (l && h)
    return l == t && h == i;
  var u = -1, d = !0, f = e & zv ? new di() : void 0;
  for (n.set(i, t), n.set(t, i); ++u < a; ) {
    var g = i[u], p = t[u];
    if (s)
      var m = o ? s(p, g, u, t, i, n) : s(g, p, u, i, t, n);
    if (m !== void 0) {
      if (m)
        continue;
      d = !1;
      break;
    }
    if (f) {
      if (!Bv(t, function(b, S) {
        if (!Wv(f, S) && (g === b || r(g, b, e, s, n)))
          return f.push(S);
      })) {
        d = !1;
        break;
      }
    } else if (!(g === p || r(g, p, e, s, n))) {
      d = !1;
      break;
    }
  }
  return n.delete(i), n.delete(t), d;
}
function Hv(i) {
  var t = -1, e = Array(i.size);
  return i.forEach(function(s, r) {
    e[++t] = [r, s];
  }), e;
}
function Yv(i) {
  var t = -1, e = Array(i.size);
  return i.forEach(function(s) {
    e[++t] = s;
  }), e;
}
var Vv = 1, Gv = 2, Nv = "[object Boolean]", Uv = "[object Date]", $v = "[object Error]", qv = "[object Map]", Kv = "[object Number]", Jv = "[object RegExp]", Zv = "[object Set]", Qv = "[object String]", ty = "[object Symbol]", ey = "[object ArrayBuffer]", sy = "[object DataView]", Ta = Mt ? Mt.prototype : void 0, Zi = Ta ? Ta.valueOf : void 0;
function ry(i, t, e, s, r, n, o) {
  switch (e) {
    case sy:
      if (i.byteLength != t.byteLength || i.byteOffset != t.byteOffset)
        return !1;
      i = i.buffer, t = t.buffer;
    case ey:
      return !(i.byteLength != t.byteLength || !n(new ui(i), new ui(t)));
    case Nv:
    case Uv:
    case Kv:
      return so(+i, +t);
    case $v:
      return i.name == t.name && i.message == t.message;
    case Jv:
    case Qv:
      return i == t + "";
    case qv:
      var a = Hv;
    case Zv:
      var c = s & Vv;
      if (a || (a = Yv), i.size != t.size && !c)
        return !1;
      var l = o.get(i);
      if (l)
        return l == t;
      s |= Gv, o.set(i, t);
      var h = Pl(a(i), a(t), s, r, n, o);
      return o.delete(i), h;
    case ty:
      if (Zi)
        return Zi.call(i) == Zi.call(t);
  }
  return !1;
}
var iy = 1, ny = Object.prototype, oy = ny.hasOwnProperty;
function ay(i, t, e, s, r, n) {
  var o = e & iy, a = Cn(i), c = a.length, l = Cn(t), h = l.length;
  if (c != h && !o)
    return !1;
  for (var u = c; u--; ) {
    var d = a[u];
    if (!(o ? d in t : oy.call(t, d)))
      return !1;
  }
  var f = n.get(i), g = n.get(t);
  if (f && g)
    return f == t && g == i;
  var p = !0;
  n.set(i, t), n.set(t, i);
  for (var m = o; ++u < c; ) {
    d = a[u];
    var b = i[d], S = t[d];
    if (s)
      var w = o ? s(S, b, d, t, i, n) : s(b, S, d, i, t, n);
    if (!(w === void 0 ? b === S || r(b, S, e, s, n) : w)) {
      p = !1;
      break;
    }
    m || (m = d == "constructor");
  }
  if (p && !m) {
    var k = i.constructor, O = t.constructor;
    k != O && "constructor" in i && "constructor" in t && !(typeof k == "function" && k instanceof k && typeof O == "function" && O instanceof O) && (p = !1);
  }
  return n.delete(i), n.delete(t), p;
}
var cy = 1, xa = "[object Arguments]", wa = "[object Array]", zr = "[object Object]", ly = Object.prototype, Ca = ly.hasOwnProperty;
function hy(i, t, e, s, r, n) {
  var o = Zt(i), a = Zt(t), c = o ? wa : Pt(i), l = a ? wa : Pt(t);
  c = c == xa ? zr : c, l = l == xa ? zr : l;
  var h = c == zr, u = l == zr, d = c == l;
  if (d && hi(i)) {
    if (!hi(t))
      return !1;
    o = !0, h = !1;
  }
  if (d && !h)
    return n || (n = new le()), o || Ol(i) ? Pl(i, t, e, s, r, n) : ry(i, t, c, e, s, r, n);
  if (!(e & cy)) {
    var f = h && Ca.call(i, "__wrapped__"), g = u && Ca.call(t, "__wrapped__");
    if (f || g) {
      var p = f ? i.value() : i, m = g ? t.value() : t;
      return n || (n = new le()), r(p, m, e, s, n);
    }
  }
  return d ? (n || (n = new le()), ay(i, t, e, s, r, n)) : !1;
}
function Al(i, t, e, s, r) {
  return i === t ? !0 : i == null || t == null || !ke(i) && !ke(t) ? i !== i && t !== t : hy(i, t, e, s, Al, r);
}
function uy(i, t) {
  return i != null && t in Object(i);
}
function dy(i, t, e) {
  t = Ei(t, i);
  for (var s = -1, r = t.length, n = !1; ++s < r; ) {
    var o = ao(t[s]);
    if (!(n = i != null && e(i, o)))
      break;
    i = i[o];
  }
  return n || ++s != r ? n : (r = i == null ? 0 : i.length, !!r && ro(r) && eo(o, r) && (Zt(i) || io(i)));
}
function fy(i, t) {
  return i != null && dy(i, t, uy);
}
var Qi = function() {
  return Xt.Date.now();
}, gy = "Expected a function", py = Math.max, my = Math.min;
function vy(i, t, e) {
  var s, r, n, o, a, c, l = 0, h = !1, u = !1, d = !0;
  if (typeof i != "function")
    throw new TypeError(gy);
  t = ea(t) || 0, Qt(e) && (h = !!e.leading, u = "maxWait" in e, n = u ? py(ea(e.maxWait) || 0, t) : n, d = "trailing" in e ? !!e.trailing : d);
  function f(x) {
    var I = s, M = r;
    return s = r = void 0, l = x, o = i.apply(M, I), o;
  }
  function g(x) {
    return l = x, a = setTimeout(b, t), h ? f(x) : o;
  }
  function p(x) {
    var I = x - c, M = x - l, E = t - I;
    return u ? my(E, n - M) : E;
  }
  function m(x) {
    var I = x - c, M = x - l;
    return c === void 0 || I >= t || I < 0 || u && M >= n;
  }
  function b() {
    var x = Qi();
    if (m(x))
      return S(x);
    a = setTimeout(b, p(x));
  }
  function S(x) {
    return a = void 0, d && s ? f(x) : (s = r = void 0, o);
  }
  function w() {
    a !== void 0 && clearTimeout(a), l = 0, s = c = r = a = void 0;
  }
  function k() {
    return a === void 0 ? o : S(Qi());
  }
  function O() {
    var x = Qi(), I = m(x);
    if (s = arguments, r = this, c = x, I) {
      if (a === void 0)
        return g(c);
      if (u)
        return clearTimeout(a), a = setTimeout(b, t), f(c);
    }
    return a === void 0 && (a = setTimeout(b, t)), o;
  }
  return O.cancel = w, O.flush = k, O;
}
function yy(i, t) {
  return Al(i, t);
}
function by(i, t, e, s) {
  if (!Qt(i))
    return i;
  t = Ei(t, i);
  for (var r = -1, n = t.length, o = n - 1, a = i; a != null && ++r < n; ) {
    var c = ao(t[r]), l = e;
    if (c === "__proto__" || c === "constructor" || c === "prototype")
      return i;
    if (r != o) {
      var h = a[c];
      l = void 0, l === void 0 && (l = Qt(h) ? h : eo(t[r + 1]) ? [] : {});
    }
    Sl(a, c, l), a = a[c];
  }
  return i;
}
function _y(i, t, e) {
  for (var s = -1, r = t.length, n = {}; ++s < r; ) {
    var o = t[s], a = im(i, o);
    e(a, o) && by(n, Ei(o, i), a);
  }
  return n;
}
function Sy(i, t) {
  return _y(i, t, function(e, s) {
    return fy(i, s);
  });
}
var Ty = am(function(i, t) {
  return i == null ? {} : Sy(i, t);
}), xy = "Expected a function";
function wy(i, t, e) {
  var s = !0, r = !0;
  if (typeof i != "function")
    throw new TypeError(xy);
  return Qt(e) && (s = "leading" in e ? !!e.leading : s, r = "trailing" in e ? !!e.trailing : r), vy(i, t, {
    leading: s,
    maxWait: t,
    trailing: r
  });
}
const Cy = (i, t) => {
  if (i.length !== t.length)
    return !1;
  const e = new Set(i.map((r) => r.id)), s = new Set(t.map((r) => r.id));
  if (e.size !== s.size)
    return !1;
  for (const r of e)
    if (!s.has(r))
      return !1;
  return !0;
}, xs = (i) => {
  const { trackItemIds: t, transitionsMap: e, trackItemsMap: s } = i, r = /* @__PURE__ */ new Map();
  Object.values(e).forEach((c) => {
    var u, d;
    if (c.kind === "none") return;
    const { fromId: l, toId: h } = c;
    r.has(l) || r.set(l, []), r.has(h) || r.set(h, []), (u = r.get(l)) == null || u.push(c), (d = r.get(h)) == null || d.push(c);
  });
  const n = [], o = /* @__PURE__ */ new Set(), a = (c) => {
    const l = [];
    let h = c;
    for (; h && !o.has(h); ) {
      o.add(h);
      const u = s[h];
      l.push(u);
      const d = Object.values(e).find(
        (f) => f.fromId === h && f.kind !== "none"
      );
      if (!d) break;
      l.push(d), h = d.toId;
    }
    return l;
  };
  for (const c of t)
    if (!o.has(c) && (!r.has(c) || !Object.values(e).some(
      (l) => l.toId === c && l.kind !== "none"
    ))) {
      const l = a(c);
      l.length > 0 && n.push(l);
    }
  return n.forEach((c) => {
    c.sort((l, h) => "display" in l && "display" in h ? l.display.from - h.display.from : 0);
  }), n;
};
function Oy(i, t, e, s, r) {
  const n = i[0].canvas, o = Object.keys(s), a = {}, c = [];
  return i.forEach((l) => {
    const h = t.filter((u) => l.items.includes(u.id)).map((u) => {
      if (r.includes(u.id)) {
        const d = n.getObjects().find((f) => f.id === `${u.id}-placeholder`);
        return (d == null ? void 0 : d.opacity) === 1 && (u.left = (d == null ? void 0 : d.left) || u.left), u;
      } else
        return u;
    }).sort((u, d) => u.left - d.left);
    for (let u = 0; u < h.length - 1; u++) {
      const d = h[u];
      let f = d.left;
      const g = h[u + 1];
      let p = g.left;
      if (o.includes(d.id) && (f = s[d.id].left), o.includes(g.id) && (p = s[g.id].left), Math.abs(f + d.width - p) <= 1) {
        const m = `${d.id}-${g.id}`;
        if (e.hasOwnProperty(m)) {
          const S = e[m];
          a[m] = S;
        } else {
          const S = {
            id: m,
            duration: 1500,
            fromId: d.id,
            toId: g.id,
            kind: "none",
            trackId: l.id,
            type: "transition"
          };
          a[m] = S;
        }
        c.push(m);
      }
    }
  }), {
    newTransitionIds: c,
    newTransitionsMap: a
  };
}
const _e = (i, t) => {
  const e = t.findIndex((h) => h.id === i), s = t[e - 1], r = t[e + 1], n = t.filter(
    (h) => h.type === "transition"
  ), o = n.indexOf(s), c = n.slice(
    0,
    o
  ).reduce((h, u) => h + (u.duration || 0), 0);
  let l = 0;
  return s && !r ? l = (s.duration || 0) / 2 : r && !s ? l = (r.duration || 0) / 2 : s && r && (l = (r.duration || 0) / 2 + (s.duration || 0) / 2), {
    durationDiff: l,
    offsetTransitions: c
  };
}, ho = (i) => {
  const { trackItemIds: t, transitionsMap: e, trackItemsMap: s } = i, r = /* @__PURE__ */ new Map();
  Object.values(e).forEach((l) => {
    var f, g;
    const { fromId: h, toId: u, kind: d } = l;
    d !== "none" && (r.has(h) || r.set(h, []), r.has(u) || r.set(u, []), (f = r.get(h)) == null || f.push(l), (g = r.get(u)) == null || g.push(l));
  });
  const n = [], o = /* @__PURE__ */ new Set(), a = (l) => {
    const h = [];
    let u = l;
    for (; u && !o.has(u); ) {
      o.add(u);
      const d = s[u];
      h.push(d);
      const f = Object.values(e).find(
        (g) => g.fromId === u && g.kind !== "none"
        // Filter here
      );
      if (!f) break;
      h.push(f), u = f.toId;
    }
    return h;
  }, c = Object.values(e).filter(
    (l) => l.kind !== "none"
  );
  for (const l of t)
    if (!o.has(l) && (!r.has(l) || !c.some((h) => h.toId === l))) {
      const h = a(l);
      h.length > 0 && n.push(h);
    }
  return n.forEach((l) => {
    l.sort((h, u) => "display" in h && "display" in u ? h.display.from - u.display.from : 0);
  }), n;
};
class ky {
  addTrackItem(t) {
    const e = Ff(t, {
      tScale: this.tScale,
      sizesMap: this.sizesMap
    });
    this.add(e);
  }
  alignItemsToTrack() {
    this.pauseEventListeners();
    const t = new Map(
      this.getObjects("Track").map((r) => [r.id, r])
    ), e = this.getTrackItems(), s = this.getObjects("Transition");
    this.trackItemIds.forEach((r) => {
      const n = this.tracks.find(
        (c) => c.items.includes(r)
      );
      if (!n) return;
      const o = t.get(n.id), a = this.getTrackItems().find((c) => c.id === r);
      a && o && (a.isMain = o.magnetic, this.trackItemsMap[r].isMain = o.magnetic, a.set({ top: o.top }), a.setCoords());
    }), t.forEach((r) => {
      r.items = e.filter((n) => n.top === r.top).map((n) => n.id);
    }), s.forEach((r) => {
      const n = r.fromId, o = e.find((a) => a.id === n);
      o && (r.set({ top: o.top }), r.setCoords());
    }), this.resumeEventListeners();
  }
  updateTrackItemsToHistory() {
    this.pauseEventListeners(), this.trackItemIds.forEach((t) => {
      const e = this.tracks.find((c) => c.items.includes(t)), s = this.getObjects().find((c) => c.id === (e == null ? void 0 : e.id)).top, r = this.trackItemsMap[t], n = this.getObjects().find((c) => c.id === t), o = D(r.display.from, this.tScale), a = D(
        r.display.to - r.display.from,
        this.tScale,
        r.playbackRate
      );
      if (n.set({ left: o, width: a, top: s }), n instanceof _t || n instanceof ft) {
        const c = n.display.to - n.display.from;
        n.setDuration ? n.setDuration(c) : n.set({ duration: c }), r.trim = n.trim, r.display = n.display;
      }
      n.setCoords();
    }), this.requestRenderAll(), this.resumeEventListeners();
  }
  deleteTrackItemToHistory(t) {
    this.getObjects().filter((e) => t.includes(e.id)).map((e) => this.remove(e)), this.alignItemsToTrack(), this.requestRenderAll();
  }
  uodateTrackItemIdsOrdering() {
    const t = this.getTrackItems();
    t.sort((e, s) => e.top - s.top), this.trackItemIds = t.map((e) => e.id).reverse();
  }
  selectTrackItemByIds(t) {
    const e = this.getActiveObjects().map((n) => n.id);
    if (yy(e, t)) return;
    const r = this.getObjects(...$o, "Transition").filter((n) => t.includes(n.id));
    if (!r.length)
      this.discardActiveObject();
    else if (r.length === 1)
      this.setActiveObject(r[0]);
    else {
      const n = new Ot(r);
      this.setActiveObject(n);
    }
    this.requestRenderAll();
  }
  synchronizeTrackItemsState() {
    this.pauseEventListeners();
    const t = this.getTrackItems(), e = {}, s = ho({
      trackItemIds: this.trackItemIds,
      transitionsMap: this.transitionsMap,
      trackItemsMap: this.trackItemsMap
    });
    t.forEach((r) => {
      const { id: n, left: o, width: a } = r, c = this.trackItemsMap[n], l = this.transitionGroups.find((h) => h.find((u) => u.id === n)) || [];
      if (l.length === 1) {
        const h = Y(o, this.tScale), u = Y(a, this.tScale, r.playbackRate), d = {
          from: h,
          to: h + u
        }, f = {
          display: d
        };
        (r instanceof _t || r instanceof ft || r instanceof Vt) && (f.trim = r.trim, f.duration = d.to - d.from), r.display = d, e[n] = {
          ...c,
          ...f
        };
      } else {
        const h = l.findIndex((f) => f.id === n), u = l[h - 1], d = l[h + 1];
        if (u && !d) {
          const f = _e(n, l), g = Y(o, this.tScale) + u.duration / 2 + f.offsetTransitions, p = Y(a, this.tScale, r.playbackRate) + (u.duration || 0) / 2, m = {
            from: g,
            to: g + p
          }, b = {
            display: m
          };
          (r instanceof _t || r instanceof ft || r instanceof Vt) && (b.trim = r.trim), r.display = m, e[n] = {
            ...c,
            ...b
          };
        } else if (d && !u) {
          const f = Y(o, this.tScale), g = Y(
            a,
            this.tScale,
            r.playbackRate
          ), p = {
            from: f,
            to: f + g + (d.duration || 0) / 2
          }, m = {
            display: p
          };
          (r instanceof _t || r instanceof ft || r instanceof Vt) && (m.trim = r.trim), r.display = p, e[n] = {
            ...c,
            ...m
          };
        } else if (u && d) {
          const f = Y(o, this.tScale), g = s.find(
            (O) => O.find((x) => x.id === r.id)
          ), b = (g == null ? void 0 : g.filter((O) => O.type === "transition").map(
            (O) => this.getObjects().find((x) => x.id === O.id)
          )).filter((O) => O.top === r.top).filter((O) => O.left + O.width <= r.left).reduce((O, x) => O + (x.duration || 0), 0), S = Y(
            a,
            this.tScale,
            r.playbackRate
          ), w = {
            from: f + b + (u.duration || 0) / 2,
            to: f + b + S + (d.duration || 0) / 2 + (u.duration || 0)
          }, k = {
            display: w
          };
          (r instanceof _t || r instanceof ft || r instanceof Vt) && (k.trim = r.trim), r.display = w, e[n] = {
            ...c,
            ...k
          };
        }
      }
    }), this.trackItemsMap = {
      ...this.trackItemsMap,
      ...e
    }, this.resumeEventListeners();
  }
  deleteTrackItemById(t) {
    const e = t, s = this.getObjects().filter(
      (a) => t.includes(a.id)
    ), r = rr(this.tracks, e), n = {};
    Object.keys(this.trackItemsMap).forEach((a) => {
      e.includes(a) || (n[a] = this.trackItemsMap[a]);
    });
    const o = this.trackItemIds.filter(
      (a) => !e.includes(a)
    );
    this.tracks = r, this.trackItemsMap = n, this.trackItemIds = o, this.discardActiveObject(), this.remove(...s), this.renderTracks(), this.alignItemsToTrack();
  }
  deleteActiveTrackItem() {
    const t = this.getActiveObjects();
    if (!t.length) return !1;
    const e = t.map((o) => o.id), s = rr(this.tracks, e), r = {};
    Object.keys(this.trackItemsMap).forEach((o) => {
      e.includes(o) || (r[o] = this.trackItemsMap[o]);
    });
    const n = this.trackItemIds.filter(
      (o) => !e.includes(o)
    );
    this.tracks = s, this.trackItemsMap = r, this.trackItemIds = n, this.discardActiveObject(), this.remove(...t), this.setActiveIds([]), this.renderTracks(), this.alignItemsToTrack(), this.updateState({ updateHistory: !0, kind: "remove" });
  }
  /*
   * This method updates the coordinates of all track items in the timeline.
   */
  updateTrackItemCoords(t) {
    const e = t ? this.getActiveObjects().map((s) => s.id) : [];
    this.trackItemIds.forEach((s) => {
      if (e.includes(s)) return;
      const r = this.transitionGroups.find((c) => c.find((l) => l.id === s)) || [];
      if ((r == null ? void 0 : r.length) === 1) {
        const c = this.getObjects().find((d) => d.id === s), l = this.trackItemsMap[s], h = D(l.display.from, this.tScale), u = D(
          l.display.to - l.display.from,
          this.tScale,
          l.playbackRate
        );
        c.set({
          left: h,
          width: u
        }), c.setCoords();
        return;
      }
      const n = r.findIndex((c) => c.id === s), o = r[n - 1], a = r[n + 1];
      if (o && !a) {
        const c = this.getObjects().find((f) => f.id === s), l = this.trackItemsMap[s], h = _e(s, r), u = D(
          l.display.from - (o.duration || 0) / 2 - h.offsetTransitions,
          this.tScale
        ), d = D(
          l.display.to - l.display.from - (o.duration || 0) / 2,
          this.tScale,
          l.playbackRate
        );
        c.set({
          left: u,
          width: d
        }), c.setCoords();
        return;
      }
      if (a && !o) {
        const c = this.getObjects().find((d) => d.id === s), l = this.trackItemsMap[s], h = D(l.display.from, this.tScale), u = D(
          l.display.to - l.display.from - (a.duration || 0) / 2,
          this.tScale,
          l.playbackRate
        );
        c.set({
          left: h,
          width: u
        }), c.setCoords();
        return;
      }
      if (o && a) {
        const c = this.getObjects().find((f) => f.id === s), l = this.trackItemsMap[s], h = _e(s, r), u = D(
          l.display.from - (o.duration || 0) / 2 - h.offsetTransitions,
          this.tScale
        ), d = D(
          l.display.to - l.display.from - (a.duration || 0) / 2 - (o.duration || 0) / 2,
          this.tScale,
          l.playbackRate
        );
        c.set({
          left: u,
          width: d
        }), c.setCoords();
        return;
      }
    });
  }
  // Restore track items sizes that are not affected by transitions
  refreshTrackItemsForTransitions() {
    const t = this.getActiveObjects().map((l) => l.id);
    this.pauseEventListeners();
    const e = this.getObjects("Track"), s = this.getObjects("Video", "Image"), r = this.getObjects("Transition"), n = s.concat(r), o = Object.keys(this.positionAfterTransform);
    e.forEach((l) => {
      o.forEach((h) => {
        if (l.items.includes(h)) {
          const u = this.getObjects().find((d) => d.id === h);
          t.includes(h) || (this.positionAfterTransform[h].left = u.left);
        }
      });
    });
    const { newTransitionsMap: a } = Oy(
      e,
      s,
      this.transitionsMap,
      this.positionAfterTransform,
      t
    ), c = xs({
      trackItemIds: this.trackItemIds,
      transitionsMap: a,
      trackItemsMap: this.trackItemsMap
    });
    s.forEach((l) => {
      const h = l.id, u = c.find((m) => m.find((b) => b.id === h)) || [], d = this.transitionGroups.find((m) => m.find((b) => b.id === h)) || [];
      if (Cy(d, u))
        return;
      const f = u.findIndex((m) => m.id === h), g = u[f - 1], p = u[f + 1];
      if (g && !p) {
        const m = _e(
          h,
          d
        ), b = _e(
          h,
          u
        ), S = D(
          m.durationDiff - b.durationDiff,
          this.tScale
        );
        l.set({
          width: l.width + S
        });
      } else if (p && !g) {
        const m = _e(
          h,
          d
        ), b = _e(
          h,
          u
        );
        if (m.durationDiff > 0) {
          const S = D(
            m.durationDiff - b.durationDiff,
            this.tScale
          );
          l.set({
            width: l.width + S
          }), u.forEach((w) => {
            if (w.id !== l.id) {
              const k = n.find(
                (O) => O.id === w.id
              );
              k == null || k.set({
                left: k.left + S
              }), k == null || k.setCoords();
            }
          });
        }
      } else if (g && p)
        console.warn("invalid spot");
      else {
        const m = _e(
          h,
          d
        ), b = D(m.durationDiff, this.tScale);
        l.set({
          width: l.width + b
        });
      }
    }), this.resumeEventListeners();
  }
  getTrackItems() {
    return this.getObjects(...$o);
  }
  setTrackItemCoords() {
    this.getTrackItems().forEach((t) => {
      t.setCoords();
    });
  }
  setActiveTrackItemCoords() {
    this.getActiveObjects().forEach((e) => e.setCoords());
  }
}
const Je = {
  text: 32,
  image: 40,
  video: 40,
  audio: 32,
  main: 40
}, Oa = (i) => {
  switch (i) {
    case "text":
      return Je.text;
    case "image":
      return Je.image;
    case "video":
      return Je.video;
    case "audio":
      return Je.audio;
    case "helperTop":
      return 1e3;
    case "helperBottom":
      return 1e3;
    case "helperCenter":
      return 8;
    case "main":
      return Je.main;
    default:
      return Je.text;
  }
};
class My {
  findOrCreateTrack(t, { trackId: e, trackIndex: s }) {
    if (e) {
      const n = this.tracks.find((o) => o.id === e);
      if (n)
        return n.items.push(t.id), e;
    }
    const r = {
      id: gr(),
      items: [t.id],
      type: t.type,
      accepts: this.acceptsMap[t.type],
      magnetic: !1,
      static: !1
    };
    return s !== void 0 ? this.tracks.splice(s, 0, r) : this.tracks.push(r), this.renderTracks(), r.id;
  }
  removeTracks() {
    this.getObjects("Track", "Helper").forEach((e) => this.remove(e));
  }
  renderTracks() {
    this.filterEmptyTracks(), this.removeTracks();
    const t = this.width, e = this.tracks.flatMap(
      (a) => [
        a,
        {
          id: `helper-${a.id}`,
          type: "helper",
          items: [],
          accepts: []
        }
      ]
    ).slice(0, -1);
    let s = -970;
    const r = C.getClass("Helper") || Ss, n = new r({
      top: s,
      selectable: !1,
      evented: !1,
      tScale: this.tScale,
      id: "helper-line-top",
      width: t,
      kind: "top",
      height: 1e3,
      metadata: {}
    });
    s += Oa("helperTop"), this.insertAt(0, n), e.forEach((a, c) => {
      if (a.type === "helper") {
        const l = Oa("helperCenter"), h = new r({
          id: a.id,
          top: s,
          tScale: this.tScale,
          width: t,
          height: l,
          metadata: {
            order: (c + 1) / 2
          },
          kind: "center"
        });
        s += l, this.insertAt(0, h);
      } else {
        const l = this.sizesMap[a.type], h = C.getClass("Track") || ue, u = new h({
          id: a.id,
          top: s,
          left: 0,
          height: l,
          width: t,
          tScale: this.tScale,
          accepts: this.acceptsMap[a.type] || [],
          items: a.items,
          magnetic: a.magnetic,
          static: a.static
        });
        s += l, this.insertAt(0, u);
      }
    });
    const o = new r({
      id: "helper-line-bottom",
      top: s,
      selectable: !1,
      evented: !1,
      tScale: this.tScale,
      width: t,
      kind: "bottom",
      height: 1e3,
      metadata: {}
    });
    this.insertAt(0, o);
  }
  filterEmptyTracks() {
    const t = /* @__PURE__ */ new Set();
    this.tracks = this.tracks.filter((e) => (e.items.length || e.static) && !t.has(e.id) ? (t.add(e.id), !0) : !1);
  }
  refreshTrackLayout() {
    const t = this.bounding.width + this.spacing.right;
    this.getObjects("Track", "Helper").forEach((e) => {
      e.updateCoords(t), e.setCoords();
    });
  }
  adjustMagneticTrack() {
    this.pauseEventListeners();
    const t = this.tracks.filter((e) => e.magnetic);
    t.length > 0 && t.forEach((e) => {
      const s = e.accepts || [], r = this.getObjects(...s).filter((o) => e.items.includes(o.id)).sort((o, a) => o.left - a.left);
      let n = 0;
      r.forEach((o) => {
        o.left = n, n += o.width;
      });
    }), this.resumeEventListeners();
  }
}
function Fl(i) {
  const t = this, e = i.target, s = i.transform;
  if (s.action === "resizing") {
    const r = t.getObjects().filter((h) => h !== e && !["Track", "Helper", "Transition", "Placeholder"].includes(h.type)), n = 10, o = e.left, a = e.width * e.scaleX, c = o + a;
    let l = !1;
    r.forEach((h) => {
      if (l) return;
      const u = h.getBoundingRect(), d = u.left, f = u.left + u.width;
      if (s.corner === "mr") {
        const g = Math.abs(c - f), p = Math.abs(c - d);
        if (g < n)
          if (e instanceof _t || e instanceof ft) {
            const m = f - e.left, b = m - a, S = Y(
              b,
              e.tScale,
              e.playbackRate
            ), w = e.trim.to + S;
            w <= e.duration && (e.set({
              width: m,
              scaleX: 1
            }), e.trim.to = w, e.onResizeSnap && e.onResizeSnap(), l = !0);
          } else
            e.set({
              width: f - e.left,
              scaleX: 1
            }), e.onResizeSnap && e.onResizeSnap(), l = !0;
        else if (p < n)
          if (e instanceof _t || e instanceof ft) {
            const m = d - e.left, b = m - a, S = Y(
              b,
              e.tScale,
              e.playbackRate
            ), w = e.trim.to + S;
            w <= e.duration && (e.set({
              width: m,
              scaleX: 1
            }), e.trim.to = w, e.onResizeSnap && e.onResizeSnap(), l = !0);
          } else
            e.set({
              width: d - e.left,
              scaleX: 1
            }), e.onResizeSnap && e.onResizeSnap(), l = !0;
      } else if (s.corner === "ml") {
        const g = Math.abs(o - d), p = Math.abs(o - f);
        if (g < n)
          if (e instanceof _t || e instanceof ft || e instanceof Vt) {
            const m = c - d, b = m - a, S = Y(
              b,
              e.tScale,
              e.playbackRate
            ), w = e.trim.from - S;
            w >= 0 && (e.set({
              left: d,
              width: m,
              scaleX: 1
            }), e.trim.from = w, e.onResizeSnap && e.onResizeSnap(), l = !0);
          } else
            e.set({
              left: d,
              width: c - d,
              scaleX: 1
            }), e.onResizeSnap && e.onResizeSnap(), l = !0;
        else if (p < n)
          if (e instanceof _t || e instanceof ft || e instanceof Vt) {
            const m = c - f, b = m - a, S = Y(
              b,
              e.tScale,
              e.playbackRate
            ), w = e.trim.from - S;
            w >= 0 && (e.set({
              left: f,
              width: m,
              scaleX: 1
            }), e.trim.from = w, e.onResizeSnap && e.onResizeSnap(), l = !0);
          } else
            e.set({
              left: f,
              width: c - f,
              scaleX: 1
            }), e.onResizeSnap && e.onResizeSnap(), l = !0;
      }
    }), l && (e.setCoords(), t.requestRenderAll());
  }
}
function Iy(i) {
  i.on("object:resizing", Fl.bind(i));
}
function Dy(i) {
  i.off("object:resizing", Fl.bind(i));
}
const Us = 100, tn = 0, Hr = 5, ka = 3, jy = 25, vs = {
  scrollInterval: null
};
function Ma(i) {
  const t = jy - ka, e = (Us - i) / Us;
  return ka + t * e;
}
function Ey(i, t) {
  vs.scrollInterval && clearInterval(vs.scrollInterval);
  const e = t.target, s = e.getBoundingRect();
  vs.scrollInterval = setInterval(() => {
    const r = i.viewportTransform, n = i.getViewportPoint(t.e);
    if (n.x > i.width - Us && e.left + s.width < i.bounding.width) {
      const o = Ma(i.width - n.x);
      e.set("left", e.left + o), i.setViewportPos(r[4] - o, r[5]);
    }
    if (n.x < Us && e.left > 0 && r[4] < Us) {
      const o = Ma(n.x);
      e.set("left", e.left - o), i.setViewportPos(r[4] + o, r[5]);
    }
    n.y > i.height - tn && e.top + s.height < i.bounding.height + 80 && (e.set("top", e.top + Hr), i.setViewportPos(r[4], r[5] - Hr)), n.y < tn && e.top > -80 && -r[5] > tn && (e.set("top", e.top - Hr), i.setViewportPos(r[4], r[5] + Hr)), e.setCoords(), i.requestRenderAll();
  }, 16);
}
function Py() {
  vs.scrollInterval && (clearInterval(vs.scrollInterval), vs.scrollInterval = null);
}
function Rl() {
  Py();
}
function Ll(i) {
  Ey(this, i);
}
function Ay(i) {
  i.on("mouse:up", Rl), i.on("object:moving", Ll.bind(i));
}
function Fy(i) {
  i.off("mouse:up", Rl), i.off("object:moving", Ll.bind(i));
}
function Bl(i) {
  const t = i.target, e = i.target.canvas;
  if (i.action === "resizing" && t instanceof Jt && e) {
    const s = t.id, r = e.getObjects("Transition").find((n) => n.id === s);
    if (r && r instanceof Jt) {
      const n = Ut(this.transitionsMap), o = {
        ...n,
        [s]: {
          ...n[s],
          width: r.width,
          duration: r.duration
        }
      };
      this.transitionsMap = o, this.updateState();
    }
  }
}
function Ry(i) {
  i.on("object:modified", Bl);
}
function Ly(i) {
  i.off("object:modified", Bl);
}
const Wl = {
  canvas: null,
  enableGuideRedraw: !0,
  isPointerOverHelperTrack: !1,
  draggingOverTrack: null,
  placeholderMovingObjects: [],
  primaryMovingObjects: [],
  secondaryMovingObjects: [],
  objectInitialPositions: {},
  originTrack: {},
  trackToItemsMap: {},
  activeTrackToItemsMap: {},
  trackTopToIdMap: {},
  trackTops: [],
  activeObjects: [],
  primaryTracks: {},
  secondaryTracks: {},
  isDragOver: !1,
  initialTrackPoints: [],
  updateItemsInTrack: null,
  orderNormalTrack: !1
}, Q = () => Wl, at = (i) => {
  Object.assign(Wl, i);
}, Ia = 10, Pi = (i, t) => {
  t.forEach((e) => e.isAlignmentAuxiliary && i.remove(e));
}, Xl = (i, t) => {
  const e = [], s = [];
  return t.getObjects().filter((r) => r.visible).forEach((r) => {
    if (i.find((o) => o.id === r.id) || r.isAlignmentAuxiliary)
      return;
    const n = r.getBoundingRect();
    e.push(
      ja(n.left, n.width, n.top, n.height)
    ), s.push(
      ja(n.top, n.height, n.left, n.width)
    );
  }), {
    vertical: e.flat(),
    horizontal: []
  };
}, zl = (i, t) => {
  const e = [], s = [];
  i.vertical.forEach((a) => {
    t.vertical.forEach((c) => {
      const l = Math.abs(a.val - c.guide);
      l < Ia && e.push({
        lineGuide: a.val,
        diff: l,
        orientation: "V",
        snap: c.snap,
        offset: c.offset,
        targetDim: { start: a.start, end: a.end }
      });
    });
  }), i.horizontal.forEach((a) => {
    t.horizontal.forEach((c) => {
      const l = Math.abs(a.val - c.guide);
      l < Ia && s.push({
        lineGuide: a.val,
        diff: l,
        orientation: "H",
        snap: c.snap,
        offset: c.offset,
        targetDim: { start: a.start, end: a.end }
      });
    });
  });
  const r = [], n = e.sort((a, c) => a.diff - c.diff)[0], o = s.sort((a, c) => a.diff - c.diff)[0];
  return n && r.push({
    lineGuide: n.lineGuide,
    offset: n.offset,
    orientation: "V",
    snap: n.snap,
    targetDim: n.targetDim
  }), o && r.push({
    lineGuide: o.lineGuide,
    offset: o.offset,
    orientation: "H",
    snap: o.snap,
    targetDim: o.targetDim
  }), r;
}, Hl = (i, t, e) => {
  i.forEach((s) => {
    const r = By(e.getZoom());
    s.orientation === "H" ? e.add(
      Da(
        [
          0,
          s.lineGuide - r.strokeWidth / 2,
          2e3,
          s.lineGuide - r.strokeWidth / 2
        ],
        { ...r, stroke: e.guideLineColor }
      )
    ) : s.orientation === "V" && e.add(
      Da(
        [
          s.lineGuide - r.strokeWidth / 2,
          0,
          s.lineGuide - r.strokeWidth / 2,
          2e3
        ],
        { ...r, stroke: e.guideLineColor }
      )
    );
  });
}, By = (i) => ({
  strokeWidth: 2 / i
}), Da = (i, t) => new Se(i, {
  ...t,
  strokeLineCap: "square",
  excludeFromExport: !0,
  isAlignmentAuxiliary: !0,
  selectable: !1,
  objectCaching: !1
}), Yl = (i) => {
  const t = i.getBoundingRect();
  return {
    vertical: [
      {
        guide: Math.round(t.left),
        offset: Math.round(i.left - t.left),
        snap: "start"
      },
      {
        guide: Math.round(t.left + t.width),
        offset: Math.round(i.left - t.left - t.width),
        snap: "end"
      }
    ],
    horizontal: [
      {
        guide: Math.round(t.top),
        offset: Math.round(i.top - t.top),
        snap: "start"
      },
      {
        guide: Math.round(t.top + t.height),
        offset: Math.round(i.top - t.top - t.height),
        snap: "end"
      }
    ]
  };
}, ja = (i, t, e, s) => [i, i + t].map((n) => ({
  val: n,
  start: e,
  end: e + s
})), Vl = (i, t) => {
  i.remove(...t), t = [];
}, Gl = (i) => {
  i.forEach((t) => t.setSelected(!1));
}, Ea = (i) => i instanceof Ss, Wy = (i) => Object.assign({}, {
  left: 16,
  right: 80
}, i), Xy = ["touchstart", "touchmove", "touchend"], zy = (i) => Xy.includes(i.type) || i.pointerType === "touch";
function Nl(i) {
  const t = this;
  if (!t) return;
  const s = Q().enableGuideRedraw, r = t.getScenePoint(i.e), n = t.getObjects("Helper", "Track"), o = n.find((g) => {
    const p = g.getBoundingRect();
    return r.x >= p.left && r.x <= p.left + p.width && r.y >= p.top && r.y <= p.top + p.height;
  });
  at({ draggingOverTrack: o }), n.forEach((g) => {
    Ea(g) && (g === o ? g.setSelected(!0) : g.setSelected(!1));
  }), Ea(o) ? at({ isPointerOverHelperTrack: !0 }) : at({ isPointerOverHelperTrack: !1 });
  const a = t.getObjects(), c = i.target, l = c.getBoundingRect();
  c.setCoords();
  const h = [
    c,
    ...t.getActiveObjects(),
    ...t.getObjects("Track", "Helper", "Transition", "Placeholder")
  ], u = Xl(h, t), d = Yl(c), f = zl(u, d);
  s && (Pi(t, a), f.length && Hl(f, l, t), at({ enableGuideRedraw: !1 }), setTimeout(() => at({ enableGuideRedraw: !0 }), 50)), f.forEach((g) => {
    g.orientation === "V" ? c.left = g.lineGuide + g.offset : c.top = g.lineGuide + g.offset;
  });
}
function Ul(i) {
  const t = i.target.canvas;
  t && (Pi(t, t.getObjects()), Gl(t.getObjects("Helper")), at({ draggingOverTrack: null, isPointerOverHelperTrack: !1 }));
}
function $l(i) {
  var a;
  const t = this, e = t.getObjects(), s = i.target, r = i.transform, n = (a = t._currentTransform) == null ? void 0 : a.corner, o = s.getBoundingRect();
  if (r.action === "resizing") {
    const c = [
      s,
      ...t.getActiveObjects(),
      ...t.getObjects("Track", "Helper", "Transition", "Placeholder")
    ], l = Xl(c, t), h = l.vertical.filter(
      (f) => {
        const g = f.val;
        if (n === "ml")
          return g <= o.left;
        if (n === "mr")
          return g >= o.left + o.width;
      }
    );
    l.vertical = h;
    const u = Yl(s), d = zl(l, u);
    Pi(t, e), d.length && Hl(d, o, t);
  }
}
function Hy(i) {
  i.on("object:moving", Nl.bind(i)), i.on("object:modified", Ul.bind(i)), i.on("object:resizing", $l.bind(i));
}
function Yy(i) {
  i.off("object:moving", Nl.bind(i)), i.off("object:modified", Ul.bind(i)), i.off("object:resizing", $l.bind(i));
}
function In(i, t, e) {
  const s = i.indexOf(t), r = i.indexOf(e);
  return s === -1 || r === -1 ? null : r - s;
}
function ql(i, t) {
  const e = t.sort((r, n) => r.tempIndex - n.tempIndex), s = [];
  for (const r of e)
    r.tempIndex < 0 && s.push(r);
  s.push(i);
  for (const r of e)
    r.tempIndex >= 0 && s.push(r);
  return s;
}
function Kl(i) {
  const t = Q(), e = t.canvas;
  at({
    activeTrackToItemsMap: {},
    primaryTracks: {},
    secondaryTracks: {},
    trackTops: [],
    trackToItemsMap: {},
    activeObjects: [],
    trackTopToIdMap: {},
    isDragOver: !1,
    initialTrackPoints: [],
    updateItemsInTrack: null
  }), e.trackIdAfterTransform = "", e.positionAfterTransform = {};
  const s = e.getActiveObject(), r = s instanceof Ot ? s.getObjects() : [s];
  at({ activeObjects: r });
  const n = e.getScenePoint(i.e), o = e.getObjects("Track"), a = e.getActiveObjects().map((u) => u.id);
  let l = o.filter((u) => {
    const d = u.items;
    return a.some((f) => d.includes(f));
  }).find((u) => {
    const d = u.getBoundingRect();
    return n.x >= d.left && n.x <= d.left + d.width && n.y >= d.top && n.y <= d.top + d.height;
  });
  at({ originTrack: l });
  const h = e.getObjects(
    "Video",
    "Image",
    "Audio",
    "Text",
    "Element",
    "Template"
  );
  o.forEach((u) => {
    const d = h.filter((f) => u.items.includes(f.id));
    t.trackToItemsMap[u.id] = d, t.trackTopToIdMap[u.top] = u.id, t.trackTops.push(u.top);
  }), t.trackTops.sort((u, d) => u - d), r.forEach((u) => {
    const d = o.find((g) => g.items.includes(u.id));
    if (!d) return;
    const f = d.id;
    t.activeTrackToItemsMap[f] ? t.activeTrackToItemsMap[f].push(u) : t.activeTrackToItemsMap[f] = [u];
  }), t.primaryMovingObjects = r.filter((u) => {
    const d = u.getBoundingRect();
    return n.y >= d.top && n.y <= d.top + d.height && !(u instanceof Jt);
  }), t.primaryMovingObjects.length !== 0 && (t.primaryMovingObjects.forEach((u) => {
    const d = u.getBoundingRect().top, f = t.trackTopToIdMap[d];
    if (t.primaryTracks[f])
      t.primaryTracks[f].objects.push(u);
    else {
      const g = In(
        t.trackTops,
        l == null ? void 0 : l.top,
        d
      );
      t.primaryTracks[f] = {
        objects: [u],
        index: g
      };
    }
  }), t.primaryMovingObjects = t.primaryMovingObjects.sort(
    (u, d) => u.left - d.left
  ), t.secondaryMovingObjects = r.filter(
    (u) => !t.primaryMovingObjects.includes(u)
  ), t.secondaryMovingObjects.forEach((u) => {
    const d = u.getBoundingRect().top, f = t.trackTopToIdMap[u.getBoundingRect().top];
    if (t.secondaryTracks[f])
      t.secondaryTracks[f].objects.push(u);
    else {
      const g = In(
        t.trackTops,
        l.top,
        d
      );
      t.secondaryTracks[f] = {
        objects: [u],
        index: g
      };
    }
  }), l && (e.trackOriginBeforeTransform = l.id), s && (e.positionBeforeTransform = {
    top: s.top,
    left: s.left
  }), i.transform.action === "drag" && (t.placeholderMovingObjects = t.primaryMovingObjects.map((u) => {
    const d = u.getBoundingRect();
    t.objectInitialPositions[u.id] = {
      top: d.top,
      left: d.left
    };
    const f = new er({
      id: `${u.id}-placeholder`,
      left: d.left,
      top: d.top,
      width: d.width,
      height: d.height
    });
    return f.draggedObject = u, f;
  }), e.add(...t.placeholderMovingObjects)));
}
function Vy(i) {
  i.on("before:transform", Kl.bind(i));
}
function Gy(i) {
  i.off("before:transform", Kl.bind(i));
}
const gs = class gs extends X {
  constructor(e) {
    super(e);
    T(this, "duration");
    T(this, "fromId");
    T(this, "toId");
    T(this, "itemType", "none");
    T(this, "isSelected", !1);
    Object.assign(this, gs.ownDefaults), this.id = e.id;
  }
  static createControls() {
    return { controls: ml() };
  }
  static getDefaults() {
    return {
      ...super.getDefaults(),
      ...gs.ownDefaults
    };
  }
  updateCoords() {
    const e = this.canvas;
    if (!e) return;
    const s = e.getObjects().find((o) => o.id === this.fromId);
    if (!s) return;
    const r = D(this.duration, this.tScale), n = s.left + s.width - r / 2;
    this.set({
      width: r,
      left: n
    });
  }
  // add custom text to the track item
  _render(e) {
    super._render(e), this.drawTextIdentity(e), this.updateSelected(e);
  }
  drawTextIdentity(e) {
    const s = new Path2D(
      "M3 5.30359C3 3.93159 4.659 3.24359 5.629 4.21359L11.997 10.5826L10.583 11.9966L5 6.41359V17.5856L10.586 11.9996L10.583 11.9966L11.997 10.5826L12 10.5856L18.371 4.21459C19.341 3.24459 21 3.93159 21 5.30359V18.6956C21 20.0676 19.341 20.7556 18.371 19.7856L12 13.5L13.414 11.9996L19 17.5866V6.41359L13.414 11.9996L13.421 12.0056L12.006 13.4206L12 13.4136L5.629 19.7846C4.659 20.7546 3 20.0676 3 18.6956V5.30359Z"
    );
    e.save(), e.translate(-12, -12), e.fillStyle = "#ffffff", e.fill(s), e.restore();
  }
  setSelected(e) {
    this.isSelected = e, this.set({ dirty: !0 });
  }
  updateSelected(e) {
    this.isSelected && (e.save(), e.beginPath(), e.roundRect(
      -this.width / 2,
      -this.height / 2,
      this.width,
      this.height,
      this.rx
    ), e.lineWidth = It, e.strokeStyle = vt, e.stroke(), e.restore());
  }
};
T(gs, "type", "TransitionGuide"), T(gs, "ownDefaults", {
  objectCaching: !1,
  borderColor: "transparent",
  stroke: "transparent",
  strokeWidth: 1.5,
  fill: "rgba(0,0,0, 0.85)",
  borderOpacityWhenMoving: 1,
  hoverCursor: "default",
  lockMovementX: !0,
  lockMovementY: !0,
  duration: 1500,
  rx: 8,
  ry: 8
});
let or = gs;
const Ny = [
  "text",
  "image",
  "video",
  "audio",
  "caption",
  "template"
];
function Jl() {
  const i = Q();
  Vl(this, i.placeholderMovingObjects);
}
function Uy(i) {
  const t = i.target.left;
  i.target.left = Math.max(t, 0);
}
function Zl(i, t) {
  return i.find((s) => {
    const r = s.getBoundingRect();
    return t.left < r.left + r.width && t.left + t.width - 1 > r.left && t.top < r.top + r.height && t.top + t.height > r.top;
  });
}
function $y(i, t) {
  const s = i.canvas.getActiveObject(), r = s.left + s.width / 2, n = t.left + t.width / 2;
  return r < n ? t.left - s.width : (r > n, t.left + t.width);
}
const qy = (i, t, e) => !(e < 0 || Zl(i, {
  ...t.getBoundingRect(),
  left: e
})), Ql = (i) => {
  const e = Q().draggingOverTrack;
  return i instanceof Oe ? e && e.accepts.includes(i.itemType) : e && e.accepts.includes(i.type);
};
function Ky(i) {
  Q().isPointerOverHelperTrack ? i.opacity = 0 : i.opacity = 1;
}
function Jy() {
  const i = Q(), t = i.primaryMovingObjects[0];
  return {
    top: i.objectInitialPositions[t.id].top,
    left: i.objectInitialPositions[t.id].left
  };
}
function Zy(i) {
  const t = i.getBoundingRect(), e = Q(), s = e.draggingOverTrack;
  if (e.primaryMovingObjects.map((n) => n.id).includes(i.id)) {
    const o = e.primaryMovingObjects[0].getBoundingRect();
    return {
      top: s.top,
      left: o.left
    };
  }
  return {
    top: s.top,
    left: t.left
  };
}
function Qy(i, t, e, s) {
  const n = i.canvas.getActiveObjects().map((h) => h.id), o = $y(i, t), a = e.filter(
    (h) => !n.includes(h.id)
  ), c = qy(
    a,
    i,
    o
  ), l = Q();
  if (l.orderNormalTrack = !0, !c || s.x - 20 < 0) {
    const h = l.draggingOverTrack;
    return {
      left: l.initialTrackPoints.reduce(
        (d, f) => Math.abs(f - s.x) < Math.abs(d - s.x) ? f : d
      ),
      top: h.top
    };
  }
  return {
    left: o,
    top: t.top
  };
}
const t0 = (i, t) => {
  i.forEach((e, s) => {
    e.set({ left: t[s] });
  });
}, th = wy(
  (i) => {
    const t = i.target.canvas;
    Uy(i);
    const e = Q(), s = e.draggingOverTrack;
    if (s) {
      const a = e.primaryMovingObjects[0];
      Ny.includes(a.type) && e.placeholderMovingObjects.forEach((c) => {
        c.visible = !0;
      });
    } else {
      e.placeholderMovingObjects.forEach((a) => {
        a.visible = !1;
      });
      return;
    }
    const r = e.placeholderMovingObjects.map(
      (a) => a.draggedObject
    ), n = (e.trackToItemsMap[s.id] || []).filter((a) => !r.includes(a)), o = Ql(e.primaryMovingObjects[0]);
    if (s.magnetic && o) {
      e.updateItemsInTrack ? e.updateItemsInTrack !== s.id && (e.updateItemsInTrack = s.id, e.initialTrackPoints = []) : (e.updateItemsInTrack = s.id, e.initialTrackPoints = []), e.initialTrackPoints.length === 0 && (e.updateItemsInTrack = s.id, e.initialTrackPoints = Pa(
        e,
        s
      ));
      let a = 0;
      for (const [c, l] of e.initialTrackPoints.entries()) {
        const h = l, u = e.initialTrackPoints[c + 1], d = e.initialTrackPoints[c - 1], f = u - h, g = h - d;
        if (!u)
          a = h;
        else if (h <= i.pointer.x && h + f / 2 >= i.pointer.x) {
          a = h;
          break;
        } else if (h - g / 2 <= i.pointer.x && i.pointer.x <= h) {
          a = h;
          break;
        }
      }
      e.placeholderMovingObjects.forEach((c) => {
        c.opacity = 1, c.left = a, c.top = s.top, a += c.width;
      }), e.placeholderMovingObjects.forEach((c) => {
        const l = c.draggedObject;
        t.positionAfterTransform[l.id] = {
          top: c.top,
          left: c.left
        };
      }), t.trackIdAfterTransform = e.trackTopToIdMap[s.top];
    } else {
      e.orderNormalTrack = !1, e.updateItemsInTrack && e.updateItemsInTrack !== s.id && (t.getObjects().find((f) => f.id === e.updateItemsInTrack).magnetic ? e0(t, e) : t.updateTrackItemCoords(!0), e.updateItemsInTrack = null, e.initialTrackPoints = []), e.initialTrackPoints.length === 0 && s instanceof ue && (e.updateItemsInTrack = s.id, e.initialTrackPoints = Pa(
        e,
        s
      ));
      const a = n.find((d) => Zl(
        r,
        d.getBoundingRect()
      )), c = [], h = e.primaryMovingObjects.sort((d, f) => d.left - f.left), u = h[0];
      h.forEach((d, f) => {
        if (!h[f - 1]) return;
        const g = d.left - u.left;
        c.push(g);
      }), e.placeholderMovingObjects.forEach((d, f) => {
        const g = d.draggedObject;
        if (g instanceof or) {
          d.visible = !1;
          return;
        }
        g.setCoords(), Ky(d);
        let p = n0(
          g,
          n,
          i.pointer,
          a
        );
        if (g instanceof Oe && p.isInvalidDrop && e.draggingOverTrack instanceof ue) {
          d.opacity = 0;
          const m = i.pointer, b = [...t.viewportTransform], S = m.y - b[5];
          i0(t, S);
        } else e.primaryMovingObjects.length > 1 ? (t.trackIdAfterTransform = e.trackTopToIdMap[p.top], t.positionAfterTransform[g.id] = {
          top: p.top,
          left: p.left + (c[f - 1] || 0)
        }, d.left = p.left + (c[f - 1] || 0), d.top = p.top) : (t.trackIdAfterTransform = e.trackTopToIdMap[p.top], t.positionAfterTransform[g.id] = {
          top: p.top,
          left: p.left
        }, d.left = p.left, d.top = p.top);
      });
    }
  }
), Pa = (i, t) => {
  const e = i.canvas, s = [];
  t.items.forEach((l) => {
    const h = e.getObjects().find((u) => u.id === l);
    h && s.push(h);
  });
  const r = i.activeObjects.map((l) => l.id), o = s.filter(
    (l) => !r.includes(l.id)
  ).sort(
    (l, h) => l.left - h.left
  );
  let a = 0;
  const c = [];
  return t.magnetic ? s0(o, a, c) : r0(t, c, e), c;
};
function e0(i, t) {
  const e = [];
  i.getObjects().find((a) => a.id === t.updateItemsInTrack).items.forEach((a) => {
    const c = i.getObjects().find((l) => l.id === a);
    c && e.push(c);
  });
  const r = t.activeObjects.map((a) => a.id), o = e.filter(
    (a) => !r.includes(a.id)
  ).sort(
    (a, c) => a.left - c.left
  );
  t.initialTrackPoints.length > o.length && t0(o, t.initialTrackPoints);
}
function s0(i, t, e) {
  var l;
  const s = Q(), r = (l = i[0]) == null ? void 0 : l.canvas, n = s.draggingOverTrack, o = s.primaryMovingObjects.map((h) => h.id);
  if (!r) return;
  const a = r.transitionIds.filter(
    (h) => r.transitionsMap[h].kind !== "none"
  );
  i.forEach((h) => {
    h.set({ left: t }), t += h.width, a.find(
      (d) => r.transitionsMap[d].toId === h.id
    ) || e.push(h.left);
  });
  const c = i[i.length - 1];
  if (e.push(((c == null ? void 0 : c.left) || 0) + ((c == null ? void 0 : c.width) || 0)), n != null && n.items.includes(o[0])) {
    const h = r.getActiveObject(), u = [...e];
    if (h) {
      const d = u.findIndex((f) => f > (h == null ? void 0 : h.left));
      d !== -1 && e.splice(d, 0, h.left);
    }
  }
}
function r0(i, t, e) {
  const s = i.items, r = {}, n = {}, o = e.getActiveObjects().map((l) => l.id);
  Object.values(e.trackItemsMap).forEach((l) => {
    s.includes(l.id) && (r[l.id] = l);
  });
  const a = e.getObjects("Transition").filter((l) => l.top === i.top).map((l) => l.id);
  Object.values(e.transitionsMap).forEach((l) => {
    a.includes(l.id) && (n[l.id] = l);
  });
  const c = ho({
    trackItemIds: Ut(s),
    transitionsMap: Ut(n),
    trackItemsMap: Ut(r)
  });
  t.push(0), c.forEach((l) => {
    if (l.length === 1) {
      const h = e.getObjects().find((u) => u.id === l[0].id);
      o.includes(h.id) || t.push(h.left + h.width);
    } else {
      const h = l[l.length - 1], u = e.getObjects().find((d) => d.id === h.id);
      t.push(u.width + u.left);
    }
  });
}
function i0(i, t) {
  i.getObjects("Helper").reduce(
    (r, n) => Math.abs(n.top - t) < Math.abs(r.top - t) ? n : r
  ).setSelected(!0);
}
const n0 = (i, t, e, s) => {
  const r = Ql(i);
  return !r && i instanceof Oe ? {
    top: 0,
    left: 0,
    isInvalidDrop: !0
  } : r ? s ? i instanceof Oe ? {
    top: 0,
    left: 0,
    isInvalidDrop: !0
  } : Qy(
    i,
    s,
    t,
    e
  ) : Zy(i) : Jy();
};
function o0(i) {
  i.on("mouse:up", Jl.bind(i)), i.on("object:moving", th);
}
function a0(i) {
  i.off("mouse:up", Jl.bind(i)), i.off("object:moving", th);
}
const c0 = (i) => {
  Q().canvas.fire("track:create", i);
}, l0 = (i) => {
  Q().canvas.fire("track-items:moved", i);
}, eh = (i) => {
  var a, c, l;
  const t = (a = i.target) == null ? void 0 : a.canvas;
  if (!t) return;
  const e = Q(), s = t.getActiveObject();
  if (!s || !t.positionBeforeTransform) return;
  const r = t.getScenePoint(i.e), o = t.getObjects("Track", "Helper").find((h) => {
    const u = h.getBoundingRect();
    return r.x >= u.left && r.x <= u.left + u.width && r.y >= u.top && r.y <= u.top + u.height;
  });
  if (i.action === "resizing") {
    const h = (e.trackToItemsMap[(c = e.originTrack) == null ? void 0 : c.id] || []).filter((d) => d !== s);
    s.setCoords();
    const u = sh(
      h,
      s.getBoundingRect()
    );
    return t.fire("track-items:resized", {
      trackId: (l = e.originTrack) == null ? void 0 : l.id,
      trackItemIds: [s.id],
      isOverlapped: !!u
    }), !1;
  }
  if (!o)
    return s == null || s.set(t.positionBeforeTransform), s == null || s.setCoords(), !1;
  if (o instanceof Ss) {
    let h;
    switch (o.kind) {
      case "top":
        h = 0;
        break;
      case "center":
        h = o.metadata.order || 0;
        break;
      case "bottom":
        h = -1;
        break;
      default:
        return;
    }
    const u = {
      isSecondaryOverlapped: !1,
      secondaryTracks: e.secondaryTracks,
      primaryTracks: e.primaryTracks,
      primaryPositions: {
        trackIndex: h,
        trackId: t.trackIdAfterTransform,
        positions: t.positionAfterTransform
      }
    };
    c0(u);
  } else if (o instanceof ue) {
    const u = {
      isSecondaryOverlapped: u0(),
      secondaryTracks: e.secondaryTracks,
      primaryTracks: e.primaryTracks,
      primaryPositions: {
        trackId: t.trackIdAfterTransform,
        positions: t.positionAfterTransform
      }
    };
    l0(u);
  }
};
function h0() {
  const i = Q(), t = i.canvas, [e] = i.primaryMovingObjects, s = e.id, r = t.positionAfterTransform[s], n = e.getBoundingRect().top, o = r.top - n, a = {};
  return i.secondaryMovingObjects.forEach((c) => {
    const l = c.getBoundingRect().top + o, h = i.trackTopToIdMap[l], u = In(
      i.trackTops,
      i.originTrack.top,
      l
    );
    a[h] ? a[h].objects.push(c) : a[h] = {
      objects: [c],
      index: u
    };
  }), a;
}
function u0() {
  const i = h0(), t = Q();
  return Object.keys(i).some((e) => {
    const s = t.trackToItemsMap[e], r = i[e].objects;
    return !s || !s.length ? !0 : s.filter((n) => !r.includes(n)).some((n) => sh(
      r,
      n.getBoundingRect()
    ));
  });
}
function sh(i, t) {
  return i.find((s) => {
    const r = s.getBoundingRect();
    return t.left < r.left + r.width && t.left + t.width > r.left && t.top < r.top + r.height && t.top + t.height > r.top;
  });
}
const d0 = (i) => {
  i.on("object:modified", eh);
}, f0 = (i) => {
  i.off("object:modified", eh);
}, rh = "drag", g0 = `${rh}:start`, ih = `${rh}:end`, nh = "timeline", p0 = `${nh}:boundingChanged`, m0 = `${nh}:seek`, v0 = "add:audio", y0 = "add:video", b0 = "add:image", _0 = "add:text", S0 = [
  "transition",
  "image",
  "video",
  "audio",
  "caption",
  "text"
];
let et, Xs, ws = [];
function T0(i, t) {
  let e = 1 / 0, s = null;
  const r = new _(i.x, i.y);
  return t.forEach((n) => {
    const o = Math.sqrt(
      Math.pow(n.left - r.x, 2) + Math.pow(n.top - r.y, 2)
    );
    o < e && (e = o, s = n);
  }), s;
}
const x0 = ({
  width: i,
  height: t,
  id: e,
  left: s,
  top: r,
  type: n,
  duration: o
}) => {
  if (n === "transition")
    return new or({
      top: 0,
      left: 0,
      height: 48,
      width: 48,
      id: "TransitionGuide"
    });
  const a = C.getClass("PreviewTrackItem") || Oe;
  return new a({
    top: r,
    left: s,
    height: t,
    width: i,
    id: e,
    type: n,
    duration: o
  });
};
function oh(i) {
  var f;
  const t = (f = i.e.dataTransfer) == null ? void 0 : f.types[0];
  if (!t) return;
  const e = JSON.parse(t), s = e.type;
  if (!S0.includes(s)) return;
  const r = e.duration || 5e3, n = this;
  n.discardActiveObject(), n.setActiveIds([]);
  const o = D(r, this.tScale), a = this.sizesMap[s];
  et = x0({
    width: o,
    height: a,
    id: "TransitionGuide",
    left: 0,
    top: 0,
    type: s,
    duration: r
  }), et.visible = !1, s === "transition" && (ws = n.getObjects("Transition"), ws.forEach((g) => {
    g.visible = !0;
  }));
  const c = Q();
  n.trackIdAfterTransform = "", n.positionAfterTransform = {};
  const l = et, h = [et];
  at({
    activeTrackToItemsMap: {},
    primaryTracks: {},
    secondaryTracks: {},
    trackTops: [],
    trackToItemsMap: {},
    activeObjects: [],
    trackTopToIdMap: {},
    isDragOver: !1
  }), at({ activeObjects: h });
  const u = n.getObjects("Track"), d = n.getTrackItems();
  u.forEach((g) => {
    const p = d.filter((m) => g.items.includes(m.id));
    c.trackToItemsMap[g.id] = p, c.trackTopToIdMap[g.top] = g.id, c.trackTops.push(g.top);
  }), c.trackTops.sort((g, p) => g - p), c.primaryMovingObjects = h, c.primaryMovingObjects = c.primaryMovingObjects.sort(
    (g, p) => g.left - p.left
  ), l && (n.positionBeforeTransform = {
    top: l.top,
    left: l.left
  }), c.placeholderMovingObjects = c.primaryMovingObjects.map((g) => {
    const p = g.getBoundingRect();
    c.objectInitialPositions[g.id] = {
      top: p.top,
      left: p.left
    };
    const m = new er({
      id: `${g.id}-placeholder`,
      left: p.left,
      top: p.top,
      width: p.width,
      height: p.height
    });
    return m.visible = !1, m.draggedObject = g, m;
  }), n.add(...c.placeholderMovingObjects), n.add(et), ie(g0);
}
const ah = (i) => {
  const t = Q();
  Vl(i, t.placeholderMovingObjects), i && (Pi(i, i.getObjects()), Gl(i.getObjects("Helper")));
};
function ch() {
  if (ah(this), at({ draggingOverTrack: null, isPointerOverHelperTrack: !1 }), !et) return;
  ie(ih);
  const i = this;
  ws.forEach((t) => {
    t.strokeDashArray = [], t.setSelected(!1), t.kind === "none" && (t.visible = !1);
  }), i.getObjects("Helper", "Track").forEach((t) => {
    t.setSelected && t.setSelected(!1);
  }), i.remove(et);
}
function lh(i) {
  const t = Q(), e = t.placeholderMovingObjects[0];
  if (e.visible || (et.visible = !0, e.visible = !0), t.activeObjects[0] instanceof or && (e.visible = !1), !et) return !1;
  i.e.preventDefault();
  const s = this, r = s.getViewportPoint(i.e), n = [...this.viewportTransform];
  et.set({
    left: r.x - 16 - n[4],
    top: r.y - n[5] - et.height / 2
  });
  const o = T0(r, ws);
  o && (Xs = o, o.strokeDashArray = [5, 1], o.setSelected(!0)), ws.forEach((c) => {
    c !== o && c.setSelected(!1);
  }), at({ isDragOver: !0 }), et.setCoords();
  const a = {
    target: et,
    action: "drag",
    originX: "center",
    originY: "center",
    offsetX: r.x - et.left,
    offsetY: r.y - et.top,
    scaleX: et.scaleX,
    scaleY: et.scaleY
  };
  s.fire("object:moving", {
    target: et,
    e: i.e,
    pointer: r,
    transform: a
  }), s.requestRenderAll();
}
function hh(i) {
  var o;
  const t = this;
  ah(t);
  const e = Q(), s = e.draggingOverTrack;
  at({ draggingOverTrack: null, isPointerOverHelperTrack: !1 });
  const r = (o = i.e.dataTransfer) == null ? void 0 : o.types[0], n = JSON.parse(i.e.dataTransfer.getData(r));
  if (n.type !== "transition") {
    const a = e.activeObjects[0], c = Y(a.left, t.tScale);
    if (s instanceof ue)
      if (e.placeholderMovingObjects[0].opacity !== 0) {
        const h = en(s, this.getObjects("Track"));
        if (s.magnetic) {
          const u = e.initialTrackPoints[e.initialTrackPoints.length - 1], d = Y(u, t.tScale);
          Yr(n, h, d);
        } else Yr(n, h, c);
      } else {
        const h = i.viewportPoint, u = [...t.viewportTransform], d = h.y - u[5], g = t.getObjects("Helper").reduce(
          (m, b) => Math.abs(b.top - d) < Math.abs(m.top - d) ? b : m
        ), p = en(g, this.getObjects("Track"));
        Yr(n, p, c, !0);
      }
    else {
      const l = en(
        s,
        this.getObjects("Track")
      );
      Yr(n, l, c, !0);
    }
    this.remove(a), this.requestRenderAll();
    return;
  }
  if (et) {
    if (Xs) {
      const a = Xs.id, c = Ty(n, ["kind", "direction"]);
      Object.keys(c).forEach((S) => {
        S === "kind" ? Xs.kind = c[S] : Xs[S] = c[S];
      });
      const l = Ut(this.trackItemIds), h = Ut(this.transitionsMap), u = Ut(this.trackItemsMap);
      h[a] = {
        ...h[a],
        ...c
      };
      const d = xs({
        trackItemIds: l,
        transitionsMap: h,
        trackItemsMap: u
      }), g = h[a].fromId, p = d.find((S) => S.find((w) => w.id === g)) || [], m = w0(
        p
      ), b = C0(
        this.trackItemsMap,
        m
      );
      this.trackItemsMap = b, this.transitionsMap[a] = {
        ...this.transitionsMap[a],
        ...c
      }, this.transitionGroups = xs({
        trackItemIds: this.trackItemIds,
        transitionsMap: this.transitionsMap,
        trackItemsMap: this.trackItemsMap
      }), this.updateTrackItemCoords(), this.adjustMagneticTrack(), this.calcBounding(), this.updateTransitions(), this.refreshTrackLayout(), this.updateState({ kind: "add:transition", updateHistory: !0 });
    }
    ws.forEach((a) => {
      a.strokeDashArray = [], a.setSelected(!1), a.kind === "none" && (a.visible = !1);
    }), t.remove(et), t.requestRenderAll(), ie(ih);
  }
}
const w0 = (i) => {
  const [t] = i, e = i.filter(
    (r) => r.type !== "transition"
  );
  let s = t.display.from;
  return e.map((r) => {
    const n = r.display.to - r.display.from, o = {
      from: s,
      to: s + n
    };
    return s = o.to, {
      ...r,
      display: o
    };
  });
}, C0 = (i, t) => {
  let e = i;
  return t.forEach((s) => {
    e[s.id] = s;
  }), e;
}, en = (i, t) => {
  const e = t.sort((o, a) => o.top - a.top);
  if (e.length === 0) return 0;
  const s = e[e.length - 1];
  if (s.top + s.height <= i.top)
    return e.length;
  const r = i.top;
  return e.reduce((o, a, c) => {
    const l = Math.abs(a.top - r), h = Math.abs(e[o].top - r);
    return l < h ? c : o;
  }, 0);
}, Yr = (i, t, e, s) => {
  i.type === "image" ? ie(b0, {
    payload: {
      ...i,
      id: Ws(),
      display: { from: e }
    },
    options: { trackIndex: t, isNewTrack: s }
  }) : i.type === "video" ? ie(y0, {
    payload: {
      ...i,
      id: Ws(),
      display: { from: e }
    },
    options: { trackIndex: t, isNewTrack: s }
  }) : i.type === "audio" ? ie(v0, {
    payload: {
      ...i,
      id: Ws(),
      display: { from: e }
    },
    options: { trackIndex: t, isNewTrack: s }
  }) : i.type === "text" && ie(_0, {
    payload: {
      ...i,
      id: Ws(),
      display: { from: e }
    },
    options: { trackIndex: t, isNewTrack: s }
  });
};
function O0(i) {
  i.on("dragover", lh), i.on("dragenter", oh), i.on("dragleave", ch), i.on("drop", hh);
}
function k0(i) {
  i.off("dragover", lh), i.off("dragenter", oh), i.off("dragleave", ch), i.off("drop", hh);
}
function uh(i) {
  const t = this.height < this.bounding.height;
  if (!(this.width < this.bounding.width) && !t) return;
  const s = this.viewportTransform;
  let r = s[4], n = s[5];
  const o = 2;
  i.e.shiftKey ? r = r - i.e.deltaY * o : (t && (n = n - i.e.deltaY * o), r = r - i.e.deltaX * o), this.setViewportPos(r, n);
}
function dh() {
  const i = this, t = i.getActiveObject(), e = i.getActiveObjects(), s = e.map((n) => n.id), r = e.filter((n) => {
    if (e.length === 1)
      return !0;
    if (n.id && !(n instanceof Jt))
      return !0;
    if (n instanceof Jt && s.includes(n.fromId) && s.includes(n.toId))
      return !0;
  }).map((n) => n.id);
  t instanceof Ot ? (t.borderColor = "rgba(0, 216, 214,0.75)", t.hasControls = !1, t.hoverCursor = "default", t.borderScaleFactor = 1, t.padding = 0, t.getObjects().forEach((n) => {
    n.setSelected(!0);
  })) : t == null || t.setSelected(!0), this.setActiveIds(r);
}
function fh(i) {
  const t = this, e = t.getActiveObject();
  e instanceof Ot && (e.borderColor = "transparent", e.hasControls = !1, e.hoverCursor = "default"), i.selected.forEach((n) => {
    n.setSelected(!0);
  }), i.deselected.forEach((n) => {
    n.setSelected(!1);
  });
  const r = t.getActiveObjects().map((n) => n.id);
  this.setActiveIds(r);
}
function gh(i) {
  i.deselected.forEach((t) => {
    t.setSelected(!1);
  });
}
const M0 = (i) => {
  i.on("selection:created", dh), i.on("selection:updated", fh), i.on("selection:cleared", gh), i.on("mouse:wheel", uh);
}, I0 = (i) => {
  i.off("mouse:wheel", uh), i.off("selection:created", dh), i.off("selection:updated", fh), i.off("selection:cleared", gh);
}, ph = () => {
  var n, o;
  const i = Q(), t = i.canvas, e = i.draggingOverTrack;
  t.updateTrackItemCoords(!0);
  const s = e == null ? void 0 : e.magnetic, r = new Set(i.activeObjects.map((a) => a.id));
  if (s) {
    const a = e.id, l = i.trackToItemsMap[a].sort((p, m) => p.left - m.left), h = i.placeholderMovingObjects, u = ((n = h[0]) == null ? void 0 : n.top) || 0, d = h.reduce(
      (p, m) => p + m.width,
      0
    ), f = Math.min(...h.map((p) => p.left));
    let g = 0;
    l.forEach((p) => {
      r.has(p.id) || p.top === u && (Math.abs(f - g) < 1 && (g += d), p.left = g, g += p.width);
    });
  } else if (e instanceof ue && i.orderNormalTrack) {
    const a = e.items, c = t.getTrackItems().filter(
      (x) => !r.has(x.id) && a.includes(x.id)
    ), l = c.sort((x, I) => x.left - I.left), h = i.placeholderMovingObjects[0], u = i.placeholderMovingObjects[i.placeholderMovingObjects.length - 1], d = h.left, f = u.left - h.left + u.width, g = l.find((x, I) => {
      if (x.left >= d - 1) return l[I];
    }), p = D(
      ((o = g == null ? void 0 : g.display) == null ? void 0 : o.from) || 0,
      t.tScale
    ), m = c.map((x) => x.id), b = {}, S = {};
    Object.values(t.trackItemsMap).forEach((x) => {
      m.includes(x.id) && (b[x.id] = x);
    });
    const w = t.getObjects("Transition").filter((x) => x.top === c[0].top).map((x) => x.id);
    Object.values(t.transitionsMap).forEach((x) => {
      w.includes(x.id) && (S[x.id] = x);
    });
    const k = ho({
      trackItemIds: Ut(c.map((x) => x.id)),
      transitionsMap: Ut(S),
      trackItemsMap: Ut(b)
    });
    c.filter(
      (x) => x.left >= d - 1
    ).forEach((x) => {
      const I = D(x.display.from, t.tScale), M = Object.values(t.transitionsMap).find(
        (R) => R.kind !== "none" && R.toId === x.id
      );
      let E = 0;
      k.forEach((R) => {
        if (R.map((F) => F == null ? void 0 : F.id).includes(x.id)) {
          for (const F of R)
            if (F.type === "transition")
              if ((M == null ? void 0 : M.id) === F.id) {
                E = E + D(F.duration, t.tScale) / 2;
                break;
              } else
                E = E + D(F.duration, t.tScale);
            else if (F.id === x.id) break;
        }
      }), p <= d + f && (x.left = I + f - E + d - p);
    });
  }
  t.alignTransitionsToTrack(!1);
};
function D0(i) {
  i.on("object:moving", ph);
}
function j0(i) {
  i.off("object:moving", ph);
}
let Ft, uo = !1;
function E0(i, t) {
  const e = i.canvas;
  if (qd.includes(i.type)) {
    Ft || (Ft = i);
    const s = i.top, r = i.height, n = i.left, o = i.width, a = t.x, c = t.y, l = Math.abs(c - (s + r / 2)) <= Jd;
    Math.abs(a - n) <= qo && l || Math.abs(a - n - o) <= qo && l ? (e.hoverCornerItem = !0, i.hoverCursor = "ew-resize") : (e.hoverCornerItem = !1, i.hoverCursor = "move"), e.requestRenderAll();
  }
}
function mh(i) {
  const t = this, e = t.findTarget(i.e), s = t.getScenePoint(i.e);
  e && (e.isSelected && Ft && (e.hoverCursor = "default"), E0(e, s));
}
function vh() {
  Ft && (Ft.lockMovementX = !1, Ft.lockMovementY = !1, Ft = void 0);
}
function yh(i) {
  Ft && (uo || Ft._renderControls(i.ctx));
}
function bh() {
  Ft && (Ft = void 0, this.requestRenderAll());
}
function _h() {
  uo = !0;
}
function Sh() {
  uo = !1;
}
function P0(i) {
  i.on("mouse:out", bh.bind(i)), i.on("mouse:up", vh.bind(i)), i.on("mouse:move", mh.bind(i)), i.on("after:render", yh.bind(i)), i.on("object:resizing", _h.bind(i)), i.on("object:modified", Sh.bind(i));
}
function A0(i) {
  i.off("mouse:out", bh.bind(i)), i.off("mouse:up", vh.bind(i)), i.off("mouse:move", mh.bind(i)), i.off("after:render", yh.bind(i)), i.off("object:resizing", _h.bind(i)), i.off("object:modified", Sh.bind(i));
}
const F0 = (i) => {
  at({ canvas: i }), Ay(i), Iy(i), Ry(i), Hy(i), Vy(i), o0(i), d0(i), O0(i), M0(i), D0(i), P0(i);
}, R0 = (i) => {
  at({ canvas: null }), Fy(i), Dy(i), Ly(i), Yy(i), Gy(i), a0(i), f0(i), k0(i), I0(i), j0(i), A0(i);
};
class L0 {
  removeTransitions() {
    const t = this.getObjects("Transition");
    this.remove(...t);
  }
  renderTransitions() {
    this.removeTransitions(), this.transitionIds.forEach((t) => {
      const e = this.transitionsMap[t], s = e.fromId, r = e.toId, n = this.getObjects(), o = n.find((d) => d.id === s), a = n.find((d) => d.id === r);
      if (!o || !a)
        return;
      const c = D(e.duration, this.tScale), l = o.left + o.width - c / 2, h = o.height, u = new Jt({
        id: e.id,
        left: l,
        top: o.top,
        height: h,
        width: c,
        tScale: this.tScale,
        duration: e.duration,
        fromId: o.id,
        toId: a.id,
        kind: e.kind
      });
      e.kind === "none" && (u.visible = !1), u && this.add(u);
    });
  }
  updateTrackTransitionsItemCoords() {
    this.pauseEventListeners(), this.getObjects("Transition").forEach((e) => {
      e.tScale = this.tScale, e.updateCoords(), e.setCoords();
    }), this.resumeEventListeners();
  }
  alignTransitionsToTrack(t = !0) {
    const e = t ? [] : this.getActiveObjects().map((s) => s.id);
    this.transitionIds.forEach((s) => {
      const r = this.getObjects("Transition").find(
        (n) => n.id === s
      );
      if (r instanceof Jt) {
        const n = this.getObjects().find(
          (c) => c.id === r.fromId && !e.includes(c.id)
        );
        if (!n) return;
        const o = D(r.duration, this.tScale), a = n.left + n.width - o / 2;
        r.set({
          left: a,
          top: n.top
        }), r.setCoords();
      }
    });
  }
  updateTransitions(t = !0) {
    t && this.pauseEventListeners();
    const e = this.getObjects("Track"), s = this.getObjects("Video", "Image");
    this.removeTransitions();
    const r = {}, n = [];
    e.forEach((a) => {
      const c = s.filter((l) => a.items.includes(l.id)).sort((l, h) => l.left - h.left);
      for (let l = 0; l < c.length - 1; l++) {
        const h = c[l], u = c[l + 1];
        if (Math.abs(h.left + h.width - u.left) <= 1) {
          const d = `${h.id}-${u.id}`;
          if (this.transitionIds.includes(d)) {
            const g = this.transitionsMap[d];
            r[d] = g;
          } else {
            const g = {
              id: d,
              duration: 1500,
              fromId: h.id,
              toId: u.id,
              kind: "none",
              trackId: a.id,
              type: "transition"
            };
            r[d] = g;
          }
          n.push(d);
        }
      }
    }), this.transitionIds = n, this.transitionsMap = r, this.renderTransitions();
    const o = this.getObjects("Transition");
    this.updateCachingActiveObjects(o), this.transitionGroups = xs({
      trackItemIds: this.trackItemIds,
      transitionsMap: this.transitionsMap,
      trackItemsMap: this.trackItemsMap
    }), t && this.resumeEventListeners();
  }
}
function Th(i) {
  const { secondaryTracks: t, primaryTracks: e, primaryPositions: s } = i, { positions: r, trackIndex: n } = s, o = n === -1 ? this.tracks.length : n, [a] = Object.keys(e), c = this.tracks.find(
    (p) => p.id === a
  ), l = e[a], h = {
    id: Ws(),
    items: l.objects.map((p) => p.id),
    type: c.type,
    accepts: c.accepts
  }, u = co(
    Object.keys(t).map((p) => t[p].objects.map((m) => m.id))
  );
  let d = rr(this.tracks, [
    ...Object.keys(r),
    ...u
  ]);
  const f = [];
  Object.keys(t).forEach((p) => {
    const { objects: m, index: b } = t[p], S = this.tracks.find(
      (O) => O.id === p
    ), w = m.map((O) => O.id).filter((O) => !this.transitionIds.includes(O)), k = {
      id: gr(),
      items: w,
      type: S.type,
      accepts: S.accepts,
      tempIndex: b
    };
    f.push(k);
  });
  const g = ql(h, f);
  g.length && d.splice(o, 0, ...g), this.tracks = d, this.renderTracks(), this.refreshTrackLayout(), this.alignItemsToTrack(), this.uodateTrackItemIdsOrdering(), this.refreshTrackItemsForTransitions(), this.adjustMagneticTrack(), this.updateTransitions(!0), this.updateState({ updateHistory: !0, kind: "update" });
}
function xh(i) {
  const {
    isSecondaryOverlapped: t,
    secondaryTracks: e,
    primaryTracks: s,
    primaryPositions: r
  } = i, { trackId: n, positions: o } = r, a = this.tracks.find((b) => b.id === n), h = Q().primaryMovingObjects.sort((b, S) => b.left - S.left);
  h.forEach((b, S) => {
    h[S - 1] && b.left - h[S - 1].left;
  });
  const u = this.tracks.findIndex((b) => b.id === n), d = co(
    Object.keys(e).map((b) => e[b].objects.map((S) => S.id))
  );
  let f = rr(this.tracks, [
    ...Object.keys(o),
    ...d
  ]);
  Object.keys(s).forEach((b) => {
    this.pauseEventListeners();
    const { objects: S } = s[b];
    S.forEach((O) => {
      if (O.isMain && (a != null && a.magnetic)) return;
      const x = o[O.id];
      O.left = x == null ? void 0 : x.left;
    }), this.resumeEventListeners();
    const w = r.trackId, k = f.find((O) => O.id === w);
    k == null || k.items.push(...Object.keys(o)), this.tracks = f;
  });
  const g = this.tracks[u], p = [];
  Object.keys(e).forEach((b) => {
    const { objects: S, index: w } = e[b], k = S.filter((I) => I.type !== "transition").map((I) => I.id), [O] = k, x = this.trackItemsMap[O];
    if (t && x) {
      const I = {
        id: gr(),
        items: k,
        type: x.type,
        accepts: this.acceptsMap[x.type],
        tempIndex: w
      };
      p.push(I);
    } else {
      const I = f[u + w];
      I == null || I.items.push(...k), this.tracks = f;
    }
  });
  const m = ql(g, p);
  m.length && f.splice(u, 1, ...m), this.tracks = f, this.renderTracks(), this.alignItemsToTrack(), this.uodateTrackItemIdsOrdering(), this.refreshTrackItemsForTransitions(), this.adjustMagneticTrack(), this.updateTransitions(!0), this.updateState({ updateHistory: !0, kind: "update" });
}
function wh({
  trackItemIds: i,
  isOverlapped: t
}) {
  const [e] = i;
  if (!e) return;
  if (!this.getObjects("Transition").find(
    (r) => r.id === e
  )) {
    const r = this.tracks.find(
      (n) => n.items.includes(e)
    );
    if (t) {
      const n = rr(this.tracks, i), o = {
        id: gr(),
        items: [e],
        type: r.type,
        accepts: r.accepts
      }, a = this.tracks.findIndex(
        (c) => c.id === r.id
      );
      n.splice(a, 0, o), this.tracks = n;
    }
  }
  this.renderTracks(), this.alignItemsToTrack(), this.refreshTrackItemsForTransitions(), this.adjustMagneticTrack(), this.updateTransitions(!0), this.uodateTrackItemIdsOrdering(), this.updateState({ updateHistory: !0, kind: "update" });
}
let Dn = { x: 0, y: 0 };
function B0(i) {
  Dn = i.scenePoint;
}
function Ch(i) {
  const t = i.scenePoint;
  if ((Dn.x === t.x || Dn.y === t.y) && !i.target) {
    const s = this.getElement().getBoundingClientRect(), r = this.viewportTransform, n = i.e.clientX - s.left - r[4], o = Y(n, this.scale.zoom);
    ie(m0, { payload: { time: o } });
  }
}
const W0 = (i) => {
  i.on("track:create", Th.bind(i)), i.on("track-items:resized", wh.bind(i)), i.on("track-items:moved", xh.bind(i)), i.on("mouse:up", Ch.bind(i)), i.on("mouse:down", B0.bind(i));
};
function X0(i) {
  i.off("track:create", Th.bind(i)), i.off("track-items:resized", wh.bind(i)), i.off("track-items:moved", xh.bind(i)), i.off("mouse:up", Ch.bind(i));
}
function z0(i, t) {
  return t.forEach((e) => {
    Object.getOwnPropertyNames(e.prototype).forEach((s) => {
      s !== "constructor" && Object.defineProperty(
        i.prototype,
        s,
        Object.getOwnPropertyDescriptor(e.prototype, s) || /* @__PURE__ */ Object.create(null)
      );
    });
  }), i;
}
const H0 = {
  video: ["*"],
  image: ["*"],
  audio: ["*"],
  text: ["*"],
  caption: ["*"],
  template: ["*"],
  composition: ["*"],
  illustration: ["*"],
  shape: ["*"]
}, Y0 = {
  video: 42,
  image: 42,
  audio: 42,
  text: 42,
  caption: 42,
  template: 42,
  illustration: 42,
  composition: 42,
  shape: 42
}, V0 = [
  "video",
  "image",
  "audio",
  "text",
  "caption",
  "template",
  "illustration",
  "composition"
], G0 = (i = {}) => {
  const t = Object.assign({}, H0, i), e = {};
  return Object.keys(t).forEach((s) => {
    const r = t[s];
    e[s] = r.includes("*") ? V0 : r;
  }), e;
}, N0 = (i = {}) => {
  const t = Object.assign({}, Y0, i), e = {};
  return i ? (Object.keys(t).forEach((s) => {
    const r = t[s];
    e[s] = r;
  }), e) : t;
};
let Oh, kh, Mh, Ih, Dh, jh, Eh, Ph;
const U0 = (i) => {
  Oh = i.state.subscribeToActiveIds(
    ({ activeIds: t }) => {
      const e = i.activeIds;
      if (t.length === 1 && e.length === 1) {
        const s = t[0], r = e[0], o = i.state.getState().structure;
        let a = "";
        if (o.forEach((c) => {
          c.id === r && c.items.includes(s) && (a = c.id);
        }), a !== "") return;
        i.selectTrackItemByIds([s]);
      } else
        i.selectTrackItemByIds(t);
    }
  ), Ph = i.state.subscribeToTracks(
    ({ tracks: t, changedTracks: e }) => {
      e.length && (i.tracks = t, i.renderTracks(), i.refreshTrackLayout());
    }
  ), Eh = i.state.subscribeToUpdateAnimations(
    ({ trackItemsMap: t, changedAnimationIds: e }) => {
      if (e != null && e.length) {
        const s = i.getTrackItems();
        i.trackItemsMap = t, s.forEach((r) => {
          if (e.includes(r.id)) {
            const n = t[r.id].animations;
            n && r.set({
              animations: n
            });
          }
        });
      }
    }
  ), jh = i.state.subscribeToUpdateTrackItemTiming(
    ({ trackItemsMap: t, changedTrimIds: e, changedDisplayIds: s }) => {
      if (e && i.getTrackItems().forEach((n) => {
        if (e.includes(n.id)) {
          const o = t[n.id].trim;
          o && n.set({
            trim: {
              from: o.from,
              to: o.to
            }
          });
        }
      }), s) {
        const r = i.getTrackItems();
        i.pauseEventListeners(), r.forEach((n) => {
          if (s.includes(n.id)) {
            const o = t[n.id].display;
            o && n.set({
              display: o
            });
          }
        }), i.resumeEventListeners();
      }
      i.requestRenderAll();
    }
  ), Dh = i.state.subscribeToScale((t) => {
    i.setScale(t.scale);
  }), Ih = i.state.subscribeToUpdateItemDetails((t) => {
    const e = i.getTrackItems();
    if (e.length === 0) return;
    const s = i.state.getState(), r = t.trackItemDetailsMap, n = s.trackItemsMap;
    e.forEach((o) => {
      const a = r[o.id];
      if (a)
        if (o instanceof _t || o instanceof Qs || o instanceof ft) {
          if (a.type === "video" || a.type === "image" || a.type === "audio") {
            const c = n[o.id];
            if (o.src !== a.details.src && o.setSrc && o.setSrc(a.details.src), a.type === "video" || a.type === "audio") {
              const h = c.display.to - c.display.from, u = D(
                h,
                i.scale.zoom,
                c.playbackRate
              );
              o.set({
                duration: c.duration,
                display: c.display,
                trim: c.trim,
                width: u
              }), o.setCoords();
            }
          }
        } else (o instanceof tr || o instanceof sr) && (a.type === "text" || a.type === "caption") && o.set({ text: a.details.text });
    }), i.requestRenderAll();
  }), Mh = i.state.subscribeToHistory((t) => {
    i.tracks = t.tracks, i.trackItemsMap = t.trackItemsMap, i.trackItemIds = t.trackItemIds, i.trackItemDetailsMap = t.trackItemDetailsMap, i.transitionIds = t.transitionIds, i.transitionsMap = t.transitionsMap, i.transitionGroups = xs({
      trackItemIds: i.trackItemIds,
      transitionsMap: i.transitionsMap,
      trackItemsMap: i.trackItemsMap
    }), i.renderTracks(), i.refreshTrackLayout(), i.updateTrackItemCoords(), i.alignItemsToTrack(), i.alignTransitionsToTrack(), i.adjustMagneticTrack(), i.updateTransitions(), i.calcBounding(), i.duration = pl(i.trackItemsMap);
  }), kh = i.state.subscribeToAddOrRemoveItems(() => {
    const t = i.getTrackItems().map((n) => n.id), e = i.state.getState(), s = e.trackItemIds, r = [];
    t.forEach((n) => {
      s.includes(n) || r.push(n);
    }), i.deleteTrackItemById(r), i.tracks = e.tracks, i.trackItemsMap = e.trackItemsMap, i.trackItemDetailsMap = e.trackItemDetailsMap, i.transitionIds = e.transitionIds, i.transitionsMap = e.transitionsMap, s.forEach((n) => {
      if (!t.includes(n)) {
        const a = {
          ...e.trackItemsMap[n],
          details: {
            ...e.trackItemDetailsMap[n].details
          }
        };
        i.addTrackItem(a);
      }
    }), i.trackItemIds = e.trackItemIds, i.activeIds = e.activeIds, i.transitionGroups = xs({
      trackItemIds: i.trackItemIds,
      transitionsMap: i.transitionsMap,
      trackItemsMap: i.trackItemsMap
    }), i.renderTracks(), i.alignItemsToTrack(), i.updateTrackItemCoords(), i.calcBounding(), i.updateTransitions(), i.refreshTrackLayout(), i.selectTrackItemByIds(e.activeIds);
  });
}, $0 = (i) => {
  Oh.unsubscribe(), kh.unsubscribe(), Mh.unsubscribe(), Ih.unsubscribe(), Dh.unsubscribe(), jh.unsubscribe(), Eh.unsubscribe(), Ph.unsubscribe();
}, Aa = (i, t) => {
  let e = !1;
  const s = [];
  return t.forEach((r) => {
    r.containsPoint(i) && (s.push(r), e = !0);
  }), { isOverObject: e, overObjects: s };
};
function q0(i) {
  return JSON.parse(JSON.stringify(i));
}
class K0 extends vn {
  constructor(e, s) {
    var r;
    super(e, s);
    T(this, "acceptsMap");
    T(this, "sizesMap", {});
    // Declare properties from state
    T(this, "tracks", []);
    T(this, "hoverCornerItem", !1);
    T(this, "trackItemsMap", {});
    T(this, "trackItemIds", []);
    T(this, "transitionIds", []);
    T(this, "transitionsMap", {});
    T(this, "trackItemDetailsMap", {});
    T(this, "scale");
    T(this, "duration");
    T(this, "bounding");
    T(this, "onScroll");
    T(this, "onResizeCanvas");
    T(this, "tScale");
    T(this, "state");
    T(this, "activeIds", []);
    T(this, "spacing");
    T(this, "guideLineColor");
    T(this, "transitionGroups", []);
    this.bounding = s.bounding || {
      width: s.width || 0,
      height: s.height || 0
    }, this.tScale = ((r = s.scale) == null ? void 0 : r.zoom) || 1, this.state = s.state, this.onScroll = s.onScroll, this.onResizeCanvas = s.onResizeCanvas, this.acceptsMap = G0(s.acceptsMap), this.sizesMap = N0(s.sizesMap), this.spacing = Wy(s.spacing), this.positionAfterTransform = {}, this.initializeCanvasDefaults(), this.scale = s.scale, this.duration = s.duration, this.guideLineColor = s.guideLineColor || vt, this.initEventListeners();
  }
  static registerItems(e) {
    Object.keys(e).forEach((s) => {
      C.setClass(e[s], s);
    });
  }
  initializeCanvasDefaults() {
    const e = this.viewportTransform;
    e[4] = this.spacing.left, Object.assign(nt.ownDefaults, {
      borderColor: "transparent",
      cornerColor: "white",
      cornerStrokeColor: "transparent",
      strokeWidth: 0,
      borderOpacityWhenMoving: 1,
      borderScaleFactor: 1,
      cornerSize: 8,
      cornerStyle: "rect",
      centeredScaling: !1,
      centeredRotation: !0,
      transparentCorners: !1
    });
  }
  // detect if the mouse click does not land on any item -> clean the selection and generate another selection
  __onMouseDown(e) {
    const s = this.getScenePoint(e), r = this._activeObject, n = this.getActiveObjects();
    if (n.length === 0) {
      super.__onMouseDown(e);
      return;
    }
    const { isOverObject: o } = Aa(
      s,
      n
    );
    if (r && (r == null ? void 0 : r.findControl(
      this.getViewportPoint(e),
      zy(e)
    ))) {
      super.__onMouseDown(e);
      return;
    }
    const a = this.getTrackItems(), c = this.getObjects("Transition"), { isOverObject: l, overObjects: h } = Aa(
      s,
      [...c, ...a]
    );
    l ? o ? super.__onMouseDown(e) : (this.setActiveIds([h[0].id]), super.__onMouseDown(e)) : (this.discardActiveObject(), this.requestRenderAll(), this.setActiveIds([]), this._groupSelector = {
      x: s.x,
      y: s.y,
      deltaY: 0,
      deltaX: 0
    }, super.__onMouseDown(e));
  }
  _setupCurrentTransform(e, s, r) {
    var n;
    if (this.hoverCornerItem) {
      const o = this.getScenePoint(e), { key: a = "", control: c } = s.getActiveControl() || {}, l = c && ((n = c.getActionHandler(e, s, c)) == null ? void 0 : n.bind(c)), h = this._getOriginFromCorner(s, a), u = {
        target: s,
        action: "resizing",
        actionHandler: l,
        actionPerformed: !1,
        corner: a,
        scaleX: s.scaleX,
        scaleY: s.scaleY,
        skewX: s.skewX,
        skewY: s.skewY,
        offsetX: o.x - s.left,
        offsetY: o.y - s.top,
        originX: h.x,
        originY: h.y,
        ex: o.x,
        ey: o.y,
        lastX: o.x,
        lastY: o.y,
        theta: s.angle * Math.PI / 180,
        width: s.width,
        height: s.height,
        shiftKey: e.shiftKey,
        altKey: !1,
        original: {
          scaleX: s.scaleX,
          scaleY: s.scaleY,
          skewX: s.skewX,
          skewY: s.skewY,
          angle: s.angle,
          left: s.left,
          flipX: s.flipX,
          flipY: s.flipY,
          top: s.top,
          originX: h.x,
          originY: h.y
        }
      };
      this._currentTransform = u, this.fire("before:transform", {
        e,
        transform: u
      });
    } else
      super._setupCurrentTransform(e, s, r);
  }
  initEventListeners() {
    W0(this), F0(this), U0(this);
  }
  setActiveIds(e) {
    this.activeIds = e, this.state.updateState(
      {
        activeIds: q0(this.activeIds)
      },
      {
        kind: "layer:selection",
        updateHistory: !1
      }
    );
  }
  updateState(e = { updateHistory: !1 }) {
    this.filterEmptyTracks(), this.synchronizeTrackItemsState(), this.requestRenderAll(), this.duration = this.getDurationBasedOnTrackItemsPosition(), this.calcBounding(), this.refreshTrackLayout(), this.setTrackItemCoords();
    const s = this.getUpdatedState();
    this.state.updateState(s, e);
  }
  getUpdatedState() {
    const e = this.getDurationBasedOnTrackItemsPosition();
    return {
      tracks: this.tracks,
      trackItemIds: this.trackItemIds,
      trackItemsMap: this.trackItemsMap,
      transitionIds: this.transitionIds,
      transitionsMap: this.transitionsMap,
      scale: this.scale,
      duration: e
    };
  }
  getDurationBasedOnTrackItemsPosition() {
    const e = this.getTrackItems().map((n) => n.getBoundingRect()), s = e.reduce((n, o) => n.left + n.width < o.left + o.width ? o : n, e[0]), r = s.left + s.width;
    return Y(r, this.tScale);
  }
  notify(e = { updateHistory: !1 }) {
    const s = this.getUpdatedState();
    this.state.updateState(s, e);
  }
  getState() {
    const e = pl(this.trackItemsMap);
    return {
      tracks: this.tracks,
      trackItemIds: this.trackItemIds,
      trackItemsMap: this.trackItemsMap,
      transitionIds: this.transitionIds,
      transitionsMap: this.transitionsMap,
      trackItemDetailsMap: this.trackItemDetailsMap,
      scale: this.scale,
      duration: e
    };
  }
  purge() {
    R0(this), X0(this), $0(), this.dispose();
  }
  scrollTo({
    scrollLeft: e,
    scrollTop: s
  }) {
    var o;
    const r = [...this.viewportTransform];
    let n = !1;
    typeof e == "number" && (r[4] = -e + this.spacing.left, n = !0), typeof s == "number" && (r[5] = -s, n = !0), n && (this.viewportTransform = r, (o = this.getActiveObject()) == null || o.setCoords(), this.requestRenderAll());
  }
  setBounding(e) {
    this.bounding = e;
  }
  calcBounding() {
    const e = this.getObjects("Track").filter(
      (c) => c.static
    ), s = [...this.getTrackItems(), ...e].reduce(
      (c, l) => {
        const { top: h, height: u } = l.getBoundingRect();
        return {
          top: Math.min(c.top, h),
          height: Math.max(c.height, h + u)
        };
      },
      {
        top: 1 / 0,
        height: 0
      }
    ), r = [...this.getTrackItems()].reduce(
      (c, l) => {
        const { left: h, width: u } = l.getBoundingRect();
        return {
          left: Math.min(c.left, h),
          width: Math.max(c.width, h + u)
        };
      },
      {
        left: 1 / 0,
        width: this.width
      }
    ), n = this.bounding.width, o = r.width, a = o - n;
    if (a < 0) {
      const c = this.getTrackItems(), l = this.getElement().clientWidth, h = c.reduce(
        (u, d) => d.left + d.width > u.left + u.width ? d : u,
        c[0]
      );
      Math.abs(a) > l ? this.setViewportPos(
        -(o - l) - this.spacing.right,
        this.viewportTransform[5]
      ) : h.left + h.width <= l ? this.setViewportPos(16, this.viewportTransform[5]) : this.setViewportPos(
        this.viewportTransform[4] - a,
        this.viewportTransform[5]
      );
    }
    this.bounding = {
      ...s,
      ...r
    }, ie(p0, {
      payload: {
        bounding: {
          ...s,
          ...r
        }
      }
    });
  }
  setViewportPos(e, s) {
    var o;
    const r = this.getViewportPos(e, s), n = this.viewportTransform;
    n[4] = r.x, n[5] = r.y, this.requestRenderAll(), this.setActiveTrackItemCoords(), (o = this.onScroll) == null || o.call(this, {
      scrollTop: r.y,
      scrollLeft: r.x - this.spacing.left
    });
  }
  getViewportPos(e, s) {
    const r = this, n = this.bounding.width - 100 >= r.width ? this.spacing.right : 0, o = r.width - this.bounding.width - n, a = this.spacing.left, c = Math.max(o, Math.min(e, a));
    if (this.bounding.height < this.height)
      return { x: c, y: 0 };
    const l = r.height - this.bounding.height - 40, u = Math.max(l, Math.min(s, 0));
    return { x: c, y: u };
  }
  setScale(e) {
    this.pauseEventListeners(), this.tScale = e.zoom, this.scale = e, this.getObjects(
      "Video",
      "Image",
      "Text",
      "Audio",
      "Caption",
      "Template"
    ).forEach((r) => {
      const n = this.transitionGroups.find((o) => o.find((a) => a.id === r.id)) || [];
      if ((n == null ? void 0 : n.length) === 1) {
        const o = D(r.display.from, this.tScale), a = D(
          r.display.to - r.display.from,
          this.tScale,
          r.playbackRate
        );
        r.set({ left: o, width: a, tScale: e.zoom });
      } else {
        const o = n.findIndex((u) => u.id === r.id), a = n[o - 1], c = n[o + 1], l = n.filter(
          (u) => u.type === "transition"
        ), h = this.trackItemsMap[r.id];
        if (a && !c) {
          const u = l.indexOf(a), f = l.slice(
            0,
            u
          ).reduce((m, b) => m + (b.duration || 0), 0), g = D(
            h.display.from - (a.duration || 0) / 2 - f,
            this.tScale
          ), p = D(
            h.display.to - h.display.from - (a.duration || 0) / 2,
            this.tScale,
            h.playbackRate
          );
          r.set({ left: g, width: p, tScale: e.zoom });
        } else if (c && !a) {
          const u = D(h.display.from, this.tScale), d = D(
            h.display.to - h.display.from - (c.duration || 0) / 2,
            this.tScale,
            h.playbackRate
          );
          r.set({ left: u, width: d, tScale: e.zoom });
        } else if (a && c) {
          const u = D(
            h.display.from - (a.duration || 0) / 2,
            this.tScale
          ), d = D(
            h.display.to - h.display.from - (c.duration || 0) / 2 - (a.duration || 0) / 2,
            this.tScale,
            r.playbackRate
          );
          r.set({ left: u, width: d, tScale: e.zoom });
        }
      }
      r.onScale && r.onScale(), r.setCoords();
    }), this.requestRenderAll(), this.calcBounding(), this.refreshTrackLayout(), this.updateTransitions(!1), this.resumeEventListeners();
  }
}
z0(K0, [
  Cf,
  My,
  ky,
  L0
]);
const rb = {
  audio: _n,
  media: xn,
  common: Sn,
  transition: Tn
};
export {
  H0 as ACCEPTS_MAP,
  ft as Audio,
  tb as BOTTOM,
  He as CENTER,
  sr as Caption,
  U as Control,
  ih as DRAG_END,
  rh as DRAG_PREFIX,
  g0 as DRAG_START,
  nt as FabricObject,
  Ss as Helper,
  Qs as Image,
  ur as LEFT,
  eb as NONE,
  Yi as Pattern,
  er as Placeholder,
  Oe as PreviewTrackItem,
  dr as RIGHT,
  X as Rect,
  Y0 as SIZES_MAP,
  p0 as TIMELINE_BOUNDING_CHANGED,
  nh as TIMELINE_PREFIX,
  m0 as TIMELINE_SEEK,
  Q0 as TOP,
  Vt as Template,
  tr as Text,
  ue as Track,
  Jt as Transition,
  _t as Video,
  sb as calculateTimelineWidth,
  Sn as changeWidth,
  C as classRegistry,
  Ds as controlsUtils,
  pf as createAudioControls,
  mf as createMediaControls,
  js as createResizeControls,
  gf as createTemplateControls,
  ml as createTransitionControls,
  K0 as default,
  qt as drawVerticalLine,
  Ws as generateId,
  pl as getDuration,
  fr as isTransformCentered,
  rb as resize,
  P as resolveOrigin,
  D as timeMsToUnits,
  Y as unitsToTimeMs,
  sd as util,
  Mi as wrapWithFixedAnchor
};

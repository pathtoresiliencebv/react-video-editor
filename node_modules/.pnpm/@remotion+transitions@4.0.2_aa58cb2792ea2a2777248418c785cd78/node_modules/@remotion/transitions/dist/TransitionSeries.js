"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransitionSeries = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const remotion_1 = require("remotion");
const no_react_1 = require("remotion/no-react");
const context_js_1 = require("./context.js");
const flatten_children_js_1 = require("./flatten-children.js");
const slide_js_1 = require("./presentations/slide.js");
const validate_js_1 = require("./validate.js");
// eslint-disable-next-line react/function-component-definition
const TransitionSeriesTransition = function (
// eslint-disable-next-line @typescript-eslint/no-unused-vars
_props) {
    return null;
};
const SeriesSequence = ({ children }) => {
    // eslint-disable-next-line react/jsx-no-useless-fragment
    return (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: children });
};
const TransitionSeriesChildren = ({ children, }) => {
    const { fps } = (0, remotion_1.useVideoConfig)();
    const frame = (0, remotion_1.useCurrentFrame)();
    const childrenValue = (0, react_1.useMemo)(() => {
        let transitionOffsets = 0;
        let startFrame = 0;
        const flattedChildren = (0, flatten_children_js_1.flattenChildren)(children);
        return react_1.Children.map(flattedChildren, (child, i) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            const current = child;
            if (typeof current === 'string') {
                // Don't throw if it's just some accidential whitespace
                if (current.trim() === '') {
                    return null;
                }
                throw new TypeError(`The <TransitionSeries /> component only accepts a list of <TransitionSeries.Sequence /> components as its children, but you passed a string "${current}"`);
            }
            const hasPrev = flattedChildren[i - 1];
            const nextPrev = flattedChildren[i + 1];
            const prev = typeof hasPrev === 'string' || typeof hasPrev === 'undefined'
                ? null
                : hasPrev.type === TransitionSeriesTransition
                    ? hasPrev
                    : null;
            const next = typeof nextPrev === 'string' || typeof nextPrev === 'undefined'
                ? null
                : nextPrev.type === TransitionSeriesTransition
                    ? nextPrev
                    : null;
            const prevIsTransition = typeof hasPrev === 'string' || typeof hasPrev === 'undefined'
                ? false
                : hasPrev.type === TransitionSeriesTransition;
            if (current.type === TransitionSeriesTransition) {
                if (prevIsTransition) {
                    throw new TypeError(`A <TransitionSeries.Transition /> component must not be followed by another <TransitionSeries.Transition /> component (nth children = ${i - 1} and ${i})`);
                }
                return null;
            }
            if (current.type !== SeriesSequence) {
                throw new TypeError(`The <TransitionSeries /> component only accepts a list of <TransitionSeries.Sequence /> and <TransitionSeries.Transition /> components as its children, but got ${current} instead`);
            }
            const castedChildAgain = current;
            const debugInfo = `index = ${i}, duration = ${castedChildAgain.props.durationInFrames}`;
            if (!(castedChildAgain === null || castedChildAgain === void 0 ? void 0 : castedChildAgain.props.children)) {
                throw new TypeError(`A <TransitionSeries.Sequence /> component (${debugInfo}) was detected to not have any children. Delete it to fix this error.`);
            }
            const durationInFramesProp = castedChildAgain.props.durationInFrames;
            const { durationInFrames, children: _children, ...passedProps } = castedChildAgain.props;
            (0, validate_js_1.validateDurationInFrames)(durationInFramesProp, {
                component: `of a <TransitionSeries.Sequence /> component`,
                allowFloats: true,
            });
            const offset = (_a = castedChildAgain.props.offset) !== null && _a !== void 0 ? _a : 0;
            if (Number.isNaN(offset)) {
                throw new TypeError(`The "offset" property of a <TransitionSeries.Sequence /> must not be NaN, but got NaN (${debugInfo}).`);
            }
            if (!Number.isFinite(offset)) {
                throw new TypeError(`The "offset" property of a <TransitionSeries.Sequence /> must be finite, but got ${offset} (${debugInfo}).`);
            }
            if (offset % 1 !== 0) {
                throw new TypeError(`The "offset" property of a <TransitionSeries.Sequence /> must be finite, but got ${offset} (${debugInfo}).`);
            }
            const currentStartFrame = startFrame + offset;
            let duration = 0;
            if (prev) {
                duration = prev.props.timing.getDurationInFrames({
                    fps,
                });
                transitionOffsets -= duration;
            }
            let actualStartFrame = currentStartFrame + transitionOffsets;
            startFrame += durationInFramesProp + offset;
            // Handle the case where the first item is a transition
            if (actualStartFrame < 0) {
                startFrame -= actualStartFrame;
                actualStartFrame = 0;
            }
            const nextProgress = next
                ? next.props.timing.getProgress({
                    frame: frame -
                        actualStartFrame -
                        durationInFrames +
                        next.props.timing.getDurationInFrames({ fps }),
                    fps,
                })
                : null;
            const prevProgress = prev
                ? prev.props.timing.getProgress({
                    frame: frame - actualStartFrame,
                    fps,
                })
                : null;
            if (next &&
                durationInFramesProp < next.props.timing.getDurationInFrames({ fps })) {
                throw new Error(`The duration of a <TransitionSeries.Sequence /> must not be shorter than the duration of the next <TransitionSeries.Transition />. The transition is ${next.props.timing.getDurationInFrames({ fps })} frames long, but the sequence is only ${durationInFramesProp} frames long (${debugInfo})`);
            }
            if (prev &&
                durationInFramesProp < prev.props.timing.getDurationInFrames({ fps })) {
                throw new Error(`The duration of a <TransitionSeries.Sequence /> must not be shorter than the duration of the previous <TransitionSeries.Transition />. The transition is ${prev.props.timing.getDurationInFrames({ fps })} frames long, but the sequence is only ${durationInFramesProp} frames long (${debugInfo})`);
            }
            if (next && prev && nextProgress !== null && prevProgress !== null) {
                const nextPresentation = (_b = next.props.presentation) !== null && _b !== void 0 ? _b : (0, slide_js_1.slide)();
                const prevPresentation = (_c = prev.props.presentation) !== null && _c !== void 0 ? _c : (0, slide_js_1.slide)();
                const UppercaseNextPresentation = nextPresentation.component;
                const UppercasePrevPresentation = prevPresentation.component;
                return ((0, jsx_runtime_1.jsx)(remotion_1.Sequence
                // eslint-disable-next-line react/no-array-index-key
                , { from: Math.floor(actualStartFrame), durationInFrames: durationInFramesProp, ...passedProps, name: passedProps.name || '<TS.Sequence>', children: (0, jsx_runtime_1.jsx)(UppercaseNextPresentation, { passedProps: (_d = nextPresentation.props) !== null && _d !== void 0 ? _d : {}, presentationDirection: "exiting", presentationProgress: nextProgress, presentationDurationInFrames: next.props.timing.getDurationInFrames({ fps }), children: (0, jsx_runtime_1.jsx)(context_js_1.WrapInExitingProgressContext, { presentationProgress: nextProgress, children: (0, jsx_runtime_1.jsx)(UppercasePrevPresentation, { passedProps: (_e = prevPresentation.props) !== null && _e !== void 0 ? _e : {}, presentationDirection: "entering", presentationProgress: prevProgress, presentationDurationInFrames: prev.props.timing.getDurationInFrames({ fps }), children: (0, jsx_runtime_1.jsx)(context_js_1.WrapInEnteringProgressContext, { presentationProgress: prevProgress, children: child }) }) }) }) }, i));
            }
            if (prevProgress !== null && prev) {
                const prevPresentation = (_f = prev.props.presentation) !== null && _f !== void 0 ? _f : (0, slide_js_1.slide)();
                const UppercasePrevPresentation = prevPresentation.component;
                return ((0, jsx_runtime_1.jsx)(remotion_1.Sequence
                // eslint-disable-next-line react/no-array-index-key
                , { from: Math.floor(actualStartFrame), durationInFrames: durationInFramesProp, ...passedProps, name: passedProps.name || '<TS.Sequence>', children: (0, jsx_runtime_1.jsx)(UppercasePrevPresentation, { passedProps: (_g = prevPresentation.props) !== null && _g !== void 0 ? _g : {}, presentationDirection: "entering", presentationProgress: prevProgress, presentationDurationInFrames: prev.props.timing.getDurationInFrames({ fps }), children: (0, jsx_runtime_1.jsx)(context_js_1.WrapInEnteringProgressContext, { presentationProgress: prevProgress, children: child }) }) }, i));
            }
            if (nextProgress !== null && next) {
                const nextPresentation = (_h = next.props.presentation) !== null && _h !== void 0 ? _h : (0, slide_js_1.slide)();
                const UppercaseNextPresentation = nextPresentation.component;
                return ((0, jsx_runtime_1.jsx)(remotion_1.Sequence
                // eslint-disable-next-line react/no-array-index-key
                , { from: Math.floor(actualStartFrame), durationInFrames: durationInFramesProp, ...passedProps, name: passedProps.name || '<TS.Sequence>', children: (0, jsx_runtime_1.jsx)(UppercaseNextPresentation, { passedProps: (_j = nextPresentation.props) !== null && _j !== void 0 ? _j : {}, presentationDirection: "exiting", presentationProgress: nextProgress, presentationDurationInFrames: next.props.timing.getDurationInFrames({ fps }), children: (0, jsx_runtime_1.jsx)(context_js_1.WrapInExitingProgressContext, { presentationProgress: nextProgress, children: child }) }) }, i));
            }
            return ((0, jsx_runtime_1.jsx)(remotion_1.Sequence
            // eslint-disable-next-line react/no-array-index-key
            , { from: Math.floor(actualStartFrame), durationInFrames: durationInFramesProp, ...passedProps, name: passedProps.name || '<TS.Sequence>', children: child }, i));
        });
    }, [children, fps, frame]);
    // eslint-disable-next-line react/jsx-no-useless-fragment
    return (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: childrenValue });
};
/**
 * @description A React component designed to manage a series of transitions and sequences where each transition may have specific timing and presentation components. It extends the capabilities of `<Sequence>` and is specifically structured to handle transitions that involve entering and exiting sequences.
 * @see [Documentation](https://remotion.dev/docs/transitions/transitionseries)
 * @param {SequencePropsWithoutDuration} props The properties for setting the initial rendering behavior like from, name, etc. It additionally accepts children that are specifically `<TransitionSeries.Sequence>` or `<TransitionSeries.Transition>`.
 * @returns React component that renders the transitions and sequences.
 */
const TransitionSeries = ({ children, name, layout: passedLayout, ...otherProps }) => {
    const displayName = name !== null && name !== void 0 ? name : '<TransitionSeries>';
    const layout = passedLayout !== null && passedLayout !== void 0 ? passedLayout : 'absolute-fill';
    if (no_react_1.NoReactInternals.ENABLE_V5_BREAKING_CHANGES &&
        layout !== 'absolute-fill') {
        throw new TypeError(`The "layout" prop of <TransitionSeries /> is not supported anymore in v5. TransitionSeries' must be absolutely positioned.`);
    }
    return ((0, jsx_runtime_1.jsx)(remotion_1.Sequence, { name: displayName, layout: layout, ...otherProps, children: (0, jsx_runtime_1.jsx)(TransitionSeriesChildren, { children: children }) }));
};
exports.TransitionSeries = TransitionSeries;
TransitionSeries.Sequence = SeriesSequence;
TransitionSeries.Transition = TransitionSeriesTransition;
remotion_1.Internals.addSequenceStackTraces(TransitionSeries);
remotion_1.Internals.addSequenceStackTraces(SeriesSequence);

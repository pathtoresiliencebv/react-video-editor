{"version":3,"file":"opfs-tools.js","sources":["../src/access-worker.ts","../src/common.ts","../src/directory.ts","../src/file.ts","../src/tmpfile.ts","../src/rollfile.ts"],"sourcesContent":["import { FileSystemSyncAccessHandle } from './common';\nimport OPFSWorker from './opfs-worker?worker&inline';\n\nexport type OPFSWorkerAccessHandle = {\n  read: (offset: number, size: number) => Promise<ArrayBuffer>;\n  write: FileSystemSyncAccessHandle['write'];\n  close: FileSystemSyncAccessHandle['close'];\n  truncate: FileSystemSyncAccessHandle['truncate'];\n  getSize: FileSystemSyncAccessHandle['getSize'];\n  flush: FileSystemSyncAccessHandle['flush'];\n};\n\nexport type OpenMode = 'read-only' | 'readwrite' | 'readwrite-unsafe';\n\nexport async function createOPFSAccess(\n  fileId: number,\n  filePath: string,\n  mode: OpenMode\n): Promise<OPFSWorkerAccessHandle> {\n  const postMsg = getWorkerMsger();\n  await postMsg('register', { fileId, filePath, mode });\n  return {\n    read: async (offset, size) =>\n      (await postMsg('read', {\n        fileId,\n        offset,\n        size,\n      })) as ArrayBuffer,\n    write: async (data, opts) =>\n      (await postMsg(\n        'write',\n        {\n          fileId,\n          data,\n          opts,\n        },\n        [ArrayBuffer.isView(data) ? data.buffer : data]\n      )) as number,\n    close: async () =>\n      (await postMsg('close', {\n        fileId,\n      })) as void,\n    truncate: async (newSize: number) =>\n      (await postMsg('truncate', {\n        fileId,\n        newSize,\n      })) as void,\n    getSize: async () =>\n      (await postMsg('getSize', {\n        fileId,\n      })) as number,\n    flush: async () =>\n      (await postMsg('flush', {\n        fileId,\n      })) as void,\n  };\n}\n\nconst msgerCache: Array<Function> = [];\nlet nextMsgerIdx = 0;\nfunction getWorkerMsger() {\n  // Create a maximum of three workers\n  if (msgerCache.length < 3) {\n    const msger = create();\n    msgerCache.push(msger);\n    return msger;\n  } else {\n    const msger = msgerCache[nextMsgerIdx];\n    nextMsgerIdx = (nextMsgerIdx + 1) % msgerCache.length;\n    return msger;\n  }\n\n  function create() {\n    const worker = new OPFSWorker();\n\n    let cbId = 0;\n    let cbFns: Record<number, { resolve: Function; reject: Function }> = {};\n\n    worker.onmessage = ({\n      data,\n    }: {\n      data: {\n        cbId: number;\n        returnVal?: unknown;\n        evtType: string;\n        errMsg: string;\n      };\n    }) => {\n      if (data.evtType === 'callback') {\n        cbFns[data.cbId]?.resolve(data.returnVal);\n      } else if (data.evtType === 'throwError') {\n        cbFns[data.cbId]?.reject(Error(data.errMsg));\n      }\n      delete cbFns[data.cbId];\n    };\n\n    return async function postMsg(\n      evtType: string,\n      args: unknown,\n      trans: Transferable[] = []\n    ) {\n      cbId += 1;\n\n      const rsP = new Promise((resolve, reject) => {\n        cbFns[cbId] = { resolve, reject };\n      });\n      worker.postMessage(\n        {\n          cbId,\n          evtType,\n          args,\n        },\n        trans\n      );\n\n      return rsP;\n    };\n  }\n}\n","export interface FileSystemSyncAccessHandle {\n  read: (container: ArrayBuffer, opts: { at: number }) => Promise<number>;\n  write: (\n    data: ArrayBuffer | ArrayBufferView,\n    opts?: { at: number }\n  ) => Promise<number>;\n  flush: () => Promise<void>;\n  close: () => Promise<void>;\n  truncate: (newSize: number) => Promise<void>;\n  getSize: () => Promise<number>;\n}\n\nexport function parsePath(path: string) {\n  if (path === '/') return { parent: null, name: '' };\n\n  const pathArr = path.split('/').filter((s) => s.length > 0);\n  if (pathArr.length === 0) throw Error('Invalid path');\n\n  const name = pathArr[pathArr.length - 1];\n\n  const parent = '/' + pathArr.slice(0, -1).join('/');\n\n  return { name, parent };\n}\n\nexport async function getFSHandle<\n  ISFile extends boolean,\n  ISCreate extends boolean,\n  T = ISFile extends true ? FileSystemFileHandle : FileSystemDirectoryHandle,\n  RT = ISCreate extends true ? T : T | null\n>(\n  path: string,\n  opts: {\n    create?: ISCreate;\n    isFile?: ISFile;\n  }\n): Promise<RT> {\n  const { parent, name } = parsePath(path);\n\n  if (parent == null) return (await navigator.storage.getDirectory()) as RT;\n\n  const dirPaths = parent.split('/').filter((s) => s.length > 0);\n\n  try {\n    let dirHandle = await navigator.storage.getDirectory();\n    for (const p of dirPaths) {\n      dirHandle = await dirHandle.getDirectoryHandle(p, {\n        create: opts.create,\n      });\n    }\n    if (opts.isFile) {\n      return (await dirHandle.getFileHandle(name, {\n        create: opts.create,\n      })) as RT;\n    } else {\n      return (await dirHandle.getDirectoryHandle(name, {\n        create: opts.create,\n      })) as RT;\n    }\n  } catch (err) {\n    if ((err as Error).name === 'NotFoundError') {\n      return null as RT;\n    }\n    throw err;\n  }\n}\n\nexport async function remove(path: string) {\n  const { parent, name } = parsePath(path);\n  if (parent == null) {\n    const root = await navigator.storage.getDirectory();\n    for await (const it of root.keys()) {\n      await root.removeEntry(it, { recursive: true });\n    }\n    return;\n  }\n\n  const dirHandle = (await getFSHandle(parent, {\n    create: false,\n    isFile: false,\n  })) as FileSystemDirectoryHandle | null;\n  if (dirHandle == null) return;\n\n  await dirHandle.removeEntry(name, { recursive: true });\n}\n\nexport function joinPath(p1: string, p2: string) {\n  return `${p1}/${p2}`.replace('//', '/');\n}\n","import { getFSHandle, joinPath, parsePath, remove } from './common';\nimport { file, OPFSFileWrap } from './file';\n\ndeclare global {\n  interface FileSystemDirectoryHandle {\n    keys: () => AsyncIterable<string>;\n    values: () => AsyncIterable<\n      FileSystemDirectoryHandle | FileSystemFileHandle\n    >;\n  }\n}\n\n/**\n * Represents a directory with utility functions.\n * @param {string} dirPath - The path of the directory.\n * @returns  An object with directory utility functions.\n * \n * @example\n  // Create a directory\n  await dir('/path/to/directory').create();\n\n  // Check if the directory exists\n  const exists = await dir('/path/to/directory').exists();\n\n  // Remove the directory\n\n  // Retrieve children of the directory\n  const children = await dir('/path/to/parent_directory').children();\n */\nexport function dir(dirPath: string) {\n  return new OPFSDirWrap(dirPath);\n}\n\nexport class OPFSDirWrap {\n  get kind(): 'dir' {\n    return 'dir';\n  }\n\n  get name() {\n    return this.#name;\n  }\n\n  get path() {\n    return this.#path;\n  }\n\n  get parent(): OPFSDirWrap | null {\n    return this.#parentPath == null ? null : dir(this.#parentPath);\n  }\n\n  #path: string;\n  #name: string;\n  #parentPath: string | null;\n\n  constructor(dirPath: string) {\n    this.#path = dirPath;\n    const { parent, name } = parsePath(dirPath);\n    this.#name = name;\n    this.#parentPath = parent;\n  }\n\n  /**\n   * Creates the directory.\n   * return A promise that resolves when the directory is created.\n   */\n  async create() {\n    await getFSHandle(this.#path, {\n      create: true,\n      isFile: false,\n    });\n    return dir(this.#path);\n  }\n\n  /**\n   * Checks if the directory exists.\n   * return A promise that resolves to true if the directory exists, otherwise false.\n   */\n  async exists() {\n    return (\n      (await getFSHandle(this.#path, {\n        create: false,\n        isFile: false,\n      })) instanceof FileSystemDirectoryHandle\n    );\n  }\n\n  /**\n   * Removes the directory.\n   * return A promise that resolves when the directory is removed.\n   */\n  async remove() {\n    for (const it of await this.children()) {\n      try {\n        await it.remove();\n      } catch (err) {\n        console.warn(err);\n      }\n    }\n    try {\n      await remove(this.#path);\n    } catch (err) {\n      console.warn(err);\n    }\n  }\n\n  /**\n   * Retrieves the children of the directory.\n   * return A promise that resolves to an array of objects representing the children.\n   */\n  async children(): Promise<Array<OPFSDirWrap | OPFSFileWrap>> {\n    const handle = (await getFSHandle(this.#path, {\n      create: false,\n      isFile: false,\n    })) as FileSystemDirectoryHandle;\n    if (handle == null) return [];\n\n    const rs = [];\n    for await (const it of handle.values()) {\n      rs.push((it.kind === 'file' ? file : dir)(joinPath(this.#path, it.name)));\n    }\n    return rs;\n  }\n\n  /**\n   * If the dest folder exists, copy the current directory into the dest folder;\n   * if the dest folder does not exist, rename the current directory to dest name.\n   */\n  async copyTo(dest: OPFSDirWrap) {\n    if (!(await this.exists())) {\n      throw Error(`dir ${this.path} not exists`);\n    }\n    const newDir = (await dest.exists())\n      ? dir(joinPath(dest.path, this.name))\n      : dest;\n    await newDir.create();\n    await Promise.all((await this.children()).map((it) => it.copyTo(newDir)));\n\n    return newDir;\n  }\n\n  /**\n   * move directory, copy then remove current\n   */\n  async moveTo(dest: OPFSDirWrap): Promise<OPFSDirWrap> {\n    const newDir = await this.copyTo(dest);\n    await this.remove();\n\n    return newDir;\n  }\n}\n","import {\n  OPFSWorkerAccessHandle,\n  OpenMode,\n  createOPFSAccess,\n} from './access-worker';\nimport { getFSHandle, joinPath, parsePath, remove } from './common';\nimport { OPFSDirWrap, dir } from './directory';\n\nconst fileCache = new Map<string, OPFSFileWrap>();\n/**\n * Retrieves a file wrapper instance for the specified file path.\n * @param {string} filePath - The path of the file.\n * @param {'r' | 'rw' | 'rw-unsafe'} mode - A string specifying the locking mode for the access handle. The default value is \"rw\"\n * return A file wrapper instance.\n * \n * @see [MDN createSyncAccessHandle](https://developer.mozilla.org/en-US/docs/Web/API/FileSystemFileHandle/createSyncAccessHandle)\n * \n * @example\n * // Read content from a file\n  const fileContent = await file('/path/to/file.txt', 'r').text();\n  console.log('File content:', fileContent);\n\n  // Check if a file exists\n  const fileExists = await file('/path/to/file.txt').exists();\n  console.log('File exists:', fileExists);\n\n  // Remove a file\n  await file('/path/to/file.txt').remove();\n */\nexport function file(filePath: string, mode: ShortOpenMode = 'rw') {\n  if (mode === 'rw') {\n    const f = fileCache.get(filePath) ?? new OPFSFileWrap(filePath, mode);\n    fileCache.set(filePath, f);\n    return f;\n  }\n  return new OPFSFileWrap(filePath, mode);\n}\n\n/**\n * Writes content to the specified file.\n * @param {string} target - The path of the file.\n * @param {string | BufferSource | ReadableStream<BufferSource>} content - The content to write to the file.\n * return A promise that resolves when the content is written to the file.\n * \n * @example\n * // Write content to a file\n   await write('/path/to/file.txt', 'Hello, world!');\n */\nexport async function write(\n  target: string | OPFSFileWrap,\n  content: string | BufferSource | ReadableStream<BufferSource> | OPFSFileWrap,\n  opts = { overwrite: true }\n) {\n  if (content instanceof OPFSFileWrap) {\n    await write(target, await content.stream(), opts);\n    return;\n  }\n\n  const writer = await (target instanceof OPFSFileWrap\n    ? target\n    : file(target, 'rw')\n  ).createWriter();\n  try {\n    if (opts.overwrite) await writer.truncate(0);\n    if (content instanceof ReadableStream) {\n      const reader = content.getReader();\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n        await writer.write(value);\n      }\n    } else {\n      await writer.write(content);\n    }\n  } catch (err) {\n    throw err;\n  } finally {\n    await writer.close();\n  }\n}\n\nlet FILE_ID = 0;\nconst genFileId = () => ++FILE_ID;\n\ntype ShortOpenMode = 'r' | 'rw' | 'rw-unsafe';\n\n/**\n * Represents a wrapper for interacting with a file in the filesystem.\n */\nexport class OPFSFileWrap {\n  get kind(): 'file' {\n    return 'file';\n  }\n\n  get path() {\n    return this.#path;\n  }\n\n  get name() {\n    return this.#name;\n  }\n\n  get parent(): ReturnType<typeof dir> | null {\n    return this.#parentPath == null ? null : dir(this.#parentPath);\n  }\n\n  #path: string;\n  #parentPath: string | null;\n  #name: string;\n  #mode: OpenMode;\n\n  #id: number;\n  constructor(filePath: string, mode: ShortOpenMode) {\n    this.#id = genFileId();\n    this.#path = filePath;\n    this.#mode = (\n      {\n        r: 'read-only',\n        rw: 'readwrite',\n        'rw-unsafe': 'readwrite-unsafe',\n      } as const\n    )[mode];\n    const { parent, name } = parsePath(filePath);\n    this.#name = name;\n    this.#parentPath = parent;\n  }\n\n  #referCnt = 0;\n  #getAccessHandle = (() => {\n    let accPromise: Promise<\n      [OPFSWorkerAccessHandle, () => Promise<void>]\n    > | null = null;\n\n    return () => {\n      this.#referCnt += 1;\n      if (accPromise != null) return accPromise;\n\n      return (accPromise = new Promise(async (resolve, reject) => {\n        try {\n          const accHandle = await createOPFSAccess(\n            this.#id,\n            this.#path,\n            this.#mode\n          );\n          resolve([\n            accHandle,\n            async () => {\n              this.#referCnt -= 1;\n              if (this.#referCnt > 0) return;\n\n              accPromise = null;\n              await accHandle.close();\n            },\n          ]);\n        } catch (err) {\n          reject(err);\n        }\n      }));\n    };\n  })();\n\n  #writing = false;\n  /**\n   * Random write to file\n   */\n  async createWriter() {\n    if (this.#mode === 'read-only') throw Error('file is read-only');\n    if (this.#writing) throw Error('Other writer have not been closed');\n    this.#writing = true;\n\n    const txtEC = new TextEncoder();\n\n    // append content by default\n    const [accHandle, unref] = await this.#getAccessHandle();\n    let pos = await accHandle.getSize();\n    let closed = false;\n    return {\n      write: async (\n        chunk: string | BufferSource,\n        opts: { at?: number } = {}\n      ) => {\n        if (closed) throw Error('Writer is closed');\n        const content = typeof chunk === 'string' ? txtEC.encode(chunk) : chunk;\n        const at = opts.at ?? pos;\n        const contentSize = content.byteLength;\n        pos = at + contentSize;\n        return await accHandle.write(content, { at });\n      },\n      truncate: async (size: number) => {\n        if (closed) throw Error('Writer is closed');\n        await accHandle.truncate(size);\n        if (pos > size) pos = size;\n      },\n      flush: async () => {\n        if (closed) throw Error('Writer is closed');\n        await accHandle.flush();\n      },\n      close: async () => {\n        if (closed) throw Error('Writer is closed');\n        closed = true;\n        this.#writing = false;\n        await unref();\n      },\n    };\n  }\n\n  /**\n   * Random access to file\n   */\n  async createReader() {\n    const [accHandle, unref] = await this.#getAccessHandle();\n\n    let closed = false;\n    let pos = 0;\n    return {\n      read: async (size: number, opts: { at?: number } = {}) => {\n        if (closed) throw Error('Reader is closed');\n        const offset = opts.at ?? pos;\n        const buf = await accHandle.read(offset, size);\n        pos = offset + buf.byteLength;\n        return buf;\n      },\n      getSize: async () => {\n        if (closed) throw Error('Reader is closed');\n        return await accHandle.getSize();\n      },\n      close: async () => {\n        if (closed) return;\n        closed = true;\n        await unref();\n      },\n    };\n  }\n\n  async text() {\n    return new TextDecoder().decode(await this.arrayBuffer());\n  }\n\n  async arrayBuffer() {\n    const fh = await getFSHandle(this.#path, { create: false, isFile: true });\n    if (fh == null) return new ArrayBuffer(0);\n    return (await fh.getFile()).arrayBuffer();\n  }\n\n  async stream() {\n    const ofile = await this.getOriginFile();\n    if (ofile == null) {\n      return new ReadableStream<Uint8Array>({\n        pull: (ctrl) => {\n          ctrl.close();\n        },\n      });\n    }\n\n    return ofile.stream();\n  }\n\n  async getOriginFile() {\n    return (\n      await getFSHandle(this.#path, { create: false, isFile: true })\n    )?.getFile();\n  }\n\n  async getSize() {\n    const fh = await getFSHandle(this.#path, { create: false, isFile: true });\n    if (fh == null) return 0;\n    return (await fh.getFile()).size;\n  }\n\n  async exists() {\n    return (\n      (await getFSHandle(this.#path, {\n        create: false,\n        isFile: true,\n      })) instanceof FileSystemFileHandle\n    );\n  }\n\n  async remove() {\n    if (this.#referCnt) throw Error('exists unclosed reader/writer');\n    await remove(this.#path);\n    // fileCache.delete(this.#path);\n  }\n\n  /**\n   * If the target is a file, use current overwrite the target;\n   * if the target is a folder, copy the current file into that folder.\n   */\n  async copyTo(target: OPFSDirWrap | OPFSFileWrap): Promise<OPFSFileWrap> {\n    if (target instanceof OPFSFileWrap) {\n      if (target.path === this.path) return this;\n\n      await write(target.path, this);\n      return file(target.path);\n    } else if (target instanceof OPFSDirWrap) {\n      if (!(await this.exists())) {\n        throw Error(`file ${this.path} not exists`);\n      }\n      return await this.copyTo(file(joinPath(target.path, this.name)));\n    }\n    throw Error('Illegal target type');\n  }\n\n  /**\n   * move file, copy then remove current\n   */\n  async moveTo(target: OPFSDirWrap | OPFSFileWrap): Promise<OPFSFileWrap> {\n    const newFile = await this.copyTo(target);\n    await this.remove();\n    return newFile;\n  }\n}\n","import { OPFSDirWrap, dir } from './directory';\nimport { OPFSFileWrap, file } from './file';\n\nconst TMP_DIR = '/.opfs-tools-temp-dir';\n\nasync function safeRemove(it: OPFSFileWrap | OPFSDirWrap) {\n  try {\n    if (it.kind === 'file') {\n      if (!(await it.exists())) return true;\n\n      const writer = await it.createWriter();\n      await writer.truncate(0);\n      await writer.close();\n      await it.remove();\n    } else {\n      await it.remove();\n    }\n    return true;\n  } catch (e) {\n    console.warn(e);\n    return false;\n  }\n}\n\n// 'export' is for ease of testing\nexport function delByInterval() {\n  setInterval(async () => {\n    const timeOf3Days = 1000 * 60 * 60 * 24 * 3;\n    for (const it of await dir(TMP_DIR).children()) {\n      const match = /^\\d+-(\\d+)$/.exec(it.name);\n      if (match == null || Date.now() - Number(match[1]) > timeOf3Days) {\n        // Delete files that are older than three days and are not in writing\n        await safeRemove(it);\n      }\n    }\n  }, 60 * 1000);\n}\n\nconst currentPageTMPFiles: string[] = [];\nlet bindedUnloadEvt = false;\n\n// 'export' is for ease of testing\nexport async function delMarkFiles() {\n  if (globalThis.localStorage == null) return;\n\n  const opfsToolsExpires = 'OPFS_TOOLS_EXPIRES_TMP_FILES';\n\n  if (!bindedUnloadEvt) {\n    bindedUnloadEvt = true;\n    globalThis.addEventListener('unload', () => {\n      if (currentPageTMPFiles.length === 0) return;\n      localStorage.setItem(\n        opfsToolsExpires,\n        `${\n          localStorage.getItem(opfsToolsExpires) ?? ''\n        },${currentPageTMPFiles.join(',')}`\n      );\n    });\n  }\n\n  let markStr = localStorage.getItem(opfsToolsExpires) ?? '';\n  for (const name of markStr.split(',')) {\n    if (name.length === 0) continue;\n    if (await safeRemove(file(`${TMP_DIR}/${name}`))) {\n      markStr = markStr.replace(name, '');\n    }\n  }\n  localStorage.setItem(opfsToolsExpires, markStr.replace(/,{2,}/g, ','));\n}\n\n(async function init() {\n  if (globalThis.__opfs_tools_tmpfile_init__ === true) return;\n  globalThis.__opfs_tools_tmpfile_init__ = true;\n\n  // not web context\n  if (\n    globalThis.FileSystemDirectoryHandle == null ||\n    globalThis.FileSystemFileHandle == null ||\n    globalThis.navigator?.storage.getDirectory == null\n  ) {\n    return;\n  }\n\n  // clear tmpfile\n  delByInterval();\n  await delMarkFiles();\n})();\n\n/**\n * Create a temporary file that will automatically be cleared to avoid occupying too much storage space.\n * The temporary file name will be automatically generated and stored in a specific directory.\n */\nexport function tmpfile() {\n  const name = `${Math.random().toString().slice(2)}-${Date.now()}`;\n  currentPageTMPFiles.push(name);\n  return file(`${TMP_DIR}/${name}`);\n}\n","import { file } from './file';\n\nexport function rollfile(filePath: string, maxSize: number) {\n  let f = file(filePath);\n\n  let size = 0;\n  let writerPromise: ReturnType<typeof f.createWriter> = f.createWriter();\n  let readerPromise = f.createReader();\n\n  const reset = async (writer: Awaited<typeof writerPromise>) => {\n    const reader = await readerPromise;\n    const data = await reader.read(size, { at: Math.round(size * 0.3) });\n    size = await writer.write(data, { at: 0 });\n    await writer.truncate(size);\n  };\n\n  return {\n    append: async (content: string) => {\n      const writer = await writerPromise;\n      size += await writer.write(content);\n      if (size >= maxSize) await reset(writer);\n    },\n    text: f.text.bind(f),\n    remove: async () => {\n      await (await readerPromise).close();\n      await (await writerPromise).close();\n      await f.remove();\n    },\n    getSize: async () => size,\n  };\n}\n"],"names":["createOPFSAccess","fileId","filePath","mode","postMsg","getWorkerMsger","offset","size","data","opts","newSize","msgerCache","nextMsgerIdx","msger","create","worker","OPFSWorker","cbId","cbFns","_a","_b","evtType","args","trans","rsP","resolve","reject","parsePath","path","pathArr","s","name","parent","getFSHandle","dirPaths","dirHandle","p","err","remove","root","it","joinPath","p1","p2","dir","dirPath","OPFSDirWrap","__privateAdd","_path","_name","_parentPath","__privateSet","__privateGet","handle","rs","file","dest","newDir","fileCache","f","OPFSFileWrap","write","target","content","writer","reader","done","value","FILE_ID","genFileId","_OPFSFileWrap","_mode","_id","_referCnt","_getAccessHandle","accPromise","accHandle","_writing","txtEC","unref","pos","closed","chunk","at","contentSize","buf","fh","ofile","ctrl","newFile","TMP_DIR","safeRemove","delByInterval","match","currentPageTMPFiles","bindedUnloadEvt","delMarkFiles","opfsToolsExpires","markStr","tmpfile","rollfile","maxSize","writerPromise","readerPromise","reset"],"mappings":"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"}
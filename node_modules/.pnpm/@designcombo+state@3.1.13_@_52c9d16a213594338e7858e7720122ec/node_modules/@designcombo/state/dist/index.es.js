var xs = Object.defineProperty;
var Ds = (t, e, r) => e in t ? xs(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;
var le = (t, e, r) => Ds(t, typeof e != "symbol" ? e + "" : e, r);
import { subject as de, filter as fe } from "@designcombo/events";
var mn = function(t, e) {
  return mn = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, s) {
    r.__proto__ = s;
  } || function(r, s) {
    for (var a in s) Object.prototype.hasOwnProperty.call(s, a) && (r[a] = s[a]);
  }, mn(t, e);
};
function Qe(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  mn(t, e);
  function r() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype, new r());
}
function yn(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, r = e && t[e], s = 0;
  if (r) return r.call(t);
  if (t && typeof t.length == "number") return {
    next: function() {
      return t && s >= t.length && (t = void 0), { value: t && t[s++], done: !t };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function gn(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r) return t;
  var s = r.call(t), a, c = [], d;
  try {
    for (; (e === void 0 || e-- > 0) && !(a = s.next()).done; ) c.push(a.value);
  } catch (f) {
    d = { error: f };
  } finally {
    try {
      a && !a.done && (r = s.return) && r.call(s);
    } finally {
      if (d) throw d.error;
    }
  }
  return c;
}
function In(t, e, r) {
  if (r || arguments.length === 2) for (var s = 0, a = e.length, c; s < a; s++)
    (c || !(s in e)) && (c || (c = Array.prototype.slice.call(e, 0, s)), c[s] = e[s]);
  return t.concat(c || Array.prototype.slice.call(e));
}
function Wt(t) {
  return typeof t == "function";
}
function ss(t) {
  var e = function(s) {
    Error.call(s), s.stack = new Error().stack;
  }, r = t(e);
  return r.prototype = Object.create(Error.prototype), r.prototype.constructor = r, r;
}
var ln = ss(function(t) {
  return function(r) {
    t(this), this.message = r ? r.length + ` errors occurred during unsubscription:
` + r.map(function(s, a) {
      return a + 1 + ") " + s.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = r;
  };
});
function bn(t, e) {
  if (t) {
    var r = t.indexOf(e);
    0 <= r && t.splice(r, 1);
  }
}
var kr = function() {
  function t(e) {
    this.initialTeardown = e, this.closed = !1, this._parentage = null, this._finalizers = null;
  }
  return t.prototype.unsubscribe = function() {
    var e, r, s, a, c;
    if (!this.closed) {
      this.closed = !0;
      var d = this._parentage;
      if (d)
        if (this._parentage = null, Array.isArray(d))
          try {
            for (var f = yn(d), b = f.next(); !b.done; b = f.next()) {
              var _ = b.value;
              _.remove(this);
            }
          } catch (u) {
            e = { error: u };
          } finally {
            try {
              b && !b.done && (r = f.return) && r.call(f);
            } finally {
              if (e) throw e.error;
            }
          }
        else
          d.remove(this);
      var M = this.initialTeardown;
      if (Wt(M))
        try {
          M();
        } catch (u) {
          c = u instanceof ln ? u.errors : [u];
        }
      var E = this._finalizers;
      if (E) {
        this._finalizers = null;
        try {
          for (var m = yn(E), T = m.next(); !T.done; T = m.next()) {
            var C = T.value;
            try {
              $n(C);
            } catch (u) {
              c = c ?? [], u instanceof ln ? c = In(In([], gn(c)), gn(u.errors)) : c.push(u);
            }
          }
        } catch (u) {
          s = { error: u };
        } finally {
          try {
            T && !T.done && (a = m.return) && a.call(m);
          } finally {
            if (s) throw s.error;
          }
        }
      }
      if (c)
        throw new ln(c);
    }
  }, t.prototype.add = function(e) {
    var r;
    if (e && e !== this)
      if (this.closed)
        $n(e);
      else {
        if (e instanceof t) {
          if (e.closed || e._hasParent(this))
            return;
          e._addParent(this);
        }
        (this._finalizers = (r = this._finalizers) !== null && r !== void 0 ? r : []).push(e);
      }
  }, t.prototype._hasParent = function(e) {
    var r = this._parentage;
    return r === e || Array.isArray(r) && r.includes(e);
  }, t.prototype._addParent = function(e) {
    var r = this._parentage;
    this._parentage = Array.isArray(r) ? (r.push(e), r) : r ? [r, e] : e;
  }, t.prototype._removeParent = function(e) {
    var r = this._parentage;
    r === e ? this._parentage = null : Array.isArray(r) && bn(r, e);
  }, t.prototype.remove = function(e) {
    var r = this._finalizers;
    r && bn(r, e), e instanceof t && e._removeParent(this);
  }, t.EMPTY = function() {
    var e = new t();
    return e.closed = !0, e;
  }(), t;
}(), is = kr.EMPTY;
function as(t) {
  return t instanceof kr || t && "closed" in t && Wt(t.remove) && Wt(t.add) && Wt(t.unsubscribe);
}
function $n(t) {
  Wt(t) ? t() : t.unsubscribe();
}
var Os = {
  Promise: void 0
}, Cs = {
  setTimeout: function(t, e) {
    for (var r = [], s = 2; s < arguments.length; s++)
      r[s - 2] = arguments[s];
    return setTimeout.apply(void 0, In([t, e], gn(r)));
  },
  clearTimeout: function(t) {
    return clearTimeout(t);
  },
  delegate: void 0
};
function Ps(t) {
  Cs.setTimeout(function() {
    throw t;
  });
}
function Nn() {
}
function yr(t) {
  t();
}
var os = function(t) {
  Qe(e, t);
  function e(r) {
    var s = t.call(this) || this;
    return s.isStopped = !1, r ? (s.destination = r, as(r) && r.add(s)) : s.destination = Fs, s;
  }
  return e.create = function(r, s, a) {
    return new vn(r, s, a);
  }, e.prototype.next = function(r) {
    this.isStopped || this._next(r);
  }, e.prototype.error = function(r) {
    this.isStopped || (this.isStopped = !0, this._error(r));
  }, e.prototype.complete = function() {
    this.isStopped || (this.isStopped = !0, this._complete());
  }, e.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = !0, t.prototype.unsubscribe.call(this), this.destination = null);
  }, e.prototype._next = function(r) {
    this.destination.next(r);
  }, e.prototype._error = function(r) {
    try {
      this.destination.error(r);
    } finally {
      this.unsubscribe();
    }
  }, e.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }, e;
}(kr), Rs = function() {
  function t(e) {
    this.partialObserver = e;
  }
  return t.prototype.next = function(e) {
    var r = this.partialObserver;
    if (r.next)
      try {
        r.next(e);
      } catch (s) {
        mr(s);
      }
  }, t.prototype.error = function(e) {
    var r = this.partialObserver;
    if (r.error)
      try {
        r.error(e);
      } catch (s) {
        mr(s);
      }
    else
      mr(e);
  }, t.prototype.complete = function() {
    var e = this.partialObserver;
    if (e.complete)
      try {
        e.complete();
      } catch (r) {
        mr(r);
      }
  }, t;
}(), vn = function(t) {
  Qe(e, t);
  function e(r, s, a) {
    var c = t.call(this) || this, d;
    return Wt(r) || !r ? d = {
      next: r ?? void 0,
      error: s ?? void 0,
      complete: a ?? void 0
    } : d = r, c.destination = new Rs(d), c;
  }
  return e;
}(os);
function mr(t) {
  Ps(t);
}
function zs(t) {
  throw t;
}
var Fs = {
  closed: !0,
  next: Nn,
  error: zs,
  complete: Nn
}, $s = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function Ns(t) {
  return t;
}
function js(t) {
  return t.length === 0 ? Ns : t.length === 1 ? t[0] : function(r) {
    return t.reduce(function(s, a) {
      return a(s);
    }, r);
  };
}
var jn = function() {
  function t(e) {
    e && (this._subscribe = e);
  }
  return t.prototype.lift = function(e) {
    var r = new t();
    return r.source = this, r.operator = e, r;
  }, t.prototype.subscribe = function(e, r, s) {
    var a = this, c = Ls(e) ? e : new vn(e, r, s);
    return yr(function() {
      var d = a, f = d.operator, b = d.source;
      c.add(f ? f.call(c, b) : b ? a._subscribe(c) : a._trySubscribe(c));
    }), c;
  }, t.prototype._trySubscribe = function(e) {
    try {
      return this._subscribe(e);
    } catch (r) {
      e.error(r);
    }
  }, t.prototype.forEach = function(e, r) {
    var s = this;
    return r = Hn(r), new r(function(a, c) {
      var d = new vn({
        next: function(f) {
          try {
            e(f);
          } catch (b) {
            c(b), d.unsubscribe();
          }
        },
        error: c,
        complete: a
      });
      s.subscribe(d);
    });
  }, t.prototype._subscribe = function(e) {
    var r;
    return (r = this.source) === null || r === void 0 ? void 0 : r.subscribe(e);
  }, t.prototype[$s] = function() {
    return this;
  }, t.prototype.pipe = function() {
    for (var e = [], r = 0; r < arguments.length; r++)
      e[r] = arguments[r];
    return js(e)(this);
  }, t.prototype.toPromise = function(e) {
    var r = this;
    return e = Hn(e), new e(function(s, a) {
      var c;
      r.subscribe(function(d) {
        return c = d;
      }, function(d) {
        return a(d);
      }, function() {
        return s(c);
      });
    });
  }, t.create = function(e) {
    return new t(e);
  }, t;
}();
function Hn(t) {
  var e;
  return (e = t ?? Os.Promise) !== null && e !== void 0 ? e : Promise;
}
function Hs(t) {
  return t && Wt(t.next) && Wt(t.error) && Wt(t.complete);
}
function Ls(t) {
  return t && t instanceof os || Hs(t) && as(t);
}
var Us = ss(function(t) {
  return function() {
    t(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
  };
}), cs = function(t) {
  Qe(e, t);
  function e() {
    var r = t.call(this) || this;
    return r.closed = !1, r.currentObservers = null, r.observers = [], r.isStopped = !1, r.hasError = !1, r.thrownError = null, r;
  }
  return e.prototype.lift = function(r) {
    var s = new Ln(this, this);
    return s.operator = r, s;
  }, e.prototype._throwIfClosed = function() {
    if (this.closed)
      throw new Us();
  }, e.prototype.next = function(r) {
    var s = this;
    yr(function() {
      var a, c;
      if (s._throwIfClosed(), !s.isStopped) {
        s.currentObservers || (s.currentObservers = Array.from(s.observers));
        try {
          for (var d = yn(s.currentObservers), f = d.next(); !f.done; f = d.next()) {
            var b = f.value;
            b.next(r);
          }
        } catch (_) {
          a = { error: _ };
        } finally {
          try {
            f && !f.done && (c = d.return) && c.call(d);
          } finally {
            if (a) throw a.error;
          }
        }
      }
    });
  }, e.prototype.error = function(r) {
    var s = this;
    yr(function() {
      if (s._throwIfClosed(), !s.isStopped) {
        s.hasError = s.isStopped = !0, s.thrownError = r;
        for (var a = s.observers; a.length; )
          a.shift().error(r);
      }
    });
  }, e.prototype.complete = function() {
    var r = this;
    yr(function() {
      if (r._throwIfClosed(), !r.isStopped) {
        r.isStopped = !0;
        for (var s = r.observers; s.length; )
          s.shift().complete();
      }
    });
  }, e.prototype.unsubscribe = function() {
    this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;
  }, Object.defineProperty(e.prototype, "observed", {
    get: function() {
      var r;
      return ((r = this.observers) === null || r === void 0 ? void 0 : r.length) > 0;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._trySubscribe = function(r) {
    return this._throwIfClosed(), t.prototype._trySubscribe.call(this, r);
  }, e.prototype._subscribe = function(r) {
    return this._throwIfClosed(), this._checkFinalizedStatuses(r), this._innerSubscribe(r);
  }, e.prototype._innerSubscribe = function(r) {
    var s = this, a = this, c = a.hasError, d = a.isStopped, f = a.observers;
    return c || d ? is : (this.currentObservers = null, f.push(r), new kr(function() {
      s.currentObservers = null, bn(f, r);
    }));
  }, e.prototype._checkFinalizedStatuses = function(r) {
    var s = this, a = s.hasError, c = s.thrownError, d = s.isStopped;
    a ? r.error(c) : d && r.complete();
  }, e.prototype.asObservable = function() {
    var r = new jn();
    return r.source = this, r;
  }, e.create = function(r, s) {
    return new Ln(r, s);
  }, e;
}(jn), Ln = function(t) {
  Qe(e, t);
  function e(r, s) {
    var a = t.call(this) || this;
    return a.destination = r, a.source = s, a;
  }
  return e.prototype.next = function(r) {
    var s, a;
    (a = (s = this.destination) === null || s === void 0 ? void 0 : s.next) === null || a === void 0 || a.call(s, r);
  }, e.prototype.error = function(r) {
    var s, a;
    (a = (s = this.destination) === null || s === void 0 ? void 0 : s.error) === null || a === void 0 || a.call(s, r);
  }, e.prototype.complete = function() {
    var r, s;
    (s = (r = this.destination) === null || r === void 0 ? void 0 : r.complete) === null || s === void 0 || s.call(r);
  }, e.prototype._subscribe = function(r) {
    var s, a;
    return (a = (s = this.source) === null || s === void 0 ? void 0 : s.subscribe(r)) !== null && a !== void 0 ? a : is;
  }, e;
}(cs), Un = function(t) {
  Qe(e, t);
  function e(r) {
    var s = t.call(this) || this;
    return s._value = r, s;
  }
  return Object.defineProperty(e.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._subscribe = function(r) {
    var s = t.prototype._subscribe.call(this, r);
    return !s.closed && r.next(this._value), s;
  }, e.prototype.getValue = function() {
    var r = this, s = r.hasError, a = r.thrownError, c = r._value;
    if (s)
      throw a;
    return this._throwIfClosed(), c;
  }, e.prototype.next = function(r) {
    t.prototype.next.call(this, this._value = r);
  }, e;
}(cs), St = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function xn(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var gr = { exports: {} };
gr.exports;
(function(t, e) {
  var r = 200, s = "__lodash_hash_undefined__", a = 1, c = 2, d = 9007199254740991, f = "[object Arguments]", b = "[object Array]", _ = "[object AsyncFunction]", M = "[object Boolean]", E = "[object Date]", m = "[object Error]", T = "[object Function]", C = "[object GeneratorFunction]", u = "[object Map]", l = "[object Number]", S = "[object Null]", w = "[object Object]", k = "[object Promise]", h = "[object Proxy]", y = "[object RegExp]", v = "[object Set]", I = "[object String]", x = "[object Symbol]", g = "[object Undefined]", O = "[object WeakMap]", D = "[object ArrayBuffer]", j = "[object DataView]", L = "[object Float32Array]", R = "[object Float64Array]", F = "[object Int8Array]", V = "[object Int16Array]", kt = "[object Int32Array]", Dt = "[object Uint8Array]", Ot = "[object Uint8ClampedArray]", U = "[object Uint16Array]", zt = "[object Uint32Array]", wt = /[\\^$.*+?()[\]{}|]/g, at = /^\[object .+?Constructor\]$/, Ft = /^(?:0|[1-9]\d*)$/, A = {};
  A[L] = A[R] = A[F] = A[V] = A[kt] = A[Dt] = A[Ot] = A[U] = A[zt] = !0, A[f] = A[b] = A[D] = A[M] = A[j] = A[E] = A[m] = A[T] = A[u] = A[l] = A[w] = A[y] = A[v] = A[I] = A[O] = !1;
  var et = typeof St == "object" && St && St.Object === Object && St, Mt = typeof self == "object" && self && self.Object === Object && self, ot = et || Mt || Function("return this")(), $t = e && !e.nodeType && e, Et = $t && !0 && t && !t.nodeType && t, Gt = Et && Et.exports === $t, Yt = Gt && et.process, ee = function() {
    try {
      return Yt && Yt.binding && Yt.binding("util");
    } catch {
    }
  }(), Bt = ee && ee.isTypedArray;
  function re(n, i) {
    for (var o = -1, p = n == null ? 0 : n.length, N = 0, P = []; ++o < p; ) {
      var G = n[o];
      i(G, o, n) && (P[N++] = G);
    }
    return P;
  }
  function Xt(n, i) {
    for (var o = -1, p = i.length, N = n.length; ++o < p; )
      n[N + o] = i[o];
    return n;
  }
  function ne(n, i) {
    for (var o = -1, p = n == null ? 0 : n.length; ++o < p; )
      if (i(n[o], o, n))
        return !0;
    return !1;
  }
  function _e(n, i) {
    for (var o = -1, p = Array(n); ++o < n; )
      p[o] = i(o);
    return p;
  }
  function ke(n) {
    return function(i) {
      return n(i);
    };
  }
  function Nt(n, i) {
    return n.has(i);
  }
  function Kt(n, i) {
    return n == null ? void 0 : n[i];
  }
  function $(n) {
    var i = -1, o = Array(n.size);
    return n.forEach(function(p, N) {
      o[++i] = [N, p];
    }), o;
  }
  function H(n, i) {
    return function(o) {
      return n(i(o));
    };
  }
  function z(n) {
    var i = -1, o = Array(n.size);
    return n.forEach(function(p) {
      o[++i] = p;
    }), o;
  }
  var rt = Array.prototype, ct = Function.prototype, B = Object.prototype, ut = ot["__core-js_shared__"], q = ct.toString, ht = B.hasOwnProperty, Se = function() {
    var n = /[^.]+$/.exec(ut && ut.keys && ut.keys.IE_PROTO || "");
    return n ? "Symbol(src)_1." + n : "";
  }(), se = B.toString, Pe = RegExp(
    "^" + q.call(ht).replace(wt, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), Y = Gt ? ot.Buffer : void 0, mt = ot.Symbol, Vt = ot.Uint8Array, qt = B.propertyIsEnumerable, Tt = rt.splice, At = mt ? mt.toStringTag : void 0, we = Object.getOwnPropertySymbols, Re = Y ? Y.isBuffer : void 0, ie = H(Object.keys, Object), ze = Ht(ot, "DataView"), ae = Ht(ot, "Map"), Fe = Ht(ot, "Promise"), $e = Ht(ot, "Set"), Ne = Ht(ot, "WeakMap"), Jt = Ht(Object, "create"), rr = yt(ze), jt = yt(ae), Er = yt(Fe), Tr = yt($e), Ar = yt(Ne), nr = mt ? mt.prototype : void 0, je = nr ? nr.valueOf : void 0;
  function nt(n) {
    var i = -1, o = n == null ? 0 : n.length;
    for (this.clear(); ++i < o; ) {
      var p = n[i];
      this.set(p[0], p[1]);
    }
  }
  function xr() {
    this.__data__ = Jt ? Jt(null) : {}, this.size = 0;
  }
  function Dr(n) {
    var i = this.has(n) && delete this.__data__[n];
    return this.size -= i ? 1 : 0, i;
  }
  function Or(n) {
    var i = this.__data__;
    if (Jt) {
      var o = i[n];
      return o === s ? void 0 : o;
    }
    return ht.call(i, n) ? i[n] : void 0;
  }
  function Cr(n) {
    var i = this.__data__;
    return Jt ? i[n] !== void 0 : ht.call(i, n);
  }
  function Pr(n, i) {
    var o = this.__data__;
    return this.size += this.has(n) ? 0 : 1, o[n] = Jt && i === void 0 ? s : i, this;
  }
  nt.prototype.clear = xr, nt.prototype.delete = Dr, nt.prototype.get = Or, nt.prototype.has = Cr, nt.prototype.set = Pr;
  function lt(n) {
    var i = -1, o = n == null ? 0 : n.length;
    for (this.clear(); ++i < o; ) {
      var p = n[i];
      this.set(p[0], p[1]);
    }
  }
  function Rr() {
    this.__data__ = [], this.size = 0;
  }
  function zr(n) {
    var i = this.__data__, o = Te(i, n);
    if (o < 0)
      return !1;
    var p = i.length - 1;
    return o == p ? i.pop() : Tt.call(i, o, 1), --this.size, !0;
  }
  function Fr(n) {
    var i = this.__data__, o = Te(i, n);
    return o < 0 ? void 0 : i[o][1];
  }
  function $r(n) {
    return Te(this.__data__, n) > -1;
  }
  function Nr(n, i) {
    var o = this.__data__, p = Te(o, n);
    return p < 0 ? (++this.size, o.push([n, i])) : o[p][1] = i, this;
  }
  lt.prototype.clear = Rr, lt.prototype.delete = zr, lt.prototype.get = Fr, lt.prototype.has = $r, lt.prototype.set = Nr;
  function It(n) {
    var i = -1, o = n == null ? 0 : n.length;
    for (this.clear(); ++i < o; ) {
      var p = n[i];
      this.set(p[0], p[1]);
    }
  }
  function jr() {
    this.size = 0, this.__data__ = {
      hash: new nt(),
      map: new (ae || lt)(),
      string: new nt()
    };
  }
  function Hr(n) {
    var i = xt(this, n).delete(n);
    return this.size -= i ? 1 : 0, i;
  }
  function Lr(n) {
    return xt(this, n).get(n);
  }
  function Ur(n) {
    return xt(this, n).has(n);
  }
  function Wr(n, i) {
    var o = xt(this, n), p = o.size;
    return o.set(n, i), this.size += o.size == p ? 0 : 1, this;
  }
  It.prototype.clear = jr, It.prototype.delete = Hr, It.prototype.get = Lr, It.prototype.has = Ur, It.prototype.set = Wr;
  function Me(n) {
    var i = -1, o = n == null ? 0 : n.length;
    for (this.__data__ = new It(); ++i < o; )
      this.add(n[i]);
  }
  function sr(n) {
    return this.__data__.set(n, s), this;
  }
  function Ee(n) {
    return this.__data__.has(n);
  }
  Me.prototype.add = Me.prototype.push = sr, Me.prototype.has = Ee;
  function Ct(n) {
    var i = this.__data__ = new lt(n);
    this.size = i.size;
  }
  function He() {
    this.__data__ = new lt(), this.size = 0;
  }
  function Gr(n) {
    var i = this.__data__, o = i.delete(n);
    return this.size = i.size, o;
  }
  function Yr(n) {
    return this.__data__.get(n);
  }
  function Br(n) {
    return this.__data__.has(n);
  }
  function Xr(n, i) {
    var o = this.__data__;
    if (o instanceof lt) {
      var p = o.__data__;
      if (!ae || p.length < r - 1)
        return p.push([n, i]), this.size = ++o.size, this;
      o = this.__data__ = new It(p);
    }
    return o.set(n, i), this.size = o.size, this;
  }
  Ct.prototype.clear = He, Ct.prototype.delete = Gr, Ct.prototype.get = Yr, Ct.prototype.has = Br, Ct.prototype.set = Xr;
  function Kr(n, i) {
    var o = Ae(n), p = !o && ur(n), N = !o && !p && xe(n), P = !o && !p && !N && fr(n), G = o || p || N || P, W = G ? _e(n.length, String) : [], J = W.length;
    for (var X in n)
      ht.call(n, X) && !(G && // Safari 9 has enumerable `arguments.length` in strict mode.
      (X == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      N && (X == "offset" || X == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      P && (X == "buffer" || X == "byteLength" || X == "byteOffset") || // Skip index properties.
      rn(X, J))) && W.push(X);
    return W;
  }
  function Te(n, i) {
    for (var o = n.length; o--; )
      if (cr(n[o][0], i))
        return o;
    return -1;
  }
  function Le(n, i, o) {
    var p = i(n);
    return Ae(n) ? p : Xt(p, o(n));
  }
  function oe(n) {
    return n == null ? n === void 0 ? g : S : At && At in Object(n) ? Lt(n) : or(n);
  }
  function ir(n) {
    return Rt(n) && oe(n) == f;
  }
  function ar(n, i, o, p, N) {
    return n === i ? !0 : n == null || i == null || !Rt(n) && !Rt(i) ? n !== n && i !== i : Vr(n, i, o, p, ar, N);
  }
  function Vr(n, i, o, p, N, P) {
    var G = Ae(n), W = Ae(i), J = G ? b : Pt(n), X = W ? b : Pt(i);
    J = J == f ? w : J, X = X == f ? w : X;
    var dt = J == w, bt = X == w, Z = J == X;
    if (Z && xe(n)) {
      if (!xe(i))
        return !1;
      G = !0, dt = !1;
    }
    if (Z && !dt)
      return P || (P = new Ct()), G || fr(n) ? Ue(n, i, o, p, N, P) : Qr(n, i, J, o, p, N, P);
    if (!(o & a)) {
      var ft = dt && ht.call(n, "__wrapped__"), st = bt && ht.call(i, "__wrapped__");
      if (ft || st) {
        var Zt = ft ? n.value() : n, Ut = st ? i.value() : i;
        return P || (P = new Ct()), N(Zt, Ut, o, p, P);
      }
    }
    return Z ? (P || (P = new Ct()), tn(n, i, o, p, N, P)) : !1;
  }
  function qr(n) {
    if (!dr(n) || sn(n))
      return !1;
    var i = lr(n) ? Pe : at;
    return i.test(yt(n));
  }
  function Jr(n) {
    return Rt(n) && Ge(n.length) && !!A[oe(n)];
  }
  function Zr(n) {
    if (!an(n))
      return ie(n);
    var i = [];
    for (var o in Object(n))
      ht.call(n, o) && o != "constructor" && i.push(o);
    return i;
  }
  function Ue(n, i, o, p, N, P) {
    var G = o & a, W = n.length, J = i.length;
    if (W != J && !(G && J > W))
      return !1;
    var X = P.get(n);
    if (X && P.get(i))
      return X == i;
    var dt = -1, bt = !0, Z = o & c ? new Me() : void 0;
    for (P.set(n, i), P.set(i, n); ++dt < W; ) {
      var ft = n[dt], st = i[dt];
      if (p)
        var Zt = G ? p(st, ft, dt, i, n, P) : p(ft, st, dt, n, i, P);
      if (Zt !== void 0) {
        if (Zt)
          continue;
        bt = !1;
        break;
      }
      if (Z) {
        if (!ne(i, function(Ut, ue) {
          if (!Nt(Z, ue) && (ft === Ut || N(ft, Ut, o, p, P)))
            return Z.push(ue);
        })) {
          bt = !1;
          break;
        }
      } else if (!(ft === st || N(ft, st, o, p, P))) {
        bt = !1;
        break;
      }
    }
    return P.delete(n), P.delete(i), bt;
  }
  function Qr(n, i, o, p, N, P, G) {
    switch (o) {
      case j:
        if (n.byteLength != i.byteLength || n.byteOffset != i.byteOffset)
          return !1;
        n = n.buffer, i = i.buffer;
      case D:
        return !(n.byteLength != i.byteLength || !P(new Vt(n), new Vt(i)));
      case M:
      case E:
      case l:
        return cr(+n, +i);
      case m:
        return n.name == i.name && n.message == i.message;
      case y:
      case I:
        return n == i + "";
      case u:
        var W = $;
      case v:
        var J = p & a;
        if (W || (W = z), n.size != i.size && !J)
          return !1;
        var X = G.get(n);
        if (X)
          return X == i;
        p |= c, G.set(n, i);
        var dt = Ue(W(n), W(i), p, N, P, G);
        return G.delete(n), dt;
      case x:
        if (je)
          return je.call(n) == je.call(i);
    }
    return !1;
  }
  function tn(n, i, o, p, N, P) {
    var G = o & a, W = ce(n), J = W.length, X = ce(i), dt = X.length;
    if (J != dt && !G)
      return !1;
    for (var bt = J; bt--; ) {
      var Z = W[bt];
      if (!(G ? Z in i : ht.call(i, Z)))
        return !1;
    }
    var ft = P.get(n);
    if (ft && P.get(i))
      return ft == i;
    var st = !0;
    P.set(n, i), P.set(i, n);
    for (var Zt = G; ++bt < J; ) {
      Z = W[bt];
      var Ut = n[Z], ue = i[Z];
      if (p)
        var Fn = G ? p(ue, Ut, Z, i, n, P) : p(Ut, ue, Z, n, i, P);
      if (!(Fn === void 0 ? Ut === ue || N(Ut, ue, o, p, P) : Fn)) {
        st = !1;
        break;
      }
      Zt || (Zt = Z == "constructor");
    }
    if (st && !Zt) {
      var pr = n.constructor, hr = i.constructor;
      pr != hr && "constructor" in n && "constructor" in i && !(typeof pr == "function" && pr instanceof pr && typeof hr == "function" && hr instanceof hr) && (st = !1);
    }
    return P.delete(n), P.delete(i), st;
  }
  function ce(n) {
    return Le(n, Ye, en);
  }
  function xt(n, i) {
    var o = n.__data__;
    return nn(i) ? o[typeof i == "string" ? "string" : "hash"] : o.map;
  }
  function Ht(n, i) {
    var o = Kt(n, i);
    return qr(o) ? o : void 0;
  }
  function Lt(n) {
    var i = ht.call(n, At), o = n[At];
    try {
      n[At] = void 0;
      var p = !0;
    } catch {
    }
    var N = se.call(n);
    return p && (i ? n[At] = o : delete n[At]), N;
  }
  var en = we ? function(n) {
    return n == null ? [] : (n = Object(n), re(we(n), function(i) {
      return qt.call(n, i);
    }));
  } : cn, Pt = oe;
  (ze && Pt(new ze(new ArrayBuffer(1))) != j || ae && Pt(new ae()) != u || Fe && Pt(Fe.resolve()) != k || $e && Pt(new $e()) != v || Ne && Pt(new Ne()) != O) && (Pt = function(n) {
    var i = oe(n), o = i == w ? n.constructor : void 0, p = o ? yt(o) : "";
    if (p)
      switch (p) {
        case rr:
          return j;
        case jt:
          return u;
        case Er:
          return k;
        case Tr:
          return v;
        case Ar:
          return O;
      }
    return i;
  });
  function rn(n, i) {
    return i = i ?? d, !!i && (typeof n == "number" || Ft.test(n)) && n > -1 && n % 1 == 0 && n < i;
  }
  function nn(n) {
    var i = typeof n;
    return i == "string" || i == "number" || i == "symbol" || i == "boolean" ? n !== "__proto__" : n === null;
  }
  function sn(n) {
    return !!Se && Se in n;
  }
  function an(n) {
    var i = n && n.constructor, o = typeof i == "function" && i.prototype || B;
    return n === o;
  }
  function or(n) {
    return se.call(n);
  }
  function yt(n) {
    if (n != null) {
      try {
        return q.call(n);
      } catch {
      }
      try {
        return n + "";
      } catch {
      }
    }
    return "";
  }
  function cr(n, i) {
    return n === i || n !== n && i !== i;
  }
  var ur = ir(/* @__PURE__ */ function() {
    return arguments;
  }()) ? ir : function(n) {
    return Rt(n) && ht.call(n, "callee") && !qt.call(n, "callee");
  }, Ae = Array.isArray;
  function We(n) {
    return n != null && Ge(n.length) && !lr(n);
  }
  var xe = Re || un;
  function on(n, i) {
    return ar(n, i);
  }
  function lr(n) {
    if (!dr(n))
      return !1;
    var i = oe(n);
    return i == T || i == C || i == _ || i == h;
  }
  function Ge(n) {
    return typeof n == "number" && n > -1 && n % 1 == 0 && n <= d;
  }
  function dr(n) {
    var i = typeof n;
    return n != null && (i == "object" || i == "function");
  }
  function Rt(n) {
    return n != null && typeof n == "object";
  }
  var fr = Bt ? ke(Bt) : Jr;
  function Ye(n) {
    return We(n) ? Kr(n) : Zr(n);
  }
  function cn() {
    return [];
  }
  function un() {
    return !1;
  }
  t.exports = on;
})(gr, gr.exports);
var Ws = gr.exports;
const Q = /* @__PURE__ */ xn(Ws), Aa = "add", Gs = "track", Ys = "trackItems", xa = `${Gs}:changed`, Da = `${Ys}:changed`, Bs = "state", Oa = `${Bs}:changed`, Dn = "design", Xs = `${Dn}:load`, Ks = `${Dn}:resize`, gt = "add", Vs = `${gt}:text`, qs = `${gt}:video`, Js = `${gt}:audio`, Ca = `${gt}:placeholder`, Zs = `${gt}:image`, Qs = `${gt}:illustration`, ti = `${gt}:shape`, Pa = `${gt}:mask`, Ra = `${gt}:transition`, ei = `${gt}:animation`, ri = `${gt}:caption`, ni = `${gt}:template`, si = `${gt}:items`, ii = `${gt}:composition`, be = "edit", ai = `${be}:object`, oi = `${be}:replaceMedia`, za = `${be}:text`, Fa = `${be}:shape`, $a = `${be}:templateItem`, Na = `${be}:deleteTemplateItem`, ja = "enterEditMode", Ce = "active", Ha = `${Ce}:set`, La = `${Ce}:delete`, ci = `${Ce}:paste`, ui = `${Ce}:clone`, li = `${Ce}:split`, pt = "layer", Ua = `${pt}:locked`, Wa = `${pt}:hidden`, Ga = `${pt}:move`, Ya = `${pt}:select`, Ba = `${pt}:selection`, Xa = `${pt}:sendTo`, Ka = `${pt}:rename`, Va = `${pt}:editingName`, qa = `${pt}:copy`, Ja = `${pt}:paste`, di = `${pt}:clone`, Za = `${pt}:split`, Qa = `${pt}:cut`, fi = `${pt}:delete`, pi = `${pt}:replace`, Sr = "history", hi = `${Sr}:undo`, mi = `${Sr}:redo`, to = `${Sr}:reset`, us = "scale", yi = `${us}:changed`;
var Ir = { exports: {} };
Ir.exports;
(function(t, e) {
  var r = 200, s = "__lodash_hash_undefined__", a = 9007199254740991, c = "[object Arguments]", d = "[object Array]", f = "[object Boolean]", b = "[object Date]", _ = "[object Error]", M = "[object Function]", E = "[object GeneratorFunction]", m = "[object Map]", T = "[object Number]", C = "[object Object]", u = "[object Promise]", l = "[object RegExp]", S = "[object Set]", w = "[object String]", k = "[object Symbol]", h = "[object WeakMap]", y = "[object ArrayBuffer]", v = "[object DataView]", I = "[object Float32Array]", x = "[object Float64Array]", g = "[object Int8Array]", O = "[object Int16Array]", D = "[object Int32Array]", j = "[object Uint8Array]", L = "[object Uint8ClampedArray]", R = "[object Uint16Array]", F = "[object Uint32Array]", V = /[\\^$.*+?()[\]{}|]/g, kt = /\w*$/, Dt = /^\[object .+?Constructor\]$/, Ot = /^(?:0|[1-9]\d*)$/, U = {};
  U[c] = U[d] = U[y] = U[v] = U[f] = U[b] = U[I] = U[x] = U[g] = U[O] = U[D] = U[m] = U[T] = U[C] = U[l] = U[S] = U[w] = U[k] = U[j] = U[L] = U[R] = U[F] = !0, U[_] = U[M] = U[h] = !1;
  var zt = typeof St == "object" && St && St.Object === Object && St, wt = typeof self == "object" && self && self.Object === Object && self, at = zt || wt || Function("return this")(), Ft = e && !e.nodeType && e, A = Ft && !0 && t && !t.nodeType && t, et = A && A.exports === Ft;
  function Mt(n, i) {
    return n.set(i[0], i[1]), n;
  }
  function ot(n, i) {
    return n.add(i), n;
  }
  function $t(n, i) {
    for (var o = -1, p = n ? n.length : 0; ++o < p && i(n[o], o, n) !== !1; )
      ;
    return n;
  }
  function Et(n, i) {
    for (var o = -1, p = i.length, N = n.length; ++o < p; )
      n[N + o] = i[o];
    return n;
  }
  function Gt(n, i, o, p) {
    for (var N = -1, P = n ? n.length : 0; ++N < P; )
      o = i(o, n[N], N, n);
    return o;
  }
  function Yt(n, i) {
    for (var o = -1, p = Array(n); ++o < n; )
      p[o] = i(o);
    return p;
  }
  function ee(n, i) {
    return n == null ? void 0 : n[i];
  }
  function Bt(n) {
    var i = !1;
    if (n != null && typeof n.toString != "function")
      try {
        i = !!(n + "");
      } catch {
      }
    return i;
  }
  function re(n) {
    var i = -1, o = Array(n.size);
    return n.forEach(function(p, N) {
      o[++i] = [N, p];
    }), o;
  }
  function Xt(n, i) {
    return function(o) {
      return n(i(o));
    };
  }
  function ne(n) {
    var i = -1, o = Array(n.size);
    return n.forEach(function(p) {
      o[++i] = p;
    }), o;
  }
  var _e = Array.prototype, ke = Function.prototype, Nt = Object.prototype, Kt = at["__core-js_shared__"], $ = function() {
    var n = /[^.]+$/.exec(Kt && Kt.keys && Kt.keys.IE_PROTO || "");
    return n ? "Symbol(src)_1." + n : "";
  }(), H = ke.toString, z = Nt.hasOwnProperty, rt = Nt.toString, ct = RegExp(
    "^" + H.call(z).replace(V, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), B = et ? at.Buffer : void 0, ut = at.Symbol, q = at.Uint8Array, ht = Xt(Object.getPrototypeOf, Object), Se = Object.create, se = Nt.propertyIsEnumerable, Pe = _e.splice, Y = Object.getOwnPropertySymbols, mt = B ? B.isBuffer : void 0, Vt = Xt(Object.keys, Object), qt = xt(at, "DataView"), Tt = xt(at, "Map"), At = xt(at, "Promise"), we = xt(at, "Set"), Re = xt(at, "WeakMap"), ie = xt(Object, "create"), ze = yt(qt), ae = yt(Tt), Fe = yt(At), $e = yt(we), Ne = yt(Re), Jt = ut ? ut.prototype : void 0, rr = Jt ? Jt.valueOf : void 0;
  function jt(n) {
    var i = -1, o = n ? n.length : 0;
    for (this.clear(); ++i < o; ) {
      var p = n[i];
      this.set(p[0], p[1]);
    }
  }
  function Er() {
    this.__data__ = ie ? ie(null) : {};
  }
  function Tr(n) {
    return this.has(n) && delete this.__data__[n];
  }
  function Ar(n) {
    var i = this.__data__;
    if (ie) {
      var o = i[n];
      return o === s ? void 0 : o;
    }
    return z.call(i, n) ? i[n] : void 0;
  }
  function nr(n) {
    var i = this.__data__;
    return ie ? i[n] !== void 0 : z.call(i, n);
  }
  function je(n, i) {
    var o = this.__data__;
    return o[n] = ie && i === void 0 ? s : i, this;
  }
  jt.prototype.clear = Er, jt.prototype.delete = Tr, jt.prototype.get = Ar, jt.prototype.has = nr, jt.prototype.set = je;
  function nt(n) {
    var i = -1, o = n ? n.length : 0;
    for (this.clear(); ++i < o; ) {
      var p = n[i];
      this.set(p[0], p[1]);
    }
  }
  function xr() {
    this.__data__ = [];
  }
  function Dr(n) {
    var i = this.__data__, o = Ee(i, n);
    if (o < 0)
      return !1;
    var p = i.length - 1;
    return o == p ? i.pop() : Pe.call(i, o, 1), !0;
  }
  function Or(n) {
    var i = this.__data__, o = Ee(i, n);
    return o < 0 ? void 0 : i[o][1];
  }
  function Cr(n) {
    return Ee(this.__data__, n) > -1;
  }
  function Pr(n, i) {
    var o = this.__data__, p = Ee(o, n);
    return p < 0 ? o.push([n, i]) : o[p][1] = i, this;
  }
  nt.prototype.clear = xr, nt.prototype.delete = Dr, nt.prototype.get = Or, nt.prototype.has = Cr, nt.prototype.set = Pr;
  function lt(n) {
    var i = -1, o = n ? n.length : 0;
    for (this.clear(); ++i < o; ) {
      var p = n[i];
      this.set(p[0], p[1]);
    }
  }
  function Rr() {
    this.__data__ = {
      hash: new jt(),
      map: new (Tt || nt)(),
      string: new jt()
    };
  }
  function zr(n) {
    return ce(this, n).delete(n);
  }
  function Fr(n) {
    return ce(this, n).get(n);
  }
  function $r(n) {
    return ce(this, n).has(n);
  }
  function Nr(n, i) {
    return ce(this, n).set(n, i), this;
  }
  lt.prototype.clear = Rr, lt.prototype.delete = zr, lt.prototype.get = Fr, lt.prototype.has = $r, lt.prototype.set = Nr;
  function It(n) {
    this.__data__ = new nt(n);
  }
  function jr() {
    this.__data__ = new nt();
  }
  function Hr(n) {
    return this.__data__.delete(n);
  }
  function Lr(n) {
    return this.__data__.get(n);
  }
  function Ur(n) {
    return this.__data__.has(n);
  }
  function Wr(n, i) {
    var o = this.__data__;
    if (o instanceof nt) {
      var p = o.__data__;
      if (!Tt || p.length < r - 1)
        return p.push([n, i]), this;
      o = this.__data__ = new lt(p);
    }
    return o.set(n, i), this;
  }
  It.prototype.clear = jr, It.prototype.delete = Hr, It.prototype.get = Lr, It.prototype.has = Ur, It.prototype.set = Wr;
  function Me(n, i) {
    var o = We(n) || Ae(n) ? Yt(n.length, String) : [], p = o.length, N = !!p;
    for (var P in n)
      z.call(n, P) && !(N && (P == "length" || nn(P, p))) && o.push(P);
    return o;
  }
  function sr(n, i, o) {
    var p = n[i];
    (!(z.call(n, i) && ur(p, o)) || o === void 0 && !(i in n)) && (n[i] = o);
  }
  function Ee(n, i) {
    for (var o = n.length; o--; )
      if (ur(n[o][0], i))
        return o;
    return -1;
  }
  function Ct(n, i) {
    return n && Ue(i, Ye(i), n);
  }
  function He(n, i, o, p, N, P, G) {
    var W;
    if (p && (W = P ? p(n, N, P, G) : p(n)), W !== void 0)
      return W;
    if (!Rt(n))
      return n;
    var J = We(n);
    if (J) {
      if (W = en(n), !i)
        return Zr(n, W);
    } else {
      var X = Lt(n), dt = X == M || X == E;
      if (lr(n))
        return Te(n, i);
      if (X == C || X == c || dt && !P) {
        if (Bt(n))
          return P ? n : {};
        if (W = Pt(dt ? {} : n), !i)
          return Qr(n, Ct(W, n));
      } else {
        if (!U[X])
          return P ? n : {};
        W = rn(n, X, He, i);
      }
    }
    G || (G = new It());
    var bt = G.get(n);
    if (bt)
      return bt;
    if (G.set(n, W), !J)
      var Z = o ? tn(n) : Ye(n);
    return $t(Z || n, function(ft, st) {
      Z && (st = ft, ft = n[st]), sr(W, st, He(ft, i, o, p, st, n, G));
    }), W;
  }
  function Gr(n) {
    return Rt(n) ? Se(n) : {};
  }
  function Yr(n, i, o) {
    var p = i(n);
    return We(n) ? p : Et(p, o(n));
  }
  function Br(n) {
    return rt.call(n);
  }
  function Xr(n) {
    if (!Rt(n) || an(n))
      return !1;
    var i = Ge(n) || Bt(n) ? ct : Dt;
    return i.test(yt(n));
  }
  function Kr(n) {
    if (!or(n))
      return Vt(n);
    var i = [];
    for (var o in Object(n))
      z.call(n, o) && o != "constructor" && i.push(o);
    return i;
  }
  function Te(n, i) {
    if (i)
      return n.slice();
    var o = new n.constructor(n.length);
    return n.copy(o), o;
  }
  function Le(n) {
    var i = new n.constructor(n.byteLength);
    return new q(i).set(new q(n)), i;
  }
  function oe(n, i) {
    var o = i ? Le(n.buffer) : n.buffer;
    return new n.constructor(o, n.byteOffset, n.byteLength);
  }
  function ir(n, i, o) {
    var p = i ? o(re(n), !0) : re(n);
    return Gt(p, Mt, new n.constructor());
  }
  function ar(n) {
    var i = new n.constructor(n.source, kt.exec(n));
    return i.lastIndex = n.lastIndex, i;
  }
  function Vr(n, i, o) {
    var p = i ? o(ne(n), !0) : ne(n);
    return Gt(p, ot, new n.constructor());
  }
  function qr(n) {
    return rr ? Object(rr.call(n)) : {};
  }
  function Jr(n, i) {
    var o = i ? Le(n.buffer) : n.buffer;
    return new n.constructor(o, n.byteOffset, n.length);
  }
  function Zr(n, i) {
    var o = -1, p = n.length;
    for (i || (i = Array(p)); ++o < p; )
      i[o] = n[o];
    return i;
  }
  function Ue(n, i, o, p) {
    o || (o = {});
    for (var N = -1, P = i.length; ++N < P; ) {
      var G = i[N], W = void 0;
      sr(o, G, W === void 0 ? n[G] : W);
    }
    return o;
  }
  function Qr(n, i) {
    return Ue(n, Ht(n), i);
  }
  function tn(n) {
    return Yr(n, Ye, Ht);
  }
  function ce(n, i) {
    var o = n.__data__;
    return sn(i) ? o[typeof i == "string" ? "string" : "hash"] : o.map;
  }
  function xt(n, i) {
    var o = ee(n, i);
    return Xr(o) ? o : void 0;
  }
  var Ht = Y ? Xt(Y, Object) : cn, Lt = Br;
  (qt && Lt(new qt(new ArrayBuffer(1))) != v || Tt && Lt(new Tt()) != m || At && Lt(At.resolve()) != u || we && Lt(new we()) != S || Re && Lt(new Re()) != h) && (Lt = function(n) {
    var i = rt.call(n), o = i == C ? n.constructor : void 0, p = o ? yt(o) : void 0;
    if (p)
      switch (p) {
        case ze:
          return v;
        case ae:
          return m;
        case Fe:
          return u;
        case $e:
          return S;
        case Ne:
          return h;
      }
    return i;
  });
  function en(n) {
    var i = n.length, o = n.constructor(i);
    return i && typeof n[0] == "string" && z.call(n, "index") && (o.index = n.index, o.input = n.input), o;
  }
  function Pt(n) {
    return typeof n.constructor == "function" && !or(n) ? Gr(ht(n)) : {};
  }
  function rn(n, i, o, p) {
    var N = n.constructor;
    switch (i) {
      case y:
        return Le(n);
      case f:
      case b:
        return new N(+n);
      case v:
        return oe(n, p);
      case I:
      case x:
      case g:
      case O:
      case D:
      case j:
      case L:
      case R:
      case F:
        return Jr(n, p);
      case m:
        return ir(n, p, o);
      case T:
      case w:
        return new N(n);
      case l:
        return ar(n);
      case S:
        return Vr(n, p, o);
      case k:
        return qr(n);
    }
  }
  function nn(n, i) {
    return i = i ?? a, !!i && (typeof n == "number" || Ot.test(n)) && n > -1 && n % 1 == 0 && n < i;
  }
  function sn(n) {
    var i = typeof n;
    return i == "string" || i == "number" || i == "symbol" || i == "boolean" ? n !== "__proto__" : n === null;
  }
  function an(n) {
    return !!$ && $ in n;
  }
  function or(n) {
    var i = n && n.constructor, o = typeof i == "function" && i.prototype || Nt;
    return n === o;
  }
  function yt(n) {
    if (n != null) {
      try {
        return H.call(n);
      } catch {
      }
      try {
        return n + "";
      } catch {
      }
    }
    return "";
  }
  function cr(n) {
    return He(n, !0, !0);
  }
  function ur(n, i) {
    return n === i || n !== n && i !== i;
  }
  function Ae(n) {
    return on(n) && z.call(n, "callee") && (!se.call(n, "callee") || rt.call(n) == c);
  }
  var We = Array.isArray;
  function xe(n) {
    return n != null && dr(n.length) && !Ge(n);
  }
  function on(n) {
    return fr(n) && xe(n);
  }
  var lr = mt || un;
  function Ge(n) {
    var i = Rt(n) ? rt.call(n) : "";
    return i == M || i == E;
  }
  function dr(n) {
    return typeof n == "number" && n > -1 && n % 1 == 0 && n <= a;
  }
  function Rt(n) {
    var i = typeof n;
    return !!n && (i == "object" || i == "function");
  }
  function fr(n) {
    return !!n && typeof n == "object";
  }
  function Ye(n) {
    return xe(n) ? Me(n) : Kr(n);
  }
  function cn() {
    return [];
  }
  function un() {
    return !1;
  }
  t.exports = cr;
})(Ir, Ir.exports);
var gi = Ir.exports;
const K = /* @__PURE__ */ xn(gi), Oe = (t) => new Promise((e, r) => {
  const s = new Image();
  console.warn("update cdn config for cors?"), s.onload = () => {
    const a = s.width, c = s.height;
    e({ width: a, height: c });
  }, s.onerror = (a) => {
    r(a);
  }, s.crossOrigin = "anonymous", s.src = t;
}), ls = (t) => new Promise((e, r) => {
  const s = new Audio();
  s.preload = "auto", s.addEventListener("loadedmetadata", () => {
    const a = s.duration * 1e3;
    e({ duration: a });
  }), s.addEventListener("error", (a) => {
    r(a);
  }), s.src = t, s.crossOrigin = "anonymous", s.load();
}), _n = (t) => new Promise((e, r) => {
  const s = document.createElement("video");
  s.preload = "auto", s.addEventListener("loadedmetadata", () => {
    const a = s.duration * 1e3, c = s.videoWidth, d = s.videoHeight;
    e({ duration: a, width: c, height: d });
  }), s.addEventListener("error", (a) => {
    r(a);
  }), s.src = t, s.load();
}), Ii = async (t) => {
  var a, c;
  const e = t.duration, r = (a = t.details) == null ? void 0 : a.width, s = (c = t.details) == null ? void 0 : c.height;
  return e && r && s ? { duration: e, width: r, height: s } : _n(t.details.src);
}, ds = (t, e) => {
  const r = document.createElement("div");
  Object.keys(e).forEach((a) => {
    a !== "height" && (r.style[a] = e[a]);
  }), document.body.appendChild(r), r.textContent = t, r.style.whiteSpace = "normal", r.style.position = "absolute", r.style.visibility = "hidden", r.style.display = "inline-block", r.style.width = e.width + "px", r.style.fontSize = e.fontSize + "px";
  const s = getComputedStyle(r).height;
  return document.body.removeChild(r), parseFloat(s);
}, br = (t) => {
  const e = t.map((r) => new FontFace(r.fontFamily, `url(${r.url})`).load().catch((s) => s));
  return e.length === 0 ? Promise.resolve(!0) : new Promise((r, s) => {
    Promise.all(e).then((a) => {
      a.forEach((c) => {
        c && c.family && (document.fonts.add(c), r(!0));
      });
    }).catch((a) => s(a));
  });
}, bi = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let Xe = (t = 21) => {
  let e = "", r = crypto.getRandomValues(new Uint8Array(t |= 0));
  for (; t--; )
    e += bi[r[t] & 63];
  return e;
};
function De(t = 16) {
  const e = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", r = e.charAt(Math.floor(Math.random() * e.length));
  let s = Xe(t - 1);
  return s = s.replace(/[^a-zA-Z0-9]/g, "").slice(0, t - 1), r + s;
}
function vi(t) {
  const e = /#([0-9a-fA-F]{3,6})\b/g, r = /rgb\(\s*(\d+),\s*(\d+),\s*(\d+)\s*\)/g, s = /rgba\(\s*(\d+),\s*(\d+),\s*(\d+),\s*([0-9.]+)\s*\)/g;
  function a(d) {
    return d.length === 3 ? `#${d[0]}${d[0]}${d[1]}${d[1]}${d[2]}${d[2]}`.toUpperCase() : `#${d.toUpperCase()}`;
  }
  function c(d, f, b) {
    return `#${(1 << 24 | d << 16 | f << 8 | b).toString(16).slice(1).toUpperCase()}`;
  }
  return t = t.replace(e, (d, f) => a(f)), t = t.replace(
    r,
    (d, f, b, _) => c(+f, +b, +_)
  ), t = t.replace(
    s,
    (d, f, b, _) => c(+f, +b, +_)
  ), t;
}
function it(t) {
  return /^#[0-9a-fA-F]{3}$/.test(t) ? "#" + t[1] + t[1] + t[2] + t[2] + t[3] + t[3] : t;
}
function Wn(t, e) {
  let r = t;
  for (const s in e)
    if (Object.prototype.hasOwnProperty.call(e, s)) {
      const a = new RegExp(s, "g");
      r = r.replace(a, e[s]);
    }
  return r;
}
function fs(t) {
  const e = t.getAttribute("fill");
  if (e && e.trim() !== "" && e.trim() !== "none")
    return e.trim();
  const r = t.getAttribute("style");
  if (r) {
    const a = /fill\s*:\s*([^;]+);?/.exec(r);
    if (a) {
      const c = a[1].trim();
      if (c !== "" && c !== "none")
        return c;
    }
  }
  const s = t.parentElement;
  return s ? fs(s) : null;
}
function Be(t) {
  return /^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6})$/.test(t);
}
const _i = (t) => {
  const e = `.${t.split(".").filter((c) => c.includes("fill:")).join(".")}`, r = {}, s = /\.([\w-]+)\s*\{\s*([^}]+)\s*\}/g;
  let a;
  for (; (a = s.exec(e)) !== null; ) {
    const c = a[1], d = a[2], f = {}, b = /fill\s*:\s*([^;]+);?/.exec(d), _ = /stroke\s*:\s*([^;]+);?/.exec(d);
    b && (f.fill = it(b[1].trim())), _ && (f.stroke = it(_[1].trim())), r[c] = f;
  }
  return r;
};
function dn(t) {
  let e = t.parentElement;
  for (; e; ) {
    if (e.tagName.toLowerCase() === "mask")
      return !0;
    e = e.parentElement;
  }
  return !1;
}
function ki(t, e, r = 300, s = 300) {
  const a = [], d = new DOMParser().parseFromString(t, "image/svg+xml"), f = d.documentElement;
  f.setAttribute("width", `${r}`), f.setAttribute("height", `${s}`);
  const b = f.querySelectorAll("style"), _ = {};
  b.forEach((u) => {
    const l = u.textContent || "", S = _i(l);
    Object.assign(_, S);
    const w = l.replace(/\.(st[\w-]+)/g, `.${e}-$1`).replace(/url\(#(.*?)\)/g, `url(#${e}-$1)`);
    u.textContent = w;
    const k = Array.from(d.querySelectorAll("*")), h = /* @__PURE__ */ new Set();
    k.forEach((y) => {
      if (dn(y)) return;
      ["fill", "stroke", "stop-color"].forEach((x) => {
        const g = y.getAttribute(x);
        g && !["none", "transparent"].includes(g) && h.add(it(g));
      });
      const v = y.getAttribute("style");
      if (v) {
        const x = /fill\s*:\s*([^;]+);?/.exec(v), g = /stroke\s*:\s*([^;]+);?/.exec(v), O = /stop-color\s*:\s*([^;]+);?/.exec(v);
        if (x) {
          const D = x[1].trim();
          D && !["none", "transparent"].includes(D) && Be(it(D)) && h.add(it(D));
        }
        if (g) {
          const D = g[1].trim();
          D && !["none", "transparent"].includes(D) && Be(it(D)) && h.add(it(D));
        }
        if (O) {
          const D = O[1].trim();
          D && !["none", "transparent"].includes(D) && Be(it(D)) && h.add(it(D));
        }
      }
      const I = y.getAttribute("class");
      I && I.split(" ").forEach((x) => {
        const g = _[x];
        g != null && g.fill && !["none", "transparent"].includes(g.fill) && h.add(it(g.fill)), g != null && g.stroke && !["none", "transparent"].includes(g.stroke) && h.add(it(g.stroke));
      });
    }), Array.from(h).forEach((y) => {
      Be(y) && a.push(y);
    });
  });
  const M = Array.from(d.querySelectorAll("*")), E = /* @__PURE__ */ new Set();
  return M.forEach((u) => {
    if (dn(u)) return;
    const l = u.getAttribute("class");
    if (l) {
      const w = l.split(" ").map((k) => `${e}-${k}`).join(" ");
      u.setAttribute("class", w), w.split(" ").forEach((k) => {
        const h = _[k];
        h != null && h.fill && !["none", "transparent"].includes(h.fill) && E.add(it(h.fill)), h != null && h.stroke && !["none", "transparent"].includes(h.stroke) && E.add(it(h.stroke));
      });
    }
    ["fill", "stroke", "stop-color"].forEach((w) => {
      const k = u.getAttribute(w);
      k && !["none", "transparent"].includes(k) && E.add(it(k));
    });
    const S = u.getAttribute("style");
    if (S) {
      const w = /fill\s*:\s*([^;]+);?/.exec(S), k = /stroke\s*:\s*([^;]+);?/.exec(S), h = /stop-color\s*:\s*([^;]+);?/.exec(S);
      if (w) {
        const y = w[1].trim();
        y && !["none", "transparent"].includes(y) && E.add(it(y));
      }
      if (k) {
        const y = k[1].trim();
        y && !["none", "transparent"].includes(y) && E.add(it(y));
      }
      if (h) {
        const y = h[1].trim();
        y && !["none", "transparent"].includes(y) && E.add(it(y));
      }
    }
  }), E.forEach(
    (u) => !a.includes(u) && Be(u) && a.push(u)
  ), Array.from(d.querySelectorAll("*")).forEach((u) => {
    if (u.hasAttribute("id")) {
      const l = u.getAttribute("id");
      u.setAttribute("id", `${e}-${l}`);
    }
    if (["fill", "stroke", "stop-color", "filter", "clip-path", "mask"].forEach(
      (l) => {
        const S = u.getAttribute(l);
        S && S.includes("url(#") && u.setAttribute(
          l,
          S.replace(/url\(#(.*?)\)/g, `url(#${e}-$1)`)
        );
      }
    ), u.hasAttribute("style")) {
      const l = u.getAttribute("style");
      l.includes("url(#") && u.setAttribute(
        "style",
        l.replace(/url\(#(.*?)\)/g, `url(#${e}-$1)`)
      );
    }
  }), Array.from(d.querySelectorAll("path")).forEach((u) => {
    if (dn(u)) return;
    !fs(u) && !u.getAttribute("class") && (u.setAttribute("fill", "#000000"), a.includes("#000000") || a.push("#000000"));
  }), { serializer: new XMLSerializer().serializeToString(d), colors: a };
}
const wr = {
  color: "#000000",
  x: 0,
  y: 0,
  blur: 0
}, ve = (t, e) => {
  let r = e != null && e.trim ? e.trim.to - e.trim.from : (e == null ? void 0 : e.duration) || 5e3;
  const s = {
    from: 0,
    to: r
  };
  if (!t)
    return s;
  if (t.from < 0)
    return console.error(
      "'from' must be a non-negative number. Returning default display."
    ), s;
  if (t.from !== void 0 && t.to === void 0)
    return {
      from: t.from,
      to: t.from + r
    };
  if (t.to !== void 0) {
    if (t.to < 0)
      return console.error(
        "'to' must be a non-negative number. Returning default display."
      ), s;
    if (t.to < t.from)
      return console.error(
        "'to' must be greater than or equal to 'from'. Returning default display."
      ), s;
  }
  return t;
}, ps = (t, e) => t ? t.from && !t.to ? {
  from: t.from,
  to: e.duration
} : t : {
  from: 0,
  to: e.duration
};
function te(t, e) {
  const r = t.scaleMode, s = {
    x: t.size.width / 2,
    y: t.size.height / 2
  }, a = { x: e.width / 2, y: e.height / 2 };
  let c;
  r === "fill" ? c = Math.max(
    t.size.width / e.width,
    t.size.height / e.height
  ) : c = Math.min(
    t.size.width / e.width,
    t.size.height / e.height
  );
  const d = s.x - a.x;
  return {
    top: `${s.y - a.y}px`,
    left: `${d}px`,
    transform: `scale(${c})`
  };
}
const hs = async (t, e) => {
  const r = t.details.src, s = await Ii(t), a = te(e, {
    ...s
  }), c = ps(t.trim, { duration: s.duration }), d = {
    width: s.width,
    height: s.height,
    opacity: 100,
    src: r,
    volume: t.details.volume ?? 100,
    // Default volume
    borderRadius: t.details.borderRadius ?? 0,
    // Default border radius
    borderWidth: t.details.borderWidth ?? 0,
    // Default border width
    borderColor: t.details.borderColor || "#000000",
    // Default border color
    boxShadow: t.details.boxShadow || wr,
    top: t.details.top || a.top || "0px",
    // Default top
    left: t.details.left || a.left || "0px",
    // Default left
    transform: t.details.transform || a.transform,
    // Default transform
    blur: t.details.blur || 0,
    brightness: t.details.brightness || 100,
    flipX: t.details.flipX || !1,
    flipY: t.details.flipY || !1,
    rotate: t.details.rotate || "0deg",
    visibility: t.details.visibility || "visible"
  };
  return {
    ...t,
    trim: c,
    type: "video",
    name: "video",
    details: d,
    playbackRate: t.playbackRate || 1,
    display: ve(t.display, { duration: s.duration, trim: c }),
    duration: s.duration
  };
}, ms = async (t) => {
  const e = t.id, r = t.details, a = (await ls(r.src)).duration, c = ps(t.trim, { duration: a });
  return {
    id: e,
    name: t.name || "audio",
    type: "audio",
    display: ve(t.display, { duration: a, trim: c }),
    trim: c,
    playbackRate: t.playbackRate || 1,
    details: {
      src: r.src,
      volume: r.volume ?? 100
      // Default volume
    },
    metadata: { ...t.metadata },
    duration: a
  };
}, ys = async (t, e) => {
  var E;
  const r = t.trackItemIds, s = t.size || {
    width: t.details.width,
    height: t.details.height
  }, a = Math.min(
    e.size.width / s.width,
    e.size.height / s.height
  ), c = ((E = t.details) == null ? void 0 : E.rotate) || 0, d = te(e, s), f = t.display;
  let b = 1 / 0, _ = 0;
  r.forEach((m) => {
    const T = t.trackItemsMap[m];
    T.display.from < b && (b = T.display.from), T.display.to > _ && (_ = T.display.to);
  });
  const M = t.trim || t.display || { from: b, to: _ };
  return {
    id: t.id,
    type: "template",
    details: {
      ...s,
      top: t.details.top || d.top,
      left: t.details.left || d.left,
      scale: a,
      rotate: c
    },
    trim: M,
    display: f || { from: b, to: _ },
    activeEdit: !1
  };
}, Si = async (t, e) => {
  var M;
  const r = t.trackItemIds, s = t.size || {
    width: t.details.width,
    height: t.details.height
  }, a = Math.min(
    e.size.width / s.width,
    e.size.height / s.height
  ), c = ((M = t.details) == null ? void 0 : M.rotate) || 0, d = te(e, s), f = t.display;
  let b = 1 / 0, _ = 0;
  return r.forEach((E) => {
    const m = t.trackItemsMap[E];
    m.display.from < b && (b = m.display.from), m.display.to > _ && (_ = m.display.to);
  }), {
    id: t.id,
    type: "composition",
    details: {
      ...s,
      top: t.details.top || d.top,
      left: t.details.left || d.left,
      scale: a,
      rotate: c
    },
    display: f || { from: b, to: _ }
  };
}, Gn = async (t, e) => {
  const r = t.details, s = Oe(r.src), a = fetch(r.src), [c, d] = await Promise.all([
    s,
    a
  ]), f = await d.text(), b = te(e, c), { serializer: _, colors: M } = ki(
    vi(f),
    t.id,
    parseFloat(r.width || c.width),
    parseFloat(r.height || c.height)
  ), E = t.details.colorMap || Object.fromEntries(M.map((m) => [m, m]));
  return {
    id: t.id,
    name: "illustration",
    type: t.type,
    display: ve(t.display),
    playbackRate: t.playbackRate || 1,
    details: {
      src: r.src || "",
      // Default source URL
      width: r.width || c.width || 100,
      // Default width
      height: r.height || c.height || 100,
      // Default height
      opacity: r.opacity ?? 100,
      // Default opacity
      transform: r.transform || b.transform,
      // Default transform
      border: r.border || "none",
      // Default border
      borderRadius: r.borderRadius || 0,
      // Default border radius
      top: r.top || b.top || "0px",
      // Default top
      left: r.left || b.left || "0px",
      // Default left
      borderWidth: r.borderWidth ?? 0,
      // Default border width
      borderColor: r.borderColor || "#000000",
      // Default border color
      flipX: r.flipX || !1,
      flipY: r.flipY || !1,
      rotate: r.rotate || "0deg",
      visibility: r.visibility || "visible",
      svgString: _,
      initialSvgString: K(_),
      colorMap: E
    },
    metadata: t.metadata || {}
  };
}, wi = async (t, e) => {
  const r = t.details, s = Oe(r.src), [a] = await Promise.all([s]), c = te(e, a);
  return {
    id: t.id,
    name: "shape",
    type: t.type,
    display: ve(t.display),
    playbackRate: t.playbackRate || 1,
    details: {
      src: r.src || "",
      // Default source URL
      width: r.width || a.width || 100,
      // Default width
      height: r.height || a.height || 100,
      // Default height
      opacity: r.opacity ?? 100,
      // Default opacity
      transform: r.transform || c.transform,
      // Default transform
      border: r.border || "none",
      // Default border
      borderRadius: r.borderRadius || 0,
      // Default border radius
      top: r.top || c.top || "0px",
      // Default top
      left: r.left || c.left || "0px",
      // Default left
      borderWidth: r.borderWidth ?? 0,
      // Default border width
      borderColor: r.borderColor || "#000000",
      // Default border color
      flipX: r.flipX || !1,
      flipY: r.flipY || !1,
      rotate: r.rotate || "0deg",
      visibility: r.visibility || "visible",
      backgroundColor: r.backgroundColor || "#808080"
    },
    metadata: t.metadata || {}
  };
}, gs = async (t, e) => {
  const r = t.details, s = await Oe(r.src), a = te(e, s);
  return {
    id: t.id,
    type: "image",
    name: "image",
    display: ve(t.display),
    playbackRate: t.playbackRate || 1,
    details: {
      src: r.src || "",
      // Default source URL
      width: r.width || s.width || 100,
      // Default width
      height: r.height || s.height || 100,
      // Default height
      opacity: r.opacity ?? 100,
      // Default opacity
      transform: r.transform || a.transform,
      // Default transform
      border: r.border || "none",
      // Default border
      borderRadius: r.borderRadius || 0,
      // Default border radius
      boxShadow: r.boxShadow || wr,
      // Default box shadow
      top: r.top || a.top || "0px",
      // Default top
      left: r.left || a.left || "0px",
      // Default left
      borderWidth: r.borderWidth ?? 0,
      // Default border width
      borderColor: r.borderColor || "#000000",
      // Default border color
      blur: r.blur || 0,
      brightness: r.brightness || 100,
      flipX: r.flipX || !1,
      flipY: r.flipY || !1,
      rotate: r.rotate || "0deg",
      visibility: r.visibility || "visible"
    },
    metadata: t.metadata || {}
  };
}, Is = async (t, e) => {
  const r = t;
  r.details.fontUrl && await br([
    {
      fontFamily: r.details.fontFamily,
      url: r.details.fontUrl
    }
  ]);
  const s = r.id, a = r.details, c = vs(a), d = ds(r.details.text, c), f = te(e, {
    width: c.width,
    height: d
  });
  return {
    id: s,
    name: "caption",
    type: "caption",
    display: ve(r.display),
    details: {
      ...c,
      text: a.text || "",
      // Default text content
      height: d,
      // Default height
      fontUrl: a.fontUrl,
      top: c.top || f.top,
      left: c.left || f.left,
      borderWidth: a.borderWidth || 0,
      borderColor: a.borderColor || "#000000",
      boxShadow: a.boxShadow || wr,
      words: a.words || [],
      appearedColor: a.appearedColor || a.color,
      activeColor: a.activeColor || a.color,
      activeFillColor: a.activeFillColor || "transparent"
    },
    metadata: t.metadata || {}
  };
}, bs = async (t, e) => {
  t.details.fontUrl && await br([
    {
      fontFamily: t.details.fontFamily,
      url: t.details.fontUrl
    }
  ]);
  const r = t.id, s = t.details, a = vs(s), c = ds(t.details.text, a), d = te(e, {
    width: a.width,
    height: c
  });
  return {
    id: r,
    name: "text",
    type: "text",
    display: ve(t.display),
    details: {
      ...a,
      text: s.text || "",
      // Default text content
      height: c,
      // Default height
      fontUrl: s.fontUrl,
      top: a.top || d.top,
      left: a.left || d.left,
      borderWidth: s.borderWidth || 0,
      borderColor: s.borderColor || "#000000",
      boxShadow: s.boxShadow || wr
    },
    metadata: {}
  };
}, vs = (t) => ({
  fontFamily: t.fontFamily || "Arial",
  // Default font family
  fontSize: t.fontSize || "16px",
  // Default font size
  fontWeight: t.fontWeight || "normal",
  // Default font weight
  fontStyle: t.fontStyle || "normal",
  // Default font style
  textDecoration: t.textDecoration || "none",
  // Default text decoration
  textAlign: t.textAlign || "left",
  // Default text alignment
  lineHeight: t.lineHeight || "normal",
  // Default line height
  letterSpacing: t.letterSpacing || "normal",
  // Default letter spacing
  wordSpacing: t.wordSpacing || "normal",
  // Default word spacing
  color: t.color || "#ffffff",
  // Default text color (black)
  backgroundColor: t.backgroundColor || "transparent",
  // Default background color
  border: t.border || "none",
  // Default border
  textShadow: t.textShadow || "none",
  // Default text shadow
  text: t.text || "",
  // Default text content
  opacity: t.opacity ?? 100,
  // Default opacity
  width: t.width || 300,
  wordWrap: t.wordWrap || "normal",
  //'break-word'
  wordBreak: t.wordBreak || "normal",
  //'break-all',
  WebkitTextStrokeColor: t.WebkitTextStrokeColor || "#ffffff",
  WebkitTextStrokeWidth: t.WebkitTextStrokeWidth || "0px",
  top: t.top,
  left: t.left,
  textTransform: t.textTransform || "none",
  transform: t.transform || "none",
  skewX: t.skewX || 0,
  skewY: t.skewY || 0
}), Mi = async (t, e) => {
  switch (t.type) {
    case "video":
      return hs(t, e || {});
    case "audio":
      return ms(t);
    case "image":
      return gs(t, e || {});
    case "text":
      return bs(t, e || {});
    case "caption":
      return Is(t, e || {});
    case "template":
      return ys(t, {
        size: e == null ? void 0 : e.size
      });
    default:
      throw new Error("Unsupported track item");
  }
};
function Ei(t, e) {
  return e.some(
    (r) => t.some((s) => s.id === r.id)
  );
}
const Ti = (t = [], e = []) => t.length === 0 ? e.map((s) => ({
  id: De(),
  items: [s.id],
  type: s.type,
  accepts: ["text", "image", "video", "audio", "caption", "template"]
})) : t.map((r) => ({
  ...r,
  items: r.items || [],
  accepts: ["audio", "video", "image", "text", "caption", "template"],
  type: r.type || "text",
  magnetic: r.magnetic || !1,
  static: r.static || !1,
  id: r.id || De()
}));
function Ai(t, e) {
  return t.filter((s) => {
    if (e.forEach((a) => {
      s.items.includes(a) && (s.items = s.items.filter((c) => c !== a));
    }), s.items.length !== 0 || s.static)
      return s;
  });
}
const he = (t) => Object.keys(t).reduce((e, r) => {
  const { display: s, playbackRate: a } = t[r];
  return Math.max(e, s.to / (a || 1));
}, 0);
function kn(t, e, r) {
  return Math.min(Math.max(t, e), r);
}
const xi = (t, e, r, s, a) => {
  if (s === void 0 && a === void 0)
    return { trackId: void 0, trackIndex: void 0 };
  const c = a !== void 0 ? e[kn(a, 0, e.length)] : e.find((b) => b.id === s);
  if (!c)
    return {
      trackId: void 0,
      trackIndex: a !== void 0 ? kn(a, 0, e.length) : void 0
    };
  const d = c.items.map((b) => r[b]), f = t.map((b) => r[b]);
  for (const b of d) {
    const _ = b.display.from, M = b.display.to;
    for (const E of f) {
      const m = E.display.from;
      if (!(E.display.to <= _ || m >= M))
        return {
          trackId: void 0,
          trackIndex: e.indexOf(c)
        };
    }
  }
  return {
    trackId: c.id,
    trackIndex: e.indexOf(c)
  };
}, Yn = (t, e) => {
  var f, b;
  const r = ((f = t.details.crop) == null ? void 0 : f.width) || t.details.width || 0, s = ((b = t.details.crop) == null ? void 0 : b.height) || t.details.height || 0;
  let a = e.width, c = e.height;
  const d = e.width / e.height;
  return r / s > d ? (a = r, c = r / d) : (c = s, a = s * d), {
    newWidth: a,
    newHeight: c,
    crop: {
      x: 0,
      y: 0,
      height: s,
      width: r
    }
  };
}, Bn = (t, e) => {
  const r = K(t.trim), s = K(t.display);
  return e.duration < t.display.to && (s.to = e.duration, r && (r.to = e.duration)), {
    duration: e.duration,
    trim: r,
    display: s
  };
}, Di = (t) => {
  const { trackItemIds: e, transitionsMap: r, trackItemsMap: s } = t, a = /* @__PURE__ */ new Map();
  Object.values(r).forEach((_) => {
    var T, C;
    const { fromId: M, toId: E, kind: m } = _;
    m !== "none" && (a.has(M) || a.set(M, []), a.has(E) || a.set(E, []), (T = a.get(M)) == null || T.push(_), (C = a.get(E)) == null || C.push(_));
  });
  const c = [], d = /* @__PURE__ */ new Set(), f = (_) => {
    const M = [];
    let E = _;
    for (; E && !d.has(E); ) {
      d.add(E);
      const m = s[E];
      M.push(m);
      const T = Object.values(r).find(
        (C) => C.fromId === E && C.kind !== "none"
        // Filter here
      );
      if (!T) break;
      M.push(T), E = T.toId;
    }
    return M;
  }, b = Object.values(r).filter(
    (_) => _.kind !== "none"
  );
  for (const _ of e)
    if (!d.has(_) && (!a.has(_) || !b.some((M) => M.toId === _))) {
      const M = f(_);
      M.length > 0 && c.push(M);
    }
  return c.forEach((_) => {
    _.sort((M, E) => "display" in M && "display" in E ? M.display.from - E.display.from : 0);
  }), c.filter((_) => _.filter((E) => E !== void 0).length > 0);
};
function Xn(t, e, r) {
  t.forEach((s) => {
    const d = Object.values(e).filter(
      (_) => s.items.includes(_.id)
    ).sort(
      (_, M) => _.display.from - M.display.from
    ).map((_) => _.id), f = Di({
      trackItemIds: d,
      transitionsMap: r,
      trackItemsMap: e
    });
    let b = 0;
    d.forEach((_) => {
      const M = [];
      for (const m of f)
        if (m.find((T) => T.id === _)) {
          const T = f.findIndex(
            (C) => C.find((u) => u.id === _)
          );
          if (T - 1 >= 0)
            for (let C = T - 1; C >= 0; C--) {
              const u = f[C];
              M.push(u);
            }
        }
      let E = 0;
      if (M.forEach((m) => {
        m.forEach((T) => {
          T.type === "transition" && (E += T.duration);
        });
      }), e[_]) {
        const m = e[_].display.to - e[_].display.from;
        e[_].display = {
          from: b - E,
          to: b + m - E
        }, b += m;
      }
    });
  });
}
function Oi(t, e) {
  let s = e.reduce(
    (a, c) => c.display.to > a.display.to ? c : a,
    { display: { to: 0 } }
  ).display.to;
  t.forEach((a) => {
    const c = a.display.from, f = a.display.to - c;
    a.display.from = s, a.display.to = a.display.from + f, s = a.display.to;
  });
}
function Ci(t) {
  const e = t, r = e.tracks, s = e.trackItemsMap, a = [], c = {}, d = e.structure;
  return r.forEach((f) => {
    var _;
    const b = f.items.map((M) => s[M]).sort((M, E) => M.display.from - E.display.from);
    for (let M = 0; M < b.length - 1; M++) {
      const E = b[M], m = b[M + 1];
      if (Math.abs(E.display.to - m.display.from) <= 1) {
        const T = `${E.id}-${m.id}`;
        if ((_ = e.transitionIds) == null ? void 0 : _.includes(T))
          c[T] = e.transitionsMap[T];
        else {
          const u = {
            id: T,
            duration: 1500,
            fromId: E.id,
            toId: m.id,
            kind: "none",
            trackId: f.id,
            type: "transition"
          };
          c[T] = u;
        }
        a.push(T);
      }
    }
  }), d.forEach((f) => {
    f.transitions.forEach((b) => {
      c[b] = {
        ...e.transitionsMap[b],
        trackId: f.id
      };
    });
  }), e.transitionIds = a, e.transitionsMap = c, {
    transitionIds: a,
    transitionsMap: c
  };
}
function Pi(t, e, r) {
  const s = t.toId, a = r[s], c = e.find((d) => d.items.includes(s));
  c && (c.magnetic || c.items.forEach((d) => {
    const f = r[d];
    f.display.from > a.display.from && (f.display.from = f.display.from + t.duration, f.display.to = f.display.to + t.duration);
  }));
}
function Ri(t) {
  const e = de.pipe(
    fe(({ key: u }) => u.startsWith(Dn))
  ), r = de.pipe(
    fe(({ key: u }) => u.startsWith(gt))
  ), s = de.pipe(
    fe(({ key: u }) => u.startsWith(pt))
  ), a = de.pipe(
    fe(({ key: u }) => u.startsWith(Sr))
  ), c = de.pipe(
    fe(({ key: u }) => u.startsWith(Ce))
  ), d = de.pipe(
    fe(({ key: u }) => u.startsWith(be))
  ), f = de.pipe(
    fe(({ key: u }) => u.startsWith(us))
  ), b = e.subscribe(async (u) => {
    var l, S;
    if (u.key === Xs) {
      const w = (l = u.value) == null ? void 0 : l.payload, k = w.trackItemsMap, h = w.trackItemDetailsMap;
      console.warn("IMPROVE FONTS LOADING");
      for (const v in h)
        if (h[v].type === "text" || h[v].type === "caption") {
          const I = h[v].details;
          await br([
            {
              fontFamily: I.fontFamily,
              url: I.fontUrl
            }
          ]);
        } else if (h[v].type === "illustration") {
          const I = k[v], x = h[v].details, g = await Gn(
            { ...I, details: x },
            {
              size: { width: x.width, height: x.height }
            }
          ), O = Wn(
            g.details.svgString,
            x.colorMap
          );
          g.details.svgString = O, h[v].details = g.details, k[v] = g;
        }
      const y = he(k);
      t.updateState(
        {
          ...w,
          duration: y
        },
        {
          kind: "design:load",
          updateHistory: !1
        }
      );
    }
    if (u.key === Ks) {
      const w = (S = u.value) == null ? void 0 : S.payload;
      t.updateState(
        {
          size: w
        },
        {
          kind: "design:resize",
          updateHistory: !1
        }
      );
    }
  }), _ = a.subscribe((u) => {
    if (u.key === hi) return t.undo();
    if (u.key === mi) return t.redo();
  }), M = f.subscribe((u) => {
    var l;
    if (u.key === yi) {
      const S = (l = u.value) == null ? void 0 : l.payload.scale;
      t.updateState(
        {
          scale: S
        },
        {
          kind: "update",
          updateHistory: !1
        }
      );
    }
  }), E = s.subscribe(async (u) => {
    var S, w, k, h, y;
    const l = [];
    if ((S = u.value) != null && S.payload.trackItemIds && (l.push((w = u.value) == null ? void 0 : w.payload.trackItemIds), t.updateState(
      { activeIds: l },
      {
        kind: "update",
        updateHistory: !1
      }
    )), u.key === fi) {
      const v = (k = u.value) == null ? void 0 : k.payload.trackItemIds, I = K(t.getState()), x = v && v.length ? v : I.activeIds, g = x.map((A) => I.trackItemsMap[A]).filter((A) => !!A).map((A) => A.id), O = I.transitionIds.filter(
        (A) => {
          const et = I.transitionsMap[A];
          return g.includes(et.fromId) || g.includes(et.toId);
        }
      );
      g.push(...O);
      const D = {}, j = I.trackItemIds, L = I.transitionIds, R = I.trackItemDetailsMap, F = K(I.tracks), V = K(I.structure);
      g.forEach((A) => {
        var Mt;
        const et = I.trackItemsMap[A] || I.transitionsMap[A];
        if (et.type === "template") {
          const ot = (Mt = I.structure.find(
            (Et) => Et.id === et.id
          )) == null ? void 0 : Mt.items;
          g.push(...ot);
          const $t = V.findIndex(
            (Et) => Et.id === et.id
          );
          V.splice($t, 1);
        }
      }), g.forEach((A) => {
        V.forEach((et) => {
          et.items.includes(A) && (et.items = et.items.filter((Mt) => Mt !== A));
        });
      });
      const kt = j.filter(
        (A) => !g.includes(A)
      );
      L.forEach((A) => {
        x.includes(A) && x.length === 1 && (D[A] = K(I.transitionsMap[A]));
      });
      const Dt = L.filter(
        (A) => !g.includes(A) && !x.includes(A)
      ), Ot = Object.fromEntries(
        Object.entries(R).filter(
          ([A]) => !g.includes(A)
        )
      ), U = Object.fromEntries(
        Object.entries(I.transitionsMap).filter(
          ([A]) => !g.includes(A)
        )
      );
      Object.keys(U).forEach((A) => {
        x.includes(A) && (U[A].kind = "none");
      });
      const zt = Ai(
        I.tracks,
        g
      ), wt = Object.fromEntries(
        Object.entries(I.trackItemsMap).filter(
          ([A]) => !g.includes(A)
        )
      ), at = F.filter((A) => A.magnetic);
      Xn(
        at,
        wt,
        I.transitionsMap
      );
      const Ft = he(wt);
      Object.keys(D).forEach((A) => {
        Pi(
          D[A],
          zt,
          wt
        );
      }), t.updateState(
        {
          trackItemIds: kt,
          trackItemDetailsMap: Ot,
          activeIds: [],
          trackItemsMap: wt,
          tracks: zt,
          duration: Ft,
          structure: V,
          transitionIds: Dt,
          transitionsMap: U
        },
        { updateHistory: !0, kind: "remove" }
      );
    }
    if (u.key === di) {
      const v = K(t.getState()), I = {}, x = ((h = u.value) == null ? void 0 : h.payload.trackItemIds) || v.activeIds;
      if (x.length === 0) return;
      x.forEach((O) => {
        const D = v.trackItemsMap[O], j = v.trackItemDetailsMap[O], L = De();
        v.trackItemsMap[L] = {
          ...K(D),
          id: L
        }, v.trackItemDetailsMap[L] = {
          ...K(j)
        }, v.trackItemIds.push(L);
        const R = v.tracks.find(
          (F) => F.items.includes(O)
        );
        I[R.id] ? I[R.id].items.push(L) : I[R.id] = {
          ...R,
          id: De(),
          items: [L],
          static: !1,
          magnetic: !1
        };
      });
      const g = Object.values(I);
      v.tracks = [...g, ...v.tracks], t.updateState(
        {
          trackItemDetailsMap: v.trackItemDetailsMap,
          tracks: v.tracks,
          trackItemIds: v.trackItemIds,
          trackItemsMap: v.trackItemsMap
        },
        {
          updateHistory: !0,
          kind: "update"
        }
      );
    }
    if (u.key === pi) {
      const v = (y = u.value) == null ? void 0 : y.payload, I = Object.keys(v)[0], x = Object.values(v)[0], g = K(t.getState()), O = g.trackItemDetailsMap[I], D = K(g.trackItemsMap[I]), j = O.details;
      if (!x.details.src) return;
      if (O.type === "image") {
        const L = await Oe(x.details.src), { crop: R, newHeight: F, newWidth: V } = Yn(
          O,
          L
        );
        x.details.crop = R, x.details.height = F, x.details.width = V;
      } else if (O.type === "video") {
        const L = await _n(x.details.src), R = g.trackItemsMap[I], { display: F, duration: V, trim: kt } = Bn(R, L), { crop: Dt, newHeight: Ot, newWidth: U } = Yn(
          O,
          L
        );
        x.details.crop = Dt, x.details.height = Ot, x.details.width = U, D.display = F, D.duration = V, D.trim = kt;
      } else if (O.type === "audio") {
        const L = await ls(x.details.src), R = g.trackItemsMap[I], { display: F, duration: V, trim: kt } = Bn(R, L);
        D.display = F, D.duration = V, D.trim = kt;
      }
      O.details = { ...j, ...x.details }, g.trackItemDetailsMap[I] = { ...O }, g.trackItemsMap[I] = { ...D }, t.updateState(
        {
          trackItemDetailsMap: g.trackItemDetailsMap,
          trackItemsMap: g.trackItemsMap
        },
        {
          updateHistory: !0,
          kind: "update:details"
        }
      );
    }
  }), m = r.subscribe(async (u) => {
    var g, O, D, j, L, R, F, V, kt, Dt, Ot, U, zt, wt, at, Ft, A, et, Mt, ot, $t, Et, Gt, Yt, ee, Bt, re, Xt, ne, _e, ke, Nt, Kt;
    const l = K(t.getState()), S = ((O = (g = u.value) == null ? void 0 : g.options) == null ? void 0 : O.isSelected) || !1, w = (j = (D = u.value) == null ? void 0 : D.options) == null ? void 0 : j.scaleMode, k = (R = (L = u.value) == null ? void 0 : L.options) == null ? void 0 : R.isNewTrack;
    let h = [], y = "text";
    const v = (V = (F = u.value) == null ? void 0 : F.options) == null ? void 0 : V.trackId;
    let I = (Dt = (kt = u.value) == null ? void 0 : kt.options) == null ? void 0 : Dt.trackIndex;
    if (u.key === ei) {
      const $ = (Ot = u.value) == null ? void 0 : Ot.payload;
      let H = l.trackItemsMap[$.id].animations;
      H ? H.in && $.animations.in ? H.in = $.animations.in : H.out && $.animations.out || !H.out && $.animations.out ? H.out = $.animations.out : !H.in && $.animations.in ? H.in = $.animations.in : H = $.animations : l.trackItemsMap[$.id].animations = $.animations;
    }
    if (u.key === si) {
      const $ = (U = u.value) == null ? void 0 : U.payload, H = $.trackItems.map(
        (Y) => Mi(Y, {
          size: l.size
        })
      ), z = await Promise.all(H), rt = Ti($.tracks, $.trackItems), ct = [];
      $.trackItems.forEach((Y) => {
        if (Y.type !== "template") return;
        l.trackItemsMap = {
          ...l.trackItemsMap,
          ...Y.trackItemsMap
        }, l.trackItemDetailsMap = {
          ...l.trackItemDetailsMap,
          ...Y.trackItemDetailsMap
        }, l.transitionsMap = {
          ...l.transitionsMap,
          ...Y.transitionsMap
        };
        const mt = {
          id: Y.id,
          items: Y.trackItemIds,
          transitions: Y.transitionsIds || [],
          tracks: Y.tracks
        };
        ct.push(mt);
      });
      const B = [], ut = {}, q = {};
      if (z.forEach((Y) => {
        const { details: mt, ...Vt } = Y;
        B.push(Y.id), ut[Y.id] = {
          type: Y.type,
          details: mt
        }, q[Y.id] = Vt;
      }), Ei(
        l.tracks,
        rt
      ))
        l.tracks.forEach((Y) => {
          rt.forEach((mt) => {
            if (Y.id === mt.id) {
              if (Y.magnetic) {
                const Vt = mt.items.map((Tt) => q[Tt]), qt = Y.items.map(
                  (Tt) => l.trackItemsMap[Tt]
                );
                Oi(
                  Vt,
                  qt
                );
              }
              Y.items.push(...B);
            }
          });
        });
      else {
        const Y = ((wt = (zt = u.value) == null ? void 0 : zt.options) == null ? void 0 : wt.trackIndex) || 0, mt = kn(
          Y,
          0,
          l.tracks.length
        );
        l.tracks.splice(mt, 0, ...rt);
      }
      l.trackItemDetailsMap = {
        ...l.trackItemDetailsMap,
        ...ut
      }, l.trackItemsMap = {
        ...l.trackItemsMap,
        ...q
      }, l.trackItemIds = [
        ...l.trackItemIds,
        ...B
      ], l.structure = [...l.structure, ...ct], l.duration = he(l.trackItemsMap);
      const { transitionIds: Se, transitionsMap: se } = Ci(
        l
      ), Pe = l.tracks.filter((Y) => Y.magnetic);
      Xn(
        Pe,
        l.trackItemsMap,
        se
      ), t.updateState(
        {
          trackItemIds: l.trackItemIds,
          trackItemDetailsMap: l.trackItemDetailsMap,
          trackItemsMap: l.trackItemsMap,
          tracks: l.tracks,
          duration: l.duration,
          structure: l.structure,
          transitionIds: Se,
          transitionsMap: se
        },
        {
          updateHistory: !0,
          kind: "add"
        }
      );
      return;
    }
    if (u.key === ri) {
      y = "caption";
      const $ = (at = u.value) == null ? void 0 : at.payload, H = [];
      for (const ct of $) {
        const B = Is(ct, {
          size: l.size
        });
        H.push(B);
      }
      const z = await Promise.all(H), rt = [];
      for (const ct of z) {
        const B = ct.id;
        rt.push(B);
        const { details: ut, ...q } = ct;
        l.trackItemDetailsMap[B] = {
          type: y,
          details: ut
        }, l.trackItemsMap[B] = q, l.trackItemIds.push(B);
      }
      h = rt;
    }
    if (u.key === Vs) {
      y = "text";
      const $ = await bs((Ft = u.value) == null ? void 0 : Ft.payload, {
        size: l.size
      }), { details: H, ...z } = $;
      l.trackItemDetailsMap[z.id] = {
        type: y,
        details: H
      }, l.trackItemsMap[z.id] = z, l.trackItemIds.push(z.id), h = [z.id];
    }
    if (u.key === ni) {
      y = "template";
      const $ = (A = u.value) == null ? void 0 : A.payload.trackItemsMap, H = (et = u.value) == null ? void 0 : et.payload.trackItemDetailsMap, z = (Mt = u.value) == null ? void 0 : Mt.payload.transitionsMap, rt = ((ot = u.value) == null ? void 0 : ot.payload.transitionIds) || [], ct = ($t = u.value) == null ? void 0 : $t.payload.trackItemIds, B = ((Et = u.value) == null ? void 0 : Et.payload.tracks) || [], { details: ut, ...q } = await ys((Gt = u.value) == null ? void 0 : Gt.payload, {
        size: l.size
      }), ht = {
        id: q.id,
        items: ct,
        transitions: rt,
        tracks: B
      };
      l.trackItemDetailsMap[q.id] = {
        type: y,
        details: ut
      }, l.trackItemsMap[q.id] = q, l.trackItemIds.push(q.id), h = [q.id], l.trackItemsMap = {
        ...l.trackItemsMap,
        ...$,
        [q.id]: {
          ...q
        }
      }, l.trackItemDetailsMap = {
        ...l.trackItemDetailsMap,
        ...H,
        [q.id]: {
          type: "template",
          details: ut
        }
      }, l.transitionsMap = {
        ...l.transitionsMap,
        ...z
      }, l.structure = [...l.structure, ht];
    }
    if (u.key === Qs) {
      y = "illustration";
      const $ = await Gn((Yt = u.value) == null ? void 0 : Yt.payload, {
        size: l.size
      }), { details: H, ...z } = $;
      l.trackItemDetailsMap[z.id] = {
        type: y,
        details: H
      }, l.trackItemsMap[z.id] = z, l.trackItemIds.push(z.id), h = [z.id];
    }
    if (u.key === ti) {
      y = "shape";
      const $ = await wi((ee = u.value) == null ? void 0 : ee.payload, {
        size: l.size
      }), { details: H, ...z } = $;
      l.trackItemDetailsMap[z.id] = {
        type: y,
        details: H
      }, l.trackItemsMap[z.id] = z, l.trackItemIds.push(z.id), h = [z.id];
    }
    if (u.key === Zs) {
      y = "image";
      const $ = await gs((Bt = u.value) == null ? void 0 : Bt.payload, {
        size: l.size,
        scaleMode: w
      }), { details: H, ...z } = $;
      l.trackItemDetailsMap[z.id] = {
        type: y,
        details: H
      }, l.trackItemsMap[z.id] = z, l.trackItemIds.push(z.id), h = [z.id];
    }
    if (u.key === Js) {
      y = "audio";
      const $ = await ms((re = u.value) == null ? void 0 : re.payload), { details: H, ...z } = $;
      l.trackItemDetailsMap[z.id] = {
        type: y,
        details: H
      }, l.trackItemsMap[z.id] = z, l.trackItemIds.push(z.id), h = [z.id];
    }
    if (u.key === qs) {
      y = "video";
      const $ = await hs((Xt = u.value) == null ? void 0 : Xt.payload, {
        size: l.size,
        scaleMode: w
      }), { details: H, ...z } = $;
      l.trackItemDetailsMap[z.id] = {
        type: y,
        details: H,
        metadata: z.metadata
      }, l.trackItemsMap[z.id] = z, l.trackItemIds.push(z.id), h = [z.id];
    }
    if (u.key === ii) {
      y = "composition";
      const $ = (ne = u.value) == null ? void 0 : ne.payload.trackItemsMap, H = (_e = u.value) == null ? void 0 : _e.payload.trackItemDetailsMap, z = (ke = u.value) == null ? void 0 : ke.payload.trackItemIds, rt = ((Nt = u.value) == null ? void 0 : Nt.payload.tracks) || [], { details: ct, ...B } = await Si(
        (Kt = u.value) == null ? void 0 : Kt.payload,
        {
          size: l.size
        }
      ), ut = {
        id: B.id,
        items: z,
        transitions: [],
        tracks: rt
      };
      l.trackItemDetailsMap[B.id] = {
        type: y,
        details: ct
      }, l.trackItemsMap[B.id] = B, l.trackItemIds.push(B.id), h = [B.id], l.trackItemsMap = {
        ...l.trackItemsMap,
        ...$,
        [B.id]: {
          ...B
        }
      }, l.trackItemDetailsMap = {
        ...l.trackItemDetailsMap,
        ...H,
        [B.id]: {
          type: y,
          details: ct
        }
      }, l.structure = [...l.structure, ut];
    }
    const x = xi(
      h,
      l.tracks,
      l.trackItemsMap,
      v,
      I
    );
    if (k) {
      const $ = Xe();
      x.trackId = $;
      const H = {
        id: x.trackId,
        accepts: [
          "text",
          "audio",
          "helper",
          "video",
          "image",
          "caption",
          "template"
        ],
        type: y,
        items: h,
        magnetic: !1,
        static: !1
      };
      l.tracks.splice(x.trackIndex, 0, H);
    } else if (x.trackId) {
      const $ = l.tracks.find(
        (H) => H.id === x.trackId
      );
      $ && $.items.push(...h);
    } else if (x.trackIndex !== void 0) {
      const $ = {
        id: Xe(),
        accepts: [
          "text",
          "audio",
          "helper",
          "video",
          "image",
          "caption",
          "template"
        ],
        type: y,
        items: h,
        magnetic: !1,
        static: !1
      };
      l.tracks.splice(x.trackIndex, 0, $);
    } else
      l.tracks.unshift({
        id: Xe(),
        accepts: [
          "text",
          "audio",
          "helper",
          "video",
          "image",
          "caption",
          "template"
        ],
        type: y,
        items: h,
        magnetic: !1,
        static: !1
      });
    S && (l.activeIds = h), l.duration = he(l.trackItemsMap), t.updateState(
      {
        activeIds: l.activeIds,
        trackItemIds: l.trackItemIds,
        trackItemDetailsMap: l.trackItemDetailsMap,
        trackItemsMap: l.trackItemsMap,
        transitionsMap: l.transitionsMap,
        tracks: l.tracks,
        duration: l.duration,
        structure: l.structure
      },
      {
        updateHistory: !0,
        kind: "add"
      }
    );
  }), T = c.subscribe(async (u) => {
    var l;
    if (u.key === li) {
      const S = K(t.getState()), w = (l = u.value) == null ? void 0 : l.options.time;
      if (S.activeIds.length === 1) {
        const k = S.activeIds[0], h = K(S.trackItemsMap[k]);
        if (w >= h.display.to || w <= h.display.from)
          return;
        const y = K(S.trackItemDetailsMap[k]), v = De(), I = K({
          ...h,
          display: {
            from: h.display.from,
            to: w
          }
        }), x = K({
          ...h,
          id: v,
          display: {
            from: w,
            to: h.display.to
          }
        });
        if (h.type === "video" || h.type === "audio") {
          const g = w - I.display.from;
          I.trim = {
            from: h.trim.from,
            to: h.trim.from + g
          }, x.trim = {
            from: h.trim.from + g,
            to: h.trim.to
          };
        }
        S.trackItemsMap[k] = I, S.trackItemsMap[v] = x, S.trackItemIds.push(v), S.trackItemDetailsMap[v] = y, S.tracks.forEach((g) => {
          g.items.includes(k) && g.items.push(v);
        }), t.updateState(
          {
            trackItemDetailsMap: S.trackItemDetailsMap,
            tracks: S.tracks,
            trackItemIds: S.trackItemIds,
            trackItemsMap: S.trackItemsMap
          },
          {
            updateHistory: !0,
            kind: "update"
          }
        );
      }
      return;
    }
    if (u.key === ui) {
      const S = K(t.getState());
      if (S.activeIds.length) {
        const w = S.activeIds, k = [], h = {
          activeIds: w,
          trackItemDetailsMap: {},
          trackItemsMap: {},
          tracks: []
        };
        w.forEach((v) => {
          h.trackItemDetailsMap[v] = S.trackItemDetailsMap[v], h.trackItemsMap[v] = S.trackItemsMap[v], k.push(
            S.tracks.find((I) => I.items.includes(v))
          );
        });
        const y = /* @__PURE__ */ new Set();
        k.filter((v) => y.has(v.id) ? !1 : (y.add(v), !0)), h.tracks = Array.from(y.keys()), localStorage.setItem("DesignComboTemp", JSON.stringify(h));
      }
    }
    if (u.key === ci) {
      const S = localStorage.getItem("DesignComboTemp");
      if (!S) return;
      const w = K(t.getState()), k = JSON.parse(S), h = {}, y = k.trackItemsMap, v = k.trackItemDetailsMap, I = k.tracks, x = [], g = k.activeIds.map(async (O) => {
        const D = v[O];
        (D.type === "caption" || D.type === "text") && D.details.fontUrl && await br([
          {
            fontFamily: D.details.fontFamily,
            url: D.details.fontUrl
          }
        ]);
        const j = De();
        return h[O] = j, w.trackItemsMap[j] = {
          ...y[O],
          id: j
        }, w.trackItemDetailsMap[j] = D, w.trackItemIds.push(j), !0;
      });
      await Promise.all(g), I.forEach((O) => {
        const D = O.items.map((L) => h[L]), j = {
          ...O,
          magnetic: !1,
          static: !1,
          items: D,
          id: Xe()
        };
        x.push(j);
      }), w.tracks = [...x, ...w.tracks], t.updateState(
        {
          trackItemDetailsMap: w.trackItemDetailsMap,
          tracks: w.tracks,
          trackItemIds: w.trackItemIds,
          trackItemsMap: w.trackItemsMap
        },
        {
          updateHistory: !0,
          kind: "update"
        }
      );
    }
  }), C = d.subscribe(async (u) => {
    var l, S, w;
    if (u.key === ai) {
      const k = K(t.getState()), h = k.trackItemDetailsMap, y = k.trackItemsMap, v = Object.keys((l = u.value) == null ? void 0 : l.payload);
      if (!v.length) return;
      const I = (S = u.value) == null ? void 0 : S.payload;
      v.forEach((g) => {
        const O = I[g];
        if (O.details) {
          if (h[g].details = {
            ...h[g].details,
            ...O.details
          }, O.details.colorMap) {
            const D = h[g].details.initialSvgString, j = Wn(
              D,
              O.details.colorMap
            );
            h[g].details.svgString = j;
          }
        } else I[g].playbackRate && (y[g].playbackRate = I[g].playbackRate);
        I[g].metadata && (y[g].metadata ? y[g].metadata = {
          ...y[g].metadata,
          ...I[g].metadata
        } : y[g].metadata = I[g].metadata), I[g].display && (y[g].display = I[g].display);
      });
      for (const g of v) {
        const O = I[g];
        if (y[g].type === "shape" && O.details.src) {
          const D = await Oe(O.details.src);
          h[g].details.width = D.width, h[g].details.height = D.height;
        }
      }
      const x = he(y);
      t.updateState(
        {
          trackItemDetailsMap: { ...h },
          trackItemsMap: { ...y },
          duration: x
        },
        {
          updateHistory: !0,
          kind: "update:details"
        }
      );
    }
    if (u.key === oi) {
      const k = (w = u.value) == null ? void 0 : w.payload, h = Object.keys(k)[0], y = Object.values(k)[0], v = K(t.getState()), I = v.trackItemDetailsMap[h], x = I.details;
      if (y.details) {
        if (y.type === "image" && y.details.src) {
          const O = await Oe(y.details.src), D = I.details.width || 0, j = I.details.height || 0;
          let L = O.width, R = O.height;
          const F = O.width / O.height;
          D / j > F ? (L = D, R = D / F) : (R = j, L = j * F), x.crop = {
            x: 0,
            y: 0,
            height: x.height,
            width: x.width
          }, y.details.width = L, y.details.height = R;
        }
        if (y.type === "video" && y.details.src) {
          const O = await _n(y.details.src), D = I.details.width || 0, j = I.details.height || 0;
          let L = O.width, R = O.height;
          const F = O.width / O.height;
          D / j > F ? (L = D, R = D / F) : (R = j, L = j * F), x.crop = {
            x: 0,
            y: 0,
            height: x.height,
            width: x.width
          }, y.details.width = L, y.details.height = R;
        }
        I.details = { ...x, ...y.details }, y.details = I.details;
      }
      const g = { ...I, ...y };
      v.trackItemDetailsMap[h] = g, v.trackItemsMap[h] = {
        ...v.trackItemsMap[h],
        type: y.type
      }, t.updateState(
        {
          trackItemDetailsMap: {
            ...v.trackItemDetailsMap
          },
          trackItemsMap: {
            ...v.trackItemsMap
          }
        },
        {
          updateHistory: !0,
          kind: "update:details"
        }
      );
    }
  });
  return {
    unsubscribe: () => {
      m.unsubscribe(), T.unsubscribe(), C.unsubscribe(), _.unsubscribe(), E.unsubscribe(), b.unsubscribe(), M.unsubscribe();
    }
  };
}
const zi = { Date: !0, RegExp: !0, String: !0, Number: !0 };
function _s(t, e, r = { cyclesFix: !0 }, s = []) {
  var f, b;
  let a = [];
  const c = Array.isArray(t);
  for (const _ in t) {
    const M = t[_], E = c ? +_ : _;
    if (!(_ in e)) {
      a.push({
        type: "REMOVE",
        path: [E],
        oldValue: t[_]
      });
      continue;
    }
    const m = e[_], T = typeof M == "object" && typeof m == "object" && Array.isArray(M) === Array.isArray(m);
    M && m && T && !zi[(b = (f = Object.getPrototypeOf(M)) == null ? void 0 : f.constructor) == null ? void 0 : b.name] && (!r.cyclesFix || !s.includes(M)) ? a.push.apply(a, _s(M, m, r, r.cyclesFix ? s.concat([M]) : []).map((C) => (C.path.unshift(E), C))) : M !== m && // treat NaN values as equivalent
    !(Number.isNaN(M) && Number.isNaN(m)) && !(T && (isNaN(M) ? M + "" == m + "" : +M == +m)) && a.push({
      path: [E],
      type: "CHANGE",
      value: m,
      oldValue: M
    });
  }
  const d = Array.isArray(e);
  for (const _ in e)
    _ in t || a.push({
      type: "CREATE",
      path: [d ? +_ : _],
      value: e[_]
    });
  return a;
}
var On = Symbol.for("immer-nothing"), Ke = Symbol.for("immer-draftable"), vt = Symbol.for("immer-state"), ks = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(t) {
    return `The plugin for '${t}' has not been loaded into Immer. To enable the plugin, import and call \`enable${t}()\` when initializing your application.`;
  },
  function(t) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${t}'`;
  },
  "This object has been frozen and should not be mutated",
  function(t) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + t;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(t) {
    return `'current' expects a draft, got: ${t}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(t) {
    return `'original' expects a draft, got: ${t}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function tt(t, ...e) {
  if (process.env.NODE_ENV !== "production") {
    const r = ks[t], s = typeof r == "function" ? r.apply(null, e) : r;
    throw new Error(`[Immer] ${s}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${t}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var me = Object.getPrototypeOf;
function ye(t) {
  return !!t && !!t[vt];
}
function Qt(t) {
  var e;
  return t ? Ss(t) || Array.isArray(t) || !!t[Ke] || !!((e = t.constructor) != null && e[Ke]) || tr(t) || er(t) : !1;
}
var Fi = Object.prototype.constructor.toString();
function Ss(t) {
  if (!t || typeof t != "object")
    return !1;
  const e = me(t);
  if (e === null)
    return !0;
  const r = Object.hasOwnProperty.call(e, "constructor") && e.constructor;
  return r === Object ? !0 : typeof r == "function" && Function.toString.call(r) === Fi;
}
function Ve(t, e) {
  ge(t) === 0 ? Reflect.ownKeys(t).forEach((r) => {
    e(r, t[r], t);
  }) : t.forEach((r, s) => e(s, r, t));
}
function ge(t) {
  const e = t[vt];
  return e ? e.type_ : Array.isArray(t) ? 1 : tr(t) ? 2 : er(t) ? 3 : 0;
}
function qe(t, e) {
  return ge(t) === 2 ? t.has(e) : Object.prototype.hasOwnProperty.call(t, e);
}
function fn(t, e) {
  return ge(t) === 2 ? t.get(e) : t[e];
}
function ws(t, e, r) {
  const s = ge(t);
  s === 2 ? t.set(e, r) : s === 3 ? t.add(r) : t[e] = r;
}
function $i(t, e) {
  return t === e ? t !== 0 || 1 / t === 1 / e : t !== t && e !== e;
}
function tr(t) {
  return t instanceof Map;
}
function er(t) {
  return t instanceof Set;
}
function pe(t) {
  return t.copy_ || t.base_;
}
function Sn(t, e) {
  if (tr(t))
    return new Map(t);
  if (er(t))
    return new Set(t);
  if (Array.isArray(t))
    return Array.prototype.slice.call(t);
  const r = Ss(t);
  if (e === !0 || e === "class_only" && !r) {
    const s = Object.getOwnPropertyDescriptors(t);
    delete s[vt];
    let a = Reflect.ownKeys(s);
    for (let c = 0; c < a.length; c++) {
      const d = a[c], f = s[d];
      f.writable === !1 && (f.writable = !0, f.configurable = !0), (f.get || f.set) && (s[d] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: f.enumerable,
        value: t[d]
      });
    }
    return Object.create(me(t), s);
  } else {
    const s = me(t);
    if (s !== null && r)
      return { ...t };
    const a = Object.create(s);
    return Object.assign(a, t);
  }
}
function Cn(t, e = !1) {
  return Mr(t) || ye(t) || !Qt(t) || (ge(t) > 1 && (t.set = t.add = t.clear = t.delete = Ni), Object.freeze(t), e && Object.entries(t).forEach(([r, s]) => Cn(s, !0))), t;
}
function Ni() {
  tt(2);
}
function Mr(t) {
  return Object.isFrozen(t);
}
var wn = {};
function Ie(t) {
  const e = wn[t];
  return e || tt(0, t), e;
}
function ji(t, e) {
  wn[t] || (wn[t] = e);
}
var Je;
function Ms() {
  return Je;
}
function Hi(t, e) {
  return {
    drafts_: [],
    parent_: t,
    immer_: e,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function Kn(t, e) {
  e && (Ie("Patches"), t.patches_ = [], t.inversePatches_ = [], t.patchListener_ = e);
}
function Mn(t) {
  En(t), t.drafts_.forEach(Li), t.drafts_ = null;
}
function En(t) {
  t === Je && (Je = t.parent_);
}
function Vn(t) {
  return Je = Hi(Je, t);
}
function Li(t) {
  const e = t[vt];
  e.type_ === 0 || e.type_ === 1 ? e.revoke_() : e.revoked_ = !0;
}
function qn(t, e) {
  e.unfinalizedDrafts_ = e.drafts_.length;
  const r = e.drafts_[0];
  return t !== void 0 && t !== r ? (r[vt].modified_ && (Mn(e), tt(4)), Qt(t) && (t = vr(e, t), e.parent_ || _r(e, t)), e.patches_ && Ie("Patches").generateReplacementPatches_(
    r[vt].base_,
    t,
    e.patches_,
    e.inversePatches_
  )) : t = vr(e, r, []), Mn(e), e.patches_ && e.patchListener_(e.patches_, e.inversePatches_), t !== On ? t : void 0;
}
function vr(t, e, r) {
  if (Mr(e))
    return e;
  const s = e[vt];
  if (!s)
    return Ve(
      e,
      (a, c) => Jn(t, s, e, a, c, r)
    ), e;
  if (s.scope_ !== t)
    return e;
  if (!s.modified_)
    return _r(t, s.base_, !0), s.base_;
  if (!s.finalized_) {
    s.finalized_ = !0, s.scope_.unfinalizedDrafts_--;
    const a = s.copy_;
    let c = a, d = !1;
    s.type_ === 3 && (c = new Set(a), a.clear(), d = !0), Ve(
      c,
      (f, b) => Jn(t, s, a, f, b, r, d)
    ), _r(t, a, !1), r && t.patches_ && Ie("Patches").generatePatches_(
      s,
      r,
      t.patches_,
      t.inversePatches_
    );
  }
  return s.copy_;
}
function Jn(t, e, r, s, a, c, d) {
  if (process.env.NODE_ENV !== "production" && a === r && tt(5), ye(a)) {
    const f = c && e && e.type_ !== 3 && // Set objects are atomic since they have no keys.
    !qe(e.assigned_, s) ? c.concat(s) : void 0, b = vr(t, a, f);
    if (ws(r, s, b), ye(b))
      t.canAutoFreeze_ = !1;
    else
      return;
  } else d && r.add(a);
  if (Qt(a) && !Mr(a)) {
    if (!t.immer_.autoFreeze_ && t.unfinalizedDrafts_ < 1)
      return;
    vr(t, a), (!e || !e.scope_.parent_) && typeof s != "symbol" && Object.prototype.propertyIsEnumerable.call(r, s) && _r(t, a);
  }
}
function _r(t, e, r = !1) {
  !t.parent_ && t.immer_.autoFreeze_ && t.canAutoFreeze_ && Cn(e, r);
}
function Ui(t, e) {
  const r = Array.isArray(t), s = {
    type_: r ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: e ? e.scope_ : Ms(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: e,
    // The base state.
    base_: t,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let a = s, c = Pn;
  r && (a = [s], c = Ze);
  const { revoke: d, proxy: f } = Proxy.revocable(a, c);
  return s.draft_ = f, s.revoke_ = d, f;
}
var Pn = {
  get(t, e) {
    if (e === vt)
      return t;
    const r = pe(t);
    if (!qe(r, e))
      return Wi(t, r, e);
    const s = r[e];
    return t.finalized_ || !Qt(s) ? s : s === pn(t.base_, e) ? (hn(t), t.copy_[e] = An(s, t)) : s;
  },
  has(t, e) {
    return e in pe(t);
  },
  ownKeys(t) {
    return Reflect.ownKeys(pe(t));
  },
  set(t, e, r) {
    const s = Es(pe(t), e);
    if (s != null && s.set)
      return s.set.call(t.draft_, r), !0;
    if (!t.modified_) {
      const a = pn(pe(t), e), c = a == null ? void 0 : a[vt];
      if (c && c.base_ === r)
        return t.copy_[e] = r, t.assigned_[e] = !1, !0;
      if ($i(r, a) && (r !== void 0 || qe(t.base_, e)))
        return !0;
      hn(t), Tn(t);
    }
    return t.copy_[e] === r && // special case: handle new props with value 'undefined'
    (r !== void 0 || e in t.copy_) || // special case: NaN
    Number.isNaN(r) && Number.isNaN(t.copy_[e]) || (t.copy_[e] = r, t.assigned_[e] = !0), !0;
  },
  deleteProperty(t, e) {
    return pn(t.base_, e) !== void 0 || e in t.base_ ? (t.assigned_[e] = !1, hn(t), Tn(t)) : delete t.assigned_[e], t.copy_ && delete t.copy_[e], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(t, e) {
    const r = pe(t), s = Reflect.getOwnPropertyDescriptor(r, e);
    return s && {
      writable: !0,
      configurable: t.type_ !== 1 || e !== "length",
      enumerable: s.enumerable,
      value: r[e]
    };
  },
  defineProperty() {
    tt(11);
  },
  getPrototypeOf(t) {
    return me(t.base_);
  },
  setPrototypeOf() {
    tt(12);
  }
}, Ze = {};
Ve(Pn, (t, e) => {
  Ze[t] = function() {
    return arguments[0] = arguments[0][0], e.apply(this, arguments);
  };
});
Ze.deleteProperty = function(t, e) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(e)) && tt(13), Ze.set.call(this, t, e, void 0);
};
Ze.set = function(t, e, r) {
  return process.env.NODE_ENV !== "production" && e !== "length" && isNaN(parseInt(e)) && tt(14), Pn.set.call(this, t[0], e, r, t[0]);
};
function pn(t, e) {
  const r = t[vt];
  return (r ? pe(r) : t)[e];
}
function Wi(t, e, r) {
  var a;
  const s = Es(e, r);
  return s ? "value" in s ? s.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (a = s.get) == null ? void 0 : a.call(t.draft_)
  ) : void 0;
}
function Es(t, e) {
  if (!(e in t))
    return;
  let r = me(t);
  for (; r; ) {
    const s = Object.getOwnPropertyDescriptor(r, e);
    if (s)
      return s;
    r = me(r);
  }
}
function Tn(t) {
  t.modified_ || (t.modified_ = !0, t.parent_ && Tn(t.parent_));
}
function hn(t) {
  t.copy_ || (t.copy_ = Sn(
    t.base_,
    t.scope_.immer_.useStrictShallowCopy_
  ));
}
var Gi = class {
  constructor(t) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (e, r, s) => {
      if (typeof e == "function" && typeof r != "function") {
        const c = r;
        r = e;
        const d = this;
        return function(b = c, ..._) {
          return d.produce(b, (M) => r.call(this, M, ..._));
        };
      }
      typeof r != "function" && tt(6), s !== void 0 && typeof s != "function" && tt(7);
      let a;
      if (Qt(e)) {
        const c = Vn(this), d = An(e, void 0);
        let f = !0;
        try {
          a = r(d), f = !1;
        } finally {
          f ? Mn(c) : En(c);
        }
        return Kn(c, s), qn(a, c);
      } else if (!e || typeof e != "object") {
        if (a = r(e), a === void 0 && (a = e), a === On && (a = void 0), this.autoFreeze_ && Cn(a, !0), s) {
          const c = [], d = [];
          Ie("Patches").generateReplacementPatches_(e, a, c, d), s(c, d);
        }
        return a;
      } else
        tt(1, e);
    }, this.produceWithPatches = (e, r) => {
      if (typeof e == "function")
        return (d, ...f) => this.produceWithPatches(d, (b) => e(b, ...f));
      let s, a;
      return [this.produce(e, r, (d, f) => {
        s = d, a = f;
      }), s, a];
    }, typeof (t == null ? void 0 : t.autoFreeze) == "boolean" && this.setAutoFreeze(t.autoFreeze), typeof (t == null ? void 0 : t.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(t.useStrictShallowCopy);
  }
  createDraft(t) {
    Qt(t) || tt(8), ye(t) && (t = Yi(t));
    const e = Vn(this), r = An(t, void 0);
    return r[vt].isManual_ = !0, En(e), r;
  }
  finishDraft(t, e) {
    const r = t && t[vt];
    (!r || !r.isManual_) && tt(9);
    const { scope_: s } = r;
    return Kn(s, e), qn(void 0, s);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(t) {
    this.autoFreeze_ = t;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(t) {
    this.useStrictShallowCopy_ = t;
  }
  applyPatches(t, e) {
    let r;
    for (r = e.length - 1; r >= 0; r--) {
      const a = e[r];
      if (a.path.length === 0 && a.op === "replace") {
        t = a.value;
        break;
      }
    }
    r > -1 && (e = e.slice(r + 1));
    const s = Ie("Patches").applyPatches_;
    return ye(t) ? s(t, e) : this.produce(
      t,
      (a) => s(a, e)
    );
  }
};
function An(t, e) {
  const r = tr(t) ? Ie("MapSet").proxyMap_(t, e) : er(t) ? Ie("MapSet").proxySet_(t, e) : Ui(t, e);
  return (e ? e.scope_ : Ms()).drafts_.push(r), r;
}
function Yi(t) {
  return ye(t) || tt(10, t), Ts(t);
}
function Ts(t) {
  if (!Qt(t) || Mr(t))
    return t;
  const e = t[vt];
  let r;
  if (e) {
    if (!e.modified_)
      return e.base_;
    e.finalized_ = !0, r = Sn(t, e.scope_.immer_.useStrictShallowCopy_);
  } else
    r = Sn(t, !0);
  return Ve(r, (s, a) => {
    ws(r, s, Ts(a));
  }), e && (e.finalized_ = !1), r;
}
function Zn() {
  process.env.NODE_ENV !== "production" && ks.push(
    'Sets cannot have "replace" patches.',
    function(m) {
      return "Unsupported patch operation: " + m;
    },
    function(m) {
      return "Cannot apply patch, path doesn't resolve: " + m;
    },
    "Patching reserved attributes like __proto__, prototype and constructor is not allowed"
  );
  const e = "replace", r = "add", s = "remove";
  function a(m, T, C, u) {
    switch (m.type_) {
      case 0:
      case 2:
        return d(
          m,
          T,
          C,
          u
        );
      case 1:
        return c(m, T, C, u);
      case 3:
        return f(
          m,
          T,
          C,
          u
        );
    }
  }
  function c(m, T, C, u) {
    let { base_: l, assigned_: S } = m, w = m.copy_;
    w.length < l.length && ([l, w] = [w, l], [C, u] = [u, C]);
    for (let k = 0; k < l.length; k++)
      if (S[k] && w[k] !== l[k]) {
        const h = T.concat([k]);
        C.push({
          op: e,
          path: h,
          // Need to maybe clone it, as it can in fact be the original value
          // due to the base/copy inversion at the start of this function
          value: E(w[k])
        }), u.push({
          op: e,
          path: h,
          value: E(l[k])
        });
      }
    for (let k = l.length; k < w.length; k++) {
      const h = T.concat([k]);
      C.push({
        op: r,
        path: h,
        // Need to maybe clone it, as it can in fact be the original value
        // due to the base/copy inversion at the start of this function
        value: E(w[k])
      });
    }
    for (let k = w.length - 1; l.length <= k; --k) {
      const h = T.concat([k]);
      u.push({
        op: s,
        path: h
      });
    }
  }
  function d(m, T, C, u) {
    const { base_: l, copy_: S } = m;
    Ve(m.assigned_, (w, k) => {
      const h = fn(l, w), y = fn(S, w), v = k ? qe(l, w) ? e : r : s;
      if (h === y && v === e)
        return;
      const I = T.concat(w);
      C.push(v === s ? { op: v, path: I } : { op: v, path: I, value: y }), u.push(
        v === r ? { op: s, path: I } : v === s ? { op: r, path: I, value: E(h) } : { op: e, path: I, value: E(h) }
      );
    });
  }
  function f(m, T, C, u) {
    let { base_: l, copy_: S } = m, w = 0;
    l.forEach((k) => {
      if (!S.has(k)) {
        const h = T.concat([w]);
        C.push({
          op: s,
          path: h,
          value: k
        }), u.unshift({
          op: r,
          path: h,
          value: k
        });
      }
      w++;
    }), w = 0, S.forEach((k) => {
      if (!l.has(k)) {
        const h = T.concat([w]);
        C.push({
          op: r,
          path: h,
          value: k
        }), u.unshift({
          op: s,
          path: h,
          value: k
        });
      }
      w++;
    });
  }
  function b(m, T, C, u) {
    C.push({
      op: e,
      path: [],
      value: T === On ? void 0 : T
    }), u.push({
      op: e,
      path: [],
      value: m
    });
  }
  function _(m, T) {
    return T.forEach((C) => {
      const { path: u, op: l } = C;
      let S = m;
      for (let y = 0; y < u.length - 1; y++) {
        const v = ge(S);
        let I = u[y];
        typeof I != "string" && typeof I != "number" && (I = "" + I), (v === 0 || v === 1) && (I === "__proto__" || I === "constructor") && tt(19), typeof S == "function" && I === "prototype" && tt(19), S = fn(S, I), typeof S != "object" && tt(18, u.join("/"));
      }
      const w = ge(S), k = M(C.value), h = u[u.length - 1];
      switch (l) {
        case e:
          switch (w) {
            case 2:
              return S.set(h, k);
            case 3:
              tt(16);
            default:
              return S[h] = k;
          }
        case r:
          switch (w) {
            case 1:
              return h === "-" ? S.push(k) : S.splice(h, 0, k);
            case 2:
              return S.set(h, k);
            case 3:
              return S.add(k);
            default:
              return S[h] = k;
          }
        case s:
          switch (w) {
            case 1:
              return S.splice(h, 1);
            case 2:
              return S.delete(h);
            case 3:
              return S.delete(C.value);
            default:
              return delete S[h];
          }
        default:
          tt(17, l);
      }
    }), m;
  }
  function M(m) {
    if (!Qt(m))
      return m;
    if (Array.isArray(m))
      return m.map(M);
    if (tr(m))
      return new Map(
        Array.from(m.entries()).map(([C, u]) => [C, M(u)])
      );
    if (er(m))
      return new Set(Array.from(m).map(M));
    const T = Object.create(me(m));
    for (const C in m)
      T[C] = M(m[C]);
    return qe(m, Ke) && (T[Ke] = m[Ke]), T;
  }
  function E(m) {
    return ye(m) ? M(m) : m;
  }
  ji("Patches", {
    applyPatches_: _,
    generatePatches_: a,
    generateReplacementPatches_: b
  });
}
var _t = new Gi(), Bi = _t.produce;
_t.produceWithPatches.bind(
  _t
);
_t.setAutoFreeze.bind(_t);
_t.setUseStrictShallowCopy.bind(_t);
var Xi = _t.applyPatches.bind(_t);
_t.createDraft.bind(_t);
_t.finishDraft.bind(_t);
var Ki = 9007199254740991, Vi = "[object Arguments]", qi = "[object Function]", Ji = "[object GeneratorFunction]", Zi = "[object Symbol]", Qi = typeof St == "object" && St && St.Object === Object && St, ta = typeof self == "object" && self && self.Object === Object && self, ea = Qi || ta || Function("return this")();
function ra(t, e, r) {
  switch (r.length) {
    case 0:
      return t.call(e);
    case 1:
      return t.call(e, r[0]);
    case 2:
      return t.call(e, r[0], r[1]);
    case 3:
      return t.call(e, r[0], r[1], r[2]);
  }
  return t.apply(e, r);
}
function na(t, e) {
  for (var r = -1, s = t ? t.length : 0, a = Array(s); ++r < s; )
    a[r] = e(t[r], r, t);
  return a;
}
function sa(t, e) {
  for (var r = -1, s = e.length, a = t.length; ++r < s; )
    t[a + r] = e[r];
  return t;
}
var Rn = Object.prototype, ia = Rn.hasOwnProperty, zn = Rn.toString, Qn = ea.Symbol, aa = Rn.propertyIsEnumerable, ts = Qn ? Qn.isConcatSpreadable : void 0, es = Math.max;
function oa(t, e, r, s, a) {
  var c = -1, d = t.length;
  for (r || (r = da), a || (a = []); ++c < d; ) {
    var f = t[c];
    r(f) ? sa(a, f) : a[a.length] = f;
  }
  return a;
}
function ca(t, e) {
  return t = Object(t), ua(t, e, function(r, s) {
    return s in t;
  });
}
function ua(t, e, r) {
  for (var s = -1, a = e.length, c = {}; ++s < a; ) {
    var d = e[s], f = t[d];
    r(f, d) && (c[d] = f);
  }
  return c;
}
function la(t, e) {
  return e = es(e === void 0 ? t.length - 1 : e, 0), function() {
    for (var r = arguments, s = -1, a = es(r.length - e, 0), c = Array(a); ++s < a; )
      c[s] = r[e + s];
    s = -1;
    for (var d = Array(e + 1); ++s < e; )
      d[s] = r[s];
    return d[e] = c, ra(t, this, d);
  };
}
function da(t) {
  return ha(t) || pa(t) || !!(ts && t && t[ts]);
}
function fa(t) {
  if (typeof t == "string" || va(t))
    return t;
  var e = t + "";
  return e == "0" && 1 / t == -1 / 0 ? "-0" : e;
}
function pa(t) {
  return ya(t) && ia.call(t, "callee") && (!aa.call(t, "callee") || zn.call(t) == Vi);
}
var ha = Array.isArray;
function ma(t) {
  return t != null && Ia(t.length) && !ga(t);
}
function ya(t) {
  return As(t) && ma(t);
}
function ga(t) {
  var e = ba(t) ? zn.call(t) : "";
  return e == qi || e == Ji;
}
function Ia(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= Ki;
}
function ba(t) {
  var e = typeof t;
  return !!t && (e == "object" || e == "function");
}
function As(t) {
  return !!t && typeof t == "object";
}
function va(t) {
  return typeof t == "symbol" || As(t) && zn.call(t) == Zi;
}
var _a = la(function(t, e) {
  return t == null ? {} : ca(t, na(oa(e), fa));
}), ka = _a;
const rs = /* @__PURE__ */ xn(ka), Sa = {
  width: 1080,
  height: 1920
}, wa = 30, Ma = {
  size: Sa,
  fps: wa,
  tracks: [],
  trackItemIds: [],
  trackItemsMap: {},
  transitionIds: [],
  transitionsMap: {},
  scale: {
    unit: 1,
    zoom: 1,
    segments: 1,
    index: 1
  },
  duration: 0,
  activeIds: [],
  trackItemDetailsMap: {},
  structure: []
}, ns = [
  "tracks",
  "trackItemsMap",
  "trackItemDetailsMap",
  "transitionIds",
  "transitionsMap",
  "trackItemIds",
  "structure"
];
class eo {
  constructor(e) {
    le(this, "stateSubject");
    le(this, "stateHistorySubject");
    le(this, "prevState");
    le(this, "undos", []);
    le(this, "redos", []);
    le(this, "listener");
    const r = Object.assign({}, Ma, e);
    this.stateSubject = new Un(r), this.stateHistorySubject = new Un({
      handleRedo: !1,
      handleUndo: !1
    }), this.prevState = r, this.initListeners();
  }
  initListeners() {
    Ri(this);
  }
  destroyListeners() {
    this.listener && this.listener.unsubscribe();
  }
  purge() {
    this.destroyListeners();
  }
  updateHistory(e, r) {
    const s = rs(e, ns), a = rs(this.getState(), ns), c = _s(a, s);
    c.length && (this.undos.push({ undos: c, type: r }), this.redos = []);
  }
  getStateHistory() {
    return this.stateHistorySubject.getValue();
  }
  subscribeHistory(e) {
    return this.stateHistorySubject.subscribe(e);
  }
  // Get the current state
  getState() {
    return this.stateSubject.getValue();
  }
  // Subscribe to state changes
  subscribe(e) {
    return this.stateSubject.subscribe(e);
  }
  // Update the state, emitting only if the part of the state has changed
  updateState(e, r = { updateHistory: !1 }) {
    const s = this.getState(), a = {
      ...K(s),
      ...K(e)
    };
    Q(s, a) || (r.updateHistory && this.updateHistory(a, r.kind), this.prevState = s, this.stateSubject.next(a));
  }
  // emit changes for design size
  subscribeToSize(e) {
    return this.stateSubject.asObservable().subscribe((r) => {
      Q(r.size, this.prevState.size) || e({ size: r.size });
    });
  }
  // Selectively subscribe to scale changes
  subscribeToScale(e) {
    return this.stateSubject.asObservable().subscribe((r) => {
      Q(r.scale, this.prevState.scale) || e({ scale: r.scale });
    });
  }
  // Selectively subscribe to fps changes
  subscribeToFps(e) {
    return this.stateSubject.asObservable().subscribe((r) => {
      r.fps !== this.prevState.fps && e({ fps: r.fps });
    });
  }
  subscribeToUpdateTrackItem(e) {
    return this.stateSubject.asObservable().subscribe((r) => {
      Q(r.trackItemsMap, this.prevState.trackItemsMap) || e({ trackItemsMap: r.trackItemsMap });
    });
  }
  subscribeToUpdateAnimations(e) {
    return this.stateSubject.asObservable().subscribe((r) => {
      const s = Object.keys(r.trackItemsMap).filter(
        (a) => {
          const c = this.prevState.trackItemsMap[a], d = r.trackItemsMap[a];
          return c && d && !Q(c.animations, d.animations);
        }
      );
      e({ trackItemsMap: r.trackItemsMap, changedAnimationIds: s });
    });
  }
  subscribeToUpdateTrackItemTiming(e) {
    return this.stateSubject.asObservable().subscribe((r) => {
      if (!Q(r.trackItemsMap, this.prevState.trackItemsMap)) {
        const s = Object.keys(r.trackItemsMap).filter((c) => {
          const d = this.prevState.trackItemsMap[c], f = r.trackItemsMap[c];
          return d && f && !Q(d.trim, f.trim);
        }), a = Object.keys(r.trackItemsMap).filter(
          (c) => {
            const d = this.prevState.trackItemsMap[c], f = r.trackItemsMap[c];
            return d && f && !Q(d.display, f.display);
          }
        );
        e({
          trackItemsMap: r.trackItemsMap,
          changedTrimIds: s.length > 0 ? s : void 0,
          changedDisplayIds: a.length > 0 ? a : void 0
        });
      }
    });
  }
  subscribeToUpdateItemDetails(e) {
    return this.stateSubject.asObservable().subscribe((r) => {
      Q(r.trackItemDetailsMap, this.prevState.trackItemDetailsMap) || e({ trackItemDetailsMap: r.trackItemDetailsMap });
    });
  }
  // Selectively subscribe to duration changes
  subscribeToDuration(e) {
    return this.stateSubject.asObservable().subscribe((r) => {
      r.duration !== this.prevState.duration && e({ duration: r.duration });
    });
  }
  subscribeToHistory(e) {
    return this.stateHistorySubject.asObservable().subscribe((r) => {
      if (r.handleRedo) {
        const s = this.undos[this.undos.length - 1].type;
        e({ ...this.getState(), type: s }), this.stateHistorySubject.next({ handleRedo: !1, handleUndo: !1 });
      }
      if (r.handleUndo) {
        const s = this.redos[this.redos.length - 1].type;
        e({ ...this.getState(), type: s }), this.stateHistorySubject.next({ handleRedo: !1, handleUndo: !1 });
      }
    });
  }
  subscribeToAddOrRemoveItems(e) {
    return this.stateSubject.asObservable().subscribe((r) => {
      const s = [...r.trackItemIds].sort(), a = [...this.prevState.trackItemIds].sort(), c = [...r.transitionIds].sort(), d = [...this.prevState.transitionIds].sort();
      (!Q(s, a) || !Q(c, d)) && e({ trackItemIds: r.trackItemIds });
    });
  }
  // Selectively subscribe to activeIds changes
  subscribeToActiveIds(e) {
    return this.stateSubject.asObservable().subscribe((r) => {
      Q(r.activeIds, this.prevState.activeIds) || e({ activeIds: r.activeIds });
    });
  }
  subscribeToTracks(e) {
    return this.stateSubject.asObservable().subscribe((r) => {
      const s = r.tracks, c = this.prevState.tracks.map((f) => f.id), d = s.filter(
        (f) => !c.includes(f.id)
      );
      d.length && e({
        tracks: r.tracks,
        changedTracks: d.map((f) => f.id)
      });
    });
  }
  // Selectively subscribe to multiple track-related properties
  subscribeToState(e) {
    return this.stateSubject.asObservable().subscribe((r) => {
      (!Q(r.tracks, this.prevState.tracks) || !Q(r.trackItemIds, this.prevState.trackItemIds) || !Q(r.trackItemsMap, this.prevState.trackItemsMap) || !Q(r.transitionIds, this.prevState.transitionIds) || !Q(r.transitionsMap, this.prevState.transitionsMap) || !Q(
        r.trackItemDetailsMap,
        this.prevState.trackItemDetailsMap
      ) || !Q(r.structure, this.prevState.structure)) && e({
        tracks: r.tracks,
        trackItemIds: r.trackItemIds,
        trackItemsMap: r.trackItemsMap,
        transitionIds: r.transitionIds,
        transitionsMap: r.transitionsMap,
        trackItemDetailsMap: r.trackItemDetailsMap,
        structure: r.structure
      });
    });
  }
  undo() {
    const e = this.undos.pop(), r = e == null ? void 0 : e.undos, s = e == null ? void 0 : e.type;
    if (!r || !s) return;
    Zn();
    const {
      trackItemDetailsMap: a,
      trackItemIds: c,
      tracks: d,
      transitionIds: f,
      transitionsMap: b,
      trackItemsMap: _,
      structure: M
    } = this.getState(), E = K({
      trackItemDetailsMap: a,
      trackItemIds: c,
      tracks: d,
      transitionIds: f,
      transitionsMap: b,
      trackItemsMap: _,
      structure: M
    }), m = [], T = [], C = [], u = [], l = [], S = [], w = [];
    r.forEach((R) => {
      let F;
      const V = R.path.slice(1);
      R.type === "CREATE" ? F = {
        path: V,
        op: "remove",
        value: R.value
      } : R.type === "CHANGE" ? F = {
        path: V,
        op: "replace",
        value: R.oldValue
      } : F = {
        path: V,
        op: "add",
        value: R.oldValue
      }, R.path.includes("trackItemIds") ? C.push(F) : R.path.includes("transitionIds") ? T.push(F) : R.path.includes("trackItemsMap") ? l.push(F) : R.path.includes("transitionsMap") ? u.push(F) : R.path.includes("tracks") ? m.push(F) : R.path.includes("trackItemDetailsMap") ? S.push(F) : R.path.includes("structure") && w.push(F);
    });
    const k = this.applyPatch(
      E.tracks,
      m
    ), h = this.applyPatch(
      E.transitionIds,
      T
    ), y = this.applyPatch(
      E.trackItemIds,
      C
    ), v = this.applyPatch(
      E.transitionsMap,
      u
    ), I = this.applyPatch(
      E.trackItemsMap,
      l
    ), x = this.applyPatch(
      E.trackItemDetailsMap,
      S
    ), g = this.applyPatch(
      E.structure,
      w
    ), O = K({
      tracks: k,
      transitionIds: h,
      trackItemIds: y,
      transitionsMap: v,
      trackItemsMap: I,
      trackItemDetailsMap: x,
      structure: g
    }), D = K(this.getState()), j = { ...D, ...O };
    this.prevState = D, this.redos.push({ redos: r, type: s });
    const L = he(j.trackItemsMap);
    this.stateSubject.next({ ...j, duration: L }), this.stateHistorySubject.next({ handleRedo: !1, handleUndo: !0 }), this.updateState(j, { updateHistory: !1 });
  }
  applyPatch(e, r) {
    return r.reverse().reduce((s, a) => Bi(s, (c) => {
      Xi(c, [a]);
    }), e);
  }
  redo() {
    const e = this.redos.pop(), r = e == null ? void 0 : e.redos, s = e == null ? void 0 : e.type;
    if (!r || !s) return;
    Zn();
    const {
      trackItemDetailsMap: a,
      trackItemIds: c,
      tracks: d,
      transitionIds: f,
      transitionsMap: b,
      trackItemsMap: _,
      structure: M
    } = this.getState(), E = K({
      trackItemDetailsMap: a,
      trackItemIds: c,
      tracks: d,
      transitionIds: f,
      transitionsMap: b,
      trackItemsMap: _,
      structure: M
    }), m = [], T = [], C = [], u = [], l = [], S = [], w = [];
    r.forEach((R) => {
      let F;
      const V = R.path.slice(1);
      R.type === "CREATE" ? F = {
        path: V,
        op: "add",
        value: R.value
      } : R.type === "CHANGE" ? F = {
        path: V,
        op: "replace",
        value: R.value
      } : F = {
        path: V,
        op: "remove",
        value: R.oldValue
      }, R.path.includes("trackItemIds") ? C.push(F) : R.path.includes("transitionIds") ? T.push(F) : R.path.includes("trackItemsMap") ? l.push(F) : R.path.includes("transitionsMap") ? u.push(F) : R.path.includes("trackItemDetailsMap") ? S.push(F) : R.path.includes("structure") ? w.push(F) : m.push(F);
    });
    const k = this.applyPatch(
      E.tracks,
      m
    ), h = this.applyPatch(
      E.transitionIds,
      T
    ), y = this.applyPatch(
      E.trackItemIds,
      C
    ), v = this.applyPatch(
      E.transitionsMap,
      u
    ), I = this.applyPatch(
      E.trackItemsMap,
      l
    ), x = this.applyPatch(
      E.trackItemDetailsMap,
      S
    ), g = this.applyPatch(
      E.structure,
      w
    ), O = K({
      tracks: k,
      transitionIds: h,
      trackItemIds: y,
      transitionsMap: v,
      trackItemsMap: I,
      trackItemDetailsMap: x,
      structure: g
    }), D = K(this.getState()), j = { ...D, ...O };
    this.prevState = D, this.undos.push({ undos: r, type: s });
    const L = he(j.trackItemsMap);
    this.stateSubject.next({ ...j, duration: L }), this.stateHistorySubject.next({ handleRedo: !0, handleUndo: !1 }), this.updateState(j, { updateHistory: !1 });
  }
  toJSON() {
    const {
      fps: e,
      tracks: r,
      size: s,
      trackItemDetailsMap: a,
      trackItemIds: c,
      transitionsMap: d,
      trackItemsMap: f,
      transitionIds: b
    } = this.getState();
    return {
      fps: e,
      tracks: r,
      size: s,
      trackItemDetailsMap: a,
      trackItemIds: c,
      transitionsMap: d,
      trackItemsMap: f,
      transitionIds: b
    };
  }
}
export {
  ui as ACTIVE_CLONE,
  La as ACTIVE_DELETE,
  ci as ACTIVE_PASTE,
  Ce as ACTIVE_PREFIX,
  Ha as ACTIVE_SET,
  li as ACTIVE_SPLIT,
  ei as ADD_ANIMATION,
  Js as ADD_AUDIO,
  ri as ADD_CAPTIONS,
  ii as ADD_COMPOSITION,
  Qs as ADD_ILLUSTRATION,
  Zs as ADD_IMAGE,
  si as ADD_ITEMS,
  Pa as ADD_MASK,
  Ca as ADD_PLACEHOLDER,
  gt as ADD_PREFIX,
  ti as ADD_SHAPE,
  Aa as ADD_SUFFIX,
  ni as ADD_TEMPLATE,
  Vs as ADD_TEXT,
  Ra as ADD_TRANSITION,
  qs as ADD_VIDEO,
  Na as DELETE_TEMPLATE_ITEM,
  Xs as DESIGN_LOAD,
  Dn as DESIGN_PREFIX,
  Ks as DESIGN_RESIZE,
  ai as EDIT_OBJECT,
  be as EDIT_PREFIX,
  Fa as EDIT_SHAPE,
  $a as EDIT_TEMPLATE_ITEM,
  za as EDIT_TEXT,
  ja as ENTER_EDIT_MODE,
  Sr as HISTORY_PREFIX,
  mi as HISTORY_REDO,
  to as HISTORY_RESET,
  hi as HISTORY_UNDO,
  di as LAYER_CLONE,
  qa as LAYER_COPY,
  Qa as LAYER_CUT,
  fi as LAYER_DELETE,
  Va as LAYER_EDITING_NAME,
  Wa as LAYER_HIDDEN,
  Ua as LAYER_LOCKED,
  Ga as LAYER_MOVE,
  Ja as LAYER_PASTE,
  pt as LAYER_PREFIX,
  Ka as LAYER_RENAME,
  pi as LAYER_REPLACE,
  Ya as LAYER_SELECT,
  Ba as LAYER_SELECTION,
  Xa as LAYER_SEND_TO,
  Za as LAYER_SPLIT,
  oi as REPLACE_MEDIA,
  Oa as STATE_CHANGED,
  Bs as STATE_PREFIX,
  yi as TIMELINE_SCALE_CHANGED,
  us as TIMELINE_SCALE_PREFIX,
  xa as TRACKS_CHANGED,
  Da as TRACK_ITEMS_CHANGED,
  Ys as TRACK_ITEMS_PREFIX,
  Gs as TRACK_PREFIX,
  eo as default
};

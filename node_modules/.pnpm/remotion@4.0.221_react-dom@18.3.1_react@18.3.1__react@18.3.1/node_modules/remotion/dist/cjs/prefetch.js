"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prefetch = exports.usePreload = void 0;
const react_1 = require("react");
const get_remotion_environment_js_1 = require("./get-remotion-environment.js");
const prefetch_state_js_1 = require("./prefetch-state.js");
const usePreload = (src) => {
    var _a;
    const preloads = (0, react_1.useContext)(prefetch_state_js_1.PreloadContext);
    return (_a = preloads[src]) !== null && _a !== void 0 ? _a : src;
};
exports.usePreload = usePreload;
const blobToBase64 = function (blob) {
    const reader = new FileReader();
    return new Promise((resolve, reject) => {
        reader.onload = function () {
            const dataUrl = reader.result;
            resolve(dataUrl);
        };
        reader.onerror = (err) => {
            return reject(err);
        };
        reader.readAsDataURL(blob);
    });
};
const getBlobFromReader = async ({ reader, contentType, contentLength, onProgress, }) => {
    let receivedLength = 0;
    const chunks = [];
    // eslint-disable-next-line no-constant-condition
    while (true) {
        const { done, value } = await reader.read();
        if (done) {
            break;
        }
        chunks.push(value);
        receivedLength += value.length;
        if (onProgress) {
            onProgress({ loadedBytes: receivedLength, totalBytes: contentLength });
        }
    }
    const chunksAll = new Uint8Array(receivedLength);
    let position = 0;
    for (const chunk of chunks) {
        chunksAll.set(chunk, position);
        position += chunk.length;
    }
    return new Blob([chunksAll], {
        type: contentType !== null && contentType !== void 0 ? contentType : undefined,
    });
};
/**
 * @description When you call the preFetch() function, an asset will be fetched and kept in memory so it is ready when you want to play it in a <Player>.
 * @see [Documentation](https://www.remotion.dev/docs/prefetch)
 */
const prefetch = (src, options) => {
    var _a;
    const method = (_a = options === null || options === void 0 ? void 0 : options.method) !== null && _a !== void 0 ? _a : 'blob-url';
    if ((0, get_remotion_environment_js_1.getRemotionEnvironment)().isRendering) {
        return {
            free: () => undefined,
            waitUntilDone: () => Promise.resolve(src),
        };
    }
    let canceled = false;
    let objectUrl = null;
    let resolve = () => undefined;
    let reject = () => undefined;
    const waitUntilDone = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
    });
    const controller = new AbortController();
    let canBeAborted = true;
    fetch(src, {
        signal: controller.signal,
    })
        .then((res) => {
        var _a, _b, _c;
        canBeAborted = false;
        if (canceled) {
            return null;
        }
        if (!res.ok) {
            throw new Error(`HTTP error, status = ${res.status}`);
        }
        const headerContentType = res.headers.get('Content-Type');
        const contentType = (_a = options === null || options === void 0 ? void 0 : options.contentType) !== null && _a !== void 0 ? _a : headerContentType;
        const hasProperContentType = contentType &&
            (contentType.startsWith('video/') ||
                contentType.startsWith('audio/') ||
                contentType.startsWith('image/'));
        if (!hasProperContentType) {
            // eslint-disable-next-line no-console
            console.warn(`Called prefetch() on ${src} which returned a "Content-Type" of ${headerContentType}. Prefetched content should have a proper content type (video/... or audio/...) or a contentType passed the options of prefetch(). Otherwise, prefetching will not work properly in all browsers.`);
        }
        if (!res.body) {
            throw new Error(`HTTP response of ${src} has no body`);
        }
        const reader = res.body.getReader();
        return getBlobFromReader({
            reader,
            contentType: (_c = (_b = options === null || options === void 0 ? void 0 : options.contentType) !== null && _b !== void 0 ? _b : headerContentType) !== null && _c !== void 0 ? _c : null,
            contentLength: res.headers.get('Content-Length')
                ? parseInt(res.headers.get('Content-Length'), 10)
                : null,
            onProgress: options === null || options === void 0 ? void 0 : options.onProgress,
        });
    })
        .then((buf) => {
        if (!buf) {
            return;
        }
        const actualBlob = (options === null || options === void 0 ? void 0 : options.contentType)
            ? new Blob([buf], { type: options.contentType })
            : buf;
        if (method === 'base64') {
            return blobToBase64(actualBlob);
        }
        return URL.createObjectURL(actualBlob);
    })
        .then((url) => {
        if (canceled) {
            return;
        }
        objectUrl = url;
        (0, prefetch_state_js_1.setPreloads)((p) => ({
            ...p,
            [src]: objectUrl,
        }));
        resolve(objectUrl);
    })
        .catch((err) => {
        reject(err);
    });
    return {
        free: () => {
            if (objectUrl) {
                if (method === 'blob-url') {
                    URL.revokeObjectURL(objectUrl);
                }
                (0, prefetch_state_js_1.setPreloads)((p) => {
                    const copy = { ...p };
                    delete copy[src];
                    return copy;
                });
            }
            else {
                canceled = true;
                if (canBeAborted) {
                    try {
                        controller.abort(new Error('free() called'));
                    }
                    catch (e) { }
                }
            }
        },
        waitUntilDone: () => {
            return waitUntilDone;
        },
    };
};
exports.prefetch = prefetch;
